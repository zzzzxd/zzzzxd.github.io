<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Flink timer定时器踩坑</title>
      <link href="/2024/01/06/Flink-2024-01-06-Flink-timer%E5%AE%9A%E6%97%B6%E5%99%A8%E8%B8%A9%E5%9D%91/"/>
      <url>/2024/01/06/Flink-2024-01-06-Flink-timer%E5%AE%9A%E6%97%B6%E5%99%A8%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>公司同事在开发时，发现任务跑一段时间后 定时器会延迟执行，查看日志如下:</p><p><img src="1.png" alt="2031704554198_.pic" style="zoom:80%;" /></p><p>延迟了一个小时,基本上高峰就会出现。</p><p>查看火焰图</p><p><img src="3.png" alt="image-20240106231800487"></p><p>​    火焰图中明显看到定时器的处理方法占用大量cpu时间，所以定时器这块多少是有点问题的，但问题到底出在哪，只能进一步结合代码来看。</p><p><img src="4.png" alt="image-20240106232240344" style="zoom:80%;" /></p><p>可以看到代码中是每条数据都会注册定时器，也就是说 同时来100条数据，就会同时注册100个定时器，并且注册的定时器时间都一样，都会在同一时间调起，这样看来 主要原因就是定时器太多了，导致执行的慢，那这又是为什么，定时器多了 flink就解决不了吗？纵使加了一倍的资源也没有好转，而且从整体的cpu指标上都很正常，任务也没有背压。</p><p><img src="5.png" alt="image-20240106232629314"></p><p><img src="8.png" alt="image-20240106232644089"></p><p><img src="6.png" alt="image-20240106232736753" style="zoom:80%;" /></p><p>算子报红，是因为包含处理逻辑 要繁忙一点，并没出现背压的情况，数据处理也没有延迟。下一步只能从定时器这块代码入手了</p><p>阅读相关源码发现，key by之后进行处理不同的key 对应不同的context，而context持有timerService服务，也就是不同的key 对应不同的InternalTimerService，即持有不同的优先级队列。</p><p><img src="7.png" alt="image-20240107133848952" style="zoom:67%;" /></p><p>但是问题是，flink任务的并发处理完全取决于并行度，也就是在每个单TM上，所有的定时队列，要靠一个工作线程来处理，尽管定时任务是多个队列 不会相互影响，但是单线程顺序处理所有的定时任务，也就意味着单个定时任务的耗时，就决定了并发处理定时任务的能力。如此一来就清晰了，因为在OnTimer()方法中调用了外部接口，单接口调用是平均5ms，也就是意味着一个TM每秒最多处理200个定时任务，而线上相关的触达数据每秒最高125左右，会注册执行完后继续注册每次注册推迟30min，也就是极端情况下，最高需要每秒处理7000的定时任务。。。这样一来肯定会延迟执行了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>​    问题分析清楚，相对就好解决了。如果还采用定时器的方案，就只能优化定时任务的消耗时间，如果单定时任务耗费在0.1ms，那就有1万的并发处理能力也就还ok，再者尽可能咱批，减少定时任务的数量</p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>watermark的传递</title>
      <link href="/2024/01/06/Flink-2024-01-06-watermark%E7%9A%84%E4%BC%A0%E9%80%92/"/>
      <url>/2024/01/06/Flink-2024-01-06-watermark%E7%9A%84%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h2 id="水位线的传递"><a href="#水位线的传递" class="headerlink" title="水位线的传递"></a>水位线的传递</h2><p><img src="1.png" alt="image-20240106194023686"></p><p>​        在流处理中，上游任务处理完⽔位线、时钟改变之后，要把当前的⽔位线再次发出，⼴ 播给所有的下游⼦任务。⽽当⼀个任务接收到多个上游并⾏任务传递来的⽔位线时，应该以 最⼩的那个作为当前任务的事件时钟。</p><p>​        ⽔位线在上下游任务之间的传递， ⾮常巧妙地避免了分布式系统中没有统⼀时钟的问 题，每个任务都以“处理完之前所有数据”为标准来确定⾃⼰的时钟。</p><h2 id="水位线未推进问题"><a href="#水位线未推进问题" class="headerlink" title="水位线未推进问题"></a>水位线未推进问题</h2><p>​    生产中，当消费kafka 多分区时，如果某些分区因为倾斜没有数据，而水位线又取的是多个分区的最小值，就会导致水位线不会被触发。具体可参考官网：<a href="https://nightlies.apache.org/flink/flink-docs-master/zh/docs/dev/datastream/event-time/generating_watermarks/" target="_blank" rel="noopener">https://nightlies.apache.org/flink/flink-docs-master/zh/docs/dev/datastream/event-time/generating_watermarks/</a></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>通过在flink内部添加参数，设定多长时间没有消息时就舍弃此分区，可以参考文章:<a href="https://mp.weixin.qq.com/s/108o9iwEZaHyMoRBGUKX8g。" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/108o9iwEZaHyMoRBGUKX8g。</a> 实际上Flink官方也提供了相关入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WatermarkStrategy</span><br><span class="line">        .&lt;Tuple2&lt;Long, String&gt;&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">20</span>))</span><br><span class="line">        .withIdleness(Duration.ofMinutes(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>Flink sql 也有相关参数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table.exec.source.idle-timeout: '1000' <span class="comment">#单位毫秒</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> Flink sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>interval join执行流程解析</title>
      <link href="/2024/01/06/Flink-2024-01-06-interval-join%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
      <url>/2024/01/06/Flink-2024-01-06-interval-join%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><p>想要熟悉interval join的原理或者读懂TimeIntervalJoin.java源码 必须先熟悉几个源码中提到的概念。假设A表 left join B表 ,A表来了一条数据a。那么会有这么几个概念。</p><ul><li><p><code>rightQualifiedLowerBound</code> (右侧合格下界):</p><p>它表示右侧流中的事件的最小匹配时间。对于每个左侧流事件，只有右侧流中的事件的时间大于等于<code>rightQualifiedLowerBound</code> 才能与之匹配。</p></li><li><p><code>rightQualifiedUpperBound</code>（右侧合格上界):</p><p>它表示右侧流中的事件的最大匹配时间。对于每个左侧流事件，只有右侧流中的事件的时间小于等于<code>rightQualifiedUpperBound</code> 才能与之匹配</p></li><li><p><code>RightExpirationTime</code>（右侧过期时间):</p><p>它表示右侧流中的事件的过期时间。如果一个右侧流事件的时间小于 <code>RightExpirationTime</code>，则该事件将被认为已过期，不再与左侧流事件进行匹配。如果是right outer Join或者full join会输出[null,R]。否则直接清除。</p></li><li><p><code>cleanUpTime</code>   (清除时间):</p><p>它表示对应数据的清除时间。比如此时A表来了数据，那此条数据何时清除呢。理论是当右流时间推进超过对应间隔时，也意味着不可能再有右流的数据与此条数据a进行关联时，此时就可以清除a了。具体时间由此变量决定。源码中类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> cleanUpTime = rowTime + leftRelativeSize + minCleanUpInterval + allowedLateness + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="推算区间"><a href="#推算区间" class="headerlink" title="推算区间"></a>推算区间</h2><p>​    熟悉一下根据数据时间推出对应时间间隔。以下sql为例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A left join B</span><br><span class="line">ON B.eventtime between A.evetntime + INTERVAL '1' SECOND and A.evetntime + INTERVAL '5' SECOND</span><br></pre></td></tr></table></figure><p>那么当 A 来了一条数据a 时，对应B的关联区间[+1,+5]，如果a的时间是10:00:00 那么B表只有 [10:00:01,10:00:05]区间才能关联上。</p><p>如果B来了一个条数据b呢？简单画一下其实就能知道，如果b的时间是10:00:00 那么A表只有 [09:59:55,09:59:59]能关联上。简单讲，对于左表数据，右表的关联区间为[+1,+5],反过来对右表数据 左表区间就是[-5,-1]。熟悉这个关系，对应阅读源码熟悉执行流程都会有帮助。</p><p>还是以此时左表数据a1 10:00:00 先到达，上面的变量值依次为</p><ul><li><p>rightQualifiedLowerBound : 10:00:01</p></li><li><p>rightQualifiedUpperBound : 10:00:05</p></li><li><p>RightExpirationTime: watermark(10:00:00)  - 1秒 -1毫秒 :  09:59:58.999 （当前先不讨论水位线的生成，不设置延迟时间）, 此时意味着右表小雨这个时间点数据 不可能再和左表数据关联了。</p></li><li><p>minCleanUpInterval: 这个为源码中设定的<code>minCleanUpInterval = (leftRelativeSize + rightRelativeSize) / 2;</code>上下边界求和除2</p></li><li><p>cleanUpTime :  10:00:00 + 5秒+3秒 +0 (allowedLateness) + 1毫秒 = 10:00:08.001 意味着这个时间就要清楚a1的状态了，从A表中缓存中剔除了,如果是left join或者full join 就要输出 [a1,null]了</p></li></ul><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>通过读源码我们可以梳理以下流程，还是以左流数据到达为例</p><p>左流数据到达之后，会先计算三个时间戳</p><ul><li>根据左流数据时间 <code>left_record_time</code> 计算关联右流的时间区间下限 <code>right_lower</code> 和上限 <code>right_upper</code></li><li>计算左流 <code>left_watermark</code> 和右流 <code>right_watermark</code> （在 EventTime 语义下这两个时间戳都等于当前的 <code>watermark</code>；在 ProcessingTime语义下都等于当前的 <code>processing_time</code>）</li><li>计算右流需要过期处理的过期时间 <code>right_expiration_time</code></li></ul><p>如果右流过期时间 <code>right_expiration_time</code> 小于关联区间上限 <code>right_upper</code>，则遍历右流状态里的所有数据</p><ul><li>如果 join on 条件为 true，则发送 <code>+I[left_record, matched_right_record]</code>；否则啥也不干</li><li>然后如果右流数据的 <code>right_record_time</code> 小于等于右流过期时间 <code>right_expiration_time</code> <em>（即右流这条数据永远不会被左流关联到）</em> 并且 join type 为 Right Join 或者 Full Outer Join，则发送 <code>+I[null, reight_record]</code>；不管 join type 是什么类型都会清除这条右流数据</li></ul><p>如果右流 <code>right_watermark</code> 小于关联区间上限 <code>right_upper</code> <em>（说明这条左流数据还有可能被右流关联到）</em> 则将这条左流数据放到左流状态中，并注册左流数据时间 <code>left_record_time</code> 的定时器，用来清除过期数据</p><p>如果右流 <code>right_watermark</code> 大于关联区间上限 <code>right_upper</code>，并且这条左流数据未能与右流关联成功，并且 join type 为 Left Join 或者 Full Outer Join，则发送 <code>+I[left_record, null]</code></p><h2 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h2><p>简单验证一下A表数据未关联上时的输出时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">tb_a.*,</span><br><span class="line">tb_b.event_time </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">tb_a  <span class="keyword">left</span> <span class="keyword">join</span> tb_b  </span><br><span class="line"><span class="keyword">on</span>   tb_a.id = tb_b.id </span><br><span class="line"><span class="keyword">AND</span> tb_b.event_time <span class="keyword">BETWEEN</span> tb_a.event_time <span class="keyword">AND</span> tb_a.event_time +  <span class="built_in">INTERVAL</span> <span class="string">'1'</span> <span class="keyword">HOUR</span> ;</span><br></pre></td></tr></table></figure><ol><li><p>输入{“id”:2,”event_time”:”2024-01-01 11:00:00”,”tb_name”:”a”,”data”:”B”}</p><p>此时无任何输出</p></li><li><p>输入{“id”:5,”event_time”:”2024-01-01 12:10:00”,”tb_name”:”b”,”data”:”3”}</p><p>无任何输出</p></li><li><p>{“id”:5,”event_time”:”2024-01-01 12:20:00”,”tb_name”:”b”,”data”:”3”}</p><p>无任何输出</p></li><li><p>{“id”:5,”event_time”:”2024-01-01 12:30:00”,”tb_name”:”b”,”data”:”3”}</p><p>仍为输出，因为此时 2024-01-01 12:30:00 仍为边界数据</p></li><li><p>{“id”:5,”event_time”:”2024-01-01 12:30:01”,”tb_name”:”b”,”data”:”3”}</p><p>此时才会有输出</p><p><img src="image-20240106191801120.png" alt="image-20240106191801120"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> Flink sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>distribute by、sort by、order by应用</title>
      <link href="/2023/11/20/%E5%A4%A7%E6%95%B0%E6%8D%AE-2023-11-20-distribute-by%E3%80%81sort-by%E3%80%81order-by%E5%BA%94%E7%94%A8/"/>
      <url>/2023/11/20/%E5%A4%A7%E6%95%B0%E6%8D%AE-2023-11-20-distribute-by%E3%80%81sort-by%E3%80%81order-by%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="order-by："><a href="#order-by：" class="headerlink" title="order by："></a>order by：</h4><p>order by关键字用于对查询结果进行全局排序。它会将所有数据收集到一个节点上进行排序，然后输出有序的结果。使用order by时，Hive会将整个数据集加载到内存中进行排序，因此适用于数据量较小的情况。然而，由于需要加载全部数据到内存，对于大规模数据集来说，可能导致内存不足的问题。<br>使用场景：当需要对查询结果进行全局排序，并且数据量较小的情况下，可以使用order by。</p><h4 id="sort-by："><a href="#sort-by：" class="headerlink" title="sort by："></a>sort by：</h4><p>sort by关键字用于对查询结果按照指定的列进行局部排序。它会将数据根据指定的列进行排序，但不保证全局有序。Hive会将数据按照指定的列进行划分和排序，每个划分内的数据是有序的，但不同划分之间的顺序是未定义的。sort by可以配合使用分区（partition）来实现更细粒度的排序。<br>使用场景：当需要按照指定的列对查询结果进行局部排序，而不要求全局有序时，可以使用sort by。</p><h4 id="distribute-by："><a href="#distribute-by：" class="headerlink" title="distribute by："></a>distribute by：</h4><p>distribute by关键字用于指定数据的分发方式。它用于控制将数据发送到不同的reducer节点上。distribute by通常与sort by或cluster by一起使用，以控制数据的分区和排序。<br>使用场景：当需要按照指定的列对数据进行分发，并且可能需要后续的排序操作时，可以使用distribute by。</p><h4 id="cluster-by："><a href="#cluster-by：" class="headerlink" title="cluster by："></a>cluster by：</h4><p>cluster by关键字用于对数据进行分区和排序。它类似于distribute by，但它会尝试将数据按照指定的列进行排序，并将相邻的值放置在相同的分区中。cluster by会自动执行分区和排序的操作。<br>使用场景：当需要将数据按照指定的列进行分区和排序，并且希望相邻值在同一分区中时，可以使用cluster by。</p><h3 id="案例解释"><a href="#案例解释" class="headerlink" title="案例解释"></a>案例解释</h3><h4 id="sort-by-distribute-by"><a href="#sort-by-distribute-by" class="headerlink" title="sort by + distribute by"></a>sort by + distribute by</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">需求：获取每个商品类别和国家下的商品个数，并按照商品类别和国家下的商品销售取前三名。</span><br><span class="line"></span><br><span class="line">数据：</span><br><span class="line"></span><br><span class="line">类别 国家 商品名称 销售数量</span><br><span class="line">movies us movies_us_1 100</span><br><span class="line">movies us movies_us_2 150</span><br><span class="line">movies us movies_us_3 200</span><br><span class="line">movies us movies_us_4 300</span><br><span class="line">movies gb movies_gb_1 100</span><br><span class="line">movies gb movies_gb_2 150</span><br><span class="line">movies gb movies_gb_3 200</span><br><span class="line">movies gb movies_gb_4 300</span><br><span class="line">office gb office_gb_1 30</span><br><span class="line">office gb office_gb_2 40</span><br><span class="line">office gb office_gb_3 50</span><br><span class="line">office gb office_gb_4 60</span><br><span class="line">office us office_us_1 30</span><br><span class="line">office us office_us_2 50</span><br><span class="line">office us office_us_3 60</span><br><span class="line">office us office_us_4 70</span><br><span class="line">按照商品类别和国家下的商品销售排名(按照category,country分组，并通过sort by每个分组的结果排序)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="keyword">category</span>,</span><br><span class="line">  country,</span><br><span class="line">  product, </span><br><span class="line">sales,</span><br><span class="line"><span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">distribute</span> <span class="keyword">by</span> <span class="keyword">category</span>,country <span class="keyword">sort</span> <span class="keyword">by</span> <span class="keyword">category</span>,country, sales <span class="keyword">desc</span>)  <span class="keyword">as</span> rk </span><br><span class="line"><span class="keyword">from</span> p_rank_demo;</span><br><span class="line"></span><br><span class="line">或者通过</span><br><span class="line"><span class="keyword">select</span>  </span><br><span class="line"><span class="keyword">category</span>,</span><br><span class="line">country,</span><br><span class="line">product, </span><br><span class="line">sales,</span><br><span class="line"><span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">category</span>,country <span class="keyword">order</span> <span class="keyword">by</span> sales <span class="keyword">desc</span>)  <span class="keyword">as</span> rk </span><br><span class="line"><span class="keyword">from</span> p_rank_demo;</span><br><span class="line"></span><br><span class="line">输出通过的结果（两者的区别： distribute by 具有相同的类别和国家的记录都发送到同一个reducer上，这样就可以统计</span><br><span class="line">出每个类别和国家的销售商品的排名了。若业务是全局排序，可以通过partition by order by 获取排名。）</span><br><span class="line"></span><br><span class="line">category country product       sales   rk</span><br><span class="line">movies  gb      movies_gb_4     300     1</span><br><span class="line">movies  gb      movies_gb_3     200     2</span><br><span class="line">movies  gb      movies_gb_2     150     3</span><br><span class="line">movies  gb      movies_gb_1     100     4</span><br><span class="line">movies  us      movies_us_4     300     1</span><br><span class="line">movies  us      movies_us_3     200     2</span><br><span class="line">movies  us      movies_us_1     100     3</span><br><span class="line">movies  us      movies_us_2     100     3</span><br><span class="line">office  gb      office_gb_4     60      1</span><br><span class="line">office  gb      office_gb_3     50      2</span><br><span class="line">office  gb      office_gb_2     40      3</span><br><span class="line">office  gb      office_gb_1     30      4</span><br><span class="line">office  us      office_us_4     70      1</span><br><span class="line">office  us      office_us_3     60      2</span><br><span class="line">office  us      office_us_2     50      3</span><br><span class="line">office  us      office_us_1     30      4</span><br><span class="line"></span><br><span class="line">按照商品类别和国家下的商品销售排名前三输出</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">* </span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">  <span class="keyword">select</span>  </span><br><span class="line">  <span class="keyword">category</span>,</span><br><span class="line">  country,</span><br><span class="line">  product,</span><br><span class="line">  sales,</span><br><span class="line">  <span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">distribute</span> <span class="keyword">by</span> <span class="keyword">category</span>,country <span class="keyword">sort</span> <span class="keyword">by</span> <span class="keyword">category</span>,country, sales <span class="keyword">desc</span>)  <span class="keyword">as</span> rk </span><br><span class="line">  <span class="keyword">from</span> p_rank_demo</span><br><span class="line">) t </span><br><span class="line"><span class="keyword">where</span> t.rk &lt;= <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="使用小结"><a href="#使用小结" class="headerlink" title="使用小结"></a>使用小结</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>理解UTC、格林威治时间、夏令时等概念</title>
      <link href="/2023/11/20/Java-2023-11-20-%E7%90%86%E8%A7%A3UTC%E3%80%81%E6%A0%BC%E6%9E%97%E5%A8%81%E6%B2%BB%E6%97%B6%E9%97%B4%E3%80%81%E5%A4%8F%E4%BB%A4%E6%97%B6%E7%AD%89%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/11/20/Java-2023-11-20-%E7%90%86%E8%A7%A3UTC%E3%80%81%E6%A0%BC%E6%9E%97%E5%A8%81%E6%B2%BB%E6%97%B6%E9%97%B4%E3%80%81%E5%A4%8F%E4%BB%A4%E6%97%B6%E7%AD%89%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><h3 id="GMT"><a href="#GMT" class="headerlink" title="GMT"></a>GMT</h3><p>GMT（Greenwich Mean Time）， 格林威治平时（也称格林威治时间）。</p><p>它规定太阳每天经过位于英国伦敦郊区的皇家格林威治天文台的时间为中午12点。</p><blockquote><p>格林威治皇家天文台为了海上霸权的扩张计划，在十七世纪就开始进行天体观测。为了天文观测，选择了穿过英国伦敦格林威治天文台子午仪中心的一条经线作为零度参考线，这条线，简称格林威治子午线。</p><p>1884年10月在美国华盛顿召开了一个国际子午线会议，该会议将格林威治子午线设定为本初子午线，并将格林威治平时 (GMT, Greenwich Mean Time) 作为世界时间标准（UT, Universal Time）。由此也确定了全球24小时自然时区的划分，所有时区都以和 GMT 之间的偏移量做为参考。</p><p>1972年之前，格林威治时间（GMT）一直是世界时间的标准。1972年之后，GMT 不再是一个时间标准了。</p></blockquote><h3 id="UTC"><a href="#UTC" class="headerlink" title="UTC"></a>UTC</h3><p>​    UTC（Coodinated Universal Time），协调世界时，又称世界统一时间、世界标准时间、国际协调时间。由于英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。</p><p>​    UTC 是现在全球通用的时间标准，全球各地都同意将各自的时间进行同步协调。UTC 时间是经过平均太阳时（以格林威治时间GMT为准）、地轴运动修正后的新时标以及以秒为单位的国际原子时所综合精算而成。</p><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><p>​    随着火车铁路与其他交通和通讯工具的发展，以及全球化贸易的推动，各地使用各自的当地太阳时间带来了时间不统一的问题，在19世纪催生了统一时间标准的需求，时区由此诞生。</p><blockquote><p>为了将本地时间方便的转换成统一的时间有时区的概念，有了统一的时间 使用不同时间标准的人们才能交流。</p></blockquote><h3 id="夏令时"><a href="#夏令时" class="headerlink" title="夏令时"></a>夏令时</h3><p>在施行夏令时的国家，一年里面有一天只有23小时（夏令时开始那一天），有一天有25小时（夏令时结束那一天），其他时间每天都是24小时。</p><blockquote><p>我国也曾实行过夏令时冬令时，但效果不明显。因为纬度不够高，日照时间变化还不是很大。但北美就不一样了，尤其是加拿大，纬度很高，昼夜时常变化很快。</p><p>对于大部分现代人来说，日出而作日落而息是不可能的，日上三竿还在睡觉是普遍现象，那么这么长的白昼照明就浪费了。尤其是高纬度地区，冬天时候日照时间很短，尽可能利用日照时间有利于节约能源。</p><p>人通常会养成个习惯，比如早晨7点天亮，起床上班。夏天太阳出来早，如果让你6点起床上班，很少有人能做到。不如把时钟拨快一个小时。这样入夜的时间也推迟了一个小时，等于节约了一个小时的照明能源。同理，冬令时是时钟拨慢一个小时。冬天天亮迟，如果不调整时间，早晨黑灯瞎火地上班去，非常冷，不如把时钟拨慢一个小时让大家多睡一会。晚上也多了一个小时的照明时间。</p><p>时间本来就是人为定义的，所谓时区也很不精确。我国横跨好几个时区，但只有一个时间，时区并没有消失，同一个经度的国家，可能使用不同时区，这完全看当地是怎么定义的，地球才不管你时区是什么样，他转他的。</p></blockquote><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="GMT-vs-UTC"><a href="#GMT-vs-UTC" class="headerlink" title="GMT vs UTC"></a>GMT vs UTC</h3><ul><li>GMT是前世界标准时，UTC是现世界标准时。</li><li>UTC 比 GMT更精准，以原子时计时，适应现代社会的精确计时。</li><li>不需要精确到秒的情况下，二者可以视为等同。</li><li>每年格林尼治天文台会发调时信息，基于UTC。</li></ul><h3 id="UTC-vs-北京时间"><a href="#UTC-vs-北京时间" class="headerlink" title="UTC vs 北京时间"></a>UTC vs 北京时间</h3><ul><li>UTC + 时区差 ＝ 本地时间</li><li>UTC = 北京时间- 0800</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink Sql Group类型</title>
      <link href="/2023/11/14/Flink-2023-11-14-Flink-Sql-Group%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/11/14/Flink-2023-11-14-Flink-Sql-Group%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Group-Aggregation"><a href="#Group-Aggregation" class="headerlink" title="Group Aggregation"></a>Group Aggregation</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>对于流式查询，计算查询结果所需的状态可能会无限增长。状态大小取决于组的数量以及聚合函数的数量和类型。例如，MIN/MAX在状态大小上很重，而COUNT则很便宜。您可以为查询配置提供适当的生存时间（TTL），以防止状态大小过大。请注意，这可能会影响查询结果的正确性</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>​    同mysql 语法</p><h3 id="用法举例"><a href="#用法举例" class="headerlink" title="用法举例"></a>用法举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">COUNT</span><span class="params">(*)</span></span></span><br><span class="line"><span class="function">FROM Orders</span></span><br><span class="line"><span class="function">GROUP BY order_id</span></span><br></pre></td></tr></table></figure><h2 id="Window-Aggregation"><a href="#Window-Aggregation" class="headerlink" title="Window Aggregation"></a>Window Aggregation</h2><h3 id="Window-TVF-Aggregation"><a href="#Window-TVF-Aggregation" class="headerlink" title="Window TVF Aggregation"></a>Window TVF Aggregation</h3><h4 id="TUMBLE-TVF"><a href="#TUMBLE-TVF" class="headerlink" title="TUMBLE TVF"></a>TUMBLE TVF</h4><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><p><code>TUMBLE(TABLE data, DESCRIPTOR(timecol), size [, offset ])</code></p><h5 id="用法举例-1"><a href="#用法举例-1" class="headerlink" title="用法举例"></a>用法举例</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> window_start, window_end, <span class="keyword">SUM</span>(price)</span><br><span class="line">  <span class="keyword">FROM</span> <span class="keyword">TABLE</span>(</span><br><span class="line">    TUMBLE(<span class="keyword">TABLE</span> Bid, <span class="keyword">DESCRIPTOR</span>(bidtime), <span class="built_in">INTERVAL</span> <span class="string">'10'</span> <span class="keyword">MINUTES</span>))</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> window_start, window_end;</span><br></pre></td></tr></table></figure><h4 id="HOP-TVF"><a href="#HOP-TVF" class="headerlink" title="HOP TVF"></a>HOP TVF</h4><h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><p><code>HOP(TABLE data, DESCRIPTOR(timecol), slide, size [, offset ])</code></p><h5 id="用法举例-2"><a href="#用法举例-2" class="headerlink" title="用法举例"></a>用法举例</h5> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> window_start, window_end, <span class="keyword">SUM</span>(price)</span><br><span class="line">  <span class="keyword">FROM</span> <span class="keyword">TABLE</span>(</span><br><span class="line">    HOP(<span class="keyword">TABLE</span> Bid, <span class="keyword">DESCRIPTOR</span>(bidtime), <span class="built_in">INTERVAL</span> <span class="string">'5'</span> <span class="keyword">MINUTES</span>, <span class="built_in">INTERVAL</span> <span class="string">'10'</span> <span class="keyword">MINUTES</span>))</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> window_start, window_end;</span><br></pre></td></tr></table></figure><h4 id="CUMULATE-TVF"><a href="#CUMULATE-TVF" class="headerlink" title="CUMULATE TVF"></a>CUMULATE TVF</h4><h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><p><code>CUMULATE(TABLE data, DESCRIPTOR(timecol), step, size)</code></p><h5 id="用法举例-3"><a href="#用法举例-3" class="headerlink" title="用法举例"></a>用法举例</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> window_start, window_end, <span class="keyword">SUM</span>(price)</span><br><span class="line">  <span class="keyword">FROM</span> <span class="keyword">TABLE</span>(</span><br><span class="line">    CUMULATE(<span class="keyword">TABLE</span> Bid, <span class="keyword">DESCRIPTOR</span>(bidtime), <span class="built_in">INTERVAL</span> <span class="string">'2'</span> <span class="keyword">MINUTES</span>, <span class="built_in">INTERVAL</span> <span class="string">'10'</span> <span class="keyword">MINUTES</span>))</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> window_start, window_end;</span><br></pre></td></tr></table></figure><h3 id="Group-Window-Aggregation"><a href="#Group-Window-Aggregation" class="headerlink" title="Group Window Aggregation"></a>Group Window Aggregation</h3><h4 id="TUMBLE"><a href="#TUMBLE" class="headerlink" title="TUMBLE"></a>TUMBLE</h4><h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><p><code>TUMBLE(time_attr, interval)</code></p><h5 id="用法举例-4"><a href="#用法举例-4" class="headerlink" title="用法举例"></a>用法举例</h5><h4 id="TUMBLE-1"><a href="#TUMBLE-1" class="headerlink" title="TUMBLE"></a>TUMBLE</h4><h5 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h5><p><code>HOP(time_attr, interval, interval)</code></p><h5 id="用法举例-5"><a href="#用法举例-5" class="headerlink" title="用法举例"></a>用法举例</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">user</span>,</span><br><span class="line">  TUMBLE_START(order_time, <span class="built_in">INTERVAL</span> <span class="string">'1'</span> <span class="keyword">DAY</span>) <span class="keyword">AS</span> wStart,</span><br><span class="line">  <span class="keyword">SUM</span>(amount) <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">  TUMBLE(order_time, <span class="built_in">INTERVAL</span> <span class="string">'1'</span> <span class="keyword">DAY</span>),</span><br><span class="line">  <span class="keyword">user</span></span><br></pre></td></tr></table></figure><h4 id="TUMBLE-2"><a href="#TUMBLE-2" class="headerlink" title="TUMBLE"></a>TUMBLE</h4><h5 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h5><p><code>HOP(time_attr, interval, interval)</code></p><h5 id="用法举例-6"><a href="#用法举例-6" class="headerlink" title="用法举例"></a>用法举例</h5><p>​    同Hop</p><h4 id="TUMBLE-3"><a href="#TUMBLE-3" class="headerlink" title="TUMBLE"></a>TUMBLE</h4><h5 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h5><p><code>SESSION(time_attr, interval)</code></p><h5 id="用法举例-7"><a href="#用法举例-7" class="headerlink" title="用法举例"></a>用法举例</h5><p>​    同Hop</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>普通的group 基于状态的，会一直持续保留group的结果，可以结合状态TTL，但是如果状态过期值会消失，会直接影响到聚合值的正确性，所以推荐window的聚合，虽然窗口会关闭 ，可以通过watermark会降低误差，及时因为延迟有未处理的数据，也只是误差的问题 不会导致结果错误。</p></li><li><p>table value function （tvl） 和 group window  fucntion 都是做聚合group 可以选择的语法，前者是后者的封装，后者逐渐废弃⚠️,前者功能很强</p><blockquote><p>Warning: Group Window Aggregation is deprecated. It’s encouraged to use Window TVF Aggregation which is more powerful and effective.</p><p>Compared to Group Window Aggregation, Window TVF Aggregation have many advantages, including:</p><ul><li>Have all performance optimizations mentioned in <a href="https://nightlies.apache.org/flink/flink-docs-release-1.18/docs/dev/table/tuning/" target="_blank" rel="noopener">Performance Tuning</a>.</li><li>Support standard <code>GROUPING SETS</code> syntax.</li><li>Can apply <a href="https://nightlies.apache.org/flink/flink-docs-release-1.18/docs/dev/table/sql/queries/window-topn/" target="_blank" rel="noopener">Window TopN</a> after window aggregation result.</li><li>and so on.</li></ul></blockquote></li><li><p>tvl 还不支持session 窗口的语法，如果有session 窗口这种场景还得用老语法。</p></li><li>tvl 增加了 cumulate 窗口，可以实现窗口连续输出消息～</li></ul>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> Flink sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发中常见图的绘制</title>
      <link href="/2023/11/05/Java-2023-11-05-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%9B%BE%E7%9A%84%E7%BB%98%E5%88%B6/"/>
      <url>/2023/11/05/Java-2023-11-05-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%9B%BE%E7%9A%84%E7%BB%98%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考:<a href="https://juejin.cn/post/6844903496542584845" target="_blank" rel="noopener">https://juejin.cn/post/6844903496542584845</a></p><p>​        <a href="https://blog.csdn.net/qq_41854911/article/details/127063022" target="_blank" rel="noopener">https://blog.csdn.net/qq_41854911/article/details/127063022</a></p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    大家应该在从事软件开发领域工作时间有一段时间之后，就开始有画图的意识，不管是懵懂的学别人还是想更好的让其它人理解自己的一个观点。所谓“一图胜千言”，我们身处于软件开发这个<strong>水很深且要求精确\</strong>的复杂*<em>领域*</em>里，要想把事情做好，最基本的是要把事情想明白，其次还要让相关的人能够明白你要说的东西，进行协作。</p><p>　　特别对于一位架构师来说，能否画得一手好图尤其重要，因为相关的干系人数较多，要让不同领域的人能够达成一个统一的认识，是一件不太容易但也是必须要做好的事情。</p><h2 id="不同场景下的图"><a href="#不同场景下的图" class="headerlink" title="不同场景下的图"></a>不同场景下的图</h2><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p><img src="1.png" alt="img"  />    </p><p>用例图（User Case）是外部用户（被称为参与者，一般为软件的面向用户）所能观察到的系统功能的模型图。</p><p>​        适用场景: 用来说明的是谁要使用系统，以及他们使用该系统可以做些什么</p><p>​        缺点: 仅仅描述的是提供什么功能，不能表达非功能需求，如可靠性、性能等非功能需求</p><h3 id="鲁棒图（Robustness-Diagram）"><a href="#鲁棒图（Robustness-Diagram）" class="headerlink" title="鲁棒图（Robustness Diagram）"></a>鲁棒图（Robustness Diagram）</h3><p><img src="2.png" alt="img"></p><p>可能英文名Robustness Diagram更为常见一些，用于衔接用例图之后的设计，识别出系统在用例图中的各种职责，对后续的细节设计提供基础。算是对用例图的一种延伸。</p><p>​        适用场景: 在确立用户场景之后，如果需要将关键功能设计出来，那么就需要它了。作图过程中最关键的2个点，发现职责，和梳理各个职责之间的关系。</p><p>​        缺点: 和用例图是一样缺点，唯一的变化是，其有了粗粒度的实现层面的内容。</p><p>（目前不常用）</p><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="3.png" alt="img"></p><p>思维导图是一个很厉害的发明，他将我们的思考过程具象化了，完美展示了由点到面不断发散的过程。但是它最大的价值，反而不是最终呈现出来的这个图，而是促进了思考的过程。并且需要注意的是，一定要把一条分支走到尽头，再回过头来走其它的分支，把思想榨干。 </p><p>​        适用场景: 在一个事情刚开始的萌芽期，不知如何下手；或者陷入一个困境的时候。利用思维导图来活跃大脑，进行发散思维。这时候如果结合头脑风暴，效果更佳。</p><p>​        缺点: 它是一种树状的信息分层可视化展视，结构比较固定，不适合分支间互相交互比较复杂的信息展示。</p><h3 id="DFD（Data-Flow-Diagram）图"><a href="#DFD（Data-Flow-Diagram）图" class="headerlink" title="DFD（Data Flow Diagram）图"></a>DFD（Data Flow Diagram）图</h3><p><img src="4.png" alt="img"></p><p>DFD图是从数据传递和加工角度，以图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法。</p><p>​        适用场景: 在将思维导图得出的东西进行整合、梳理形成一个粗粒度的流程。</p><p>​        缺点: 反映系统“做什么”，不反映“如何做”，粒度算是中等，需要其它更细粒度的图来对细节做支撑。</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="5.png" alt="img"></p><p><img src="6.png" alt="img"></p><p>上面贴了2张图都是流程图，流程图有时也称作输入-输出图。该图直观地描述一个工作过程的具体步骤，各种操作一目了然，不会产生“歧义性”，便于理解，算法出错时容易发现。流程图对准确了解事情是如何进行的，以及决定应如何改进过程极有帮助。大到系统级别、小到某个操作背后的运转逻辑都可以使用流程图来画，我个人认为这应该是被最多人认识的图，没有之一。</p><p>​        适用场景：正如上面所说这个适用场景比较广，日常工作中小到算法逻辑，大到战略层面的执行落地都需要它。主要用它来将背后的流程可视化，辅助做决策去（如改进等）。</p><p>​        缺点：所占篇幅较大，由于允许使用流程线，过于灵活，不受约束，使用者可使流程任意转向，从而造成程序阅读和修改上的困难，不利于结构化程序的设计。</p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="7.png" alt="img"></p><p>UML类图是UML交互图中的一种，也是我们较常见的一种。类图是描述系统中的类，以及各个类之间的关系的静态视图。它不但是设计人员关心的核心，更是实现人员关注的核心。</p><p>​        适用场景：一般作为编码前做的最后一步，将设计转为相应的模型。也可以使用Code First的方式直接在项目中建模，现在的VS也支持直接从代码中生成UML类图。</p><p>　　缺点：缺点就是画起来太费时间了，但反过来其表达的粒度更细致，是代码实现级别的内容。由于现在有比较多的工具可以从代码生成UML类图，甚至在大部分提倡使用Code First的场景下，我们画UML类图的机会是越来越少了。</p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p><img src="8.png" alt="img"></p><p>状态图是对类图的补充。描述类的对象所有可能的状态，以及事件发生时状态的转移条件。可以捕获对象、子系统和系统的生命周期。他们可以告知一个对象可以拥有的状态，并且事件(如消息的接收、时间的流逝、错误、条件变为真等)会怎么随着时间的推移来影响这些状态。一个状态图应该连接到所有具有清晰的可标识状态和复杂行为的类；该图可以确定类的行为，以及该行为如何根据当前的状态变化，也可以展示哪些事件将会改变类的对象的状态。</p><p>　　适用场景：当有一个对象拥有多个状态的时候，想要表达清楚状态之间的演变关系（也就是这个对象的生命周期）。比如通过什么条件触发状态变动的，到达某个状态之后会做什么动作等。这也是基于事件驱动设计的良好可视化图。</p><p>　　缺点：仅能表达行为/事件与状态之间的演变关系，不适用于其它领域。</p><h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><p><img src="10.png" alt="img"></p><p>E-R图提供了表示实体型(Entity)、属性(Attribute)和联系(Relationship)的方法。其中最核心的还属联系(Relationship)的表示。</p><p>　　适用场景：虽然在UML类图中，也可以体现出聚合、依赖等关系。但是如果相关联的模型数量巨大的话，你会发现看起来特别费劲，要缩的很小才能看清全貌。这时候你需要E-R图出场了。</p><p>　　缺点：相对类图来说，E-R图无法定义类/实体的行为。它更面向数据库而不是代码。</p><h3 id="UML时序图"><a href="#UML时序图" class="headerlink" title="UML时序图"></a>UML时序图</h3><p><img src="9.png" alt="img"></p><p>时序图也是UML交互图中的一种，是描述对象是如何交互的，并且将重点放在消息序列上。也就是说，描述消息是如何在对象间发送和接收的。时序图有两个坐标轴：纵坐标轴显示时间，横坐标轴显示对象。</p><p>　　适用场景：一般当我们想反映一个包含顺序的交互流程，比如http请求的生命周期、页面上某个按钮背后流转细节等情况时，就需要它了。</p><p>　　缺点：一个时序图仅能面向一个Case，同时画起来比较费时间</p><h3 id="泳道图"><a href="#泳道图" class="headerlink" title="泳道图"></a>泳道图</h3><p><img src="11.png" alt="图片"></p><p>​        泳道图，又被称为流程图或过程图，是一种常用的业务分析工具，广泛用于描绘业务过程，提供可视化的步骤和流程。</p><p>​        泳道图提供了一种视觉化的呈现方式，使得初次接触业务的新手能够更好地理解业务的运行过程，从而对现有流程进行分析和优化。</p><pre><code>      适用场景: 明确流程环节所属的阶段、流程环节负责人、组织机构或部门的一类图形。</code></pre><h2 id="实际的运用"><a href="#实际的运用" class="headerlink" title="实际的运用"></a>实际的运用</h2><p>其实上一节中图的顺序就是按照由层次从高到底，粒度从粗到细规划的。我们可以用用例图来确定用户核心需求，再用Robustness Diagram定义好关键功能，随后在关键功能的实现上通过思维导图进行发散，然后用DFD图把粗粒度的内容串起来，至此大体的设计工作算是完成了。</p><p>　　然后再通过流程图、UML类图、状态图、E-R图、时序图在不同的场景确定细节实现。最终就是Coding的事情了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>其实最好的图是手稿，不但画起来快，还能让你的思维专注到构思上，用什么颜色之类的问题不会对你产生干扰。另外我们不要为了画图而画图，结合实际的情况把握好尺度，一般情况下，时间上不太会允许我们把图画的面面俱到，能覆盖到核心甚至80%就很好了</li><li>个人常用一般是从用例图构思模块、思维导图梳理细节功能、数据流图进行功能交互、泳道图梳理规范流程</li><li>还缺少一个很重要的 架构图，上面只是描述的构思思路，而在编写文档时候 首先亮相的就应该是架构图，让其他人知道最顶层的设计。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink Sql Join类型</title>
      <link href="/2023/10/11/Flink-2023-10-11-Flink-Sql-Join%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/10/11/Flink-2023-10-11-Flink-Sql-Join%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="Regular-Joins-普通join"><a href="#Regular-Joins-普通join" class="headerlink" title="Regular Joins(普通join)"></a>Regular Joins(普通join)</h3><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>最普通的join 两条流任何一条流更新都会触发计算,为了支持结果的更新，下游目的表需要定义主键。</li><li>运行时需要保留左表和右表的状态，且随着时间的推移，状态会无限增长，最终可能导致作业 OOM 崩溃或异常缓慢。因此我们强烈建议用户在 Flink 参数中设置 table.exec.state.ttl 选项，它可以指定 JOIN 状态的保留时间（定义键的状态在多长时间内没被更新过就会被删除），以便 Flink 及时清理过期的状态，默认值是0 ms，即保存所有状态。比如设置为1天，SET ‘table.exec.state.ttl’ = ‘86400 s’;</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>​    和普通的数据库join一样，支持INNER、LEFT、RIGHT 等多种 JOIN 类型，但是目前仅支持等值条件的连接（on x=y)</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM Orders</span><br><span class="line">INNER JOIN Product</span><br><span class="line">ON Orders.product_id = Product.id</span><br></pre></td></tr></table></figure><h3 id="Interval-Joins-区间join"><a href="#Interval-Joins-区间join" class="headerlink" title="Interval Joins(区间join)"></a>Interval Joins(区间join)</h3><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>需要至少一个等值关联条件 和 时间限制条件，时间限制条件可以是等值、条件比较、或者Between，如下ltime 左表时间属性 rtime 右表时间属性<ul><li>ltime = rtime</li><li>ltime &gt;= rtime AND ltime &lt; rtime + INTERVAL ‘10’ MINUTE</li><li>ltime BETWEEN rtime - INTERVAL ‘10’ SECOND AND rtime + INTERVAL ‘5’ SECOND</li></ul></li><li>该类型join只支持Append 数据流，不支持含 Retract等 的动态表。由于给定了关联的区间，因此只需要保留很少的状态，内存压力较小。但是缺点是如果关联的数据晚到或者早到，导致落不到 JOIN 区间内，就可能导致结果不准确。此外，只有当区间过了以后，JOIN 结果才会输出，因此会有一定的延迟存在。</li></ul><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre><code>1. 两个表中指定时间属性1. Join条件中 需要包含至少一个等值关联条件  外加一个时间区间的条件</code></pre><h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM Orders o, Shipments s</span><br><span class="line">WHERE o.id = s.order_id</span><br><span class="line">AND o.order_time BETWEEN s.ship_time - INTERVAL <span class="string">'4'</span> HOUR AND s.ship_time</span><br></pre></td></tr></table></figure><h3 id="Temporal-Joins（时态表join）"><a href="#Temporal-Joins（时态表join）" class="headerlink" title="Temporal Joins（时态表join）"></a>Temporal Joins（时态表join）</h3><h4 id="Event-Time-Temporal-Join"><a href="#Event-Time-Temporal-Join" class="headerlink" title="Event Time Temporal Join"></a>Event Time Temporal Join</h4><h4 id="Processing-Time-Temporal-Join"><a href="#Processing-Time-Temporal-Join" class="headerlink" title="Processing Time Temporal Join"></a>Processing Time Temporal Join</h4><h3 id="Lookup-Join（查找join"><a href="#Lookup-Join（查找join" class="headerlink" title="Lookup Join（查找join)"></a>Lookup Join（查找join)</h3><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>Lookup Join常用于流与维表之间的join，维表来源于外部系统，比如mysql、redis等。而维表的作用就是对流式数据进行数据补全</p></li><li><p>的，这要在性能和正确性之间做权衡。所以Lookup Join也提供了缓存的机制，使用的是guava cache实现的。默认缓存机制是禁用的。</p><ul><li><p>lookup.cache.max-rows 和 lookup.cache.ttl。两个都配置了才能启用缓存。</p><p>lookup.cache.max-rows：指定缓存的最大行数。如果超过该值，则最老的行记录将会过期，会被新的记录替换掉。</p><p>lookup.cache.ttl：指定缓存中每行记录的最大存活时间。如果某行记录超过该时间，则该行记录将会过期。</p><p>lookup.cache.caching-missing-key：是否缓存空查询结果的key，默认值是true，即缓存空查询结果的key（即key值没查到结果）</p><p>lookup.max-retries：查询数据库的最大重试次数</p></li></ul></li></ul><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p>​        Lookup Join要求流表具有处理时间属性（必须是processing time，当前不支持event time，也就是说这种方法不支持根据数据流的事件时间去查维度表里的对应时刻的数据），而维表可以直接使用连接器connector支持。Lookup Join使用Processing Time Temporal Join 的语法，且必须要有等值连接条件。</p><p>​    关键写法：JOIN table2 FOR SYSTEM_TIME AS OF table1.proctime</p><h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">orders</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    order_id    STRING,</span></span></span><br><span class="line"><span class="function"><span class="params">    price       DECIMAL(<span class="number">32</span>,<span class="number">2</span>)</span>,</span></span><br><span class="line"><span class="function">    customer_id    STRING,</span></span><br><span class="line"><span class="function">    order_time  <span class="title">TIMESTAMP</span><span class="params">(<span class="number">3</span>)</span>,</span></span><br><span class="line"><span class="function">    proc_time as <span class="title">PROCTIME</span><span class="params">()</span></span></span><br><span class="line"><span class="function">) <span class="title">with</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'connector'</span> = <span class="string">'kafka'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'topic'</span> = <span class="string">'mdxxx'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'properties.bootstrap.servers'</span> = <span class="string">'xxx-003:9092'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'properties.group.id'</span> = <span class="string">'xxx'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'scan.startup.mode'</span> = <span class="string">'latest-offset'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'format'</span> = <span class="string">'json'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'json.fail-on-missing-field'</span> = <span class="string">'false'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'json.ignore-parse-errors'</span> = <span class="string">'true'</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function">CREATE TABLE <span class="title">customers</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  id INT,</span></span></span><br><span class="line"><span class="function"><span class="params">  name STRING,</span></span></span><br><span class="line"><span class="function"><span class="params">  country STRING,</span></span></span><br><span class="line"><span class="function"><span class="params">  zip STRING</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">with</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'connector'</span> = <span class="string">'jdbc'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'url'</span> = <span class="string">'jdbc:mysql://mysqlhost:3306/customerdb'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'table-name'</span> = <span class="string">'da.customers'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'username'</span> = <span class="string">'xxx'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'password'</span> = <span class="string">'xxx'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'lookup.cache.max-rows'</span> = <span class="string">'100000'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'lookup.cache.ttl'</span> = <span class="string">'86400000'</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">SELECT o.order_id, o.price, c.country, c.zip</span><br><span class="line">FROM orders AS o</span><br><span class="line">  JOIN customers FOR SYSTEM_TIME AS OF o.proc_time AS c</span><br><span class="line">    ON o.customer_id = c.id;</span><br></pre></td></tr></table></figure><h3 id="Table-Function-Join（表函数join）"><a href="#Table-Function-Join（表函数join）" class="headerlink" title="Table Function Join（表函数join）"></a>Table Function Join（表函数join）</h3><h4 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h4><p>​    将表与表函数的结果join起来。左边(外部)表的每一行都与表函数的相应调用所产生的所有行join。用户定义表函数必须在使用前注册</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><p>​    <code>JOIN LATERAL TABLE(table_func(filed))</code></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT order_id, res</span><br><span class="line">FROM Orders,</span><br><span class="line"><span class="function">LATERAL <span class="title">TABLE</span><span class="params">(table_func(order_id)</span>) <span class="title">t</span><span class="params">(res)</span></span></span><br><span class="line"><span class="function">SELECT order_id, res</span></span><br><span class="line"><span class="function">FROM Orders</span></span><br><span class="line"><span class="function">LEFT OUTER JOIN LATERAL <span class="title">TABLE</span><span class="params">(table_func(order_id)</span>) <span class="title">t</span><span class="params">(res)</span></span></span><br><span class="line"><span class="function">ON TRUE</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> Flink sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaParse操作Java代码</title>
      <link href="/2023/10/10/Java-2023-10-10-JavaParse%E6%93%8D%E4%BD%9CJava%E4%BB%A3%E7%A0%81/"/>
      <url>/2023/10/10/Java-2023-10-10-JavaParse%E6%93%8D%E4%BD%9CJava%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载 <a href="https://www.python100.com/html/83113.html" target="_blank" rel="noopener">https://www.python100.com/html/83113.html</a></p></blockquote><p>​    JavaParse是一个Java库，它可以轻松解析和操作Java代码。使用JavaParse，您可以轻松处理Java源代码，而无需手动解析和处理文本文件。本文将从不同方面详细介绍JavaParse的功能和使用方法。</p><h3 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h3><p>JavaParse的核心类是com.github.javaparser.JavaParser。该类有一个parse()方法，可以将Java源代码解析为一个CompilationUnit对象。CompilationUnit是JavaParse中的一个类，代表整个Java源代码文件。它包含了所有的类、接口、注释和import语句。</p><p>以下是使用JavaParse进行简单解析的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String code = <span class="string">"public class Example &#123;public static void main(String[] args) &#123;System.out.println(\"Hello World!\");&#125;&#125;"</span>;</span><br><span class="line">CompilationUnit cu = JavaParser.parse(code);</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们将一个包含一个main方法的Java源代码字符串解析为一个CompilationUnit对象。</p><h3 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h3><p>JavaParser的parse()方法有一些重载，可以用不同的方式解析Java源代码。下面是一些常用的parse()方法重载：</p><h4 id="parse-File-file"><a href="#parse-File-file" class="headerlink" title="parse(File file)"></a><strong>parse(File file)</strong></h4><p>该方法可以从文件中读取Java源代码并解析它。以下是一个使用parse(File)方法解析Java文件的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"Example.java"</span>);</span><br><span class="line">CompilationUnit cu = JavaParser.parse(file);</span><br></pre></td></tr></table></figure><h4 id="parse-InputStream-in"><a href="#parse-InputStream-in" class="headerlink" title="parse(InputStream in)"></a><strong>parse(InputStream in)</strong></h4><p>该方法可以从InputStream对象中读取Java源代码并解析它。以下是一个使用parse(InputStream)方法解析Java文件的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"Example.java"</span>);</span><br><span class="line">CompilationUnit cu = JavaParser.parse(in);</span><br></pre></td></tr></table></figure><h4 id="parse-String-code"><a href="#parse-String-code" class="headerlink" title="parse(String code)"></a><strong>parse(String code)</strong></h4><p>该方法可以将Java源代码字符串解析为CompilationUnit对象。以下是使用parse(String)方法解析Java源代码字符串的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String code = <span class="string">"public class Example &#123;public static void main(String[] args) &#123;System.out.println(\"Hello World!\");&#125;&#125;"</span>;</span><br><span class="line">CompilationUnit cu = JavaParser.parse(code);</span><br></pre></td></tr></table></figure><h3 id="parse函数"><a href="#parse函数" class="headerlink" title="parse函数"></a>parse函数</h3><p>除了parse()方法外，JavaParser还有一些parse函数，可以方便地解析特定类型的Java代码元素，例如类、方法、注释和表达式等。</p><h4 id="parseClassOrInterfaceDeclaration-String-code"><a href="#parseClassOrInterfaceDeclaration-String-code" class="headerlink" title="parseClassOrInterfaceDeclaration(String code)"></a><strong>parseClassOrInterfaceDeclaration(String code)</strong></h4><p>该函数可以将Java类或接口解析为一个ClassOrInterfaceDeclaration对象。以下是使用parseClassOrInterfaceDeclaration(String)方法解析Java类的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String code = <span class="string">"public class Example &#123;public static void main(String[] args) &#123;System.out.println(\"Hello World!\");&#125;&#125;"</span>;</span><br><span class="line">ClassOrInterfaceDeclaration clazz = JavaParser.parseClassOrInterfaceDeclaration(code);</span><br></pre></td></tr></table></figure><h4 id="parseMethod-String-code"><a href="#parseMethod-String-code" class="headerlink" title="parseMethod(String code)"></a><strong>parseMethod(String code)</strong></h4><p>该函数可以将Java方法解析为一个MethodDeclaration对象。以下是使用parseMethod(String)方法解析Java方法的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String code = <span class="string">"public void sayHello(String name) &#123;System.out.println(\"Hello, \" + name + \"!\");&#125;"</span>;</span><br><span class="line">MethodDeclaration method = JavaParser.parseMethod(code);</span><br></pre></td></tr></table></figure><h3 id="parse方法的使用"><a href="#parse方法的使用" class="headerlink" title="parse方法的使用"></a>parse方法的使用</h3><p>JavaParse的parse()方法和parse函数可以与其他Java库一起使用，例如开发IDE插件或生成Java代码。</p><p>以下是一个使用JavaParse在Eclipse IDE中生成setter和getter方法的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerateMethodsAction</span> <span class="keyword">implements</span> <span class="title">IWorkbenchWindowActionDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(IAction action)</span> </span>&#123;</span><br><span class="line">        ITextSelection selection = (ITextSelection) HandlerUtil.getCurrentSelection(event);</span><br><span class="line">        String selectedText = selection.getText();</span><br><span class="line"></span><br><span class="line">        CompilationUnit cu = JavaParser.parse(selectedText);</span><br><span class="line">        List&gt; types = cu.getTypes();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (TypeDeclaration type : types) &#123;</span><br><span class="line">            List fields = type.getFields();</span><br><span class="line">            <span class="keyword">for</span> (FieldDeclaration field : fields) &#123;</span><br><span class="line">                <span class="keyword">for</span> (VariableDeclarator variable : field.getVariables()) &#123;</span><br><span class="line">                    String name = variable.getNameAsString();</span><br><span class="line">                    Type type = field.getElementType();</span><br><span class="line">                    String methodName = <span class="string">"get"</span> + name.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + name.substring(<span class="number">1</span>);</span><br><span class="line">                    MethodDeclaration getter = <span class="keyword">new</span> MethodDeclaration(Modifier.PUBLIC, type, methodName);</span><br><span class="line">                    getter.setBody(<span class="keyword">new</span> BlockStmt(<span class="keyword">new</span> ReturnStmt(name)));</span><br><span class="line">                    type.addMember(getter);</span><br><span class="line">                    methodName = <span class="string">"set"</span> + name.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + name.substring(<span class="number">1</span>);</span><br><span class="line">                    MethodDeclaration setter = <span class="keyword">new</span> MethodDeclaration(Modifier.PUBLIC, <span class="keyword">new</span> VoidType(), methodName);</span><br><span class="line">                    setter.addParameter(<span class="keyword">new</span> Parameter(type, name));</span><br><span class="line">                    setter.setBody(<span class="keyword">new</span> BlockStmt(<span class="keyword">new</span> ExpressionStmt(<span class="keyword">new</span> AssignExpr(<span class="keyword">new</span> NameExpr(name), <span class="keyword">new</span> NameExpr(name), Operator.ASSIGN))));</span><br><span class="line">                    type.addMember(setter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the generated code to file</span></span><br><span class="line">        saveToFile(cu.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveToFile</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Code to save generated code to file</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在上面的示例中，我们使用JavaParse解析选择的Java源代码。然后，我们遍历每个字段，并生成相应的setter和getter方法。最后，我们将生成的Java代码保存到文件中。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>​    JavaParse可以帮助您轻松解析和操作Java源代码。它包括从解析整个源代码文件到解析单个Java元素的多种方法。通过与其他Java库结合使用，您可以使用JavaParse进行自动化代码生成或IDE插件开发等任务。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flink回撤流问题与剖析</title>
      <link href="/2023/10/10/Flink-2023-10-10-flink%E5%9B%9E%E6%92%A4%E6%B5%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%89%96%E6%9E%90/"/>
      <url>/2023/10/10/Flink-2023-10-10-flink%E5%9B%9E%E6%92%A4%E6%B5%81%E9%97%AE%E9%A2%98%E4%B8%8E%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">--用户中心</span><br><span class="line"><span class="function">CREATE TEMPORARY TABLE <span class="title">tb_urs_user_kafka</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    origin_database STRING METADATA FROM <span class="string">'value.database'</span> VIRTUAL,</span></span></span><br><span class="line"><span class="function"><span class="params">    origin_table STRING METADATA FROM <span class="string">'value.table'</span> VIRTUAL,</span></span></span><br><span class="line"><span class="function"><span class="params">    origin_ts string METADATA FROM <span class="string">'value.ingestion-timestamp'</span> VIRTUAL,</span></span></span><br><span class="line"><span class="function"><span class="params">    id BIGINT COMMENT <span class="string">'主键'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        user_id STRING COMMENT <span class="string">'用户id'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        create_time TIMESTAMP(<span class="number">0</span>)</span> COMMENT '创建时间',</span></span><br><span class="line"><span class="function">        update_time <span class="title">TIMESTAMP</span><span class="params">(<span class="number">0</span>)</span> COMMENT '修改时间'</span></span><br><span class="line"><span class="function">) <span class="title">WITH</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'connector'</span> = <span class="string">'kafka'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'topic'</span> = <span class="string">'yb_canal_binlog_basic_ucenter_prod'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'properties.bootstrap.servers'</span> = <span class="string">'$&#123;secret_values.kafka_ip_prod&#125;'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'properties.group.id'</span> = <span class="string">'flink_basic_ybfqsync_zxd_02_prod_sql'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'scan.startup.mode'</span> = <span class="string">'timestamp'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'value.format'</span> = <span class="string">'canal-json'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'scan.startup.timestamp-millis'</span> = <span class="string">'1693324500000'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'value.canal-json.ignore-parse-errors'</span>=<span class="string">'true'</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="comment">//hbase sink 表 </span></span><br><span class="line">CREATE temporary TABLE dim_ybfq_user_id</span><br><span class="line">(</span><br><span class="line">   rk          varchar</span><br><span class="line">  ,pt varchar</span><br><span class="line">  ,<span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(rk)</span> NOT ENFORCED</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"><span class="title">WITH</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="string">'connector'</span> = <span class="string">'lindorm'</span></span></span></span><br><span class="line"><span class="function"><span class="params">  ,<span class="string">'seedserver'</span> = <span class="string">'$&#123;secret_values.lindorm_url&#125;'</span></span></span></span><br><span class="line"><span class="function"><span class="params">  ,<span class="string">'namespace'</span> = <span class="string">'ut'</span></span></span></span><br><span class="line"><span class="function"><span class="params">  ,<span class="string">'username'</span> = <span class="string">'$&#123;secret_values.lindorm_user&#125;'</span></span></span></span><br><span class="line"><span class="function"><span class="params">  ,<span class="string">'password'</span> = <span class="string">'$&#123;secret_values.lindorm_password&#125;'</span></span></span></span><br><span class="line"><span class="function"><span class="params">  ,<span class="string">'tableName'</span> = <span class="string">'dim_ybfq_user_id'</span></span></span></span><br><span class="line"><span class="function"><span class="params">  ,<span class="string">'columnFamily'</span> = <span class="string">'info'</span></span></span></span><br><span class="line"><span class="function"><span class="params">  ,<span class="string">'ignoreDelete'</span>=<span class="string">'true'</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">--写hbase</span><br><span class="line">INSERT INTO  dim_ybfq_user_id</span><br><span class="line">SELECT </span><br><span class="line">user_id,</span><br><span class="line">cast(TO_DATE(create_time) as string) as pt</span><br><span class="line">FROM tb_urs_user_kafka</span><br><span class="line">where</span><br><span class="line">REGEXP(origin_table, <span class="string">'^(tb_urs_user_)\d+$'</span>);</span><br></pre></td></tr></table></figure><p>一个简单的同步,在使用flink sql同步 kafka数据写入hbase时，发现莫名其妙的会删除数据，初始化数据有1000万，同步增量之后慢慢只有不到800万,从hbase后台发现会出现一批DELETE请求，那DELETE请求怎么来的，就得与联系Flink的回撤流了</p><h3 id="回撤流"><a href="#回撤流" class="headerlink" title="回撤流"></a>回撤流</h3><p>​    Flink中，Kafka Source是非回撤流，Group By是回撤流。所谓回撤流，就是可以更新历史数据的流，更新历史数据并不是将发往下游的历史数据进行更改，要知道，已经发往下游的消息是追不回来的。更新历史数据的含义是，在得知某个Key（接在Key BY / Group By后的字段）对应数据已经存在的情况下，如果该Key对应的数据再次到来，会生成一条delete消息和一条新的insert消息发往下游。目的就是为了做更新 。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetractDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// set up execution environment</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// use blink planner in streaming mode</span></span><br><span class="line">        EnvironmentSettings settings = EnvironmentSettings.newInstance()</span><br><span class="line">                .inStreamingMode()</span><br><span class="line">                .build();</span><br><span class="line">        StreamTableEnvironment tEnv = StreamTableEnvironment.create(env, settings);</span><br><span class="line">        <span class="comment">// 用fromElements模拟非回撤消息</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; dataStream = env.fromElements(<span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"hello"</span>, <span class="number">1</span>), <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"hello"</span>, <span class="number">1</span>), <span class="keyword">new</span> Tuple2&lt;&gt;(<span class="string">"hello"</span>, <span class="number">1</span>));</span><br><span class="line">        tEnv.registerDataStream(<span class="string">"tmpTable"</span>, dataStream, <span class="string">"word, num"</span>);</span><br><span class="line">        Table table = tEnv.sqlQuery(<span class="string">"select cnt, count(word) as freq from (select word, count(num) as cnt from tmpTable group by word) group by cnt"</span>);</span><br><span class="line">        <span class="comment">// 启用回撤流机制</span></span><br><span class="line">        tEnv.toRetractStream(table, TypeInformation.of(<span class="keyword">new</span> TypeHint&lt;Tuple2&lt;Long, Long&gt;&gt;() &#123;</span><br><span class="line">        &#125;)).print();</span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">true</span>,(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">(<span class="keyword">false</span>,(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">(<span class="keyword">true</span>,(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">(<span class="keyword">false</span>,(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">(<span class="keyword">true</span>,(<span class="number">3</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="在这里插入图片描述"></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="聚合算子回撤"><a href="#聚合算子回撤" class="headerlink" title="聚合算子回撤"></a>聚合算子回撤</h4><p>有如下sql：</p><p>​    第一层count，接收kafka source的非回撤流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT region, count(id) AS order_cnt FROM order_tab GROUP BY region</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="在这里插入图片描述"></p><p>第二层count，接收第一层count的回撤流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT order_cnt, count(region) as region_cnt FROM order_count_view GROUP BY order_cnt</span><br></pre></td></tr></table></figure><p><img src="4.png" alt="在这里插入图片描述"></p><p>下面来分析一下其源码：</p><ol><li><p>代码生成</p><p>Flink在为SQL语句生成物理执行计划是，会在<code>AggregateUtil.createGroupAggregateFunction</code>方法中生成聚合方法<code>GeneratedAggregations#retract()</code>,并最终利用Janino动态编译框架编译运行。生成<code>GeneratedAggregations</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">object AggregateUtil &#123;</span><br><span class="line"><span class="keyword">private</span>[flink] def createDataStreamGroupAggregateFunction[K](...generateRetraction: Boolean...)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 动态生成聚合方法</span></span><br><span class="line">    <span class="keyword">new</span> GroupTableAggProcessFunction[K](</span><br><span class="line">    genAggregations.asInstanceOf[GeneratedTableAggregationsFunction],</span><br><span class="line">    aggregationStateType,</span><br><span class="line">    <span class="comment">// 生成聚合函数是否支持retraction，该方法通过判断上游流是否支持回撤来进行返回，true表示支持，false表示不支持</span></span><br><span class="line">    <span class="comment">// 例如kafka source算子不支持回撤流，count聚合算子支持回撤流</span></span><br><span class="line">    generateRetraction,</span><br><span class="line">    groupings.length,</span><br><span class="line">    queryConfig)</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class GroupAggProcessFunction[K](...private val generateRetraction: Boolean...)&#123;</span><br><span class="line">  <span class="comment">// 代理模式，真正生成的function被GroupTableAggProcessFunction所代理</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> function: GeneratedTableAggregations = _</span><br><span class="line">  </span><br><span class="line"><span class="function">override def <span class="title">open</span><span class="params">(config: Configuration)</span> </span>&#123;</span><br><span class="line">  LOG.debug(s<span class="string">"Compiling TableAggregateHelper: $&#123;genTableAggregations.name&#125; \n\n "</span> +</span><br><span class="line">      s<span class="string">"Code:\n$&#123;genTableAggregations.code&#125;"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用janino动态编译框架，动态编译并动态加载聚合函数</span></span><br><span class="line">    val clazz = compile(</span><br><span class="line">      <span class="comment">// 获取类加载器</span></span><br><span class="line">      getRuntimeContext.getUserCodeClassLoader,</span><br><span class="line">      genAggregations.name,</span><br><span class="line">      genAggregations.code)</span><br><span class="line">    LOG.debug(<span class="string">"Instantiating TableAggregateHelper."</span>)</span><br><span class="line">    function = clazz.newInstance()</span><br><span class="line">    function.open(getRuntimeContext)</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// janino的使用</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">import</span> org.codehaus.janino.SimpleCompiler</span><br><span class="line">trait Compiler[T] &#123;</span><br><span class="line">  <span class="meta">@throws</span>(classOf[CompileException])</span><br><span class="line">  <span class="function">def <span class="title">compile</span><span class="params">(cl: ClassLoader, name: String, code: String)</span>: Class[T] </span>= &#123;</span><br><span class="line">    require(cl != <span class="keyword">null</span>, <span class="string">"Classloader must not be null."</span>)</span><br><span class="line">    val compiler = <span class="keyword">new</span> SimpleCompiler()</span><br><span class="line">    compiler.setParentClassLoader(cl)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      compiler.cook(code)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> t: Throwable =&gt;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidProgramException(<span class="string">"Table program cannot be compiled. "</span> +</span><br><span class="line">          <span class="string">"This is a bug. Please file an issue."</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">    compiler.getClassLoader.loadClass(name).asInstanceOf[Class[T]</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回撤</p><p>聚合算子中包含两种状态，state 存储中间结果状态（如count(id)值）、cntState存储key对应的消息数量（聚合消息+1，回撤消息-1）。state用于不断更新中间聚合状态，cntState用于判断向下游发送当前新的聚合消息，还是上一次聚合消息对应的回撤消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">state class GroupAggProcessFunction[K](...)</span><br><span class="line">    extends ProcessFunctionWithCleanupState[K, CRow, CRow](queryConfig)&#123;</span><br><span class="line">      <span class="comment">// 每一条消息都会经过该方法处理</span></span><br><span class="line">      <span class="function">override def <span class="title">processElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      // 消息的格式是CRow，包含一个change字段，标识是否是聚合消息；<span class="keyword">true</span>标识聚合消息，<span class="keyword">false</span>标识回撤消息</span></span></span><br><span class="line"><span class="function"><span class="params">      inputC: CRow,</span></span></span><br><span class="line"><span class="function"><span class="params">      ctx: KeyedProcessFunction[K, CRow, CRow]#Context,</span></span></span><br><span class="line"><span class="function"><span class="params">      out: Collector[CRow])</span>: Unit </span>= &#123;</span><br><span class="line">      ...</span><br><span class="line">        </span><br><span class="line">          <span class="comment">// 中间状态，即上一次的聚合结果</span></span><br><span class="line">    <span class="keyword">var</span> accumulators = state.value()</span><br><span class="line">          <span class="comment">// key对应的消息数量，对于不支持回撤流的消息，取值可以&gt;1；对于支持回撤流的消息，取值为0或1</span></span><br><span class="line">    <span class="keyword">var</span> inputCnt = cntState.value()</span><br><span class="line">          <span class="comment">// 如果是聚合消息</span></span><br><span class="line">          <span class="keyword">if</span> (inputC.change) &#123;</span><br><span class="line">      inputCnt += <span class="number">1</span></span><br><span class="line">      <span class="comment">// accumulate()是聚合方法，例如count()</span></span><br><span class="line">      function.accumulate(accumulators, input)</span><br><span class="line">      function.setAggregationResults(accumulators, newRow.row)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对于支持回撤流的消息，inputCnt取值为0或1，因为某条消息如果要发生变更，只有先撤回，再新增新消息，如图片中的（+ SH 1）,（- SH 1），（+ SH 2）</span></span><br><span class="line">      inputCnt -= <span class="number">1</span></span><br><span class="line">            <span class="comment">// function对象的retract（）方法，只有在判断上游算子支持回撤流时才会生成；在当前场景下为与count()相反的逻辑，即对input中key的count聚合进行减一操作</span></span><br><span class="line">      function.retract(accumulators, input)</span><br><span class="line">      function.setAggregationResults(accumulators, newRow.row)</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">          <span class="comment">// 如果该key对应的中间状态还存在，即如果该key还存在，发送最新的聚合消息</span></span><br><span class="line">          <span class="keyword">if</span> (inputCnt != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// update the state</span></span><br><span class="line">      state.update(accumulators)</span><br><span class="line">      cntState.update(inputCnt)</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// newRow/prevRow分别代表新消息和对上一次消息的回撤消息，具体请参考源码</span></span><br><span class="line">          out.collect(newRow)</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果该key的聚合消息和回撤消息数量相等，则认为该key即将消失，发送回撤消息</span></span><br><span class="line">            out.collect(prevRow)</span><br><span class="line">      <span class="comment">// 清除状态</span></span><br><span class="line">      state.clear()</span><br><span class="line">      cntState.clear()</span><br><span class="line">          &#125;</span><br><span class="line">    ...</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Sink算子回撤"><a href="#Sink算子回撤" class="headerlink" title="Sink算子回撤"></a>Sink算子回撤</h4><p>回顾一下 flink sql的处理流程</p><p><img src="5.png" alt="image-20231010104618924"></p><p>流式表查询的处理过程：</p><ol><li><p>流被转换为动态表</p></li><li><p>对动态表计算连续查询，生成新的动态表</p></li><li><p>生成的动态表被转换回流</p></li></ol><p>官方对于sink的插入模式有以下三种描述：</p><ul><li>Append 模式 - 该模式用户在定义Sink的DDL时候不定义PK，在Apache Flink内部生成的所有只有INSERT语句；</li><li>Upsert 模式 - 该模式用户在定义Sink的DDL时候可以定义PK，在Apache Flink内部会根据事件打标(retract机制)生成Upsert和DELETE 语句,其中如果定义了PK， UPDATE语句按PK进行更新，如果没有定义PK UPDATE会按整行更新；</li><li>Retract 模式 - 该模式下会产生INSERT和DELETE两种信息，Sink Connector 根据这两种信息构造对应的数据操作指令；</li></ul><p>但其实sink算子是否支持回撤流，要根据sink数据源的特性而定。例如kafka sink只支持append模式，jdbc sink在Flink1.11中只支持upsert（不配置primary key会报错）。这都跟sink数据源的特性密切相关</p><ol><li><p>kafka sink</p><p>如kafka是利用log中顺序追加消息的方式存储消息，因此只支持append模式，网上有修改kafka sink connector以支持upsert的方法：将聚合算子中的回撤消息（false）过滤掉，只留下聚合消息（true），并写入kafka，带来的现象就是一个聚合结果会多次出现在kafka中，算是一种阉割版的upsert模式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaTableSinkBase</span> <span class="keyword">implements</span> <span class="title">AppendStreamTableSink</span>&lt;<span class="title">Row</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 将 kafka 改成 upsert</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DataStreamSink&lt;?&gt; consumeDataStream(DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dataStream) &#123;</span><br><span class="line">    <span class="keyword">final</span> SinkFunction&lt;Row&gt; kafkaProducer = createKafkaProducer(</span><br><span class="line">            topic,</span><br><span class="line">            properties,</span><br><span class="line">            serializationSchema,</span><br><span class="line">            partitioner);</span><br><span class="line">    <span class="comment">// 过滤掉回撤消息</span></span><br><span class="line">    <span class="keyword">return</span> dataStream.filter(t -&gt; t.f0).map(t -&gt; t.f1)</span><br><span class="line">            .addSink(kafkaProducer)</span><br><span class="line">            .setParallelism(dataStream.getParallelism())</span><br><span class="line">            .name(TableConnectorUtils.generateRuntimeName(<span class="keyword">this</span>.getClass(), getFieldNames()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>JDBC Sink</p><p>jdbc sink我们以mysql为例，理论上mysql支持append、upsert、retract中的所有模式，但是Flink1.11中只提供了upsert模式。这很好理解，CDC作为Flink1.11的重大特性，append和retract对于CDC都没有意义，只有upsert符合CDC的初衷。</p><blockquote><p>注意：Flink 1.11中ddl中不配置primary key会报错，尽管Flink并不会校验primary key的正确性，而只是upsert模式的一种表征</p></blockquote><p>其原理是利用了mysql的upsert原子语句（必须有主键）来实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `TABLE_SINK_SYNC`(`eno`, `ename`, `esex`, `ebirthday`, `eteam`, `eincome`)</span><br><span class="line">VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">ON DUPLICATE KEY UPDATE `eno`=VALUES(`eno`),</span><br><span class="line">                        `ename`=VALUES(`ename`),</span><br><span class="line">                        `esex`=VALUES(`esex`),</span><br><span class="line">                        `ebirthday`=VALUES(`ebirthday`),</span><br><span class="line">                        `eteam`=VALUES(`eteam`),</span><br><span class="line">                        `eincome`=VALUES(`eincome`)</span><br></pre></td></tr></table></figure><p>如果upsert操作不是原子的，很可能会发生并发问题，带来预料不到的后果。</p></li></ol></li></ol><h4 id="聚合算子回撤-VS-Sink算子回撤"><a href="#聚合算子回撤-VS-Sink算子回撤" class="headerlink" title="聚合算子回撤 VS Sink算子回撤"></a>聚合算子回撤 VS Sink算子回撤</h4><ol><li>原理不同</li></ol><ul><li><p>聚合算子通过在state和cntState这两个状态分别维护中间聚合状态和某key所对应的消息数量（聚合消息+1，回撤消息-1），如果cntState.value() = 1，则下发最新的聚合消息；如果cntState.value() = 0，则将state中维护的上一次的聚合状态作为回撤消息进行下发。</p></li><li><p>Sink算子则是解析canal或debezium中的op字段，如果op=create，则取after字段中的有效数据进行下发；如果op=update，则分别取before和after中的有效数据进行下发；如果op=delete，则取before中的有效数据进行下发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DebeziumJsonDeserializationSchema</span> <span class="keyword">implements</span> <span class="title">DeserializationSchema</span>&lt;<span class="title">RowData</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] message, Collector&lt;RowData&gt; out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    GenericRowData row = (GenericRowData) jsonDeserializer.deserialize(message);</span><br><span class="line">GenericRowData payload;</span><br><span class="line"><span class="keyword">if</span> (schemaInclude) &#123;</span><br><span class="line">payload = (GenericRowData) row.getField(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">payload = row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GenericRowData before = (GenericRowData) payload.getField(<span class="number">0</span>);</span><br><span class="line">GenericRowData after = (GenericRowData) payload.getField(<span class="number">1</span>);</span><br><span class="line">String op = payload.getField(<span class="number">2</span>).toString();</span><br><span class="line">      <span class="comment">// 关键逻辑</span></span><br><span class="line"><span class="keyword">if</span> (OP_CREATE.equals(op) || OP_READ.equals(op)) &#123;</span><br><span class="line">after.setRowKind(RowKind.INSERT);</span><br><span class="line">out.collect(after);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (OP_UPDATE.equals(op)) &#123;</span><br><span class="line">before.setRowKind(RowKind.UPDATE_BEFORE);</span><br><span class="line">after.setRowKind(RowKind.UPDATE_AFTER);</span><br><span class="line">out.collect(before);</span><br><span class="line">out.collect(after);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (OP_DELETE.equals(op)) &#123;</span><br><span class="line">before.setRowKind(RowKind.DELETE);</span><br><span class="line">out.collect(before);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!ignoreParseErrors) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IOException(format(</span><br><span class="line"><span class="string">"Unknown \"op\" value \"%s\". The Debezium JSON message is '%s'"</span>, op, <span class="keyword">new</span> String(message)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后，利用JDBC原子语句<code>ON DUPLICATE KEY UPDATE</code>实现upsert语义。</p></li></ul><ol><li><p>数据结构不同</p><p>聚合算子中的数据格式为<code>CRow</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class CRow(var row: Row, var change: Boolean) &#123;&#125;</span><br></pre></td></tr></table></figure><p>Sink算子中的数据结构为Row</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericRowData</span> <span class="keyword">implements</span> <span class="title">RowData</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object[] fields;</span><br><span class="line">  <span class="comment">// Flink1.11新增的属性</span></span><br><span class="line"><span class="keyword">private</span> RowKind kind;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RowKind &#123;</span><br><span class="line">INSERT(<span class="string">"+I"</span>, (<span class="keyword">byte</span>) <span class="number">0</span>),</span><br><span class="line">UPDATE_BEFORE(<span class="string">"-U"</span>, (<span class="keyword">byte</span>) <span class="number">1</span>),</span><br><span class="line">UPDATE_AFTER(<span class="string">"+U"</span>, (<span class="keyword">byte</span>) <span class="number">2</span>),</span><br><span class="line">DELETE(<span class="string">"-D"</span>, (<span class="keyword">byte</span>) <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>聚合算子和Sink算子关于回撤的概念相似，但原理不同且使用场景也不同，聚合算子的回撤用于聚合状态的更新，Sink算子的回撤则更多的是应用于CDC场景。</p><p>聚合算子的撤回机制，保证了FlinkSQL持续查询/增量查询的正确语义；而Sink算子的回撤机制，保证了CDC场景下的正确语义。</p><p>在回到头看我们引入的问题，实际上就是flink sql写入hbase时 转成了 回撤流 所以一个写入请求 被拆成了 DELETE和PUT请求，并且由于两个时间戳一致，hbase正是通过时间戳来判断写入顺序的，就导致先PUT之后又删除的情况,而实际上 HBase本身是由rowkey保证幂等的无需回撤，所以只要过滤掉DELETE请求即可，可通过参数 <code>ignoreDelete&#39;=&#39;true</code>搞定。</p><blockquote><p><a href="https://blog.csdn.net/daijiguo/article/details/109976105" target="_blank" rel="noopener">https://blog.csdn.net/daijiguo/article/details/109976105</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flink泛型擦除</title>
      <link href="/2023/10/09/Flink-2023-10-09-flink%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/"/>
      <url>/2023/10/09/Flink-2023-10-09-flink%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java 8的Lambda表达式允许以一种直接的方式实现和传递函数，而不需要声明额外的(匿名的)类。Flink对Java API的所有操作符都支持使用lambda表达式，但是当lambda表达式使用了Java泛型时，开发者需要显式声明类型信息。如果开发者没有显式声明类型信息，那么使用lambda表达式会导致程序出错，这是Java编译器的泛型擦除问题所导致的。</p></blockquote><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>Java编译器在编译后会抛弃大部分的泛型类型信息,这被称为Java的泛型擦除。这意味着Flink应用程序在运行时，对象的一个实例不会知道它的泛型类型，例如DataStream<string>和DataStream<long>的实例在JVM中看起来是相同。</p><p>下面的示例map函数的输入和输出参数的类型不需要声明，因为它们是由Java编译器推断的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">DataStream&lt;Long&gt; dataStream = env.generateSequence(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 在map操作上使用lambda表达式</span></span><br><span class="line">DataStream&lt;Long&gt; resultStream=dataStream.map(i -&gt; i*i);</span><br><span class="line">resultStream.print();</span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure></p><p>​    Flink可以从方法签名OUT map(IN value)的实现中自动提取结果类型信息，但是对于具有泛型返回或输入类型的map函数Tuple2<Long, Long> map(Tuple2<Long, Long> value)会被Java编译器编译成Tuple2 map(Tuple2 value),这使得Flink不可能自动推断输入和输出类型的类型信息。<br>​    第二次map操作中数据流中的元素为Tuple2<Long, Long>具有泛型类型，而map操作使用了Lambda表达式导致Flink无法推断出泛型的类型，应用程序会抛出一个类似于下面的异常:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.apache.flink.api.common.functions.InvalidTypesException: The generic type parameters of <span class="string">'Tuple2'</span> are missing. </span><br><span class="line">In many cases lambda methods don<span class="string">'t provide enough information for automatic type extraction when Java generics are involved. </span></span><br><span class="line"><span class="string">An easy workaround is to use an (anonymous) class instead that </span></span><br><span class="line"><span class="string">implements the '</span>org.apache.flink.api.common.functions.MapFunction<span class="string">' interface.</span></span><br><span class="line"><span class="string">Otherwise the type has to be specified explicitly using type information.</span></span><br><span class="line"><span class="string">    at org.apache.flink.api.java.typeutils.TypeExtractionUtils.validateLambdaType(TypeExtractionUtils.java:350)</span></span><br><span class="line"><span class="string">    at org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(TypeExtractor.java:579)</span></span><br><span class="line"><span class="string">    at org.apache.flink.api.java.typeutils.TypeExtractor.getMapReturnTypes(TypeExtractor.java:175)</span></span><br><span class="line"><span class="string">    at org.apache.flink.streaming.api.datastream.DataStream.map(DataStream.java:587)</span></span><br><span class="line"><span class="string">    ... 1 more</span></span><br></pre></td></tr></table></figure><h2 id="returns方法"><a href="#returns方法" class="headerlink" title="returns方法"></a>returns方法</h2><p>对于Flink应用程序中操作符上使用Lambda表达式导致Flink无法推断出泛型的类型的问题，需要开发者在使用lambda表达式传递函数的操作符后面调用returns(…)方法来添加有关此操作符的返回类型的类型信息提示，否则输出将被视为Object类型，从而导致无效的序列化。</p><p>对上面的程序我们在mapStream数据流上调用map操作符之后调用returns(…)方法添加此操作符的返回类型的类型信息提示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.Types;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">DataStream&lt;Long&gt; dataStream = env.generateSequence(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//将Long类型的数据流转换为一个Tuple2&lt;Long, Long&gt;类型的数据流</span></span><br><span class="line">DataStream&lt;Tuple2&lt;Long, Long&gt;&gt; mapStream=dataStream.map(<span class="keyword">new</span> MapFunction&lt;Long, Tuple2&lt;Long, Long&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title">map</span><span class="params">(Long value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(value, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)；</span><br><span class="line"><span class="comment">// 在map操作上使用lambda表达式</span></span><br><span class="line">DataStream&lt;Tuple2&lt;Long, Long&gt;&gt; resultStream=mapStream.map(value -&gt; value)</span><br><span class="line">                                                <span class="comment">//提供明确的类型信息</span></span><br><span class="line">                                                .returns(Types.TUPLE(Types.LONG, Types.LONG))</span><br><span class="line">resultStream.print();</span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure></p><p>returns(…)方法提供了三个重载方法：</p><ul><li><p>public SingleOutputStreamOperator<T> returns(Class<T> typeClass)：类可以用作非泛型类型（没有泛型参数的类）的类型提示，但不能用于诸如Tuples之类的泛型类型。对于那些泛型类型，请使用returns(TypeHint<T> typeHint)方法。</p></li><li><p>public SingleOutputStreamOperator<T> returns(TypeHint<T> typeHint)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过以下方式使用此方法：</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.TypeHint;</span><br><span class="line">DataStream&lt;Tuple2&lt;String, Double&gt;&gt; result =</span><br><span class="line">          stream.flatMap(<span class="keyword">new</span> FunctionWithNonInferrableReturnType())</span><br><span class="line">                .returns(<span class="keyword">new</span> TypeHint&lt;Tuple2&lt;String, Double&gt;&gt;()&#123;&#125;);</span><br></pre></td></tr></table></figure></li><li><p>public SingleOutputStreamOperator<T> returns(TypeInformation<T> typeInfo)：在大多数情况下，首选方法returns(Class)和returns(TypeHint)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过以下方式使用此方法：</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.Types;</span><br><span class="line">DataStream&lt;Tuple2&lt;String, Double&gt;&gt; result =</span><br><span class="line">          stream.flatMap(<span class="keyword">new</span> FunctionWithNonInferrableReturnType())</span><br><span class="line">                .returns(Types.TUPLE(Types.String, Types.Double));</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务解决方案之3PC</title>
      <link href="/2023/03/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2023-03-09-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B3PC/"/>
      <url>/2023/03/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2023-03-09-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B3PC/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是3PC"><a href="#什么是3PC" class="headerlink" title="什么是3PC"></a>什么是3PC</h2><p> 3PC，三阶段提交协议，是二阶段提交协议的改进版本，三阶段提交有两个改动点：</p><p>（1）在协调者和参与者中都引入超时机制<br>（2）在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。<br>        所以3PC会分为3个阶段，CanCommit 准备阶段、PreCommit 预提交阶段、DoCommit 提交阶段，处理流程如下：<br><img src="1.jpg" alt="img" style="zoom:75%;" /></p><h2 id="3PC阶段详情"><a href="#3PC阶段详情" class="headerlink" title="3PC阶段详情"></a>3PC阶段详情</h2><h3 id="阶段一：CanCommit-准备阶段"><a href="#阶段一：CanCommit-准备阶段" class="headerlink" title="阶段一：CanCommit 准备阶段"></a>阶段一：CanCommit 准备阶段</h3><p>协调者向参与者发送 canCommit 请求，参与者如果可以提交就返回Yes响应，否则返回No响应，具体流程如下：</p><ol><li>事务询问：协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。</li><li>响应反馈：参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。</li></ol><h3 id="阶段二：PreCommit-阶段"><a href="#阶段二：PreCommit-阶段" class="headerlink" title="阶段二：PreCommit 阶段"></a>阶段二：PreCommit 阶段</h3><p>​        协调者根据参与者的反应情况来决定是否可以进行事务的 PreCommit 操作。根据响应情况，有以下两种可能：</p><h4 id="执行事务："><a href="#执行事务：" class="headerlink" title="执行事务："></a><strong>执行事务</strong>：</h4><p>假如所有参与者均反馈 yes，协调者预执行事务，具体如下：</p><ol><li>发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入准备阶段</li><li>事务预提交 ：参与者接收到 PreCommit 请求后，会执行本地事务操作，并将 undo 和 redo 信息记录到事务日志中（但不提交事务）</li><li>响应反馈 ：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</li></ol><p>​        <img src="2.jpg" alt="img" style="zoom:67%;" /></p><h4 id="中断事务："><a href="#中断事务：" class="headerlink" title="中断事务："></a><strong>中断事务：</strong></h4><p>任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务</p><ol><li>发送中断请求：如果协调者处于工作状态，向所有参与者发出 abort 请求</li><li><p>中断事务 ：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</p><p><img src="3.jpg" alt="img" style="zoom:80%;" /></p></li></ol><h3 id="阶段三：doCommit阶段"><a href="#阶段三：doCommit阶段" class="headerlink" title="阶段三：doCommit阶段"></a>阶段三：doCommit阶段</h3><p>该阶段进行真正的事务提交，也可以分为以下两种情况：</p><h4 id="提交事务："><a href="#提交事务：" class="headerlink" title="提交事务："></a><strong>提交事务：</strong></h4><ol><li>发送提交请求：协调接收到所有参与者发送的ACK响应，那么他将从预提交状态进入到提交状态，并向所有参与者发送 doCommit 请求</li><li>本地事务提交：参与者接收到doCommit请求之后，执行正式的事务提交，并在完成事务提交之后释放所有事务资源</li><li>响应反馈：事务提交完之后，向协调者发送ack响应。</li><li><p>完成事务：协调者接收到所有参与者的ack响应之后，完成事务。</p><p><img src="4.jpg" alt="img"></p></li></ol><h4 id="中断事务"><a href="#中断事务" class="headerlink" title="中断事务:"></a><strong>中断事务</strong>:</h4><p>任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务</p><ol><li>发送中断请求：如果协调者处于工作状态，向所有参与者发出 abort 请求</li><li>事务回滚：参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</li><li>反馈结果：参与者完成事务回滚之后，向协调者反馈ACK消息</li><li><p>中断事务：协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p><p><img src="5.jpg" alt="img"></p></li></ol><p>​        </p><p>​        进入doCommit阶段后，无论协调者出现问题，或者协调者与参与者之间的网络出现问题，都会导致参与者无法接收到协调者发出的 doCommit 请求或 abort 请求。此时，参与者都会在等待超时之后，继续执行事务提交。这其实基于概率来决定的，当进入第三阶段时，说明第一阶段收到所有参与者的CanCommit响应都是Yes，意味着大家都同意修改了，并且第二阶段所有的参与者对协调者的PreCommit请求也都是同意的。所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>​    3PC 作为2PC的改动出现，引入第一阶段，就是为了尽可能的减少锁定资源的时间，降低了阻塞范围，并且在等待超时后，协调者或参与者会中断事务，避免了协调者单点问题，阶段三中协调者出现问题时，参与者会继续提交事务。</p><p>​    数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 doCommit 指令时，此时如果协调者请求中断事务，而协调者因为网络问题无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</p><p>​    3PC是假设网络环境差的情况下，但通常情况 2PC即可。</p><blockquote><p>引用：<a href="https://blog.csdn.net/a745233700/article/details/122402303" target="_blank" rel="noopener">https://blog.csdn.net/a745233700/article/details/122402303</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务解决方案之2PC</title>
      <link href="/2023/03/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2023-03-09-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B2PC/"/>
      <url>/2023/03/09/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2023-03-09-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B2PC/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是2PC"><a href="#什么是2PC" class="headerlink" title="什么是2PC"></a>什么是2PC</h2><p>2PC即两阶段提交协议，是将<strong>整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase），2是指两个阶段，P是指准备阶段，C是指提交阶段</strong>。</p><p>举例：张三和李四好久不见，老友约起聚餐，饭店老板要求先买单，才能出票。这时张三和李四分别抱怨近况不如意，囊中羞涩，都不愿意请客，这时只能AA。</p><p>只有张三和李四都付款，老板才能出票安排就餐。但由于张三和李四都是铁公鸡，形成了尴尬的一幕：</p><p><strong>准备阶段</strong>：老板要求张三付款，张三付款。老板要求李四付款，李四付款。</p><p><strong>提交阶段</strong>：老板出票，两人拿票纷纷落座就餐。</p><blockquote><p>例子中形成了一个事务，若张三或李四其中一人拒绝付款，或钱不够，店老板都不会给出票，并且会把已收款退回。整个事务过程由事务管理器和参与者组成，店老板就是事务管理器，张三、李四就是事务参与者，事务管理器负责决策整个分布式事务的提交和回滚，事务参与者负责自己本地事务的提交和回滚。在计算机中部分关系数据库如Oracle、MySQL支持两阶段提交协议。</p></blockquote><h2 id="阶段详情"><a href="#阶段详情" class="headerlink" title="阶段详情"></a>阶段详情</h2><h3 id="准备阶段（Prepare-phase）"><a href="#准备阶段（Prepare-phase）" class="headerlink" title="准备阶段（Prepare phase）"></a>准备阶段（Prepare phase）</h3><p>事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，</p><p>此时事务没有提交。（Undo日志是记录修改前的数据，用于数据库回滚，Redo日志是记录修改后的数据，用于提交事务后写入数据文件）</p><h3 id="提交阶段（commit-phase）"><a href="#提交阶段（commit-phase）" class="headerlink" title="提交阶段（commit phase）"></a>提交阶段（commit phase）</h3><p>如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；</p><p>参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。</p><p>注意：必须在最后阶段释放锁资源。</p><p>下图展示了2PC的两个阶段，分成功和失败两个情况说明：</p><ol><li><p>成功情况</p><p><img src="1.jpg" alt="img"></p></li><li><p>失败情况</p><p><img src="2.jpg" alt="img"></p></li></ol><h2 id="XA协议"><a href="#XA协议" class="headerlink" title="XA协议"></a>XA协议</h2><p>​    是X/OPEN 提出的分布式事务处理规范。XA则规范了TM与RM之间的通信接口，在TM与多个RM之间形成一个双向通信桥梁，从而在多个数据库资源下保证ACID四个特性。目前知名的数据库，如Oracle, DB2,mysql等，都是实现了XA接口的，都可以作为RM。</p><p>XA是数据库的分布式事务，强一致性，在整个过程中，数据一张锁住状态，即从prepare到commit、rollback的整个过程中，TM一直把持折数据库的锁，如果有其他人要修改数据库的该条数据，就必须等待锁的释放，存在长事务风险。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点：原理简单，实现方便</strong><br><strong>缺点：同步阻塞，单点问题，数据不一致，缺乏容错机制</strong>    </p><p>2PC协议明显的优点就是：原理简单、容易实现。相比优点，缺点更多：</p><ul><li>同步阻塞 每个参与者都需要等待其他参与者完成后，才能继续下一阶段，也就是说事务操作逻辑都是处于阻塞状态，极大限制了分布式系统性能</li><li>数据不一致 在第二阶段，如果出现网络异常导致一部分参与者收到了commit请求，一部分参与者没有收到commit请求，结果会是一部分参与者提交了事务，一部分参与者无法进行事务提交</li><li>单点问题/脑裂 协调者在2PC中，太过重要，当协调者宕机，整个集群将不可用。更可怕的是，协调者在第二阶段之前宕机，那么所有参与者将一直锁定准备阶段的事务资源。脑裂（动态选主情况下）是指因为网络原因，出现多个协调者。</li><li>太过保守 任何一个节点故障，都会导致整个事务协调失败，换句话说没有完善的容错机制。</li></ul><blockquote><p>引用:<a href="https://blog.csdn.net/qq_38826019/article/details/119342296" target="_blank" rel="noopener">https://blog.csdn.net/qq_38826019/article/details/119342296</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clickhouse join分析及优化</title>
      <link href="/2023/03/06/%E5%A4%A7%E6%95%B0%E6%8D%AE-2023-03-06-clickhouse-join%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>/2023/03/06/%E5%A4%A7%E6%95%B0%E6%8D%AE-2023-03-06-clickhouse-join%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="ClickHouse-Join"><a href="#ClickHouse-Join" class="headerlink" title="ClickHouse Join"></a>ClickHouse Join</h2><p>clickhouse的join 分为单机join和分布式join </p><h3 id="单机join"><a href="#单机join" class="headerlink" title="单机join"></a>单机join</h3><p>​    SQL 里面只有本地表的 JOIN，只会在当前节点执行。本地JOIN方式分为Hash JOIN和Merge Join。优先使用 hash join 当内存达到一定阈值后再使用 merge join，优先满足性能要求。</p><h4 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a><strong>Hash Join</strong></h4><ul><li>右表全部数据加载到内存，再在内存构建 hash table。key 为 joinkey。</li><li>从左表分批读取数据，从右表 hash table匹配数据。</li></ul><h4 id="Merge-join"><a href="#Merge-join" class="headerlink" title="Merge join"></a><strong>Merge join</strong></h4><ul><li>对右表排序，内部 block 切分，超出内存部分 flush 到磁盘上，内存大小通过参数设定。</li><li>左表基于 block 排序，按照每个 block 依次与右表 merge</li></ul><h3 id="分布式join"><a href="#分布式join" class="headerlink" title="分布式join"></a>分布式join</h3><p>​    分布式Join分为普通分布式Join以及Global Join。在分析两种Join的执行流程下，我们先看看CK的执行模式。</p><h4 id="执行模式"><a href="#执行模式" class="headerlink" title="执行模式"></a><strong>执行模式</strong></h4><p>​    和SR很像，查询也是两个阶段</p><p><img src="1.jpg" alt=""></p><p>​       第一阶段，Coordinator 收到查询后将请求发送给对应的 worker 节点；第二阶段，Coordinator 收到各个 worker 节点的结果后汇聚起来处理后返回。</p><h4 id="普通分布式Join"><a href="#普通分布式Join" class="headerlink" title="普通分布式Join"></a><strong>普通分布式Join</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    et.os_name, </span><br><span class="line">    ut.device_id <span class="keyword">AS</span> user_device_id</span><br><span class="line"><span class="keyword">FROM</span> tob_apps_all <span class="keyword">AS</span> et </span><br><span class="line"><span class="keyword">ANY</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        device_id, </span><br><span class="line">        hash_uid</span><br><span class="line">    <span class="keyword">FROM</span> users_unique_all </span><br><span class="line">    <span class="keyword">WHERE</span> (tea_app_id = <span class="number">268411</span>) <span class="keyword">AND</span> (last_active_date &gt;= <span class="string">'2022-08-06'</span>)</span><br><span class="line">) <span class="keyword">AS</span> ut <span class="keyword">ON</span> et.hash_uid = ut.hash_uid</span><br><span class="line"><span class="keyword">WHERE</span> (tea_app_id = <span class="number">268411</span>) </span><br><span class="line"><span class="keyword">AND</span> (<span class="keyword">event</span> = <span class="string">'app_launch'</span>) </span><br><span class="line"><span class="keyword">AND</span> (event_date = <span class="string">'2022-08-06'</span>)</span><br></pre></td></tr></table></figure><p>对于上面的SQL，其执行过程如下：</p><ol><li><p>Coordinator 节点，给每个节点分发子查询，子查询 sql（tob_apps_all 替换成本地表，users_unique_all 保持不变依然是分布式表）。</p></li><li><p>每个节点执行 Coordinator 分发的 sql 时，发现 users_unique_all 是分布式表，就会去所有节点上去查询以下 SQL(一共有 N*N。N 为 shard 数量)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> device_id, hash_uid <span class="keyword">FROM</span> users_unique <span class="keyword">WHERE</span> (tea_app_id = <span class="number">268411</span>) <span class="keyword">AND</span> (last_active_date &gt;= <span class="string">'2022-08-06'</span>)</span><br></pre></td></tr></table></figure></li><li><p>每个节点从其他 N-1个节点拉取2中子查询的全部数据，全量存储(内存 or 文件) ，进行本地 JOIN</p></li><li>Coordinator 节点从每个节点拉取3中的结果集，然后做处理返回给 client。</li></ol><p>可以看出，ClickHouse 普通分布式JOIN查询是一个简单版的Shuffle JOIN的实现，或者说是一个不完整的实现。不完整的地方在于，并未按JOIN KEY去Shuffle数据，而是每个节点全量拉去右表数据。存在的问题：</p><ol><li>子查询数量放大。</li><li>每个节点都全量存储全量的数据。</li></ol><h4 id="分布式Global-Join"><a href="#分布式Global-Join" class="headerlink" title="分布式Global Join"></a>分布式Global Join</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    et.os_name, </span><br><span class="line">    ut.device_id <span class="keyword">AS</span> user_device_id</span><br><span class="line"><span class="keyword">FROM</span> tob_apps_all <span class="keyword">AS</span> et </span><br><span class="line"><span class="keyword">GLOBAL</span> <span class="keyword">ANY</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        device_id, </span><br><span class="line">        hash_uid</span><br><span class="line">    <span class="keyword">FROM</span> users_unique_all </span><br><span class="line">    <span class="keyword">WHERE</span> (tea_app_id = <span class="number">268411</span>) <span class="keyword">AND</span> (last_active_date &gt;= <span class="string">'2022-08-06'</span>)</span><br><span class="line">) <span class="keyword">AS</span> ut <span class="keyword">ON</span> et.hash_uid = ut.hash_uid</span><br><span class="line"><span class="keyword">WHERE</span> (tea_app_id = <span class="number">268411</span>) </span><br><span class="line"><span class="keyword">AND</span> (<span class="keyword">event</span> = <span class="string">'app_launch'</span>) </span><br><span class="line"><span class="keyword">AND</span> (event_date = <span class="string">'2022-08-06'</span>)</span><br></pre></td></tr></table></figure><p>对于上面SQL，其基本执行过程：</p><ol><li>一个 Clickhouse 节点作为 Coordinator 节点，分发查询。在每个节点上执行sql（tob_apps_all 替换成本地表，右表子查询替换成别名 ut）。</li><li>Coordinator 节点去其他节点拉取 users_unique_all 的全部数据，然后分发到全部节点（作为1中别名表 ut 的数据）。</li><li>每个节点都会存储全量的2中分发的数据(内存or文件)，进行本地 local join。</li><li>Coordinator 节点从每个节点拉取3中的结果集，然后做处理返回给 client。</li></ol><p>GLOBAL JOIN 可以看做一个不完整的Broadcast JOIN实现,将右表的查询在initiator节点上完成后，通过网络发送到其他节点，避免其他节点重复计算，从而避免查询放大。然而同样可能存在问题：</p><p>每个节点都全量存储数据。</p><p>如果右表较大，分发的数据较大，会占用网络带宽资源。</p><h2 id="ClickHouse-Join-优化"><a href="#ClickHouse-Join-优化" class="headerlink" title="ClickHouse Join 优化"></a>ClickHouse Join 优化</h2><h3 id="避免Join"><a href="#避免Join" class="headerlink" title="避免Join"></a>避免Join</h3><p><strong>生成大宽表</strong></p><p>数据预生成(由 Spark/Flink 或者 Clickhouse 物化视图产出数据)，形成大宽表，基于单表的查询是 ClickHouse 最为擅长的场景。</p><p>我们有个指标，实现的 SQL 比较复杂（如下），每次实时查询很耗时，我们单独建了一个表 table，由 Spark 每日构建出这个指标，查询时直接基于 table 查询。</p><p><strong>使用IN代替JOIN</strong></p><p>JOIN 需要基于内存构建 hash table 且需要存储右表全部的数据，然后再去匹配左表的数据。而 IN 查询会对右表的全部数据构建 hash set，但是不需要匹配左表的数据，且不需要回写数据到 block。</p><h3 id="更快的Join"><a href="#更快的Join" class="headerlink" title="更快的Join"></a>更快的Join</h3><p>​    数据预先相同规则分区，也就是 Colocate JOIN。优先将需要关联的表按照相同的规则进行分布，查询时就不需要分布式的 JOIN；数据冗余存储，如果一个表的数据量比较小，可以不分 Shard 存储，每个 shard 都存储全量的数据。查询时，不需要分布式 JOIN，直接在本地进行 JOIN 即可。</p><h3 id="更少的数据"><a href="#更少的数据" class="headerlink" title="更少的数据"></a>更少的数据</h3><p>不论是分布式 JOIN 还是本地 JOIN，都需要尽量让少的数据参与 JOIN，既能提升查询速度也能减少资源消耗。比如优化SQL下推。</p><h3 id="实现优化"><a href="#实现优化" class="headerlink" title="实现优化"></a>实现优化</h3><p>CK并未实现标准的Shuffle JOIN，可以想办法优化JOIN执行方式。像字节跳动对ClickHouse的Join实现模式进行了优化，支持了完整的Shuffle join和Broadcast Join，详细内容，请看：<a href="https://link.zhihu.com/?target=https%3A//www.51cto.com/article/718049.html">揭秘字节跳动解决ClickHouse复杂查询问题的技术实践</a></p><blockquote><p>参考：<a href="https://blog.csdn.net/ByteDanceTech/article/details/126716600" target="_blank" rel="noopener">https://blog.csdn.net/ByteDanceTech/article/details/126716600</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式算法 </tag>
            
            <tag> OLAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式Join原理</title>
      <link href="/2023/03/06/%E5%A4%A7%E6%95%B0%E6%8D%AE-2023-03-06-%E5%88%86%E5%B8%83%E5%BC%8FJoin%E5%8E%9F%E7%90%86/"/>
      <url>/2023/03/06/%E5%A4%A7%E6%95%B0%E6%8D%AE-2023-03-06-%E5%88%86%E5%B8%83%E5%BC%8FJoin%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Join操作可以说是最复杂、代价最大的操作，也是OLAP场景中使用相对较多的操作，尤其是在大数据领域中，Join操作的性能优劣直接会影响到整个查询，接下来我们就高屋建瓴的对整个JOIN操作进行解析，方便大家更深入的理解JOIN原理。</p><h2 id="单机Join算法"><a href="#单机Join算法" class="headerlink" title="单机Join算法"></a>单机Join算法</h2><p>一般的Join算法：Nested-Loop Join (NL Join)、Block Nested-Loop Join、Sort Merge Join、Hash Join。</p><p>接下来依次进行解析。</p><h3 id="Nested-Loop-Join-NL-Join"><a href="#Nested-Loop-Join-NL-Join" class="headerlink" title="Nested-Loop Join (NL Join)"></a>Nested-Loop Join (NL Join)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Nested-Loop Join</span><br><span class="line">for outer_row in outer_table:</span><br><span class="line">   for inner_row in inner_table:</span><br><span class="line">      if join_condition is True:</span><br><span class="line">         output (outer_row, inner_row)</span><br></pre></td></tr></table></figure><p>可以看出，NL join实际上就是简单的循环 来进行关联，时间复杂度是O(m*n)。假如参与Join的两张表一张量级为1万，一张量级为10w，那么进行比较的次数为1w*10w=10亿次。这在大表场景下几乎不可用，所以这种可以算是join算法发展过程中最原始的算法，实际上很少用到。</p><h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Index Nested-Loop Join</span><br><span class="line"><span class="keyword">for</span> outer_row in outer_table:</span><br><span class="line">   <span class="keyword">for</span> inner_row in inner_index.lookup(outer_join_key):</span><br><span class="line">      <span class="keyword">if</span> join_condition is True:</span><br><span class="line">         output (outer_row, inner_row)</span><br></pre></td></tr></table></figure><p>假设其中一个表存在索引，那么对外层表进行循环，对内表就可以利用索引进行点查,复杂度瞬间降了下来。</p><h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a><strong>Block Nested-Loop Join</strong></h3><p>如果没有索引，那就只能对 普通的NL Join 进行优化，主要是两个方面：</p><ol><li>小表驱动大表，即数据量较大的集作为于for循环的内部循环。目的是结合2，减少内表的扫描。</li><li>一次处理一个数据块，而不是一条记录。也就是所谓的Block Nested Loop Join，通过对外表进行分块降低IO次数，提升缓存命中率。</li></ol><p>​    将外层循环的行/结果集存入join buffer, 内层循环的每一行与整个buffer中的记录做比较，从而减少内层循环的次数. 举例来说，外层循环的结果集是100行，使用NLJ 算法需要扫描内部表100次，如果使用BNL算法，先把对Outer Loop表(外部表)每次读取的10行记录放到join buffer,然后在InnerLoop表(内部表)扫瞄一次中直接匹配这10行数据，内存循环就可以一次与这10行进行比较, 这样只需要比较10次，对内部表的扫描减少了9/10。所以BNL算法就能够显著减少内层循环表扫描的次数. 前面描述的query, 如果使用join buffer。其实 这点很容易想到，对磁盘读取，当然是尽可能一次读取较多的内容，减少IO。</p><h3 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort Merge Join"></a><strong>Sort Merge Join</strong></h3><p>对NL join，如果集合中的元素是有序的，比较的次数会大幅度降低，避免很多无意义的比较运算。</p><p>通过将JOIN操作拆分成Sort和Merge两个阶段实现Join操作的加速。对于Sort阶段，是可以提前准备好可以复用的。这样的思想对于MySQL这类关系型数据库是非常友好的，这也能解释阿里巴巴开发手册中要求关联的字段必须建立索引，因为索引保证了数据有序。该算法时间复杂度为排序开销O(m<em>log(m)+n</em>log(n))+合并开销O(m+n)。但是通常由于索引保证了数据有序，索引其时间复杂度为O(m+n)。</p><h3 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a><strong>Hash Join</strong></h3><p>Hash Join在大数据中非常常用的算法，其是思路也很简单，无非是利用hash，选取其中一个表 A对join key做hash，建立hash表，对另一个表进行扫描，扫描时就可以对join key利用hash 直接定位到表A 相应的记录。下面借他人文章举一个例子，文章的引用末尾会给出。</p><p>先来看看这样一条SQL语句：select * from order,item where item.id = order.i_id，很简单一个Join节点，参与join的两张表是item和order，join key分别是item.id以及order.i_id。现在假设这个Join采用的是hash join算法，整个过程会经历三步：</p><ol><li>确定Build Table以及Probe Table：这个概念比较重要，Build Table使用join key构建Hash Table，而Probe Table使用join key进行探测，探测成功就可以join在一起。通常情况下，小表会作为Build Table，大表作为Probe Table。此事例中item为Build Table，order为Probe Table。</li><li>构建Hash Table：依次读取Build Table（item）的数据，对于每一行数据根据join key（item.id）进行hash，hash到对应的Bucket，生成hash table中的一条记录。数据缓存在内存中，如果内存放不下需要dump到外存。</li><li>探测：再依次扫描Probe Table（order）的数据，使用相同的hash函数映射Hash Table中的记录，映射成功之后再检查join条件（item.id = order.i_id），如果匹配成功就可以将两者join在一起。<img src="2.jpg" alt="img"></li></ol><p>基本流程可以参考上图，这里有两个小问题需要关注：</p><ol><li><p>hash join性能如何？</p><p>​    很显然，hash join基本都只扫描两表一次，可以认为o(a+b)，较之最极端的笛卡尔集运算a*b，不知甩了多少条街。</p></li></ol><ol><li><p>为什么Build Table选择小表？</p><p>   道理很简单，因为构建的Hash Table最好能全部加载在内存，效率最高；这也决定了hash join算法只适合至少一个小表的join场景，对于两个大表的join场景并不适用。</p></li></ol><h2 id="分布式Join算法"><a href="#分布式Join算法" class="headerlink" title="分布式Join算法"></a>分布式Join算法</h2><p>所谓的分布式，无非是为了充分利用并行计算的资源，利用的算法还是单机join的算法，所以分布式join算法 无非是 分布方式 + Join 算法 ，根据分布方式有三种：boradcast、shuffle、located ，利用这几种数据分布方式再选择上合适的Join算法，就构成了分布式JOIN，常见的分布式JOIN有如下几种:</p><blockquote><ul><li>A <strong>shuffle join</strong> re-distributes rows from both tables among nodes based on join key values, such that all rows with the same join key value are moved to the same node. Depending on a particular algorithm used to compute joins, a shuffle join can be a shuffle hash join, shuffle sort-merge join, and so forth.</li><li>A <strong>broadcast join</strong> moves data stored in only one table, such that all rows from the smallest table are available on every node. Depending on a particular algorithm used to compute joins, a broadcast join can be a broadcast hash join, broadcast nested-loop join, and so forth.</li><li>A <strong>co-located join</strong> does not need to move data at all because data is already stored such that all rows with the same join key value reside on the same node. Data still needs to be joined using a nested-loop, sort-merge, or hash join algorithm.</li><li>A <strong>pre-computed join</strong> does not need to move data or compute joins locally on each node because data is already stored in a joined form. This type of join skips data movement and join computation and goes directly to merging and returning results.</li></ul></blockquote><p><img src="1.jpg" alt="img" style="zoom:50%;" /></p><h2 id="Spark-Join-算法"><a href="#Spark-Join-算法" class="headerlink" title="Spark Join 算法"></a>Spark Join 算法</h2><pre><code>### broadcast hash join</code></pre><p>​    将其中一张小表广播分发到另一张大表所在的分区节点上，分别并发地与其上的分区记录进行hash join。broadcast适用于小表很小，可以直接广播的场景。</p><h4 id="broadcast阶段："><a href="#broadcast阶段：" class="headerlink" title="broadcast阶段："></a><strong>broadcast阶段：</strong></h4><p>​    将小表广播分发到大表所在的所有主机。广播算法可以有很多，最简单的是先发给driver，driver再统一分发给所有executor；要不就是基于BitTorrent的TorrentBroadcast。</p><h4 id="hash-join阶段："><a href="#hash-join阶段：" class="headerlink" title="hash join阶段："></a><strong>hash join阶段：</strong></h4><p>​    在每个executor上执行单机版hash join，小表映射，大表试探。</p><p>​    <img src="3.jpg" alt="2" style="zoom:80%;" /></p><p>SparkSQL规定broadcast hash join执行的基本条件为被广播小表必须小于参数spark.sql.autoBroadcastJoinThreshold，默认为10M</p><h3 id="shuffle-hash-join"><a href="#shuffle-hash-join" class="headerlink" title="shuffle hash join"></a>shuffle hash join</h3><p>​    在大数据条件下如果一张表很小，执行join操作最优的选择无疑是broadcast hash join，效率最高。但是一旦小表数据量增大，广播所需内存、带宽等资源必然就会太大，broadcast hash join就不再是最优方案。此时可以按照join key进行分区，根据key相同必然分区相同的原理，就可以将大表join分而治之，划分为很多小表的join，充分利用集群资源并行化。如下图所示，shuffle hash join也可以分为两步：</p><h4 id="shuffle阶段"><a href="#shuffle阶段" class="headerlink" title="shuffle阶段:"></a>shuffle阶段:</h4><p>​    分别将两个表按照join key进行分区，将相同join key的记录重分布到同一节点，两张表的数据会被重分布到集群中所有节点。这个过程称为shuffle。</p><h4 id="hash-join阶段"><a href="#hash-join阶段" class="headerlink" title="hash join阶段:"></a>hash join阶段:</h4><p><img src="4.jpg" alt="6a53a913-eb7e-4985-9b37-4c990332b5e0"></p><p>看到这里，可以初步总结出来如果两张小表join可以直接使用单机版hash join；如果一张大表join一张极小表，可以选择broadcast hash join算法；而如果是一张大表join一张小表，则可以选择shuffle hash join算法；那如果是两张大表进行join呢</p><h3 id="sort-merge-join"><a href="#sort-merge-join" class="headerlink" title="sort merge join"></a><strong>sort merge join</strong></h3><p>SparkSQL对两张大表join采用了全新的算法－sort-merge join，如下图所示，整个过程分为三个步骤：</p><h4 id="shuffle阶段："><a href="#shuffle阶段：" class="headerlink" title="shuffle阶段："></a><strong>shuffle阶段：</strong></h4><p>​    将两张大表根据join key进行重新分区，两张表数据会分布到整个集群，以便分布式并行处理。</p><h4 id="sort阶段："><a href="#sort阶段：" class="headerlink" title="sort阶段："></a><strong>sort阶段：</strong></h4><p>​    对单个分区节点的两表数据，分别进行排序。</p><h4 id="merge阶段："><a href="#merge阶段：" class="headerlink" title="merge阶段："></a><strong>merge阶段：</strong></h4><p>​    对排好序的两张分区表数据执行join操作。join操作很简单，分别遍历两个有序序列，碰到相同join key就merge输出，否则取更小一边。如下图所示：</p><p>​    <img src="5.jpg" style="zoom:80%;" /></p><p>经过上文的分析，很明显可以得出来这几种Join的代价关系：</p><p>cost(broadcast hash join) &lt; cost(shuffle hash join) &lt; cost(sort merge join)，数据仓库设计时最好避免大表与大表的join查询，SparkSQL也可以根据内存资源、带宽资源适量将参数spark.sql.autoBroadcastJoinThreshold调大，让更多join实际执行为broadcast hash join。</p><blockquote><p>引用：<a href="https://ost.51cto.com/posts/12860" target="_blank" rel="noopener">https://ost.51cto.com/posts/12860</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式算法 </tag>
            
            <tag> OLAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(十三)HBASE优化实操</title>
      <link href="/2023/02/21/Hbase-2023-02-21-%E5%8D%81%E4%B8%89-HBASE%E4%BC%98%E5%8C%96%E5%AE%9E%E6%93%8D/"/>
      <url>/2023/02/21/Hbase-2023-02-21-%E5%8D%81%E4%B8%89-HBASE%E4%BC%98%E5%8C%96%E5%AE%9E%E6%93%8D/</url>
      
        <content type="html"><![CDATA[<h4 id="HBASE优化实操"><a href="#HBASE优化实操" class="headerlink" title="HBASE优化实操"></a>HBASE优化实操</h4><h5 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">在HBase中Hmaster负责监控RegionServer的生命周期，均衡RegionServer的负载，如果Hmaster挂掉了，那么整个HBase集群将陷入不健康的状态，并且此时的工作状态并不会维持太久。所以HBase支持对Hmaster的高可用配置。</span></span><br></pre></td></tr></table></figure><h6 id="关闭HBase集群"><a href="#关闭HBase集群" class="headerlink" title="关闭HBase集群"></a>关闭HBase集群</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos1 home]# stop-hbase.sh</span><br></pre></td></tr></table></figure><h6 id="在conf目录下创建backup-masters文件"><a href="#在conf目录下创建backup-masters文件" class="headerlink" title="在conf目录下创建backup-masters文件"></a>在conf目录下创建backup-masters文件</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos2 home]# touch conf/backup-masters</span><br></pre></td></tr></table></figure><h6 id="在backup-masters文件中配置高可用HMaster节点"><a href="#在backup-masters文件中配置高可用HMaster节点" class="headerlink" title="在backup-masters文件中配置高可用HMaster节点"></a>在backup-masters文件中配置高可用HMaster节点</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos2 home]# echo "192.168.49.101" &gt; conf/backup-masters</span><br></pre></td></tr></table></figure><h6 id="将整个conf目录scp到其他节点"><a href="#将整个conf目录scp到其他节点" class="headerlink" title="将整个conf目录scp到其他节点"></a>将整个conf目录scp到其他节点</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos1 home]# scp -r conf/ 192.168.49.101:/home/hbase-1.2.1/hbase/</span><br></pre></td></tr></table></figure><h6 id="打开页面测试查看"><a href="#打开页面测试查看" class="headerlink" title="打开页面测试查看"></a>打开页面测试查看</h6><h5 id="预分区"><a href="#预分区" class="headerlink" title="预分区"></a>预分区</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">每一个region维护着startRow与endRowKey，如果加入的数据符合某个region维护的rowKey范围，则该数据交给这个region维护。那么依照这个原则，我们可以将数据所要投放的分区提前大致的规划好，以提高HBase性能。</span></span><br></pre></td></tr></table></figure><h6 id="手动预分区"><a href="#手动预分区" class="headerlink" title="手动预分区"></a>手动预分区</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create 'stf1','info','partition1',SPLITS =&gt; ['1000','2000','3000','4000']</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put 'stf1', '888', 'info:name', 'lixi'</span><br></pre></td></tr></table></figure><h6 id="生成16进制序列预分区"><a href="#生成16进制序列预分区" class="headerlink" title="生成16进制序列预分区"></a>生成16进制序列预分区</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create 'stf2','info','partition2',&#123;NUMREGIONS =&gt; 15, SPLITALGO =&gt; 'HexStringSplit'&#125;</span><br></pre></td></tr></table></figure><h6 id="按照文件中设置的规则预分区"><a href="#按照文件中设置的规则预分区" class="headerlink" title="按照文件中设置的规则预分区"></a>按照文件中设置的规则预分区</h6><ul><li>创建splits.txt文件内容如下：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aaaa</span></span><br><span class="line"><span class="attr">bbbb</span></span><br><span class="line"><span class="attr">cccc</span></span><br><span class="line"><span class="attr">dddd</span></span><br></pre></td></tr></table></figure><ul><li>然后执行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create 'stf3','partition3',SPLITS_FILE =&gt; '/home/splits.txt'</span><br></pre></td></tr></table></figure><h6 id="JavaAPI创建预分区"><a href="#JavaAPI创建预分区" class="headerlink" title="JavaAPI创建预分区"></a>JavaAPI创建预分区</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义算法，产生一系列Hash散列值存储在二维数组中</span></span><br><span class="line"><span class="keyword">byte</span>[][] splitKeys = 某个散列值函数</span><br><span class="line"><span class="comment">//创建HBaseAdmin实例</span></span><br><span class="line">HBaseAdmin hAdmin = <span class="keyword">new</span> HBaseAdmin(HBaseConfiguration.create());</span><br><span class="line"><span class="comment">//创建HTableDescriptor实例</span></span><br><span class="line">HTableDescriptor tableDesc = <span class="keyword">new</span> HTableDescriptor(tableName);</span><br><span class="line"><span class="comment">//通过HTableDescriptor实例和散列值二维数组创建带有预分区的HBase表</span></span><br><span class="line">hAdmin.createTable(tableDesc, splitKeys);</span><br></pre></td></tr></table></figure><h5 id="RowKey设计"><a href="#RowKey设计" class="headerlink" title="RowKey设计"></a>RowKey设计</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">一条数据的唯一标识就是rowkey，那么这条数据存储于哪个分区，取决于rowkey处于哪个一个预分区的区间内，设计rowkey的主要目的</span> <span class="string">，就是让数据均匀的分布于所有的region中，在一定程度上防止数据倾斜。接下来我们就谈一谈rowkey常用的设计方案。</span></span><br></pre></td></tr></table></figure><h6 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">20191124000001转成10000042119102</span></span><br><span class="line"><span class="attr">20191124000002转成20000042119102</span></span><br></pre></td></tr></table></figure><h6 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">20191124000001_lixi</span></span><br><span class="line"><span class="attr">20191124000001_rock</span></span><br></pre></td></tr></table></figure><h6 id="生成随机数、hash、散列值"><a href="#生成随机数、hash、散列值" class="headerlink" title="生成随机数、hash、散列值"></a>生成随机数、hash、散列值</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">比如：</span></span><br><span class="line"><span class="attr">原本rowKey为1001的，SHA1后变成：dd01903921ea24941c26a48f2cec24e0bb0e8cc7</span></span><br><span class="line"><span class="attr">原本rowKey为3001的，SHA1后变成：49042c54de64a1e9bf0b33e00245660ef92dc7bd</span></span><br><span class="line"><span class="attr">原本rowKey为5001的，SHA1后变成：7b61dec07e02c188790670af43e717f0f46e8913</span></span><br><span class="line"><span class="attr">在做此操作之前，一般我们会选择从数据集中抽取样本，来决定什么样的rowKey来Hash后作为每个分区的临界值。</span></span><br></pre></td></tr></table></figure><h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考十九</span><br></pre></td></tr></table></figure><h5 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">HBase操作过程中需要大量的内存开销，毕竟Table是可以缓存在内存中的，一般会分配整个可用内存的70%给HBase的Java堆。但是不建议分配非常大的堆内存，因为GC过程持续太久会导致RegionServer处于长期不可用状态，一般16~48G内存就可以了，如果因为框架占用内存过高导致系统内存不足，框架一样会被系统服务拖死。</span></span><br></pre></td></tr></table></figure><h6 id="设置在HDFS中追加内容"><a href="#设置在HDFS中追加内容" class="headerlink" title="设置在HDFS中追加内容"></a>设置在HDFS中追加内容</h6><ul><li>hdfs-site.xml、hbase-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.support.append<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>开启HDFS追加同步，可以优秀的配合HBase的数据同步和持久化。默认值为true<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="dataNode允许的最大文件打开数"><a href="#dataNode允许的最大文件打开数" class="headerlink" title="dataNode允许的最大文件打开数"></a>dataNode允许的最大文件打开数</h6><ul><li>hdfs-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.max.transfer.threads<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>HBase一般都会同一时间操作大量的文件，根据集群的数量和规模以及数据动作，设置为4096或者更高。默认值：4096<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="设置延迟高的数据操作的等待时间"><a href="#设置延迟高的数据操作的等待时间" class="headerlink" title="设置延迟高的数据操作的等待时间"></a>设置延迟高的数据操作的等待时间</h6><ul><li>hdfs-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.image.transfer.timeout<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>60000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>如果对于某一次数据操作来讲，延迟非常高，socket需要等待更长的时间，建议把该值设置为更大的值（默认60000毫秒），以确保socket不会被timeout掉。<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="优化数据的写入效率"><a href="#优化数据的写入效率" class="headerlink" title="优化数据的写入效率"></a>优化数据的写入效率</h6><ul><li>mapred-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.output.compress<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>开启这两个数据可以大大提高文件的写入效率，减少写入时间。<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.output.compress.codec<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.io.compress.GzipCodec<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>开启这两个数据可以大大提高文件的写入效率，减少写入时间。org.apache.hadoop.io.compress.GzipCodec或者其他压缩方式<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="设置RPC监听数量"><a href="#设置RPC监听数量" class="headerlink" title="设置RPC监听数量"></a>设置RPC监听数量</h6><ul><li>hbase-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.regionserver.handler.count<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>30<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>默认值为30，用于指定RPC监听的数量，可以根据客户端的请求数进行调整，读写请求较多时，增加此值。<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="设置HStore文件大小"><a href="#设置HStore文件大小" class="headerlink" title="设置HStore文件大小"></a>设置HStore文件大小</h6><ul><li>hbase-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.hregion.max.filesize<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>10737418240<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>默认值10737418240（10GB），如果需要运行HBase的MR任务，可以减小此值，因为一个region对应一个map任务，如果单个region过大，会导致map任务执行时间过长。该值的意思就是，如果HFile的大小达到这个数值，则这个region会被切分为两个Hfile。<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="设置hbase客户端缓存"><a href="#设置hbase客户端缓存" class="headerlink" title="设置hbase客户端缓存"></a>设置hbase客户端缓存</h6><ul><li>hbase-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.client.write.buffer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>用于指定HBase客户端缓存，增大该值可以减少RPC调用次数，但是会消耗更多内存，反之则反之。一般我们需要设定一定的缓存大小，以达到减少RPC次数的目的。<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="指定scan-next扫描HBase所获取的行数"><a href="#指定scan-next扫描HBase所获取的行数" class="headerlink" title="指定scan.next扫描HBase所获取的行数"></a>指定scan.next扫描HBase所获取的行数</h6><ul><li>hbase-site.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.client.scanner.caching<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>用于指定scan.next方法获取的默认行数，值越大，消耗内存越大。<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="flush、compact、split机制"><a href="#flush、compact、split机制" class="headerlink" title="flush、compact、split机制"></a>flush、compact、split机制</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">大的Storefile文件。split则是当Region达到阈值，会把过大的Region一分为二。</span></span><br><span class="line"><span class="attr">涉及属性：</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">128M就是Memstore的默认阈值</span></span><br><span class="line"><span class="attr">hbase.hregion.memstore.flush.size：134217728</span></span><br><span class="line"><span class="attr">tip</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">这个参数的作用是当单个HRegion内所有的Memstore大小总和超过指定值时，flush该HRegion的所有memstore。RegionServer的flush是通过将请求添加一个队列，模拟生产消费模型来异步处理的。那这里就有一个问题，当队列来不及消费，产生大量积压请求时，可能会导致内存陡增，最坏的情况是触发OOM。</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">2.</span> <span class="string"></span></span><br><span class="line"><span class="attr">hbase.regionserver.global.memstore.upperLimit：0.4</span></span><br><span class="line"><span class="attr">hbase.regionserver.global.memstore.lowerLimit：0.38</span></span><br><span class="line"><span class="attr">tip</span>:<span class="string"></span></span><br><span class="line"><span class="meta">当MemStore使用内存总量达到hbase.regionserver.global.memstore.upperLimit指定值时，将会有多个MemStores</span> <span class="string">flush到文件中，MemStore flush 顺序是按照大小降序执行的，直到刷新到MemStore使用内存略小于lowerLimit</span></span><br></pre></td></tr></table></figure><h5 id="HBase2-0新特性"><a href="#HBase2-0新特性" class="headerlink" title="HBase2.0新特性"></a>HBase2.0新特性</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2017年8月22日凌晨2点左右，HBase发布了2.0.0</span> <span class="string">alpha-2，相比于上一个版本，修复了500个补丁，我们来了解一下2.0版本的HBase新特性。</span></span><br><span class="line"><span class="attr">最新文档：</span></span><br><span class="line"><span class="attr">http</span>:<span class="string">//hbase.apache.org/book.html#ttl</span></span><br><span class="line"><span class="attr">官方发布主页：</span></span><br><span class="line"><span class="attr">http</span>:<span class="string">//mail-archives.apache.org/mod_mbox/www-announce/201708.mbox/&lt;CADcMMgFzmX0xYYso-UAYbU7V8z-Obk1J4pxzbGkRzbP5Hps+iA@mail.gmail.com</span></span><br><span class="line"><span class="attr">举例：</span></span><br><span class="line"><span class="meta">1)</span> <span class="string">region进行了多份冗余</span></span><br><span class="line"><span class="attr">主region负责读写，从region维护在其他HregionServer中，负责读以及同步主region中的信息，如果同步不及时，是有可能出现client在从region中读到了脏数据（主region还没来得及把memstore中的变动的内容flush）。</span></span><br><span class="line"><span class="meta">2)</span> <span class="string">更多变动</span></span><br><span class="line"><span class="attr">https</span>:<span class="string">//issues.apache.org/jira/secure/ReleaseNote.jspa?version=12340859&amp;styleName=&amp;projectId=12310753&amp;Create=Create&amp;atl_token=A5KQ-2QAV-T4JA-FDED%7Ce6f233490acdf4785b697d4b457f7adb0a72b69f%7Clout</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(十二)HBASE企业级调优</title>
      <link href="/2023/02/21/Hbase-2023-02-21-%E5%8D%81%E4%BA%8C-HBASE%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E4%BC%98/"/>
      <url>/2023/02/21/Hbase-2023-02-21-%E5%8D%81%E4%BA%8C-HBASE%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><ol><li><p>hbase.regionserver.handler.count：rpc请求的线程数量，默认值是10，生产环境建议使用100，也不是越大越好，特别是当请求内容很大的时候，比如scan/put几M的数据，会占用过多的内存，有可能导致频繁的GC，甚至出现内存溢出。</p></li><li><p>hbase.master.distributed.log.splitting：默认值为true，建议设为false。关闭hbase的分布式日志切割，在log需要replay时，由master来负责重放</p></li><li><p>hbase.regionserver.hlog.splitlog.writer.threads：默认值是3，建议设为10，日志切割所用的线程数</p></li><li><p>hbase.snapshot.enabled：快照功能，默认是false(不开启)，建议设为true，特别是对某些关键的表，定时用快照做备份是一个不错的选择。</p></li><li><p>hbase.hregion.max.filesize：默认是10G， 如果任何一个column familiy里的StoreFile超过这个值, 那么这个Region会一分为二，因为region分裂会有短暂的region下线时间(通常在5s以内)，为减少对业务端的影响，建议手动定时分裂，可以设置为60G。</p></li><li><p>hbase.hregion.majorcompaction：hbase的region主合并的间隔时间，默认为1天，建议设置为0，禁止自动的major主合并，major合并会把一个store下所有的storefile重写为一个storefile文件，在合并过程中还会把有删除标识的数据删除，在生产集群中，主合并能持续数小时之久，为减少对业务的影响，建议在业务低峰期进行手动或者通过脚本或者api定期进行major合并。</p></li><li><p>hbase.hregion.memstore.flush.size：默认值128M，单位字节，一旦有memstore超过该值将被flush，如果regionserver的jvm内存比较充足(16G以上)，可以调整为256M。</p></li><li><p>hbase.hregion.memstore.block.multiplier：默认值2，如果一个memstore的内存大小已经超过hbase.hregion.memstore.flush.size *  hbase.hregion.memstore.block.multiplier，则会阻塞该memstore的写操作，为避免阻塞，建议设置为5，如果太大，则会有OOM的风险。如果在regionserver日志中出现”Blocking updates for ‘<threadName>‘ on region <regionName> : memstore size &lt;多少M&gt; is &gt;= than blocking &lt;多少M&gt; size”的信息时，说明这个值该调整了。</p></li><li><p>hbase.hstore.compaction.min：默认值为3，如果任何一个store里的storefile总数超过该值，会触发默认的合并操作，可以设置5~8，在手动的定期major compact中进行storefile文件的合并，减少合并的次数，不过这会延长合并的时间，以前的对应参数为hbase.hstore.compactionThreshold。</p></li><li><p>hbase.hstore.compaction.max：默认值为10,一次最多合并多少个storefile，避免OOM。</p></li><li><p>hbase.hstore.blockingStoreFiles：默认为7，如果任何一个store(非.META.表里的store)的storefile的文件数大于该值，则在flush memstore前先进行split或者compact，同时把该region添加到flushQueue，延时刷新，这期间会阻塞写操作直到compact完成或者超过hbase.hstore.blockingWaitTime(默认90s)配置的时间，可以设置为30，避免memstore不及时flush。当regionserver运行日志中出现大量的“Region <regionName> has too many store files; delaying flush up to 90000ms”时，说明这个值需要调整了</p></li><li><p>hbase.regionserver.global.memstore.upperLimit：默认值0.4，regionserver所有memstore占用内存在总内存中的upper比例，当达到该值，则会从整个regionserver中找出最需要flush的region进行flush，直到总内存比例降到该数以下，采用默认值即可。</p></li><li><p>hbase.regionserver.global.memstore.lowerLimit：默认值0.35，采用默认值即可。</p></li><li><p>hbase.regionserver.thread.compaction.small：默认值为1，regionserver做Minor Compaction时线程池里线程数目,可以设置为5。</p></li><li><p>hbase.regionserver.thread.compaction.large：默认值为1，regionserver做Major Compaction时线程池里线程数目，可以设置为8。</p></li><li><p>hbase.regionserver.lease.period：默认值60000(60s)，客户端连接regionserver的租约超时时间，客户端必须在这个时间内汇报，否则则认为客户端已死掉。这个最好根据实际业务情况进行调整</p></li><li><p>hfile.block.cache.size：默认值0.25，regionserver的block cache的内存大小限制，在偏向读的业务中，可以适当调大该值，需要注意的是hbase.regionserver.global.memstore.upperLimit的值和hfile.block.cache.size的值之和必须小于0.8。</p></li><li><p>dfs.socket.timeout：默认值60000(60s)，建议根据实际regionserver的日志监控发现了异常进行合理的设置，比如我们设为900000，这个参数的修改需要同时更改hdfs-site.xml</p></li><li><p>dfs.datanode.socket.write.timeout：默认480000(480s),有时regionserver做合并时，可能会出现datanode写超时的情况，480000 millis timeout while waiting for channel to be ready for write，这个参数的修改需要同时更改hdfs-site.xml</p></li></ol><h2 id="jvm和垃圾收集参数"><a href="#jvm和垃圾收集参数" class="headerlink" title="jvm和垃圾收集参数"></a>jvm和垃圾收集参数</h2><p>export HBASE_REGIONSERVER_OPTS=”-Xms36g -Xmx36g -Xmn1g -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=15 -XX:CMSInitiatingOccupancyFraction=70 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/data/logs/gc-$(hostname)-hbase.log”<br>    由于我们服务器内存较大(96G),我们给一部分regionserver的jvm内存开到64G，到现在为止，还没有发生过一次full gc，hbase在内存使用控制方面确实下了不少功夫，比如各种blockcache的实现，细心的同学可以看源码。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol><li><p>hbase.client.write.buffer：默认为2M，写缓存大小，推荐设置为5M，单位是字节，当然越大占用的内存越多，此外测试过设为10M下的入库性能，反而没有5M好</p></li><li><p>hbase.client.pause：默认是1000(1s),如果你希望低延时的读或者写，建议设为200，这个值通常用于失败重试，region寻找等</p></li><li><p>hbase.client.retries.number：默认值是10，客户端最多重试次数,可以设为11，结合上面的参数，共重试时间71s</p></li><li><p>hbase.ipc.client.tcpnodelay：默认是false，建议设为true，关闭消息缓冲</p></li><li><p>hbase.client.scanner.caching：scan缓存，默认为1，避免占用过多的client和rs的内存，一般1000以内合理，如果一条数据太大，则应该设置一个较小的值，通常是设置业务需求的一次查询的数据条数 如果是扫描数据对下次查询没有帮助，则可以设置scan的setCacheBlocks为false，避免使用缓存；</p></li><li><p>table用完需关闭，关闭scanner</p></li><li><p>限定扫描范围：指定列簇或者指定要查询的列，指定startRow和endRow</p></li><li><p>使用Filter可大量减少网络消耗</p></li><li><p>通过Java多线程入库和查询，并控制超时时间。后面会共享下我的hbase单机多线程入库的代码</p></li><li><p>建表注意事项：</p><ul><li>开启压缩</li><li>合理的设计rowkey</li><li>进行预分</li><li>开启bloomfilter</li></ul></li></ol><h2 id="Zookeeper调优"><a href="#Zookeeper调优" class="headerlink" title="Zookeeper调优"></a>Zookeeper调优</h2><ol><li><p>zookeeper.session.timeout：默认值3分钟，不可配置太短，避免session超时，hbase停止服务，线上生产环境由于配置为1分钟，如果太长，当regionserver挂掉，zk还得等待这个超时时间(已有patch修复)，从而导致master不能及时对region进行迁移。</p></li><li><p>zookeeper数量：建议5个或者7个节点。给每个zookeeper 4G左右的内存，最好有独立的磁盘。</p></li><li><p>hbase.zookeeper.property.maxClientCnxns：zk的最大连接数，默认为300，无需调整。</p></li><li><p>设置操作系统的swappiness为0，则在物理内存不够的情况下才会使用交换分区，避免GC回收时会花费更多的时间，当超过zk的session超时时间则会出现regionserver宕机的误报</p></li></ol><h2 id="HDFS调优"><a href="#HDFS调优" class="headerlink" title="HDFS调优"></a>HDFS调优</h2><ol><li><p>dfs.name.dir：namenode的数据存放地址，可以配置多个，位于不同的磁盘并配置一个nfs远程文件系统，这样namenode的数据可以有多个备份</p></li><li><p>dfs.namenode.handler.count：namenode节点RPC的处理线程数，默认为10，可以设置为60</p></li><li><p>dfs.datanode.handler.count：datanode节点RPC的处理线程数，默认为3，可以设置为30</p></li><li><p>dfs.datanode.max.xcievers：datanode同时处理文件的上限，默认为256，可以设置为8192</p></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>列族名、column名、rowkey均会存储到hfile中，因此这几项在设计表结构时都尽量短些</p><p>regionserver的region数量不要过1000，过多的region会导致产生很多memstore，可能会导致内存溢出，也会增加major compact的耗时</p><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(十一)HBASE的协处理器</title>
      <link href="/2023/02/21/Hbase-2023-02-21-%E5%8D%81%E4%B8%80-HBASE%E7%9A%84%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>/2023/02/21/Hbase-2023-02-21-%E5%8D%81%E4%B8%80-HBASE%E7%9A%84%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hbase作为列族数据库最经常被人诟病的特性包括：无法轻易建立“二级索引”，难以执行求和、计数、排序等操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如，在旧版本的(&lt;0.92)Hbase 中，统计数据表的总行数，需要使用 Counter 方法，执行一次 MapReduce Job 才能得到。虽然HBase在数据存储层中集成了MapReduce，能够有效用于数据表的分布式计算。然而在很多情况下，做一些简单的相加或者聚合计算的时候，如果直接将计算过程放置在server端，能够减少通讯开销，从而获得很好的性能提升。于是，HBase 在 0.92 之后引入了协处理器(coprocessors)，实现一些激动人心的新特性：能够轻易建立二次索引、复杂过滤器(谓词下推)以及访问控制等。</span><br></pre></td></tr></table></figure><h2 id="协处理器分类"><a href="#协处理器分类" class="headerlink" title="协处理器分类"></a>协处理器分类</h2><p>协处理器有两种:</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>Observer 类似于传统数据库中的触发器，当发生某些事件的时候这类协处理器会被 Server 端调用。Observer Coprocessor 就是一些散布在 HBase Server 端代码中的 hook 钩子， 在固定的事件发生时被调用。比如：put 操作之前有钩子函数 prePut，该函数在 put 操作执行前会被 Region Server 调用；在 put 操作之后则有 postPut 钩子函数</p><p>hbase0.92版本后，常见的Observer接口有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- RegionObserver：针对Region的观察者，可以监听关于Region的操作</span><br><span class="line">- RegionServerObserver：针对RegionServer的观察者，可以监听关于RegionServer的操作</span><br><span class="line">- WALObserver：针对WAL的观察者，可以监听关于WAL的操作</span><br><span class="line">- MasterObserver：针对Master的观察者，可以监听关于Master的操作</span><br></pre></td></tr></table></figure><p>1） 普通的put请求流程</p><p><img src="038.png" alt=""></p><p>2） 加入Observer协处理器的put请求流程</p><p><img src="039.png" alt=""></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1</span> <span class="string">客户端发出put请求</span></span><br><span class="line"><span class="attr">2</span> <span class="string">请求被分派给合适的RegionServer和Region</span></span><br><span class="line"><span class="attr">3</span> <span class="string">coprocessorHost拦截请求，然后在该表上登记的每个RegionObserver上调用prePut方法</span></span><br><span class="line"><span class="attr">4</span> <span class="string">如果没有被prePut拦截，请求就继续送到region，然后进行处理</span></span><br><span class="line"><span class="attr">5</span> <span class="string">region产生了处理后的结果再次被coprocessor拦截，调用postPut方法</span></span><br><span class="line"><span class="attr">6</span> <span class="string">假设没有被postPut拦截响应，最终结果就返回给客户端</span></span><br></pre></td></tr></table></figure><p>3) Observer的类型</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">RegionObserver</span> : <span class="string">此组件勾在数据访问和操作阶段，所有标准的数据操作命令都可以被pre-hooks和post-hooks拦截</span></span><br><span class="line"><span class="attr">WALObserver</span> : <span class="string">WAL所支持的Observer，可用的钩子是pre-WAL和post-WAL</span></span><br><span class="line"><span class="attr">MasterObserver</span> : <span class="string">勾住DDL事件，如表创建</span></span><br></pre></td></tr></table></figure><h3 id="endpoint"><a href="#endpoint" class="headerlink" title="endpoint"></a>endpoint</h3><p>Endpoint 协处理器类似传统数据库中的存储过程，客户端可以调用这些 Endpoint 协处 理器执行一段 Server 端代码，并将 Server 端代码的结果返回给客户端进一步处理，最常见 的用法就是进行聚集操作。如果没有协处理器，当用户需要找出一张表中的最大数据，即 max 聚合操作，就必须进行全表扫描，在客户端代码内遍历扫描结果，并执行求最大值的 操作。这样的方法无法利用底层集群的并发能力，而将所有计算都集中到 Client 端统一执行， 势必效率低下。利用 Coprocessor，用户可以将求最大值的代码部署到 HBase Server 端，HBase 将利用底层 cluster 的多个节点并发执行求最大值的操作。即在每个 Region 范围内执行求最 大值的代码，将每个 Region 的最大值在 Region Server 端计算出，仅仅将该 max 值返回给客 户端。在客户端进一步将多个 Region 的最大值进一步处理而找到其中的最大值。这样整体 的执行效率就会提高很多</p><p>下图是 EndPoint 的工作原理：<br><img src="1228818-20180403130107289-1349588066.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- Observer 允许集群在正常的客户端操作过程中可以有不同的行为表现  </span><br><span class="line">- Endpoint 允许扩展集群的能力，对客户端应用开放新的运算命令  </span><br><span class="line">- Observer 类似于 RDBMS 中的触发器，主要在服务端工作</span><br><span class="line">- Endpoint 类似于 RDBMS 中的存储过程，主要在服务端工作</span><br><span class="line">- Observer 可以实现权限管理、优先级设置、监控、ddl 控制、二级索引等功能</span><br><span class="line">- Endpoint 可以实现 min、max、avg、sum、distinct、group by 等功能</span><br></pre></td></tr></table></figure><h2 id="协处理器-二级索引案例"><a href="#协处理器-二级索引案例" class="headerlink" title="协处理器+二级索引案例"></a>协处理器+二级索引案例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. create &#39;guanzhu&#39;,&#39;f1&#39;</span><br><span class="line">   rowkey:   用户名-明星名</span><br><span class="line">   column1:  from:用户名</span><br><span class="line">    to:明星名</span><br><span class="line"></span><br><span class="line">   create &#39;fensi&#39;,&#39;f1&#39;</span><br><span class="line">   rowkey:  to-明星名</span><br><span class="line">            s001:粉丝名</span><br><span class="line">   </span><br><span class="line">2. 需求:在向关注表插入数据时，通过协处理器向粉丝表(二级索引表)插入数据。</span><br><span class="line">3. 继承BaseRegionObserver,重写prePut(.....)</span><br><span class="line">4. 导出jar包，上传到集群上</span><br><span class="line">5. 将协处理器挂载到关注表中</span><br><span class="line">   </span><br><span class="line">alter &#39;guanzhu&#39;,METHOD &#x3D;&gt; &#39;table_att&#39;,&#39;coprocessor&#39;&#x3D;&gt;&#39;hdfs:&#x2F;&#x2F;qianfeng01:8020&#x2F;jar&#x2F;nz201_hbase-1.0-SNAPSHOT.jar|com.dante.hbase.coprocessor.FensiObServer|1001|&#39;</span><br><span class="line">6. 通过api向关注表模拟插入数据操作</span><br><span class="line">7. 查询fensi表的数据。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dante.hbase.coprocessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dante.hbase.util.HbaseUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.Cell;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.CellUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.TableName;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Durability;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Table;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.coprocessor.BaseRegionObserver;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.coprocessor.ObserverContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.regionserver.wal.WALEdit;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FensiObServer</span> <span class="keyword">extends</span> <span class="title">BaseRegionObserver</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监测region的put操作。在执行前会进行拦截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> put   put形参就是拦截到的put对象   put 'guanzhu','wcm-gyy','f1:from','wcm'</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> edit                              put 'guanzhu','wcm-gyy','f1:to','gyy'</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> durability</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException                      put  'fensi','to-gyy','f1:s1','wcm'</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prePut</span><span class="params">(ObserverContext&lt;RegionCoprocessorEnvironment&gt; e, Put put, WALEdit edit, Durability durability)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取指定单元格数据 也就是key-value</span></span><br><span class="line">        List&lt;Cell&gt; c1 = put.get(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"from"</span>));</span><br><span class="line">        <span class="comment">//获取value值，获取粉丝名称</span></span><br><span class="line">        String fans = <span class="keyword">new</span> String(CellUtil.cloneValue(c1.get(<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取明星名</span></span><br><span class="line">        List&lt;Cell&gt; c2 = put.get(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"to"</span>));</span><br><span class="line">        String star = <span class="keyword">new</span> String(CellUtil.cloneValue(c2.get(<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将明星名和粉丝名插入到粉丝表中</span></span><br><span class="line"></span><br><span class="line">        Table table = HbaseUtil.getTable(<span class="string">"fensi"</span>);</span><br><span class="line">        Put newput = <span class="keyword">new</span> Put(Bytes.toBytes(<span class="string">"to-"</span>+star));</span><br><span class="line">        newput.addColumn(Bytes.toBytes(<span class="string">"f1"</span>),<span class="string">"s1"</span>.getBytes(),fans.getBytes());</span><br><span class="line">        table.put(newput);</span><br><span class="line">        HbaseUtil.closeTable(table);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协处理加载方式"><a href="#协处理加载方式" class="headerlink" title="协处理加载方式"></a>协处理加载方式</h2><p>协处理器的加载方式有两种，我们称之为静态加载方式（Static Load）和动态加载方式 （Dynamic Load）。静态加载的协处理器称之为 System Coprocessor，动态加载的协处理器称 之为 Table Coprocessor。</p><p>11.3.1 静态加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通过修改 hbase-site.xml 这个文件来实现，启动全局 aggregation，能过操纵所有的表上 的数据。只需要添加如下代码：</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hbase.coprocessor.user.region.classes&lt;&#x2F;name&gt;</span><br><span class="line">&lt;value&gt;类全名&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">可以用”,”分割加载多个 class</span><br></pre></td></tr></table></figure><p>11.3.2 动态加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">只对特定的表生效。通过 HBase Shell 来实现。</span><br><span class="line"></span><br><span class="line">1. 停用表　　disable &#39;mytable&#39;</span><br><span class="line"></span><br><span class="line">2. 添加协处理器　　alter &#39;t_guanzhu&#39;,METHOD &#x3D;&gt; &#39;table_att&#39;,&#39;coprocessor&#39;&#x3D;&gt;&#39;hdfs:&#x2F;&#x2F;supercluster&#x2F;jar&#x2F;mycoprocessor.jar|com.dante.hbase.coprocessor.MyIndexCoprocessor|1001|&#39;</span><br><span class="line">3. 启用表　　enable &#39;mytable&#39;</span><br></pre></td></tr></table></figure><p>11.3.3 协处理器卸载。同样是3步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. disable &#39;mytable&#39;</span><br><span class="line">2. alter &#39;mytable&#39;,METHOD&#x3D;&gt;&#39;table_att_unset&#39;,NAME&#x3D;&gt;&#39;coprocessor$1&#39;</span><br><span class="line">3. enable &#39;mytable&#39;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(十)HBASE的二级索引</title>
      <link href="/2023/02/21/Hbase-2023-02-21-%E5%8D%81-HBASE%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95/"/>
      <url>/2023/02/21/Hbase-2023-02-21-%E5%8D%81-HBASE%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>当涉及到了HBase的多条件组合查询时，要把多条件组合查询的字段都拼接在RowKey中显然不太可能，这个时候，我们可以通过设计HBase的二级索引来解决这个问题.</p><h2 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h2><p><img src="20160612234508199-1338773707.png" alt=""></p><p>二级索引的本质就是建立各列值与行键之间的映射关系</p><p>如图，当要对F:C1这列建立索引时，只需要建立F:C1各列值到其对应行键的映射关系，如C11-&gt;RK1等，这样就完成了对F:C1列值的二级索引的构建，当要查询符合F:C1=C11对应的F:C2的列值时（即根据C1=C11来查询C2的值,图1青色部分）</p><p>其查询步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 根据C1&#x3D;C11到索引数据中查找其对应的RK，查询得到其对应的RK&#x3D;RK1</span><br><span class="line">2. 得到RK1后就自然能根据RK1来查询C2的值了 这是构建二级索引大概思路，其他组合查询的联合索引的建立也类似。</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(九)rowkey设计原则和案例</title>
      <link href="/2023/02/21/Hbase-2023-02-21-%E4%B9%9D-rowkey%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E6%A1%88%E4%BE%8B/"/>
      <url>/2023/02/21/Hbase-2023-02-21-%E4%B9%9D-rowkey%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="热点问题"><a href="#热点问题" class="headerlink" title="热点问题"></a>热点问题</h2><p>当大量客户端的访问定向到群集的一个节点或仅几个节点时，就会发生热点。此访问可能是读取、可能是写入。大量的访问使负责管理该region的单台计算机不堪重负，从而导致性能下降并可能导致region不可用。这也可能对由同一regionserver管理的其他region产生不利影响，因为该主机无法满足请求的负载。设计数据访问模式非常重要，这样才能充分，均匀地利用群集。</p><h2 id="rowkey的重要性"><a href="#rowkey的重要性" class="headerlink" title="rowkey的重要性"></a>rowkey的重要性</h2><p>HBase由于其存储和读写的高性能，在OLAP分析中越来越发挥重要的作用。作为Nosql数据库的一员，HBase在查询数据时，只有两种方式：</p><ol><li>通过Rowkey进行查询(Rowkey用来表示唯一一行记录)</li><li>全表扫描再结合过滤器筛选出目标数据,缺点是性能太低</li></ol><font color='red'>**可见，Rowkey设计的优劣直接影响读写性能**。</font><p>因此，在存储数据之前，我们就应该想好未来可能发生的查询需求，比如，按照部门编号查询、按照日期查询、还是按照地域性查询。这样，我们在设计rowkey时，就可以存储一些比较关键的检索信息，尽可能的避免全表扫描，以提高查询性能。</p><pre><code>-- 再次强调一下：HBase中的数据是按照Rowkey的ASCII字典顺序进行全局排序的,有伙伴可能对ASCII字典序印象不够深刻，下面举例说明：-- 假如现在有5个Rowkey，分别是：&quot;012&quot;, &quot;0&quot;, &quot;123&quot;, &quot;234&quot;, &quot;3&quot;</code></pre><p>​    rowkey排序规则：<br>​        会先比较两个Rowkey的第一个字节，如果相同，然后会比对第二个字节，依次类推…  对比到第X个字节时，已经超出了其中一个Rowkey的长度，那么短的Rowkey就会排在前面。<br>​    “0”<br>​    “012”<br>​    “123”<br>​    “234”<br>​    “3”</p><p>​    因此：rowkey设计的长度最好一致的。<br>​    “012”, “000”, “123”, “234”, “003”<br>​<br>​    “000”<br>​    “003”<br>​    “012”<br>​    “123”<br>​    “234”</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="唯一原则"><a href="#唯一原则" class="headerlink" title="唯一原则"></a>唯一原则</h3><p>必须在设计上保证其唯一性。</p><p>由于在HBase中数据存储是Key-Value形式，若HBase中同一张表插入相同Rowkey，并且是同一个列族下的同一个key时，如果version设置为1的话，则原先的数据会被覆盖掉，所以务必保证Rowkey的唯一性</p><h3 id="长度原则"><a href="#长度原则" class="headerlink" title="长度原则"></a>长度原则</h3><p>rowkey的长度统一。</p><p>Rowkey是一个二进制码流，Rowkey的长度被很多开发者建议说设计在10~100个字节，不过建议是越短越好，不要超过16个字节。</p><p>原因如下：</p><ol><li>数据的持久化文件HFile中是按照KeyValue存储的，如果Rowkey过长比如100个字节，1000万列数据光Rowkey就要占用100*1000万=10亿个字节，将近1G数据，这会极大影响HFile的存储效率；</li><li>MemStore将缓存部分数据到内存，如果Rowkey字段过长内存的有效利用率会降低，系统将无法缓存更多的数据，这会降低检索效率。因此Rowkey的字节长度越短越好。</li><li>目前操作系统是都是64位系统，内存8字节对齐。控制在16个字节，8字节的整数倍利用操作系统的最佳特性。</li></ol><p>​    需要指出的是不仅Rowkey的长度是越短越好，而且列族名、列名等尽量使用短名字，因为HBase属于列式数据库，这些名字都是会写入到HBase的持久化文件HFile中去，过长的Rowkey、列族、列名都会导致整体的存储量成倍增加。</p><h3 id="散列原则"><a href="#散列原则" class="headerlink" title="散列原则"></a>散列原则</h3><p>我们设计的Rowkey应均匀的分布在各个HBase节点上。</p><p>拿常见的时间戳举例，假如Rowkey是按系统时间戳的方式递增，Rowkey的第一部分如果是时间戳信息的话将造成所有新数据都在一个RegionServer上堆积的热点现象，就是region热点问题。</p><p>我们可以采取下面三种方式，来解决这个Region热点问题：</p><h4 id="Reverse反转"><a href="#Reverse反转" class="headerlink" title="Reverse反转"></a>Reverse反转</h4><p>针对固定长度的Rowkey反转后存储，这样可以使Rowkey中经常改变的部分放在最前面，可以有效的随机Rowkey。<br>反转Rowkey的例子通常以手机举例，可以将手机号反转后的字符串作为Rowkey，这样的就避免了以手机号那样比较固定开头(137x、15x等)导致热点问题，这样做的缺点是牺牲了Rowkey的有序性。</p><h4 id="Salting-加盐"><a href="#Salting-加盐" class="headerlink" title="Salting(加盐)"></a>Salting(加盐)</h4><p>Salting是将每一个Rowkey加一个前缀，前缀使用一些随机字符，使得数据分散在多个不同的Region，达到Region负载均衡的目标。比如在一个有4个Region(注：以 [ ,a)、[a,b)、[b,c)、[c, )为Region起止)的HBase表中，<br>加Salt前的Rowkey：abc001、abc002、abc003<br>我们分别加上a、b、c前缀，加Salt后Rowkey为：a-abc001、b-abc002、c-abc003<br>可以看到，加盐前的Rowkey默认会在第2个region中，加盐后的Rowkey数据会分布在3个region中，理论上处理后的吞吐量应是之前的3倍。由于前缀是随机的，读这些数据时需要耗费更多的时间，所以Salt增加了写操作的吞吐量，不过缺点是同时增加了读操作的开销。</p><h4 id="Hash散列或者Mod"><a href="#Hash散列或者Mod" class="headerlink" title="Hash散列或者Mod"></a>Hash散列或者Mod</h4><p>用Hash散列来替代随机Salt前缀的好处是能让一个给定的行有相同的前缀，这在分散了Region负载的同时，使读操作也能够推断。确定性Hash(比如md5后取前4位做前缀)能让客户端重建完整的RowKey，可以使用get操作直接get想要的行。</p><p>例如将上述的原始Rowkey经过hash处理，此处我们采用md5散列算法取前4位做前缀，结果如下<br>9bf0-abc001 （abc001在md5后是9bf049097142c168c38a94c626eddf3d，取前4位是9bf0）<br>7006-abc002<br>95e6-abc003  </p><p>若用前4个字符作为不同分区的起止，上面几个Rowkey数据会分布在3个region中。实际应用场景是当数据量越来越大的时候，这种设计会使得分区之间更加均衡。</p><p>如果Rowkey是数字类型的，也可以考虑Mod方法。</p><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><h3 id="支持多条件查询的RowKey设计"><a href="#支持多条件查询的RowKey设计" class="headerlink" title="支持多条件查询的RowKey设计"></a>支持多条件查询的RowKey设计</h3><h4 id="提示说明"><a href="#提示说明" class="headerlink" title="提示说明"></a>提示说明</h4><p>HBase按指定的条件获取一批记录时，使用的就是scan方法。 scan方法有以下特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-1. scan可以通过setCaching与setBatch方法提高速度。（以空间换时间）</span><br><span class="line">-2. scan可以通过setStartRow与setEndRow来限定范围。（范围越小，性能越高）</span><br><span class="line"></span><br><span class="line">通过巧妙的RowKey设计使我们批量获取记录集合中的元素挨在一起（应该在同一个Region下），可以在遍历结果时获得很好的性能。</span><br><span class="line"></span><br><span class="line">-3. scan可以通过setFilter方法添加过滤器，这也是分页、多条件查询的基础。</span><br></pre></td></tr></table></figure><p>因此，在满足长度、散列、唯一原则后，我们只需要考虑如何通过巧妙设计RowKey来利用scan方法的范围功能，使得获取一批记录的查询速度能提高。</p><h4 id="案例需求"><a href="#案例需求" class="headerlink" title="案例需求"></a>案例需求</h4><p>下例就描述如何将多个列组合成一个RowKey，使用scan的range来达到较快查询速度。</p><p><img src="044-1588406276904.png" alt=""></p><p>以图为例，我们在表中存储的是文件信息，每个文件有5个属性：文件id（long，全局唯一）、创建时间（long）、文件名（String）、分类名（String）、所有者（User）。</p><p>这里UserID对应另一张User表，暂不列出。我们只需知道UserID的含义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1代表 浙江卫视； </span><br><span class="line">2代表 好声音剧组； </span><br><span class="line">3代表 XX微博； </span><br><span class="line">4代表 赞助商。</span><br></pre></td></tr></table></figure><p>我们的需求是按照以下条件进行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-1. 文件创建时间区间 （比如从20120901到20120914期间创建的文件）</span><br><span class="line">-2. 文件名（“中国好声音”），</span><br><span class="line">-3. 分类（“综艺”），</span><br><span class="line">-4. 所有者（“浙江卫视”）。</span><br></pre></td></tr></table></figure><p>调用查询接口的时候将上述5个条件同时输入到<strong>find(20120901,20120914,”中国好声音”,”综艺”,”浙江卫视”)</strong>。此时我们应该得到的记录应该有第1、2、3、4、5、7条。第6条由于不属于“浙江卫视”应该不被选中。</p><h4 id="rowkey设计"><a href="#rowkey设计" class="headerlink" title="rowkey设计"></a>rowkey设计</h4><p>我们在设计RowKey时可以这样做：采用 UserID + CreateTime + FileID组成RowKey，这样既能满足多条件查询，又能有很快的查询速度。</p><p>需要注意以下几点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 每条记录的RowKey，每个字段都需要填充到相同长度。</span><br><span class="line">假如预期我们最多有10万量级的用户，则userID应该统一填充至6位，如000001，000002…</span><br><span class="line">- 结尾添加全局唯一的FileID的用意也是使每个文件对应的记录全局唯一。</span><br><span class="line">避免当UserID与CreateTime相同时的两个不同文件记录相互覆盖。</span><br></pre></td></tr></table></figure><p>按照这种RowKey存储上述文件记录，在HBase表中是下面的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rowKey（userID 6 + time 8 + fileID 6） name category ….</span><br><span class="line"></span><br><span class="line">00000120120902000001</span><br><span class="line">00000120120904000002</span><br><span class="line">00000120120906000003</span><br><span class="line">00000120120908000004</span><br><span class="line">00000120120910000005</span><br><span class="line">00000120120914000007</span><br><span class="line">00000220120912000006</span><br><span class="line">00000220120916000008</span><br><span class="line">00000320120918000009</span><br><span class="line">00000420120920000010</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-1. 在建立一个scan对象后，我们setStartRow(00000120120901)，setEndRow(00000120120914)。</span><br><span class="line"></span><br><span class="line">  这样，scan时只扫描userID&#x3D;1的数据，且时间范围限定在这个指定的时间段内，满足了按用户以及按时间范围对结果的筛选。并且由于记录集中存储，性能很好。</span><br><span class="line"></span><br><span class="line">-2. 然后使用 SingleColumnValueFilter（org.apache.hadoop.hbase.filter.SingleColumnValueFilter），共4个，分别约束name的上下限，与category的上下限。满足按同时按文件名以及分类名的前缀匹配。</span><br><span class="line"></span><br><span class="line">  （注意：使用SingleColumnValueFilter会影响查询性能，在真正处理海量数据时会消耗很大的资源，且需要较长的时间）</span><br><span class="line"></span><br><span class="line">- 如果需要分页还可以再加一个PageFilter限制返回记录的个数。</span><br></pre></td></tr></table></figure><p>以上，我们完成了高性能的支持多条件查询的HBase表结构设计。</p><h3 id="针对事务数据Rowkey设计"><a href="#针对事务数据Rowkey设计" class="headerlink" title="针对事务数据Rowkey设计"></a>针对事务数据Rowkey设计</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">事务数据是带时间属性的，建议将时间信息存入到Rowkey中，这有助于提示查询检索速度。对于事务数据建议缺省就按天为数据建表，这样设计的好处是多方面的。按天分表后，时间信息就可以去掉日期部分只保留小时分钟毫秒，这样4个字节即可搞定。加上散列字段2个字节一共6个字节即可组成唯一</span> <span class="string">Rowkey。如下图所示：</span></span><br></pre></td></tr></table></figure><p><img src="041.png" alt=""></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">这样的设计从操作系统内存管理层面无法节省开销，因为64位操作系统是必须8字节对齐。但是对于持久化存储中Rowkey部分可以节省25%的开销。也许有人要问为什么不将时间字段以主机字节序保存，这样它也可以作为散列字段了。这是因为时间范围内的数据还是尽量保证连续，相同时间范围内的数据查找的概率很大，对查询检索有好的效果，因此使用独立的散列字段效果更好，对于某些应用，我们可以考虑利用散列字段全部或者部分来存储某些数据的字段信息，只要保证相同散列值在同一时间（毫秒）唯一。</span></span><br></pre></td></tr></table></figure><h3 id="针对统计数据的Rowkey设计"><a href="#针对统计数据的Rowkey设计" class="headerlink" title="针对统计数据的Rowkey设计"></a>针对统计数据的Rowkey设计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">统计数据也是带时间属性的，统计数据最小单位只会到分钟（到秒预统计就没意义了）。同时对于统计数据我们也缺省采用按天数据分表，这样设计的好处无需多说。按天分表后，时间信息只需要保留小时分钟，那么0~1400只需占用两个字节即可保存时间信息。由于统计数据某些维度数量非常庞大，因此需要4个字节作为序列字段，因此将散列字段同时作为序列字段使用也是6个字节组成唯一Rowkey。如下图所示：</span><br></pre></td></tr></table></figure><p><img src="042.png" alt=""></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">同样这样的设计从操作系统内存管理层面无法节省开销，因为64位操作系统是必须8字节对齐。但是对于持久化存储中Rowkey部分可以节省25%的开销。预统计数据可能涉及到多次反复的重计算要求，需确保作废的数据能有效删除，同时不能影响散列的均衡效果，因此要特殊处理。</span></span><br></pre></td></tr></table></figure><h3 id="针对通用数据的Rowkey设计"><a href="#针对通用数据的Rowkey设计" class="headerlink" title="针对通用数据的Rowkey设计"></a>针对通用数据的Rowkey设计</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">通用数据采用自增序列作为唯一主键，用户可以选择按天建分表也可以选择单表模式。这种模式需要确保同时多个入库加载模块运行时散列字段（序列字段）的唯一性。可以考虑给不同的加载模块赋予唯一因子区别。设计结构如下图所示。</span></span><br></pre></td></tr></table></figure><p><img src="143.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池使用详解</title>
      <link href="/2023/02/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2023-02-21-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/02/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2023-02-21-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h3><p>问题一：反复创建线程开销大</p><p>问题二：过多的线程会占用太多内存</p><p>解决以上两个问题的思路</p><ul><li><p>用少量的线程——避免内存占用过多</p></li><li><p>让这部分线程都保持工作，且可以反复执行任务——避免生命周期 的损耗</p></li></ul><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><ul><li>加快响应速度 </li><li>合理利用CPU和内存 </li><li>统一管理</li></ul><h3 id="线程池的使用场景"><a href="#线程池的使用场景" class="headerlink" title="线程池的使用场景"></a>线程池的使用场景</h3><ul><li>服务器接收到大量请求时，使用线程池技术是非常合适的，它可 以大大减少线程的创建和销毁次数，提高服务器的工作效率</li><li>实际上，在开发中，如果需要创建5个以上的线程，那么就可以使 用线程池来管理</li></ul><h2 id="线程池构造参数"><a href="#线程池构造参数" class="headerlink" title="线程池构造参数"></a>线程池构造参数</h2><div class="table-container"><table><thead><tr><th>参数名</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>corePoolSize</td><td>int</td><td>核心线程数</td></tr><tr><td>maxPoolSize</td><td>int</td><td>最大线程数</td></tr><tr><td>maxPoolSize</td><td>long</td><td>最大保活时间</td></tr><tr><td>workQueue</td><td>BlockingQueue</td><td>任务存储队列</td></tr><tr><td>threadFactory</td><td>ThreadFactory</td><td>当线程池需要新的线程的时候， 会使用 threadFactory来生成新的线程</td></tr><tr><td>Handler</td><td>RejectedExecutionHandle r</td><td>由于线程池无法接受你所提交的任务的 拒绝策略</td></tr></tbody></table></div><h3 id="corePoolSize和maxPoolSize"><a href="#corePoolSize和maxPoolSize" class="headerlink" title="corePoolSize和maxPoolSize"></a>corePoolSize和maxPoolSize</h3><p>corePoolSize指的是核心线程数</p><ul><li>线程池在完成初始化后，默认情况下，线程池中并没有任何线程， 线程池会等待有任务到来时，再创建新线程去执行任务</li></ul><p>最大量maxPoolSize</p><ul><li>在核心线程数的基础上，额外增加的线程数的上限</li></ul><h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h3><ul><li>如果线程池当前的线程数多于corePoolSize，那么如果多余的 线程空闲时间超过keepAliveTime，它们就会被终止</li></ul><h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><ul><li>新的线程是由ThreadFactory创建的，默认使用 Executors.defaultThreadFactory() </li><li>创建出来的线程都在同一个线程组，拥有同样的 NORM_PRIORITY优先级并且都不是守护线程。 </li><li>如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。 </li><li>通常使用默认的ThreadFactory就可以了</li></ul><h3 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h3><p>有3种最常见的队列类型：</p><p>1) 直接交接：SynchronousQueue</p><p>2) 无界队列：LinkedBlockingQueue</p><p>3) 有界的队列：ArrayBlockingQueue</p><h2 id="添加线程规则"><a href="#添加线程规则" class="headerlink" title="添加线程规则"></a>添加线程规则</h2><ol><li><p>如果线程数小于corePoolSize，即使其他工作线程处于空闲状 态，也会创建一个新线程来运行新任务。</p></li><li><p>如果线程数等于（或大于）corePoolSize但少于 maximumPoolSize，则将任务放入队列。</p></li><li>如果队列已满，并且线程数小于maxPoolSize，则创建一个新 线程来运行任务。</li><li>如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝 该任务。</li></ol><p>​    <img src="image-20230221112059376.png" alt="image-20230221112059376" style="zoom:50%;" /></p><p>是否需要增加线程的判断顺序是：</p><ul><li>corePoolSize</li><li>workQueue</li><li>maxPoolSize</li></ul><h2 id="线程数量设定"><a href="#线程数量设定" class="headerlink" title="线程数量设定"></a>线程数量设定</h2><ul><li><p>CPU密集型（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右。 </p></li><li><p>耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一 般会大于CPU核心数很多倍 </p><p>参考Brain Goetz推荐的计算方法：</p></li></ul><p>​        线程数=CPU核心数*（1+平均等待时间/平均工作时间</p><h2 id="常见线程池分析"><a href="#常见线程池分析" class="headerlink" title="常见线程池分析"></a>常见线程池分析</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>FixedThreadPool  : 固定线程数量</li><li>CachedThreadPool : 具有自动回收多余线程的功能</li><li>ScheduledThreadPool :支持定时及周期性任务执行的线程池</li><li>SingleThreadExecutor :只会用唯一的工作线程来执行任务,原理和FixedThreadPool是一样的，但是此时的线程数量被设 置为了1</li></ul><h3 id="构造参数"><a href="#构造参数" class="headerlink" title="构造参数"></a>构造参数</h3><p><img src="image-20230221113954110.png" alt="image-20230221113954110"></p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><ul><li><p>FixedThreadPool和SingleThreadExecutor的Queue是 LinkedBlockingQueue</p><p>由于是固定线程，为了满足执行更多的任务 选用了无界队列。</p></li><li><p>CachedThreadPool使用的Queue是SynchronousQueue</p><p>队列不用来存储任务，要求每个任务必须有返回结果，采用交接队列。</p></li><li><p>ScheduledThreadPool来说，它使用的是延迟队列 DelayedWorkQueue</p><p>定时任务搭配DelayedWorkQueue。</p></li></ul><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><ul><li>AbortPolicy : 拒绝了 直接抛异常</li><li>DiscardPolicy :默默的丢弃掉。不会得到通知</li><li>DiscardOldestPolicy :丢弃最老的，存最新的</li><li>CallerRunsPolicy :线程池没办法处理的话，谁提交的任务谁来做，负反馈，它一直在提交，让它干点任务，       等一下，也给线程池多点时间</li></ul><h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><div class="table-container"><table><thead><tr><th>说明</th><th>状态</th></tr></thead><tbody><tr><td>RUNNING</td><td>接受新任务并处理排队任务</td></tr><tr><td>SHUTDOWN</td><td>不接受新任务，但处理排队任务</td></tr><tr><td>STOP</td><td>不接受新任务，也不处理排队任务，并中断正在进行的任务</td></tr><tr><td>TIDYING</td><td>所有任务都已终止，workerCount为零时，线程会转换到 TIDYING状态，并将运行terminate（）钩子方法</td></tr><tr><td>TERMINATED</td><td>terminate（）运行完成</td></tr></tbody></table></div><h2 id="使用线程池的注意点"><a href="#使用线程池的注意点" class="headerlink" title="使用线程池的注意点"></a>使用线程池的注意点</h2><ul><li>避免任务堆积 </li><li>避免线程数过度增加 </li><li>排查线程泄漏 </li><li>和ThreadLocal配合</li></ul><h2 id="勾子方法实践"><a href="#勾子方法实践" class="headerlink" title="勾子方法实践"></a>勾子方法实践</h2><p>在任务执行前后，可以利用勾子函数 打印一些日志信息等,下面代码利用勾子函数在执行任务前进行判断，实现线程池的暂停操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RejectedExecutionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PauseableThreadPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition unpaused = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PauseableThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PauseableThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">            TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PauseableThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">            TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PauseableThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">            TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory,</span><br><span class="line">                handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isPaused) &#123;</span><br><span class="line">                unpaused.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">false</span>;</span><br><span class="line">            unpaused.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        PauseableThreadPool pauseableThreadPool = <span class="keyword">new</span> PauseableThreadPool(<span class="number">10</span>, <span class="number">20</span>, <span class="number">10l</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"我被执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            pauseableThreadPool.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        pauseableThreadPool.pause();</span><br><span class="line">        System.out.println(<span class="string">"线程池被暂停了"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        pauseableThreadPool.resume();</span><br><span class="line">        System.out.println(<span class="string">"线程池被恢复了"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal 源码解析</title>
      <link href="/2023/02/20/%E6%BA%90%E7%A0%81-jdk-2023-02-20-ThreadLocal-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/02/20/%E6%BA%90%E7%A0%81-jdk-2023-02-20-ThreadLocal-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>ThreadLocal 提供了一种方式，让在多线程环境下，每个线程都可以拥有自己独特的数据，并 且可以在整个线程执行过程中，从上而下的传递。</p><h2 id="用法演示"><a href="#用法演示" class="headerlink" title="用法演示"></a>用法演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                local.set(<span class="string">"thread-1 local value"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 等待5000毫秒，确保threadTwo 执行remove完成</span></span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(local.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread threadTwo = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                local.set(<span class="string">"thread-2 local value"</span>);</span><br><span class="line">                System.out.println(local.get());</span><br><span class="line">                local.remove();</span><br><span class="line">                System.out.println(local.get());</span><br><span class="line">                System.out.println(<span class="string">"thread-2 remove 变量local 操作完毕。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadTwo. start();</span><br><span class="line">        threadOne. start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread-<span class="number">2</span> local value</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">thread-<span class="number">2</span> remove 变量local 操作完毕。</span><br><span class="line">thread-<span class="number">1</span> local value</span><br></pre></td></tr></table></figure><p>可以看到,不同线程保存的变量 都是线程私有。</p><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><h3 id="类范型"><a href="#类范型" class="headerlink" title="类范型"></a>类范型</h3><p>ThreadLocal 定义类时带有泛型，说明 ThreadLocal 可以储存任意格式的数据，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h3><p>ThreadLocal 有几个关键属性，我们一一看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="comment">// nextHashCode 主要作用是当前 ThreadLocal 赋唯一值，计算当前 ThreadLocal 在 ThreadLocalMap 中的索引位置</span></span><br><span class="line">    <span class="comment">// 被 static 修饰非常关键，因为一个线程在处理业务的过程中，ThreadLocalMap 是会被 set 多个 ThreadLocal 的，多个 ThreadLocal 就依靠 threadLocalHashCode 进行区分</span></span><br><span class="line">    <span class="comment">// static + AtomicInteger 保证了在一台机器上每个 ThreadLocal 的 threadLocalHashCode 是唯一的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br></pre></td></tr></table></figure><p>还有一个重要属性：ThreadLocalMap，当一个线程有多个 ThreadLocal 时，需要一个容器来 管理多个 ThreadLocal，ThreadLocalMap 的作用就是这个，管理线程中多个 ThreadLocal。</p><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>ThreadLocalMap 本 身 就 是 一 个 简 单 的 Map 结 构 ， key 是 ThreadLocal ， value 是 ThreadLocal 保存的值，底层是数组的数据结构，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组中的每个节点值，WeakReference 是弱引用，当没有引用指向时，会直接被回收</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 当前 ThreadLocal 关联的值</span></span><br><span class="line">        Object value;</span><br><span class="line">        <span class="comment">// WeakReference 的引用 referent 就是 ThreadLocal</span></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组的初始化大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储 ThreadLocal 的数组大小</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容的阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构， 底层是数组， 有初始化大 小，也有扩容阈值大小，数组的元素是 Entry，Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值。</p><h2 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h2><p>ThreadLocal 是线程安全的， 我们可以放心使用， 主要因为 ThreadLocalMap 是线程的属 性，我们看下线程 Thread 的源码，如下：</p><p><img src="image-20230220232850995.png" alt="image-20230220232850995" style="zoom:75%;" /></p><p>从 上 图 中 ， 我 们 可 以 看 到 ThreadLocals.ThreadLocalMap 和 InheritableThreadLocals.ThreadLocalMap 分 别 是 线 程 的 属 性 ， 所 以 每 个 线 程 的 ThreadLocals 都是隔离独享的。</p><p>父 线 程 在 创 建 子 线 程 的 情 况 下 ， 会 拷 贝 inheritableThreadLocals 的 值 ， 但 不 会 拷 贝 threadLocals 的值，源码如下：</p><p><img src="image-20230220233038779.png" alt="image-20230220233038779" style="zoom:67%;" /></p><p>从上图中我们可以看到，在线程创建时，会把父线程的 inheritableThreadLocals 属性值进行拷 贝。</p><h2 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h2><p>set 方法的主要作用是往当前 ThreadLocal 里面 set 值， 假如当前 ThreadLocal 的泛型是 Map，那么就是往当前 ThreadLocal 里面 set map，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set 操作每个线程都是串行的，不会有线程安全的问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 当前 thradLocal 之前有设置值，直接设置，否则初始化</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">// 初始化ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑比较清晰，我们在一起来看下 ThreadLocalMap.set 的源码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 计算 key 在数组中的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看 i 索引位置有没有值，有值的话，索引位置 + 1，直到找到没有值的位置</span></span><br><span class="line">    <span class="comment">// 这种解决 hash 冲突的策略，也导致了其在 get 时查找策略有所不同，体现在 getEntryAfterMiss 中</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// nextIndex 就是让在不超过数组长度的基础上，把数组的索引位置 + 1</span></span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 找到内存地址一样的 ThreadLocal，直接替换</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前 key 是 null，说明 ThreadLocal 被清理了，直接替换掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前 i 位置是无值的，可以被当前 thradLocal 使用</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// 当数组大小大于等于扩容阈值(数组大小的三分之二)时，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面源码我们注意几点：</p><ol><li><p>是通过递增的 AtomicInteger 作为 ThreadLocal 的 hashCode 的；</p></li><li><p>计算数组索引位置的公式是：hashCode 取模数组大小，由于 hashCode 不断自增，所 以不同的 hashCode 大概率上会计算到同一个数组的索引位置（但这个不用担心，在实际 项目中，ThreadLocal 都很少，基本上不会冲突）；</p></li><li><p>通过 hashCode 计算的索引位置 i 处如果已经有值了，会从 i 开始，通过 +1 不断的往后 寻找，直到找到索引位置为空的地方，把当前 ThreadLocal 作为 key 放进去。</p></li></ol><p>好在日常工作中使用 ThreadLocal 时，常常只使用 1~2 个 ThreadLocal，通过 hash 计算出 重复的数组的概率并不是很大。</p><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>set 时的解决数组元素位置冲突的策略，也对 get 方法产生了影响，接着我们一起来看一下 get 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为 threadLocal 属于线程的属性，所以需要先把当前线程拿出来</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 从线程中拿到 ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 map 中拿到 entry，由于 ThreadLocalMap 在 set 时的 hash 冲突的策略不同，导致拿的时候逻辑也不太一样</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 如果不为空，读取当前 ThreadLocal 中保存的值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则给当前线程的 ThreadLocal 初始化，并返回初始值 null</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来看下 ThreadLocalMap 的 getEntry 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到当前 thradLocal 对应的值，值的类型是由 thradLocal 的泛型决定的</span></span><br><span class="line"><span class="comment">// 由于 thradLocalMap set 时解决 Hash 冲突的逻辑，导致 thradLocalMap get 时的逻辑也会相应不同</span></span><br><span class="line"><span class="comment">// 首先尝试根据 hashcode 取模数组大小 = 索引位置i 寻找，找不到的话，自旋把 i+1，直到找到 thradLocal 为至</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算索引位置：ThreadLocal 的 hashCode 取模数组大小</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// e 不为空，并且 e 的 ThreadLocal 的内存地址和 key 相同，直接返回，否则就是没有找到，继续通过 getEntryAfterMiss 方法找</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自旋 i+1，直到找到为止</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 在大量使用不同 key 的 ThreadLocal 时，其实还蛮耗性能的</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 内存地址一样，表示找到了</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 删除没用的 key</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="comment">// 继续使索引位置 + 1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 逻辑源码中注释已经写的很清楚了，我们就不重复说了。</p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>ThreadLocalMap 中的 ThreadLocal 的个数超过阈值时， ThreadLocalMap 就要开始扩容 了，我们一起来看下扩容的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿出旧的数组</span></span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="comment">// 新数组的大小为老数组的两倍</span></span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 初始化新数组</span></span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 老数组的值拷贝到新数组上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 计算 ThreadLocal 在新数组中的位置</span></span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 如果索引 h 的位置值不为空，往后+1，直到找到值为空的索引位置</span></span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                <span class="comment">// 给新数组赋值</span></span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给新数组初始化下次扩容阈值，为数组长度的三分之二</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码注解也比较清晰，我们注意两点：</p><ol><li><p>扩容后数组大小是原来数组的两倍；</p></li><li><p>扩容时是绝对没有线程安全问题的，因为 ThreadLocalMap 是线程的一个属性，一个线 程同一时刻只能对 ThreadLocalMap 进行操作，因为同一个线程执行业务逻辑必然是串 行的，那么操作 ThreadLocalMap 必然也是串行的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolExecutor 源码解析</title>
      <link href="/2023/02/20/%E6%BA%90%E7%A0%81-jdk-2023-02-20-ThreadPoolExecutor-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/02/20/%E6%BA%90%E7%A0%81-jdk-2023-02-20-ThreadPoolExecutor-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h2><p><img src="image-20230220113220759.png" alt="image-20230220113220759"></p><h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>首先我们来看一下 ThreadPoolExecutor 的类结构，如下图：</p><p><img src="image-20230220113425008.png" alt="image-20230220113425008" style="zoom:50%;" /></p><p>接下来我们大概的看下这几个类的大概 含义：</p><ol><li><p>Executor：定义 execute 方法来执行任务，入参是 Runnable，无出参：</p><p><img src="image-20230220113645825.png" alt="image-20230220113645825"></p></li><li><p>ExecutorService：Executor 的功能太弱，ExecutorService 丰富了对任务的执行和管理 的功能，主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭，不会接受新的任务，也不会等待未完成的任务</span></span><br><span class="line">    <span class="comment">// 如果需要等待未完成的任务，可以使用 awaitTermination 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 试图关闭所有正在执行的任务，返回等待执行的任务列表</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的任务是否都已经终止，是的话，返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在超时时间内阻塞，等待所有的任务执行完成</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 提交有返回值的任务，使用 get 方法可以阻塞等待任务的结果返回</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"> </span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 提交没有返回值的任务</span></span><br><span class="line">    <span class="comment">// 任务执行完成之后，返回 null 值</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    <span class="comment">// 给定任务集合，返回已经执行完成的 Future 集合，每个返回的 Future 都是 isDone = true 的状态</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"> </span><br><span class="line">  &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                 <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 给定任务中有一个执行成功就返回，如果抛异常，其余未完成的任务将被取消</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AbstractExecutorService 是一个抽象类，封装了 Executor 的很多通用功能，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把 Runnable 转化成 RunnableFuture</span></span><br><span class="line"><span class="comment">// RunnableFuture 是一个接口，实现了 Runnable 和 Future</span></span><br><span class="line"><span class="comment">// FutureTask 是 RunnableFuture 的实现类，主要是对任务进行各种管理</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>有几个点需要注意下：</p><ol><li><p>FutureTask  其本身就是一个任务，而且具备对任务管理的功能，比 如可以通过 get 方法拿到任务的执行结果；</p></li><li><p>submit 方法是我们平时使用线程池时提交任务的方法，支持 Runable 和 Callable 两种任 务的提交，方法中 execute 方法是其子类 ThreadPoolExecutor 实现的，不管是那种任 务入参，execute 方法最终执行的任务都是 FutureTask；</p></li><li><p>ThreadPoolExecutor 继承了 AbstractExecutorService 抽象类，具备以上三个类的所有 功能。</p></li></ol><h3 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h3><p>ThreadPoolExecutor 的类注释有很多，我们选取关键的注释如下：</p><ol><li>ExecutorService 使用线程池中的线程执行提交的任务，线程池我们可以使用 Executors 进行配置</li><li><p>线程池解决两个问题：1：通过减少任务间的调度开销 (主要是通过线程池中的线程被重复 使用的方式)，来提高大量任务时的执行性能；2：提供了一种方式来管理线程和消费，维 护基本数据统计等工作，比如统计已完成的任务数；</p></li><li><p>Executors 为常用的场景设定了可直接初始化线程池的方法，比如 Executors#newCachedThreadPool 无界的线程池，并且可以自动回收； Executors#newFixedThreadPool 固定大小线程池； Executors#newSingleThreadExecutor 单个线程的线程池；</p></li><li><strong>为了在各种上下文中使用线程池，线程池提供可供扩展的参数设置：1：coreSize：当新 任务提交时，发现运行的线程数小于 coreSize，一个新的线程将被创建，即使这时候其它 工作线程是空闲的，可以通过 getCorePoolSize 方法获得 coreSize；2：maxSize: 当任 务提交时，coreSize &lt; 运行线程数 &lt;= maxSize，但队列没有满时，任务提交到队列中， 如果队列满了，在 maxSize 允许的范围内新建线程；</strong></li><li>一般来说，coreSize 和 maxSize 在线程池初始化时就已经设定了，但我们也可以通过 setCorePoolSize、setMaximumPoolSize 方法动态的修改这两个值；</li><li>默认的，core threads 需要到任务提交后才创建的，但我们可以分别使用 prestartCoreThread、prestartAllCoreThreads 两个方法来提前创建一个、所有的 core threads；</li><li>新的线程被默认 ThreadFactory 创建时，优先级会被限制成 NORM_PRIORITY，默认会 被设置成非守护线程，这个和新建线程的继承是不同的；</li><li><strong>Keep-alive times 参数的作用：1：如果当前线程池中有超过 coreSize 的线程；2：并且 线程空闲的时间超过 keepAliveTime，当前线程就会被回收，这样可以避免线程没有被使 用时的资源浪费；</strong></li><li>通过 setKeepAliveTime 方法可以动态的设置 keepAliveTime 的值；</li><li>如果设置 allowCoreThreadTimeOut 为 ture 的话，core thread 空闲时间超过 keepAliveTime 的话，也会被回收；</li><li>线程池新建时，有多种队列可供选择，比如：1：SynchronousQueue，为了避免任务被 拒绝，要求线程池的 maxSize 无界，缺点是当任务提交的速度超过消费的速度时，可能 出现无限制的线程增长；2：LinkedBlockingQueue，无界队列，未消费的任务可以在队 列中等待；3：ArrayBlockingQueue，有界队列，可以防止资源被耗尽；</li><li>队列的维护：提供了 getQueue () 方法方便我们进行监控和调试，严禁用于其他目的， remove 和 purge 两个方法可以对队列中的元素进行操作；</li><li>在 Executor 已经关闭或对最大线程和最大队列都使用饱和时，可以使用 RejectedExecutionHandler 类进行异常捕捉，有如下四种处理策略： ThreadPoolExecutor.AbortPolicy、ThreadPoolExecutor.DiscardPolicy、 ThreadPoolExecutor.CallerRunsPolicy、ThreadPoolExecutor.DiscardOldestPolicy；</li><li>线程池提供了很多可供扩展的钩子函数，比如有：1：提供在每个任务执行之前 beforeExecute 和执行之后 afterExecute 的钩子方法，主要用于操作执行环境，比如初 始化 ThreadLocals、收集统计数据、添加日志条目等；2: 如果在执行器执行完成之后想 干一些事情，可以实现 terminated 方法，如果钩子方法执行时发生异常，工作线程可能 会失败并立即终止。</li></ol><p>可以看到 ThreadPoolExecutor 的注释是非常多的，也是非常重要的，我们很多面试的题目， 在注释上都能找到答案。</p><h2 id="ThreadPoolExecutor-重要属性"><a href="#ThreadPoolExecutor-重要属性" class="headerlink" title="ThreadPoolExecutor 重要属性"></a>ThreadPoolExecutor 重要属性</h2><p>接下来我们来看一看 ThreadPoolExecutor 都有哪些重要属性，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ctl 线程池状态控制字段，由两部分组成：</span></span><br><span class="line"> <span class="comment">//1:workerCount  有效的线程数，我们限制workerCount最大是到(2^29)-1，大概 5 亿个线程</span></span><br><span class="line"> <span class="comment">//2:runState 线程池的状态，提供了生命周期的控制，源码中有很多关于状态的校验，状态枚举如下：</span></span><br><span class="line"> <span class="comment">//RUNNING（-536870912）：接受新任务或者处理队列里的任务。</span></span><br><span class="line"> <span class="comment">//SHUTDOWN（0）：不接受新任务，但仍在处理已经在队列里面的任务。</span></span><br><span class="line"> <span class="comment">//STOP（-536870912）：不接受新任务，也不处理队列中的任务，对正在执行的任务进行中断。</span></span><br><span class="line"> <span class="comment">//TIDYING（1073741824）： 所以任务都被中断，workerCount 是 0，整理状态</span></span><br><span class="line"> <span class="comment">//TERMINATED（1610612736）： terminated() 已经完成的时候</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//runState 之间的转变过程：</span></span><br><span class="line"> <span class="comment">//RUNNING -&gt; SHUTDOWN：调用 shudown(),finalize()</span></span><br><span class="line"> <span class="comment">//(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()</span></span><br><span class="line"> <span class="comment">//SHUTDOWN -&gt; TIDYING -&gt; workerCount ==0</span></span><br><span class="line"> <span class="comment">//STOP -&gt; TIDYING -&gt; workerCount ==0</span></span><br><span class="line"> <span class="comment">//TIDYING -&gt; TERMINATED -&gt; terminated() 执行完成之后</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;<span class="comment">// 29</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;<span class="comment">// =(2^29)-1=536870911</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;<span class="comment">//-536870912</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;<span class="comment">//0</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;<span class="comment">//-536870912</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;<span class="comment">//1073741824</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;<span class="comment">//1610612736</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 已完成任务的计数</span></span><br><span class="line"> <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"> <span class="comment">// 线程池最大容量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"> <span class="comment">// 已经完成的任务数</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"> <span class="comment">// 用户可控制的参数都是 volatile 修饰的</span></span><br><span class="line"> <span class="comment">// 创建失败一般不抛出异常，只有在 OutOfMemoryError 时候才会</span></span><br><span class="line"> <span class="comment">// 可以使用 threadFactory 创建 thread</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"> <span class="comment">// 饱和或者运行中突然关闭的 handler 处理类</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"> <span class="comment">// 线程存活时间设置</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"> <span class="comment">// 设置 true 的话，核心线程空闲 keepAliveTime 时间后，也会被回收</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"> <span class="comment">// coreSize</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"> <span class="comment">// maxSize 最大限制 (2^29)-1</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"> <span class="comment">// 默认的拒绝策略</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">     <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 队列会 hold 住任务，并且利用队列的阻塞的特性，来保持线程的存活周期</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 大多数情况下是控制对 workers 的访问权限</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 包含线程池中所有的工作线程</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure><p><img src="image-20230220124629975.png" alt="image-20230220124629975"></p><p>Worker 我们可以理解成线程池中任务运行的最小单元，Worker 的大致结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 维护着运行中的任务的线程锁和可中断状态</span></span><br><span class="line"><span class="comment">// Worker 继承 AQS，具有锁功能</span></span><br><span class="line"><span class="comment">// Worker 实现 Runnable，本身是一个可执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 任务运行的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要执行的任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非常巧妙的设计,Worker本身是个 Runnable,把自己作为任务传递给 thread</span></span><br><span class="line">    <span class="comment">// 内部有个属性又设置了 Runnable</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 把 Worker 自己作为 thread 运行的任务</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Worker 本身是 Runnable，run 方法是 Worker 执行的入口， runWorker 是外部的方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">// 0 代表没有锁住，1 代表锁住</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试加锁，CAS 赋值为 1，表示锁住</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试释放锁，释放锁没有 CAS 校验，可以任意的释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解 Worker 非常关键，主要有以下几点：</p><ol><li><p>Worker 很像是任务的代理，在线程池中，最小的执行单位就是 Worker，所以 Worker 实现了 Runnable 接口，实现了 run 方法；</p></li><li><p>在 Worker 初始化时 this.thread = getThreadFactory ().newThread (this) 这行代码比 较关键，它把当前 Worker 作为线程的构造器入参，我们在后续的实现中会发现这样的代 码：Thread t = w.thread;t.start ()，此时的 w 是 Worker 的引用申明，此处 t.start 实际 上执行的就是 Worker 的 run 方法；</p></li><li><p>Worker 本身也实现了 AQS，所以其本身也是一个锁，其在执行任务的时候，会锁住自 己，任务执行完成之后，会释放自己。</p></li></ol><h2 id="线程池的任务提交"><a href="#线程池的任务提交" class="headerlink" title="线程池的任务提交"></a>线程池的任务提交</h2><p>线程池的任务提交从 submit 方法说起，submit 方法是 AbstractExecutorService 抽象类定义 的，主要做了两件事情：</p><ol><li><p>把 Runnable 和 Callable 都转化成 FutureTask，这个我们之前看过源码了；</p></li><li><p>使用 execute 方法执行 FutureTask。 </p></li></ol><h3 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h3><p>execute 方法是 ThreadPoolExecutor 中的方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 运行的线程数小于 corePoolSize，新建线程</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running,</span></span><br><span class="line"><span class="comment">     * try to start a new thread with the given command as its first task.</span></span><br><span class="line"><span class="comment">     * The call to addWorker atomically checks runState and workerCount,</span></span><br><span class="line"><span class="comment">     * and so prevents false alarms that would add threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued,</span></span><br><span class="line"><span class="comment">     * then we still need to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or</span></span><br><span class="line"><span class="comment">     *  that the pool shut down since entry into this method.</span></span><br><span class="line"><span class="comment">     * So we recheck state and if necessary roll back the enqueuing if stopped,</span></span><br><span class="line"><span class="comment">     * or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new thread.</span></span><br><span class="line"><span class="comment">     * If it fails, we know we are shut down or saturated and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 工作的线程小于核心线程数，创建新的线程，成功返回，失败不抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 线程池状态可能由变化</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工作的线程大于核心线程数，或者新建线程失败</span></span><br><span class="line">    <span class="comment">// 线程池状态正常，并且可以入队的话，尝试入队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果线程池状态异常 尝试从队列中移除任务，可以移除的话就拒绝掉任务</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 发现可运行的线程数是 0，就初始化一个线程，这里是个极限情况，入队的时候，突然发现</span></span><br><span class="line">        <span class="comment">// 线程都被回收了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// Runnable是空的，不会影响新增线程，但是线程在 start 的时候不会运行</span></span><br><span class="line">            <span class="comment">// Thread.run() 里面有判断</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列满了，开启线程到 maxSize，如果失败直接拒绝,</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execute 方法执行的就是整体架构图的左半边的逻辑， 其中多次调用 addWorker 方法， addWorker 方法的作用是新建一个 Worker，我们一起来看下源码：</p><h3 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结合线程池的情况看是否可以添加新的 worker</span></span><br><span class="line"><span class="comment">// firstTask 不为空可以直接执行，为空执行不了，Thread.run()方法有判断，Runnable为空不执行</span></span><br><span class="line"><span class="comment">// core 为 true 表示线程最大新增个数是 coresize，false 表示最大新增个数是 maxsize</span></span><br><span class="line"><span class="comment">// 返回 true 代表成功，false 失败</span></span><br><span class="line"><span class="comment">// break retry 跳到retry处，且不再进入循环</span></span><br><span class="line"><span class="comment">// continue retry 跳到retry处，且再次进入循环</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// rs &gt;= SHUTDOWN 说明线程池状态不正常</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 工作中的线程数大于等于容量，或者大于等于 coreSize or maxSize</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="comment">// break 结束 retry 的 for 循环</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 线程池状态被更改</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="comment">// 跳转到retry位置</span></span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 巧妙的设计，Worker 本身是个 Runnable.</span></span><br><span class="line">        <span class="comment">// 在初始化的过程中，会把 worker 丢给 thread 去初始化</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">//启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addWorker 方法首先是执行了一堆校验，然后使用 new Worker (firstTask) 新建了 Worker， 最后使用 t.start () 执行 Worker，上文我们说了 Worker 在初始化时的关键代码：this.thread = getThreadFactory ().newThread (this)， Worker（this） 是作为新建线程的构造器入参 的，所以 t.start () 会执行到 Worker 的 run 方法上，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; runWorker(<span class="keyword">this</span>); &#125;</span><br></pre></td></tr></table></figure><h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><p>runWorker 方法是非常重要的方法，我们一起看下源码实现：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    <span class="comment">//帮助gc回收</span></span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// task 为空的情况:任务入队列了，发现没有运行的线程，允许的话会新增一个线程</span></span><br><span class="line">        <span class="comment">// 如果 task 为空，会使用 getTask 方法阻塞从队列中拿数据</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//锁住worker</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 线程池stop中,但是线程没有到达中断状态，帮助线程中断</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行before钩子函数</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//同步执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//执行after钩子函数,如果这里抛出异常，会覆盖catch的异常</span></span><br><span class="line">                    <span class="comment">//所以这里异常最好不要抛出来</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//任务执行完成，计算解锁</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//做一些抛出异常的善后工作</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230220134953013.png" alt="image-20230220134953013" style="zoom:67%;" /></p><p>我们聚焦一下这行代码：task.run () 此时的 task 是什么呢？此时的 task 是 FutureTask 类， 所以我们继续追索到 FutureTask 类的 run 方法的源码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * run 方法可以直接被调用</span></span><br><span class="line"><span class="comment"> * 也可以由线程池进行调用</span></span><br><span class="line"><span class="comment"> * 如果需要开启子线程的话，只能走线程池，线程池会帮忙开启线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 状态不是任务创建，或者当前任务已经有线程在执行了</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">// Callable 不为空，并且已经初始化完成</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用执行</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 给 outcome 赋值</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run 方法中有两行关键代码：</p><ol><li><p>result = c.call () 这行代码是真正执行业务代码的地方；</p></li><li><p>set (result) 这里是给 outCome 赋值，这样 Future.get 方法执行时，就可以从 outCome 中拿值，这个我们之前我们有说 到。</p></li></ol><p>至此，submit 方法就执行完成了，整体流程比较复杂，我们画一个图释义一下任务提交执行的 主流程</p><p><img src="image-20230220135854156.png" alt="image-20230220135854156" style="zoom:67%;" /></p><h3 id="线程执行第一个任务之后"><a href="#线程执行第一个任务之后" class="headerlink" title="线程执行第一个任务之后"></a>线程执行第一个任务之后</h3><p>线程执行完任务之后，是消亡还是干什么呢？这是一个值得思考的问题，我们可以从源码中找到 答案， 从 ThreadPoolExecutor 的 runWorker 方法中，我们截图释义一下：</p><p><img src="image-20230220141906752.png" alt="image-20230220141906752" style="zoom:50%;" /></p><p>这个 while 循环有个 getTask 方法，getTask 的主要作用是阻塞从队列中拿任务出来，如果队 列中有任务，那么就可以拿出来执行，如果队列中没有任务，这个线程会一直阻塞到有任务为止 （或者超时阻塞），下面我们一起来看下 getTask 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从阻塞队列中拿任务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池关闭 &amp;&amp; 队列为空，不需要在运行了，直接放回</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// true  运行的线程数大于 coreSize || 核心线程也可以被灭亡</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列以 LinkedBlockingQueue 为例，timedOut 为 true 说明 poll 方法执行返回的是 null</span></span><br><span class="line">        <span class="comment">// 说明在等待 keepAliveTime 时间后，队列中仍然没有数据</span></span><br><span class="line">        <span class="comment">// 说明此线程已经空闲了 keepAliveTime 了</span></span><br><span class="line">        <span class="comment">// 再加上 wc &gt; 1 || workQueue.isEmpty() 的判断</span></span><br><span class="line">        <span class="comment">// 所以使用 compareAndDecrementWorkerCount 方法使线程池数量减少 1</span></span><br><span class="line">        <span class="comment">// 并且直接 return，return 之后，此空闲的线程会自动被回收</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从队列中拿 worker</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 设置已超时，说明此时队列没有数据</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码有两处关键：</p><ol><li>使用队列的 poll 或 take 方法从队列中拿数据，根据队列的特性，队列中有任务可以返 回，队列中无任务会阻塞；</li><li>方法中的第二个 if 判断，说的是在满足一定条件下（条件看注释），会减少空闲的线程， 减少的手段是使可用线程数减一，并且直接 return，直接 return 后，该线程就执行结束 了，JVM 会自动回收该线程。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次主要以 submit 方法为主线阐述了 ThreadPoolExecutor 的整体架构和底层源码，只要 有队列和线程的基础知识的话， 理解 ThreadPoolExecutor 并不复杂。 ThreadPoolExecutor 还有一些其他的源码，比如说拒绝请求的策略、得到各种属性、设置各种属性等等方法，这些方 法都比较简单，感兴趣的可以再研究。</p>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantLock 源码解析</title>
      <link href="/2023/02/20/%E6%BA%90%E7%A0%81-jdk-2023-02-20-ReentrantLock-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/02/20/%E6%BA%90%E7%A0%81-jdk-2023-02-20-ReentrantLock-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h2><p>ReentrantLock 中文我们习惯叫做可重入互斥锁，可重入的意思是同一个线程可以对同一个共 享资源重复的加锁或释放锁，互斥就是 AQS 中的排它锁的意思，只允许一个线程获得锁。</p><p>我们来一起来看下类注释上都有哪些重要信息：</p><ol><li>可重入互斥锁，和 synchronized 锁具有同样的功能语义，但更有扩展性；</li><li>构造器接受 fairness 的参数，fairness 是 ture 时，保证获得锁时的顺序，false 不保 证；</li><li>公平锁的吞吐量较低，获得锁的公平性不能代表线程调度的公平性；</li><li>tryLock() 无参方法没有遵循公平性，是非公平的（lock 和 unlock 都有公平和非公平， 而 tryLock 只有公平锁，所以单独拿出来说一说）。</li></ol><p>我们补充一下第二点， ReentrantLock 的公平和非公平， 是针对获得锁来说的， 如果是公平 的，可以保证同步队列中的线程从头到尾的顺序依次获得锁，非公平的就无法保证，在释放锁的 过程中，我们是没有公平和非公平的说法的。</p><p>ReentrantLock 类本身是不继承 AQS 的，实现了 Lock 接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>Lock 接口定义了各种加锁，释放锁的方法，接口有如下几个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 获取可中断的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 锁空闲，立马返回true，否则返回 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 带有超时等待时间的锁，如果超时时间到了，仍然没有获得锁，返回 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 得到新的 Condition</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 就负责实现这些接口，我们使用时，直接面对的也是这些方法，这些方法的底 层实现都是交给 Sync 内部类去实现的，Sync 类的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>Sync 继承了 AbstractQueuedSynchronizer ， 所以 Sync 就具有了锁的框架， 根据 AQS 的 框架，Sync 只需要实现 AQS 预留的几个方法即可，但 Sync 也只是实现了部分方法，还有一 些交给子类 NonfairSync 和 FairSync 去实现了， NonfairSync 是非公平锁， FairSync 是公 平锁，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步器 Sync 的两个子类锁 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>几个类整体的结构如下：</p><p><img src="image-20230220220655525.png" alt="image-20230220220655525" style="zoom:50%;" /></p><p>图中 Sync、NonfairSync、FairSync 都是静态内部类的方式实现的，这个也符合 AQS 框架定 义的实现标准。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>ReentrantLock 构造器有两种，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数构造器，相当于 ReentrantLock(false)，默认是非公平的 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  sync = <span class="keyword">new</span> NonfairSync(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">  sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参构造器默认构造是非公平的锁，有参构造器可以选择。</p><p>从构造器中可以看出， 公平锁是依靠 FairSync 实现的， 非公平锁是依靠 NonfairSync 实现 的。</p><h2 id="Sync同步器"><a href="#Sync同步器" class="headerlink" title="Sync同步器"></a>Sync同步器</h2><p>Sync 表示同步器，继承了 AQS</p><p><img src="image-20230220221059482.png" alt="image-20230220221059482" style="zoom:50%;" /></p><p>从  图中可以看出，lock 方法是个抽象方法，留给 FairSync 和 NonfairSync 两个子类去 实现，我们一起来看下剩余重要的几个方法。</p><h3 id="nonfairTryAcquire"><a href="#nonfairTryAcquire" class="headerlink" title="nonfairTryAcquire"></a>nonfairTryAcquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试获得非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">  <span class="keyword">int</span> c = getState();</span><br><span class="line">  <span class="comment">// 同步器的状态是 0 表示同步器的锁没有人持有</span></span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前线程持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">      <span class="comment">// 标记当前持有锁的线程是谁</span></span><br><span class="line">      setExclusiveOwnerThread(current);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果当前线程已经持有锁了</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="comment">// 当前线程持有锁的数量 + acquires</span></span><br><span class="line">    <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="comment">// int 是有最大值的，&lt;0 表示持有锁的数量超过了 int 的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//否则线程进入同步队列</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>通过判断 AQS 的 state 的状态来决定是否可以获得锁，0 表示锁是空闲的；</p></li><li><p>else if 的代码体现了可重入加锁，同一个线程对共享资源重入加锁，底层实现就是把 state + 1，并且可重入的次数是有限制的，为 Integer 的最大值；</p></li><li><p>这个方法是非公平的，所以只有非公平锁才会用到，公平锁是另外的实现。</p></li></ol><p>无参的 tryLock 方法调用的就是此方法，tryLock 的方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 提供的 tryRelease 默认实现，非公平和公平锁都使用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前同步器的状态减去释放的个数，releases 一般为 1</span></span><br><span class="line">  <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">  <span class="comment">// 当前线程不持有锁，报错</span></span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 如果 c 为 0，表示当前线程持有的锁都释放了</span></span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    free = <span class="keyword">true</span>;</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 c 不为 0，那么就是可重复锁释放了一次锁</span></span><br><span class="line">  setState(c);</span><br><span class="line">  <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryRelease 方法是公平锁和非公平锁都公用的，在锁释放的时候，是没有公平和非公平的说法 的。</p><p>从代码中可以看到，锁最终被释放的标椎是 state 的状态为 0，在重入加锁的情况下，需要重入 解锁相应的次数后，才能最终把锁释放，比如线程 A 对共享资源 B 重入加锁 5 次，那么释放锁 的话，也需要释放 5 次之后，才算真正的释放该共享资源了。</p><h2 id="FairSync-公平锁"><a href="#FairSync-公平锁" class="headerlink" title="FairSync 公平锁"></a>FairSync 公平锁</h2><p>FairSync 公平锁只实现了 lock 和 tryAcquire 两个方法，lock 方法非常简单，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquire 是 AQS 的方法，表示先尝试获得锁，失败之后进入同步队列阻塞等待 </span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire 方法是 AQS 在 acquire 方法中留给子类实现的抽象方法，FairSync 中实现的源码 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// hasQueuedPredecessors 是实现公平的关键</span></span><br><span class="line">      <span class="comment">// 会判断当前线程是不是属于同步队列的头节点的下一个节点(头节点是释放锁的节点)</span></span><br><span class="line">      <span class="comment">// 如果是(返回false)，符合先进先出的原则，可以获得锁</span></span><br><span class="line">      <span class="comment">// 如果不是(返回true)，则继续等待</span></span><br><span class="line">      <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">          compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">      <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代 码 和 Sync 的 nonfairTryAcquire 方 法 实 现 类 似 ， 唯 一 不 同 的 是 在 获 得 锁 时 使 用 hasQueuedPredecessors 方法体现了其公平性。</p><h2 id="NonfairSync-非公平锁"><a href="#NonfairSync-非公平锁" class="headerlink" title="NonfairSync 非公平锁"></a>NonfairSync 非公平锁</h2><p>NonfairSync 底层实现了 lock 和 tryAcquire 两个方法，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// cas给state赋值</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">      <span class="comment">// cas赋值成功，代表拿到当前锁，记录拿到锁的线程</span></span><br><span class="line">      setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// acquire是抽象类AQS的方法,</span></span><br><span class="line">      <span class="comment">// 会再次尝试获得锁，失败会进入到同步队列中</span></span><br><span class="line">      acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 直接使用的是 Sync.nonfairTryAcquire 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识串联"><a href="#知识串联" class="headerlink" title="知识串联"></a>知识串联</h2><p>以上内容主要说了 ReentrantLock 的基本结构，比较零散，那么这些零散的结构如何串联起来 呢？我们是通过 lock、tryLock、unlock 这三个 API 将以上几个类串联起来， 我们来一一看 下。</p><h3 id="lock-加锁"><a href="#lock-加锁" class="headerlink" title="lock 加锁"></a>lock 加锁</h3><p>lock 的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; sync.lock(); &#125;</span><br></pre></td></tr></table></figure><p>其底层的调用关系(只是简单表明调用关系，并不是完整分支图)如下：</p><p><img src="image-20230220223706791.png" alt="image-20230220223706791" style="zoom:60%;" /></p><h3 id="tryLock-尝试加锁"><a href="#tryLock-尝试加锁" class="headerlink" title="tryLock 尝试加锁"></a>tryLock 尝试加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// timeout 为超时的时间，在时间内，仍没有得到锁，会返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unlock-释放锁"><a href="#unlock-释放锁" class="headerlink" title="unlock 释放锁"></a>unlock 释放锁</h3><p>unlock 释放锁的方法， 底层调用的是 Sync 同步器的 release 方法， release 是 AQS 的方 法，分成两步：</p><ol><li>尝试释放锁，如果释放失败，直接返回 false；</li><li>释放成功，从同步队列的头节点的下一个节点开始唤醒，让其去竞争锁。</li></ol><p><strong>这个地方不要晕，已经在队列中的节点线程当然不会竞争,能竞争的是那些来抢锁，新出现的线程，还没被加到队列中。而锁的意义就在这，解决资源的竞争</strong>。</p><p>unLock 的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123; sync.release(<span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    AQS 搭建了整个 锁架构，子类锁只需要根据场景，实现 AQS 对应的方法即可，不仅仅是 ReentrantLock 是这 样，JUC 中的其它锁也都是这样，只要对 AQS 了如指掌，锁其实非常简单。</p>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(八)布隆过滤器应用</title>
      <link href="/2023/02/16/Hbase-2023-02-16-%E5%85%AB-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%BA%94%E7%94%A8/"/>
      <url>/2023/02/16/Hbase-2023-02-16-%E5%85%AB-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="布隆过滤器由来"><a href="#布隆过滤器由来" class="headerlink" title="布隆过滤器由来"></a>布隆过滤器由来</h2><p>​    Bloom filter 是由 Howard Bloom 在 1970 年提出的二进制向量数据结构，它具有很好的空间和时间效率，被用来检测一个元素是不是集合中的一个成员。如果检测结果为是，该元素不一定在集合中；但如果检测结果为否，该元素一定不在集合中。因此Bloom filter具有100%的召回率。这样每个检测请求返回有“在集合内（可能错误）”和“不在集合内（绝对不在集合内）”两种情况，可见 Bloom filter 是牺牲了正确率以节省空间。</p><h2 id="布隆过滤器应用场景"><a href="#布隆过滤器应用场景" class="headerlink" title="布隆过滤器应用场景"></a>布隆过滤器应用场景</h2><p><img src="017.png" alt=""></p><h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p>​    它的时间复杂度是O(1)，但是空间占用取决其优化的方式。它是布隆过滤器的基础。<br>布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组（或者叫位向量）和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k</p><p><img src="016.png" alt=""></p><p>以上图为例，具体的插入数据和校验是否存在的流程：</p><p>假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。</p><p>Step1：将位数组初始化，每位都设置为0。</p><p>Step2：对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，哈希值对应位数组上面的一个点，将该位置标记为1。</p><p>Step3：查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。</p><p>Step4：如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中。注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。<br>可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因。</p><h2 id="布隆过滤器在HBASE中的应用"><a href="#布隆过滤器在HBASE中的应用" class="headerlink" title="布隆过滤器在HBASE中的应用"></a>布隆过滤器在HBASE中的应用</h2><p>布隆过滤器是hbase中的高级功能，它能够减少特定访问模式（get/scan）下的查询时间。不过由于这种模式增加了内存和存储的负担，所以被默认为关闭状态。<br>hbase支持如下类型的布隆过滤器：</p><p>1、NONE          不使用布隆过滤器<br>2、ROW           行键使用布隆过滤器<br>3、ROWCOL    列键使用布隆过滤器<br>其中ROWCOL是粒度更细的模式。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在介绍为什么hbase要引入布隆过滤器之前，我们先来了解一下hbase存储文件HFile的块索引机制</p><p>我们知道hbase的实际存储结构是HFile，它是位于hdfs系统中的，也就是在磁盘中。而加载到内存中的数据存储在MemStore中，当MemStore中的数据达到一定数量时，它会将数据存入HFile中。</p><p>HFIle是由一个个数据块与索引块组成，他们通常默认为64KB。hbase是通过块索引来访问这些数据块的。而索引是由每个数据块的第一行数据的rowkey组成的。当hbase打开一个HFile时，块索引信息会优先加载到内存当中。然后hbase会通过这些块索引来查询数据。</p><p>但是块索引是相当粗粒度的，我们可以简单计算一下。假设一个行占100bytes的空间，所以一个数据块64KB，所包含的行大概有：(64 * 1024)/100 = 655.53 = ~700行。而我们只能从索引给出的一个数据块的起始行开始查询。</p><p>如果用户随机查找一个行键，则这个行键很可能位于两个开始键（即索引）之间的位置。对于hbase来说，它判断这个行键是否真实存在的唯一方法就是加载这个数据块，并且扫描它是否包含这个键。</p><p>同时，还存在很多情况使得这种情况更加复杂。</p><p>对于一个应用来说，用户通常会以一定的速率进行更新数据，这就将导致内存中的数据被刷写到磁盘中，并且之后系统会将他们合并成更大的存储文件。在hbase的合并存储文件的时候，它仅仅会合并最近几个存储文件，直至合并的存储文件到达配置的最大大小。最终系统中会有很多的存储文件，所有的存储文件都是候选文件，其可能包含用户请求行键的单元格。</p><p>如下图所示：<br>我们可以看到，这些不同的文件都来自同一个列族，所以他们的行键分布类似。所以，虽然我们要查询更新的特定行只在某个或者某几个文件中，但是采用块索引方式，还是会覆盖整个行键范围。当块索引确定那些块可能含有某个行键后，regionServer需要加载每一个块来检查该块中是否真的包含该行的单元格。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>当我们随机读get数据时，如果采用hbase的块索引机制，hbase会加载很多块文件。如果采用布隆过滤器后，它能够准确判断该HFile的所有数据块中，是否含有我们查询的数据，从而大大减少不必要的块加载，从而增加hbase集群的吞吐率。这里有几点细节：</p><ol><li><p>布隆过滤器的存储在哪?<br>对于hbase而言，当我们选择采用布隆过滤器之后，HBase会在生成StoreFile（HFile）时包含一份布隆过滤器结构的数据，称其为MetaBlock；MetaBlock与DataBlock（真实的KeyValue数据）一起由LRUBlockCache维护。所以，开启bloomfilter会有一定的存储及内存cache开销。但是在大多数情况下，这些负担相对于布隆过滤器带来的好处是可以接受的。</p></li><li><p>采用布隆过滤器后，hbase如何get数据？<br>在读取数据时，hbase会首先在布隆过滤器中查询，根据布隆过滤器的结果，再在MemStore中查询，最后再在对应的HFile中查询。</p></li><li><p>采用ROW还是ROWCOL布隆过滤器？<br>这取决于用户的使用模式。如果用户只做行扫描，使用更加细粒度的行加列布隆过滤器不会有任何的帮助，这种场景就应该使用行级布隆过滤器。当用户不能批量更新特定的一行，并且最后的使用存储文件都含有改行的一部分时，行加列级的布隆过滤器更加有用。</p></li></ol><p>例如：ROW 使用场景假设有2个Hfile文件hf1和hf2， hf1包含kv1（r1 cf:q1 v）、kv2（r2 cf:q1 v） hf2包含kv3（r3 cf:q1 v）、kv4（r4 cf:q1 v） 如果设置了CF属性中的bloomfilter（布隆过滤器）为ROW，那么get(r1)时就会过滤hf2，get(r3)就会过滤hf1 。</p><p>​    ROWCOL使用场景假设有2个Hfile文件hf1和hf2， hf1包含kv1（r1 cf:q1 v）、kv2（r2 cf:q1 v） hf2包含kv3（r1 cf:q2 v）、kv4（r2 cf:q2 v） 如果设置了CF属性中的bloomfilter为ROW，无论get(r1,q1)还是get(r1,q2)，都会读取hf1+hf2；而如果设置了CF属性中的bloomfilter为ROWCOL，那么get(r1,q1)就会过滤hf2，get(r1,q2)就会过滤hf1。</p><p>tip:<br>ROW和ROWCOL只是名字上有联系，但是ROWCOL并不是ROW的扩展，也不能取代ROW</p><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(七)HBASE与其他框架整合</title>
      <link href="/2023/02/16/Hbase-2023-02-16-%E4%B8%83-HBASE%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"/>
      <url>/2023/02/16/Hbase-2023-02-16-%E4%B8%83-HBASE%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="整合的原因"><a href="#整合的原因" class="headerlink" title="整合的原因"></a>整合的原因</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. HBase的最主要的目的是做数据存储</span><br><span class="line">2. Hive的最主要作用是做数据分析</span><br><span class="line">3. 整合的目的是为了方便的在项目中存储+分析</span><br><span class="line">4. hbase中的表数据在hive中能看到，hive中的表数据在hbase中也能看到</span><br></pre></td></tr></table></figure><h3 id="Hive-To-Hbase"><a href="#Hive-To-Hbase" class="headerlink" title="Hive-To-Hbase"></a>Hive-To-Hbase</h3><p><strong>1） 首先在hive中创建hbase能看到的表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> hive2hbase (</span><br><span class="line">uid <span class="built_in">int</span>,</span><br><span class="line">uname <span class="keyword">string</span>,</span><br><span class="line">age <span class="built_in">int</span>,</span><br><span class="line">sex <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">by</span> <span class="string">'org.apache.hadoop.hive.hbase.HBaseStorageHandler'</span></span><br><span class="line"><span class="keyword">with</span> serdeproperties(</span><br><span class="line"><span class="string">"hbase.columns.mapping"</span>=<span class="string">":key,base_info:name,base_info:age,base_info:sex"</span></span><br><span class="line">)</span><br><span class="line">tblproperties(</span><br><span class="line"><span class="string">"hbase.table.name"</span>=<span class="string">"hive2hbase1"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>2） 如果hive是低版本的，如1.2.1，那么应该报以下错误</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.DDLTask. org.apache.hadoop.hbase.HTableDescriptor.addFamily(Lorg&#x2F;apache&#x2F;hadoop&#x2F;hbase&#x2F;HColumnDescriptor;)V</span><br><span class="line"></span><br><span class="line">原因是：依赖于hive-hbase-handler-1.2.1.jar，而找到的hbase中的版本匹配不一致造成的。</span><br><span class="line"></span><br><span class="line">hive-2.1.1不会出现以上错误</span><br></pre></td></tr></table></figure><p><strong>3） 解决办法</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- 可以使用maven 下载此包</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-hbase-handler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">- 去本地仓库中找到源码包，解压</span><br><span class="line">- 使用IDE，随便创建一个空项目</span><br><span class="line">- 将源码包copy到src下，因为依赖hive和hbase的jar,因此有红叉</span><br><span class="line">- 将hive和hbase的lib下的所有jar 放入此项目下的lib中 </span><br><span class="line">- 将源码重写打包生成hive-hbase-handler-1.2.1.jar,覆盖掉hive的lib下原有的jar包</span><br><span class="line">- 然后再重写建表，就好了</span><br></pre></td></tr></table></figure><p><strong>4） 进行测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 在hive中插入一条记录</span><br><span class="line"></span><br><span class="line">   insert into hive2hbase values(1, &#39;michael&#39;, 32, &#39;男&#39;);</span><br><span class="line"></span><br><span class="line">2. 在hbase中插入一条记录</span><br><span class="line"></span><br><span class="line">    put &#39;hive2hbase1&#39;, &#39;2&#39;, &#39;base_info:age&#39;,&#39;33&#39;</span><br><span class="line">put &#39;hive2hbase1&#39;, &#39;2&#39;, &#39;base_info:name&#39;,&#39;rock&#39;</span><br><span class="line">   put &#39;hive2hbase1&#39;, &#39;2&#39;, &#39;base_info:sex&#39;,&#39;女&#39;</span><br><span class="line"></span><br><span class="line">3. 分别查看查询结果</span><br><span class="line"></span><br><span class="line">4. 导入数据</span><br><span class="line"></span><br><span class="line">   借助中间表向hive2hbase表中导入数据。</span><br></pre></td></tr></table></figure><h3 id="Hbase-To-Hive"><a href="#Hbase-To-Hive" class="headerlink" title="Hbase-To-Hive"></a>Hbase-To-Hive</h3><p><strong>1） 确定hbase中的某一张表的表结构和表数据</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">hbase&gt;</span> <span class="string">create 'ns1:t1','f1'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">put</span> <span class="string">'ns1:t1','rk00001','f1:name','zhaoyun'</span></span><br><span class="line"><span class="attr">put</span> <span class="string">'ns1:t1','rk00001','f1:age',23</span></span><br><span class="line"><span class="attr">put</span> <span class="string">'ns1:t1','rk00001','f1:gender','m'</span></span><br><span class="line"><span class="attr">put</span> <span class="string">'ns1:t1','rk00002','f1:name','zhenji'</span></span><br><span class="line"><span class="attr">put</span> <span class="string">'ns1:t1','rk00002','f1:age',24</span></span><br><span class="line"><span class="attr">put</span> <span class="string">'ns1:t1','rk00002','f1:gender','f'</span></span><br><span class="line"><span class="attr">put</span> <span class="string">'ns1:t1','rk00003','f1:name','貂蝉'</span></span><br><span class="line"><span class="attr">put</span> <span class="string">'ns1:t1','rk00003','f1:age',24</span></span><br><span class="line"><span class="attr">put</span> <span class="string">'ns1:t1','rk00003','f1:gender','f'</span></span><br></pre></td></tr></table></figure><p><strong>2） 根据hbase的表结构建立hive表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> hbase2hive;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> hbase2hive(</span><br><span class="line">uid <span class="keyword">string</span>,</span><br><span class="line">age <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="keyword">string</span>,</span><br><span class="line">sex <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">by</span> <span class="string">'org.apache.hadoop.hive.hbase.HBaseStorageHandler'</span></span><br><span class="line"><span class="keyword">with</span> serdeproperties(</span><br><span class="line"><span class="string">"hbase.columns.mapping"</span>=<span class="string">"f1:age,f1:name,f1:gender"</span></span><br><span class="line">)</span><br><span class="line">tblproperties(</span><br><span class="line"><span class="string">"hbase.table.name"</span>=<span class="string">"ns1:t1"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>3） 在hive中查看结果</strong></p><p><strong>4） 注意事项</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 映射hbase的列时，要么就写:key，要么不写，默认使用:key</span><br><span class="line">2. hbase中表存在的时候，在hive中创建表时应该使用external关键字。</span><br><span class="line">3. 如果删除了hbase中对应的表数据，那么hive中就不能查询出来数据。</span><br><span class="line">4. hbase中的列和hive中的列个数和数据类型应该尽量相同，hive表和hbase表的字段不是按照名字匹配，而是按照顺序来匹配的。</span><br><span class="line">5. hive、hbase和mysql等可以使用第三方工具来进行整合。</span><br></pre></td></tr></table></figure><h3 id="hbase与mr整合"><a href="#hbase与mr整合" class="headerlink" title="hbase与mr整合"></a>hbase与mr整合</h3><h4 id="pom-xml依赖"><a href="#pom-xml依赖" class="headerlink" title="pom.xml依赖"></a>pom.xml依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-common --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-hdfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.hbase/hbase-client --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.hbase/hbase-client --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Hbase-to-mr"><a href="#Hbase-to-mr" class="headerlink" title="Hbase-to-mr"></a>Hbase-to-mr</h3><p><strong>1） Mapper类的定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxd.hbase.hbase2mr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.Cell;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.CellScanner;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.CellUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Result;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableMapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Author</span> dante</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Company</span> dante's blog</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Description</span> </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 需求：使用mr查询hbase的数据    ns1:students</span></span><br><span class="line"><span class="comment"> * 1. 读取每一行</span></span><br><span class="line"><span class="comment"> * rk00002                         column=f1:age, timestamp=1589306416170, value=23</span></span><br><span class="line"><span class="comment"> * rk00002                         column=f1:gender, timestamp=1589306416170, value=f</span></span><br><span class="line"><span class="comment"> * rk00002                         column=f1:name, timestamp=1589306416170, value=zhenji</span></span><br><span class="line"><span class="comment"> * rk00003                         column=f1:age, timestamp=1589306416170, value=25</span></span><br><span class="line"><span class="comment"> * rk00003                         column=f1:gender, timestamp=1589306416170, value=m</span></span><br><span class="line"><span class="comment"> * rk00003                         column=f1:name, timestamp=1589306416170, value=zhaoyun</span></span><br><span class="line"><span class="comment"> * ..........</span></span><br><span class="line"><span class="comment"> * 2. 将hbase中的一行转成以下格式，使用mr输出到hdfs上</span></span><br><span class="line"><span class="comment"> *     age:23   gender:f    name:zhenji</span></span><br><span class="line"><span class="comment"> *     age:25   gender:m    name:zhaoyun</span></span><br><span class="line"><span class="comment"> *  ...............</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  编写模板：</span></span><br><span class="line"><span class="comment"> *      Mapper类型：</span></span><br><span class="line"><span class="comment"> *      Driver类型：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * org.apahce.hadoop.hbase.mapreduce.TableMapper&lt;KEYOUT，VALUEOUT&gt;</span></span><br><span class="line"><span class="comment"> * 说明：此类型是hbase和mr整合的一个Mapper端的类型，</span></span><br><span class="line"><span class="comment"> * 只有两个泛型需要提供，一个K2,一个V2，不需要提供k1和v1的泛型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在Map端的map函数中，我们只需要将hbase中的一行的所有的单元格拼接成想</span></span><br><span class="line"><span class="comment"> * 要的字符串，作为k2, NullWritable作为v2写到hdfs上即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hbase2HDFSMapper</span> <span class="keyword">extends</span> <span class="title">TableMapper</span>&lt;<span class="title">Text</span>, <span class="title">NullWritable</span>&gt; </span>&#123;</span><br><span class="line">    Text k2 = <span class="keyword">new</span> Text();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  是hbase中的一个行标识，就是rowkey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value是一行的所有的单元格的一个封装，即Result类型对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(ImmutableBytesWritable key, Result value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个StringBuilder类型，来拼接字符串</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//遍历value对象里的所有单元格</span></span><br><span class="line">        CellScanner cellScanner = value.cellScanner();</span><br><span class="line">        <span class="keyword">while</span>(cellScanner.advance())&#123;</span><br><span class="line">            Cell cell = cellScanner.current();</span><br><span class="line">            <span class="comment">//获取单元格的key和value</span></span><br><span class="line">            String _key = <span class="keyword">new</span> String(CellUtil.cloneQualifier(cell));</span><br><span class="line">            String _value = <span class="keyword">new</span> String(CellUtil.cloneValue(cell));</span><br><span class="line">            sb.append(_key+<span class="string">":"</span>+_value+<span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束后，age:23   gender:f    name:zhenji 单元格就拼接成功</span></span><br><span class="line">        k2.set(sb.toString());</span><br><span class="line">        context.write(k2,NullWritable.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2） Driver类的定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxd.hbase.hbase2mr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Scan;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.Tool;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.ToolRunner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Author</span> dante</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Company</span> dante's blog</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * mapreduce程序的驱动类，换一种写法。学习两个新类型</span></span><br><span class="line"><span class="comment"> * Tool接口里 有三个方法：</span></span><br><span class="line"><span class="comment"> *          - int run(String[] args) -----&gt;是一个任务体</span></span><br><span class="line"><span class="comment"> *          - setConf(Configuration conf)----&gt;绑定配置对象</span></span><br><span class="line"><span class="comment"> *          - getConf();    ----&gt;获取配置对象</span></span><br><span class="line"><span class="comment"> * ToolRunner类型 提供一个方法：</span></span><br><span class="line"><span class="comment"> *          -static run(Configuration conf,Tool tool,String[] args)&#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                 tool.run(args)</span></span><br><span class="line"><span class="comment"> *          &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hbase2HdfsDriver</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Configuration conf;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//编写job对象和绑定各种信息</span></span><br><span class="line"></span><br><span class="line">        Job job = Job.getInstance(conf,<span class="string">"hbase2mr"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 调用initTableMapperJob初始化job作业的各种信息</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 参数table:  指定要查询的hbase的表名</span></span><br><span class="line"><span class="comment">         * 参数scan：  hbase表的扫描器对象</span></span><br><span class="line"><span class="comment">         * 参数mapper: map端的用户自定义类型对象</span></span><br><span class="line"><span class="comment">         * 参数outputKeyClass： k2的类型</span></span><br><span class="line"><span class="comment">         * 参数outputValueClass：v2的类型</span></span><br><span class="line"><span class="comment">         * 参数job: job对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TableMapReduceUtil.initTableMapperJob(<span class="string">"ns1:students"</span>,<span class="keyword">new</span> Scan(),Hbase2HDFSMapper<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">Text</span>.<span class="title">class</span>, <span class="title">NullWritable</span>.<span class="title">class</span>,<span class="title">job</span>)</span>;</span><br><span class="line">        <span class="comment">// 4. 设置输出路径</span></span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(<span class="string">"/hbase2mr"</span>));</span><br><span class="line">        <span class="comment">// 5. 提交</span></span><br><span class="line">        <span class="keyword">boolean</span> b = job.waitForCompletion(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> b ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConf</span><span class="params">(Configuration conf)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//配置链接hbase的参数</span></span><br><span class="line">        conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"qianfeng01:2181,qianfeng02:2181,qianfeng03:2181"</span>);</span><br><span class="line">        <span class="comment">//配置连接hdfs的参数</span></span><br><span class="line">        conf.set(<span class="string">"fs.defaultFS"</span>,<span class="string">"hdfs://qianfeng01:8020"</span>);</span><br><span class="line">        <span class="comment">//设置mr的资源管理器</span></span><br><span class="line">        conf.set(<span class="string">"mapreduce.framework.name"</span>,<span class="string">"local"</span>);</span><br><span class="line">        <span class="keyword">this</span>.conf=conf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Configuration <span class="title">getConf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> conf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//会执行Hbase2HdfsDriver的run方法</span></span><br><span class="line">        ToolRunner.run(HBaseConfiguration.create(),<span class="keyword">new</span> Hbase2HdfsDriver(),args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）错误说明：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当在集群上运行jar包程序的时候：</span><br><span class="line"></span><br><span class="line">hadoop jar mytestHbase2Hdfs.jar com.zxd.hbase.TestHbaseMr.Hdfs2Hbase  &#x2F;mytestHbase2Hdfs1&#x2F;</span><br><span class="line"></span><br><span class="line">会出现异常：</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org&#x2F;apache&#x2F;hadoop&#x2F;hbase&#x2F;HBaseConfiguration</span><br><span class="line"></span><br><span class="line">原因:hadoop程序使用的HADOOP_CLASSPATH路径中没有hbase的jar包</span><br></pre></td></tr></table></figure><p><strong>4） 解决办法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 临时设置：</span><br><span class="line">export HADOOP_CLASSPATH&#x3D;$HADOOP_CLASSPATH:&#x2F;usr&#x2F;local&#x2F;hbase&#x2F;lib&#x2F;*</span><br><span class="line"></span><br><span class="line">2. 配置hadoop-env.sh：永久生效</span><br><span class="line">   export HADOOP_CLASSPATH&#x3D;$HADOOP_CLASSPATH:&#x2F;usr&#x2F;local&#x2F;hbase&#x2F;lib&#x2F;*</span><br><span class="line"></span><br><span class="line">3. 最暴力的方式：把hbase的lib的jar包，拷贝到hadoop的classpath中</span><br></pre></td></tr></table></figure><h3 id="MR-to-Hbase"><a href="#MR-to-Hbase" class="headerlink" title="MR-to-Hbase"></a>MR-to-Hbase</h3><p><strong>1） Mapper的定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxd.hbase.mr2hbase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Author</span> dante</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Company</span> dante's blog</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需求：统计每个年龄的人数</span></span><br><span class="line"><span class="comment"> * 数据如下：</span></span><br><span class="line"><span class="comment"> * age:15gender:女name:貂蝉</span></span><br><span class="line"><span class="comment"> * age:15gender:女name:王昭君</span></span><br><span class="line"><span class="comment"> * age:23gender:fname:zhenji</span></span><br><span class="line"><span class="comment"> * age:25gender:mname:zhaoyun</span></span><br><span class="line"><span class="comment"> * age:30gender:mname:liubei</span></span><br><span class="line"><span class="comment"> * age:30gender:mname:sunquan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果存储在hbase表： userAgeinfo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    rowkey</span></span><br><span class="line"><span class="comment"> *    age:15    column=f1:age       value = 15</span></span><br><span class="line"><span class="comment"> *    age:15    column=f1:count     value = 2</span></span><br><span class="line"><span class="comment"> *    age:23    column=f1:age       value = 23</span></span><br><span class="line"><span class="comment"> *    age:23    column=f1:count     value = 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hdfs2HbaseMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Text k = <span class="keyword">new</span> Text();</span><br><span class="line">    <span class="keyword">private</span> LongWritable v = <span class="keyword">new</span> LongWritable(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 解析进来的每一行记录</span></span><br><span class="line">        String line = value.toString();</span><br><span class="line">        String[] columns = line.split(<span class="string">"\t"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String column : columns) &#123;</span><br><span class="line">            <span class="comment">//查找有age的键值对</span></span><br><span class="line">            <span class="keyword">if</span> (column.contains(<span class="string">"age"</span>)) &#123;</span><br><span class="line">                <span class="comment">//解析成k2,v2，并写出。</span></span><br><span class="line">                String[] kv = column.split(<span class="string">":"</span>);</span><br><span class="line">                <span class="comment">//使用年龄的具体值充当k2,  那么相同年龄的行记录机会汇聚到一个reduce函数中</span></span><br><span class="line">                k.set(kv[<span class="number">1</span>]);</span><br><span class="line">                context.write(k, v);</span><br><span class="line">                <span class="comment">//打断当前行的循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2） Reducer的定义</strong>    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxd.hbase.mr2hbase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.io.ImmutableBytesWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableReducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> dante</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span> dante's blog</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hdfs2HbaseReducer</span> <span class="keyword">extends</span> <span class="title">TableReducer</span>&lt;<span class="title">Text</span>, <span class="title">LongWritable</span>, <span class="title">ImmutableBytesWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 相同的年龄汇聚到一起，输入到一个reduce函数中。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   k2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values    list&lt;v2&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;LongWritable&gt; values, Context context)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 计数器</span></span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2. 迭代</span></span><br><span class="line">        Iterator&lt;LongWritable&gt; iterator = values.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            LongWritable n = iterator.next();</span><br><span class="line">            count += n.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束后：   15    2    .....</span></span><br><span class="line">        <span class="comment">// 3. 输出一定要是hbase的对象，如put.   指定rowkey   "age:15"</span></span><br><span class="line">        Put put = <span class="keyword">new</span> Put(Bytes.toBytes(<span class="string">"age:"</span>+key.toString()));</span><br><span class="line">        <span class="comment">// 4. 将结果集写入put对象</span></span><br><span class="line">        put.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"age"</span>),</span><br><span class="line">                      Bytes.toBytes(key.toString()));</span><br><span class="line">        put.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"count"</span>),</span><br><span class="line">                      Bytes.toBytes(count + <span class="string">""</span>));</span><br><span class="line">        <span class="comment">// 5. 写</span></span><br><span class="line">        context.write(<span class="keyword">new</span> ImmutableBytesWritable(Bytes.toBytes(<span class="string">"age:"</span>+key.toString())), put);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3） Driver的定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxd.hbase.mr2hbase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zxd.hbase.util.HbaseUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HColumnDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HTableDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.TableName;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Admin;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.regionserver.BloomType;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.Tool;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.ToolRunner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> dante</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span> dante's blog</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 从hdfs读取数据 然后写到hbase 统计每个年龄的人数，并将结果存储到hbase中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hdfs2HbaseDriver</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建配置对象</span></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String HBASE_CONNECT_KEY = <span class="string">"hbase.zookeeper.quorum"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String HBASE_CONNECT_VALUE = <span class="string">"qianfeng01:2181,qianfeng02:2181,qianfeng03:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String HDFS_CONNECT_KEY = <span class="string">"fs.defaultFS"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String HDFS_CONNECT_VALUE = <span class="string">"hdfs://qianfeng01:8020"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String MAPREDUCE_CONNECT_KEY = <span class="string">"mapreduce.framework.name"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String MAPREDUCE_CONNECT_VALUE = <span class="string">"local"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Job job = Job.getInstance(configuration,<span class="string">"hdfs2hbase"</span>);</span><br><span class="line">        job.setJarByClass(Hdfs2HbaseDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        job.setMapperClass(Hdfs2HbaseMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(Hdfs2HbaseReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(LongWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 1.创建表</span></span><br><span class="line">        String tablename = <span class="string">"userAgeinfo"</span>;</span><br><span class="line">        createTable(tablename);</span><br><span class="line">        <span class="comment">// 2. 设置reduce向hbase输出</span></span><br><span class="line">        TableMapReduceUtil.initTableReducerJob(tablename, Hdfs2HbaseReducer<span class="class">.<span class="keyword">class</span>, <span class="title">job</span>)</span>;</span><br><span class="line">        <span class="comment">// 3. 设置输入路径</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(<span class="string">"/hbase2mr"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验表是否存在，如果不存在就创建，存在就先删除再创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTable</span><span class="params">(String tablename)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Admin admin = HbaseUtil.getAdmin();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isExist = admin.tableExists(TableName.valueOf(tablename));</span><br><span class="line">            <span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">                admin.disableTable(TableName.valueOf(tablename));</span><br><span class="line">                admin.deleteTable(TableName.valueOf(tablename));</span><br><span class="line">            &#125;</span><br><span class="line">            HTableDescriptor tableDescriptor = <span class="keyword">new</span> HTableDescriptor(TableName.valueOf(tablename));</span><br><span class="line">            HColumnDescriptor columnDescriptor1 = <span class="keyword">new</span> HColumnDescriptor(<span class="string">"f1"</span>);</span><br><span class="line">            columnDescriptor1.setBloomFilterType(BloomType.ROW);</span><br><span class="line">            columnDescriptor1.setVersions(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            tableDescriptor.addFamily(columnDescriptor1);</span><br><span class="line">            admin.createTable(tableDescriptor);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            HbaseUtil.closeAdmin(admin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConf</span><span class="params">(Configuration conf)</span> </span>&#123;</span><br><span class="line">        conf.set(HBASE_CONNECT_KEY, HBASE_CONNECT_VALUE); <span class="comment">// 设置连接的hbase</span></span><br><span class="line">        conf.set(HDFS_CONNECT_KEY, HDFS_CONNECT_VALUE); <span class="comment">// 设置连接的hadoop</span></span><br><span class="line">        conf.set(MAPREDUCE_CONNECT_KEY, MAPREDUCE_CONNECT_VALUE); <span class="comment">// 设置使用的mr运行平台</span></span><br><span class="line">        <span class="keyword">this</span>.configuration = conf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Configuration <span class="title">getConf</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ToolRunner.run(HBaseConfiguration.create(), <span class="keyword">new</span> Hdfs2HbaseDriver(), args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(六)HBASE的工作机制</title>
      <link href="/2023/02/16/Hbase-2023-02-16-%E5%85%AD-HBASE%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/02/16/Hbase-2023-02-16-%E5%85%AD-HBASE%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="寻址机制"><a href="#寻址机制" class="headerlink" title="寻址机制"></a>寻址机制</h2><p>我们应该知道读写操作都在 RegionServer 上发生，而每个 RegionSever 为一定数量的 Region 服务，那么 Client 要对某一行数据做读写访问时，是如何知道具体要去访问哪个 RegionServer 呢？那就是接下来我们要讨论的问题</p><p><strong>首先</strong>，我们要知道hbase:meta表的结构，有助于我们理解寻址过程。</p><p>meta表结构参考</p><p><img src="014-1588396368629.png" alt=""></p><hr><h3 id="新的寻址方式"><a href="#新的寻址方式" class="headerlink" title="新的寻址方式"></a>新的寻址方式</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">在0.96版本以后，hbase直接将meta表所在的regionsServer信息存储在zk中的/hbase/meta-region-server中，之后又引用了namespace的概念，因此，meta表改成了hbase</span>:<span class="string">meta。 </span></span><br><span class="line"></span><br><span class="line"><span class="attr">如下图所示：</span></span><br></pre></td></tr></table></figure><p><img src="102.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 访问过程分3步：</span></span></span><br><span class="line"></span><br><span class="line">第1步：Client请求ZooKeeper获取hbase:meta表所在的RegionServer的地址。</span><br><span class="line"></span><br><span class="line">第2步：Client 请求hbase:meta表所在的RegionServer获取访问数据所在的RegionServer地址，Client会将hbase:meta表的相关信息cache下来，以便下一次快速访问。</span><br><span class="line"></span><br><span class="line">第3步：Client请求数据所在的 RegionServer，获取所需要的数据。</span><br></pre></td></tr></table></figure><h3 id="老的寻址方式-参考"><a href="#老的寻址方式-参考" class="headerlink" title="老的寻址方式(参考)"></a>老的寻址方式(参考)</h3><p>在 0.96 版本以前，HBase 有两个特殊的表，分别是-ROOT-表和.META.表，其中-ROOT-的位置存储在ZooKeeper中，-ROOT-本身存储.META.表的 RegionInfo 信息，并且-ROOT不会分裂，只有一个 Region。而.META.表可以被切分成多个 Region。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">寻找流程：client -&gt;  -root-表  -&gt;  .meta.表  -&gt;  region</span><br><span class="line">也被称之为三层跳转。</span><br></pre></td></tr></table></figure><p>root表结构参考：</p><p><img src="013-1588396368629.png" alt=""></p><p>具体的寻址流程如下图所示：</p><p><img src="101.png" alt=""></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">第</span> <span class="string">1 步：Client 请求 ZooKeeper 获得-ROOT-所在的 RegionServer 地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">第</span> <span class="string">2 步：Client 请求-ROOT-所在的 RS 地址，获取.META.表的地址，Client 会将-ROOT-的相关 信息 cache 下来，以便下一次快速访问</span></span><br><span class="line"></span><br><span class="line"><span class="meta">第</span> <span class="string">3 步：Client 请求.META.表的 RegionServer 地址，获取访问数据所在 RegionServer 的地址， Client 会将.META.的相关信息 cache 下来，以便下一次快速访问</span></span><br><span class="line"></span><br><span class="line"><span class="meta">第</span> <span class="string">4 步：Client 请求访问数据所在 RegionServer 的地址，获取对应的数据</span></span><br></pre></td></tr></table></figure><p>从上面的路径我们可以看出，用户需要 3 次请求才能到达用户 Table 真正的位置(具体的region)，这在一定程度上，性能明显下降。在 0.96 之前使用 3 层设计的主要原因是考虑到元数据可能需要很大。但是真正集群运行，元数据的大小其实很容易计算出来。在 BigTable 的论文中，每行 METADATA 数据存储大小为 1KB 左右，如果按照一个 Region 为 128M 的计算，3 层设计可以支持的 Region 个数为 2^34 个，采用 2 层设计可以支持 2^17（131072）。那么 2 层设计的情 况下一个集群可以存储 4P 的数据。这仅仅是一个 Region 只有 128M 的情况下。如果是 10G 呢? 因此，通过计算，其实 2 层设计就可以满足集群的需求。因此在 0.96 版本以后就去掉 了-ROOT-表了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">总结去掉-ROOT-的原因有如下</span> <span class="string">2 点：</span></span><br><span class="line"><span class="attr">其一：提高性能</span></span><br><span class="line"><span class="meta">其二：2</span> <span class="string">层结构已经足以满足集群的需求</span></span><br><span class="line"></span><br><span class="line"><span class="meta">这里还有一个问题需要说明，那就是</span> <span class="string">Client 会缓存.META.的数据，用来加快访问，既然有缓存，那它什么时候更新？如果.META.更新了，比如 Region1 不在 RerverServer2 上了，被转移 到了 RerverServer3 上。Client 的缓存没有更新会有什么情况？</span></span><br><span class="line"><span class="meta">其实，Client</span> <span class="string">的元数据缓存不更新，当.META.的数据发生更新。如上面的例子，由于 Region1 的位置发生了变化，Client 再次根据缓存去访问的时候，会出现错误，当出现异常达到重试 次数后就会去.META.所在的 RegionServer 获取最新的数据，如果.META.所在的 RegionServer 也变了，Client 就会去 ZooKeeper 上获取.META.所在的 RegionServer 的最新地址。</span></span><br></pre></td></tr></table></figure><h2 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h2><h3 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h3><p><img src="010.png" alt=""></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.</span> <span class="string">数据的存储是每个Region所承担的工作了</span></span><br><span class="line"><span class="meta">1)</span> <span class="string">我们知道一个Region代表的是一张 Hbase表中特定Rowkey范围内的数据，</span></span><br><span class="line"><span class="meta">2)</span> <span class="string">而Hbase是面向列存储的数据库，所以在一个Region中，有多个文件来存储这些列。</span></span><br><span class="line"><span class="meta">3)</span> <span class="string">Hbase中数据列是由列簇来组织的，所以每一个列簇都会有对应的一个数据结构，</span></span><br><span class="line"><span class="meta">3.1)</span> <span class="string">Hbase将列簇的存储数据结构抽象为Store，一个Store代表一个列簇。</span></span><br><span class="line"><span class="attr">总结：所以在这里也可以看出为什么在我们查询的时候要尽量减少不需要的列，而经常一起查询的列要组织到一个列簇里：因为要需要查询的列簇越多，意味着要扫描越多的Store文件，这就需要越多的时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">2.</span> <span class="string">Store中存储数据的方式:Hbase采用的是LSM树的结构，这种结构的关键是:</span></span><br><span class="line"><span class="meta">1)</span> <span class="string">每一次的插入操作都会先进入MemStore（内存缓冲区），</span></span><br><span class="line"><span class="meta">2)</span> <span class="string">当 MemStore达到上限的时候，Hbase会将内存中的数据输出为有序的StoreFile文件数据（根据Rowkey、版本、列名排序，这里已经和列簇无关了因为Store里都属于同一个列簇）。</span></span><br><span class="line"><span class="meta">3)</span> <span class="string">这样会在Store中形成很多个小的StoreFile，当这些小的File数量达到一个阀值的时 候，Hbase会用一个线程来把这些小File合并成一个大的File。这样，Hbase就把效率低下的文件中的插入、移动操作转变成了单纯的文件输出、 合并操作。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">由上可知，在Hbase底层的Store数据结构中，</span></span><br><span class="line">    <span class="meta">1）</span> <span class="string">每个StoreFile内的数据是有序的，</span></span><br><span class="line">    <span class="meta">2）</span> <span class="string">但是StoreFile之间不一定是有序的，</span></span><br><span class="line">    <span class="meta">3）</span> <span class="string">Store只需要管理StoreFile的索引就可以了。</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">这里也可以看出为什么指定版本和Rowkey可以加强查询的效率，因为指定版本和Rowkey的查询可以利用</span> <span class="string">StoreFile的索引跳过一些肯定不包含目标数据的数据。</span></span><br></pre></td></tr></table></figure><p><img src="211.png" alt=""></p><h3 id="两种文件类型"><a href="#两种文件类型" class="headerlink" title="两种文件类型"></a>两种文件类型</h3><p>HBase中的所有数据文件都存储在Hadoop HDFS文件系统上，主要包括两种文件类型:</p><p><strong>1）HFile(storefile)</strong></p><p>HFile是HBase的数据存储的实际载体，从体系结构中我们也能看出，Hbase不直接与磁盘进行交互，而是通过调用HDFS的client接口，由HDFS进行存储的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网上资料上也有不少人管HFile叫storefile的，其实这么叫也是没有错的。HFile在Hadoop中是一种二进制格式文件，它模仿了BigTable中的SSTable格式(参考下图)。实际上StoreFile就是对HFile做了轻量级包装,进行数据的存储。Hbase是基于java编写得，那么所有物理上得东西，在java程序运行时，都有一个对象与之对应，在物理存储上我们管StoreFile刷写而成得文件叫HFile,StoreFile是HFile得抽象类而已。</span><br></pre></td></tr></table></figure><p><img src="20150821140814648.jpg" alt=""></p><p><strong>2）HLog File</strong></p><p>HBase中采用WAL(Write Ahead Log)的存储格式，物理上是Hadoop的SequenceFile。在写数据时会先往Hlog写一份，然后往内存写，以避免内存丢失数据，可以从日志文件中恢复Hlog记录数据的所有变更，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个HRegionServer维护一个HLog，而不是每个HRegion一个。这样不同region（来自不同table）的日志会混在一起，这样做的目的是不断追加单个文件相对于同时写多个文件而言，可以减少磁盘寻址次数，因此可以提高对table的写性能。带来的麻烦是，如果一台HRegionServer下线，为了恢复其上的region，需要将HRegionServer上的log进行拆分，然后分发到其它HRegionServer上进行恢复。</span><br></pre></td></tr></table></figure><h3 id="Flush与Compact、Split"><a href="#Flush与Compact、Split" class="headerlink" title="Flush与Compact、Split"></a>Flush与Compact、Split</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 1. Flush</span><br><span class="line">客户端的数据会写入内存，一直到MemStore满了或者达到其他flush条件时，会将MemStore中的数据Flush成</span><br><span class="line">一个StoreFile</span><br><span class="line">- 2. Compact</span><br><span class="line">当storefile的数量越来越多，增长到数量阈值时，会触发Compact合并操作多个StoreFile合并成一个</span><br><span class="line">StoreFile，同时进行版本合并和数据删除 </span><br><span class="line">- 3. Split</span><br><span class="line">由于合并操作，当单个StoreFile大小超过一定阈值后，这样会触发Region Split操作。实际上是新生成两个</span><br><span class="line">Region来管理维护旧的Region中的数据，旧的Region会下线，新的两个Region会被HMaster重新分配到相应</span><br><span class="line">的HRegionServer上，这样使得原先1个Region的压力得以分流到2个Region上。</span><br></pre></td></tr></table></figure><h3 id="增删改查的真正面目"><a href="#增删改查的真正面目" class="headerlink" title="增删改查的真正面目"></a>增删改查的真正面目</h3><p>Hbase是一个可以随机读写的数据，而它是基于HDFS的，HDFS的特点是只能新增，要么整个删除，不能修改。那么HDFS是如何实现我们的增删改查的呢。实际上Hbase几乎总是在做新增操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 新增单元格数据时，在HDFS上新增一条记录</span><br><span class="line">- 修改一个单元格时，也是新增一条记录，只是版本号比之前大了。</span><br><span class="line">- 删除时，还是新增一条记录，只不过没有value值，类型为DELETE。</span><br><span class="line"></span><br><span class="line">为了提高性能，Hbase每间隔一段时间或者文件大小达到阀值后，都会进行一次合并，合并的对象就是HFile文件。当合并成一个HFile时，会忽略掉DELETE类型的记录，从而达到了删除的目的，并对剩下的数据做排序和版本合并。形成一个大的HFile，当Hfile的大小达到需要切分的阀值时，会等分为两个HFile...</span><br></pre></td></tr></table></figure><h2 id="Region的管理"><a href="#Region的管理" class="headerlink" title="Region的管理"></a>Region的管理</h2><p>一张表的数据可能只有一个region，也可能有多个region。当一个region的数据越来越大时，regionserver会进行split策略，将一个region的数据，切分成两个region，这个旧的region会下线，两个新的region由hmaster来重新分配regionserver进行管理，尽可能的做到集群的负载均衡。</p><p>在管理region时，我们也可以通过建表的预分区和手动操作来进行管理region</p><h3 id="预分区"><a href="#预分区" class="headerlink" title="预分区"></a>预分区</h3><p>每一个region都维护着startRow与endRowKey，如果加入的数据符合某个region维护的rowKey范围，则该数据交给这个region维护。那么依照这个原则，我们可以将数据所要投放的分区提前大致的规划好，以提高HBase性能。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):050:0&gt; create 'mydb:emp13','base_info',SPLITS=&gt;['1000','2000','3000','4000']</span><br></pre></td></tr></table></figure><p><img src="20191128195121.jpg" alt=""></p><p>我们可以插入下面五条数据，就会进入不同的region里</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):050:0&gt;put 'mydb:emp13','0001','base_info:name','zhangsan'</span><br><span class="line">hbase(main):051:0&gt;put 'mydb:emp13','1001','base_info:name','lisi'</span><br><span class="line">hbase(main):052:0&gt;put 'mydb:emp13','2001','base_info:name','wangwu'</span><br><span class="line">hbase(main):053:0&gt;put 'mydb:emp13','3001','base_info:name','zhaoliu'</span><br><span class="line">hbase(main):054:0&gt;put 'mydb:emp13','4001','base_info:name','xiaoqi'</span><br><span class="line">hbase(main):050:0&gt;flush  'mydb:emp13'#手动flush到hdfs中</span><br><span class="line"></span><br><span class="line"><span class="keyword">flush</span>语法：</span><br><span class="line">hbase&gt; <span class="keyword">flush</span> <span class="string">'TABLENAME'</span></span><br><span class="line">hbase&gt; <span class="keyword">flush</span> <span class="string">'REGIONNAME'</span></span><br><span class="line">hbase&gt; <span class="keyword">flush</span> <span class="string">'ENCODED_REGIONNAME'</span></span><br></pre></td></tr></table></figure><h3 id="手动管理"><a href="#手动管理" class="headerlink" title="手动管理"></a>手动管理</h3><p>1)  切分region</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">split 'tableName'</span><br><span class="line">split 'namespace:tableName'</span><br><span class="line">split 'regionName' <span class="comment"># format: 'tableName,startKey,id'</span></span><br><span class="line">split 'tableName', 'splitKey'</span><br><span class="line">split 'regionName', 'splitKey'</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">hbase(main):064:0&gt; split 'mydb:emp13,4000,1574941694731.1952dc6f126caa2d82d6ebb09d27fd81.','5000'</span><br></pre></td></tr></table></figure><p>2)  合并region</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; merge_region 'ENCODED_REGIONNAME', 'ENCODED_REGIONNAME'</span><br><span class="line">hbase&gt; merge_region 'ENCODED_REGIONNAME', 'ENCODED_REGIONNAME', true</span><br></pre></td></tr></table></figure><h2 id="读写流程"><a href="#读写流程" class="headerlink" title="读写流程"></a>读写流程</h2><h3 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h3><p><img src="018.png" alt=""></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.</span> <span class="string">HBase使用memstore和storefile存储对表的更新。数据在更新时首先写入hlog和memstore，memstore中的数据是排序的，当memstore累计到一定的阀值时，就会创建一个新的memstore，并将老的memstore添加到flush队列，由单独的线程flush到磁盘上，成为一个storefile。与此同时，系统会在zookeeper中记录一个checkpoint，表示这个时刻之前的数据变更已经持久化了。当系统出现意外时，可能导致memstore中的数据丢失，此时使用hlog来恢复checkpoint之后的数据。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">2.</span> <span class="string">Storefile是只读的，一旦创建之后就不可修改。因此hbase的更新就是不断追加的操作。当一个store的storefile达到一定的阀值后，就会进行一次合并操作，将对同一个key的修改合并到一起，同时进行版本合并和数据删除，形成一个大的storefile。当storefile的大小达到一定的阀值后，又会对storefile进行切分操作，等分为两个storefile。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.</span> <span class="string">Hbase中只有增添数据，所有的更新和删除操作都是在后续的合并中进行的，使得用户的写操作只要进入内存就可以立刻返回，实现了hbase的高速存储。</span></span><br></pre></td></tr></table></figure><p>具体写流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1) Client通过Zookeeper的调度，向RegionServer发出写数据请求，在Region中写数据。</span><br><span class="line">(2) 数据被写入Region的MemStore，直到MemStore达到预设阈值。</span><br><span class="line">(3) MemStore中的数据被Flush成一个StoreFile。</span><br><span class="line">(4) 随着StoreFile文件的不断增多，当其数量增长到一定阈值后，触发Compact合并操作，将多个StoreFile合并成一个StoreFile，同时进行版本合并和数据删除。</span><br><span class="line">(5) StoreFiles通过不断的Compact合并操作，逐步形成越来越大的StoreFile。</span><br><span class="line">(6) 单个StoreFile大小超过一定阈值后，触发Split操作，把当前Region Split成2个新的Region。父Region会下线，新Split出的2个子Region会被HMaster分配到相应的RegionServer上，使得原先1个Region的压力得以分流到2个Region上。</span><br></pre></td></tr></table></figure><h3 id="读数据流程-HBase1-0之前"><a href="#读数据流程-HBase1-0之前" class="headerlink" title="读数据流程(HBase1.0之前)"></a>读数据流程(HBase1.0之前)</h3><p><img src="019.png" alt=""></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Hbase的所有region元数据被存储在.META表中，随着region的增多，.META表中的数据也会增大，并分裂成多个新的region。为了定位.META表中各个region的位置，把.META表中的所有region的元数据保存在-ROOT-表中(1.0之后转移到zk的master目录)，最后由zookeeper记录-ROOT-表的位置信息。所有的客户端访问数据之前，需要首先访问zookeeper获取-ROOT-的位置，然后访问-ROOT-表获得.META表的位置，最后根据.META表中的信息确定用户数据存放的位置。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">-ROOT-表永远不会被分割，它只有一个region，这样可以保证最多只需要三次跳转就可以定位任意一个region。为了加快访问速度，.META表的所有region全部保存在内存中。客户端会将查询过的位置信息缓存起来，且缓存不会主动失效。如果客户端根据缓存信息还访问不到数据，则询问相关.META表的region服务器，试图获取数据的位置，如果还是失败，则询问-ROOT-表相关的.META表在哪里。最后，如果前面的信息全部失效，则通过zookeeper重新定位region的信息。所以如果客户端上的缓存全部失效，则需要进行6次网络来定位，才能定位到正确的region。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">client--&gt;Zookeeper--&gt;-ROOT-表（master）--&gt;.META.表--&gt;RegionServer--&gt;Region--&gt;client</span> <span class="string"></span></span><br><span class="line"></span><br><span class="line">   <span class="meta">(1)</span> <span class="string">Client访问Zookeeper，查找-ROOT-表，获取.META.表信息。</span></span><br><span class="line">   <span class="meta">(2)</span> <span class="string">从.META.表查找，获取存放目标数据的Region信息，从而找到对应的RegionServer。</span></span><br><span class="line">   <span class="meta">(3)</span> <span class="string">通过RegionServer获取需要查找的数据。</span></span><br><span class="line">   <span class="meta">(4)</span> <span class="string">Regionserver的内存分为MemStore和BlockCache两部分，MemStore主要用于写数据，BlockCache主要用于读数据。读请求先到MemStore中查数据，然后在到BlockCache中查，最后再到StoreFile上读，并把读的结果放入BlockCache，</span></span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>(五)HBASE  API</title>
      <link href="/2023/02/16/Hbase-2023-02-16-%E4%BA%94-HBASE-API/"/>
      <url>/2023/02/16/Hbase-2023-02-16-%E4%BA%94-HBASE-API/</url>
      
        <content type="html"><![CDATA[<h2 id="Namespace-DDL"><a href="#Namespace-DDL" class="headerlink" title="Namespace-DDL"></a>Namespace-DDL</h2><h3 id="hbase的连接服务测试API"><a href="#hbase的连接服务测试API" class="headerlink" title="hbase的连接服务测试API"></a>hbase的连接服务测试API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1、获取配置对象</span></span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">        <span class="comment">// 2、配置zookeeper的参数</span></span><br><span class="line">        conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"qianfeng01:2181,qianfeng02:2181,qianfeng03:2181"</span>);</span><br><span class="line">        <span class="comment">// 3、获取连接对象</span></span><br><span class="line">        Connection connection = ConnectionFactory.createConnection(conf);</span><br><span class="line">        <span class="comment">// 4、获取一个DDL操作的hbase客户端Admin</span></span><br><span class="line">        Admin admin = connection.getAdmin();</span><br><span class="line">        <span class="comment">//5 、创建一个namespace的描述器</span></span><br><span class="line">        NamespaceDescriptor descriptor = NamespaceDescriptor.create(<span class="string">"ns3"</span>).build();</span><br><span class="line">        <span class="comment">//6. 客户端进行提交创建</span></span><br><span class="line">        admin.createNamespace(descriptor);</span><br><span class="line">        <span class="comment">//7. 关闭操作</span></span><br><span class="line">        connection.close();</span><br><span class="line">        admin.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HbaseUtil的工具类的封装"><a href="#HbaseUtil的工具类的封装" class="headerlink" title="HbaseUtil的工具类的封装"></a>HbaseUtil的工具类的封装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HbaseUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection conn;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、获取配置对象</span></span><br><span class="line">            Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">            <span class="comment">// 2、配置zookeeper的参数</span></span><br><span class="line">            conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"master:2181,slave1:2181,slave2:2181"</span>);</span><br><span class="line">            <span class="comment">// 3、获取连接对象</span></span><br><span class="line">            conn = ConnectionFactory.createConnection(conf);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 获取DDL操作的客户端Admin */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Admin <span class="title">getAdmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Admin admin = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            admin = conn.getAdmin();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> admin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 关闭客户端Admin */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeAdmin</span><span class="params">(Admin admin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (admin != <span class="keyword">null</span>) &#123;</span><br><span class="line">                admin.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写好Junit执行代码模板"><a href="#编写好Junit执行代码模板" class="headerlink" title="编写好Junit执行代码模板"></a>编写好Junit执行代码模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NamespaceHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Admin admin;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAdmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        admin = HbaseUtil.getAdmin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HbaseUtil.closeAdmin(admin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建namespace的API"><a href="#创建namespace的API" class="headerlink" title="创建namespace的API"></a>创建namespace的API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createNamespace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取namespace描述器对象</span></span><br><span class="line">        NamespaceDescriptor descriptor = NamespaceDescriptor.create(<span class="string">"ns2"</span>).build();</span><br><span class="line">        <span class="comment">//提交到hbase中，进行创建</span></span><br><span class="line">        admin.createNamespace(descriptor);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列出所有的namespace"><a href="#列出所有的namespace" class="headerlink" title="列出所有的namespace"></a>列出所有的namespace</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listNamespace</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//通过客户端，获取namespace的描述器数组</span></span><br><span class="line">    NamespaceDescriptor[] nss = admin.listNamespaceDescriptors();</span><br><span class="line">    <span class="keyword">for</span> (NamespaceDescriptor descriptor : nss) &#123;</span><br><span class="line">        <span class="comment">//遍历描述器进行打印名称</span></span><br><span class="line">        System.out.println(descriptor.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列出所有namespace中的表名"><a href="#列出所有namespace中的表名" class="headerlink" title="列出所有namespace中的表名"></a>列出所有namespace中的表名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listNamespaceTable</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//通过客户端，获取namespace的描述器数组</span></span><br><span class="line">    NamespaceDescriptor[] nss = admin.listNamespaceDescriptors();</span><br><span class="line">    <span class="keyword">for</span> (NamespaceDescriptor descriptor : nss) &#123;</span><br><span class="line">        System.out.println(<span class="string">"-------名称空间："</span> + descriptor.getName() + <span class="string">"-----------"</span>);</span><br><span class="line">        <span class="comment">//通过客户端，并指定namespace，来获取相应表描述器的数组，进行遍历</span></span><br><span class="line">        HTableDescriptor[] tss = admin</span><br><span class="line">            .listTableDescriptorsByNamespace(descriptor.getName());</span><br><span class="line">        <span class="keyword">for</span> (HTableDescriptor t : tss) &#123;</span><br><span class="line">            System.out.println(t.getTableName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listNamespaceTable1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过客户端，获取所有的TableName，进行遍历</span></span><br><span class="line">    TableName[] ts = admin.listTableNames();</span><br><span class="line">    <span class="keyword">for</span> (TableName t : ts) &#123;</span><br><span class="line">        System.out.println(t.getNameAsString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改namespace的属性信息"><a href="#修改namespace的属性信息" class="headerlink" title="修改namespace的属性信息"></a>修改namespace的属性信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alterNamespace</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取指定namespace的描述器</span></span><br><span class="line">    NamespaceDescriptor ns2 = admin.getNamespaceDescriptor(<span class="string">"ns2"</span>);</span><br><span class="line">    <span class="comment">//设置属性</span></span><br><span class="line">    ns2.setConfiguration(<span class="string">"author"</span>, <span class="string">"michael"</span>);</span><br><span class="line">    <span class="comment">//进行提交修改</span></span><br><span class="line">    admin.modifyNamespace(ns2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除namespace"><a href="#删除namespace" class="headerlink" title="删除namespace"></a>删除namespace</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNamespace</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//删除指定的namespace</span></span><br><span class="line">    admin.deleteNamespace(<span class="string">"ns2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Table-DDL"><a href="#Table-DDL" class="headerlink" title="Table-DDL"></a>Table-DDL</h2><h3 id="编写Junit执行代码模板"><a href="#编写Junit执行代码模板" class="headerlink" title="编写Junit执行代码模板"></a>编写Junit执行代码模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tablehandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Admin admin;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAdmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        admin = HbaseUtil.getAdmin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HbaseUtil.closeAdmin(admin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建一个table"><a href="#创建一个table" class="headerlink" title="创建一个table"></a>创建一个table</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTable</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取TableName对象，指定要创建的表名</span></span><br><span class="line">    TableName tableName = TableName.valueOf(<span class="string">"ns1:students"</span>);</span><br><span class="line">    <span class="comment">//新建一个表描述器</span></span><br><span class="line">    HTableDescriptor descriptor = <span class="keyword">new</span> HTableDescriptor(tableName);</span><br><span class="line">    <span class="comment">//新建一个列族描述器</span></span><br><span class="line">    HColumnDescriptor columnDescriptor = <span class="keyword">new</span> HColumnDescriptor(<span class="string">"f1"</span>);</span><br><span class="line">    <span class="comment">//设置列族的布隆过滤器为列类型</span></span><br><span class="line">    columnDescriptor.setBloomFilterType(BloomType.ROWCOL);</span><br><span class="line">    <span class="comment">//设置列族支持缓存</span></span><br><span class="line">    columnDescriptor.setInMemory(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//设置列族内的单元格支持3个版本</span></span><br><span class="line">    columnDescriptor.setVersions(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//设置列族的单元格过期时间为1天</span></span><br><span class="line">    columnDescriptor.setTimeToLive(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    <span class="comment">//将列族描述器添加到表描述器中, 可以添加多个列族描述器</span></span><br><span class="line">    descriptor.addFamily(columnDescriptor);</span><br><span class="line">    <span class="comment">//提交到Hbase，进行创建</span></span><br><span class="line">    admin.createTable(descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改table的列族属性信息"><a href="#修改table的列族属性信息" class="headerlink" title="修改table的列族属性信息"></a>修改table的列族属性信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alterTable2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//指定表名</span></span><br><span class="line">    TableName tableName = TableName.valueOf(<span class="string">"ns1:students"</span>);</span><br><span class="line">    <span class="comment">//获取表描述器</span></span><br><span class="line">    HTableDescriptor tableDescriptor = admin.getTableDescriptor(tableName);</span><br><span class="line">    <span class="comment">//获取指定的列族的描述器</span></span><br><span class="line">    HColumnDescriptor columnDescriptor =tableDescriptor.getFamily(Bytes.toBytes(<span class="string">"f1"</span>));</span><br><span class="line">    <span class="comment">//修改属性</span></span><br><span class="line">    columnDescriptor.setBloomFilterType(BloomType.ROWCOL);</span><br><span class="line">    columnDescriptor.setVersions(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    columnDescriptor.setTimeToLive(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>); </span><br><span class="line">    <span class="comment">//提交到Hbase</span></span><br><span class="line">    admin.modifyColumn(tableName, columnDescriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向table中添加新的列族"><a href="#向table中添加新的列族" class="headerlink" title="向table中添加新的列族"></a>向table中添加新的列族</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alterTable2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    TableName tableName = TableName.valueOf(<span class="string">"ns1:students"</span>);</span><br><span class="line">    HColumnDescriptor columnDescriptor = <span class="keyword">new</span> HColumnDescriptor(<span class="string">"f2"</span>);</span><br><span class="line">    columnDescriptor.setBloomFilterType(BloomType.ROWCOL);</span><br><span class="line">    columnDescriptor.setVersions(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    columnDescriptor.setTimeToLive(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>); <span class="comment">// 秒为单位</span></span><br><span class="line">    admin.addColumn(tableName, columnDescriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取table的描述信息"><a href="#获取table的描述信息" class="headerlink" title="获取table的描述信息"></a>获取table的描述信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describeTable</span><span class="params">()</span> <span class="keyword">throws</span> IOException, Exception </span>&#123;</span><br><span class="line">    TableName tableName = TableName.valueOf(<span class="string">"ns1:students"</span>);</span><br><span class="line">    HTableDescriptor descriptor =admin.getTableDescriptor(tableName);</span><br><span class="line">    HColumnDescriptor[] hcs = descriptor.getColumnFamilies();</span><br><span class="line">    <span class="keyword">for</span>(HColumnDescriptor hc:hcs) &#123;</span><br><span class="line">        System.out.print(<span class="string">"NAME=&gt;"</span>+hc.getNameAsString()+<span class="string">"\t"</span>);</span><br><span class="line">        System.out.print(<span class="string">"BLOOMFILTER=&gt;"</span>+hc.getBloomFilterType()+<span class="string">"\t"</span>);</span><br><span class="line">        System.out.print(<span class="string">"VERSIONS=&gt;"</span>+hc.getMaxVersions()+<span class="string">"\t"</span>);</span><br><span class="line">        System.out.print(<span class="string">"TTL=&gt;"</span>+hc.getTimeToLive()+<span class="string">"\t"</span>);</span><br><span class="line">        System.out.println(<span class="string">"BLOCKSIZE=&gt;"</span>+hc.getBlocksize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除table"><a href="#删除table" class="headerlink" title="删除table"></a>删除table</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dropTable</span><span class="params">()</span> <span class="keyword">throws</span> TableNotFoundException, IOException </span>&#123;</span><br><span class="line">    TableName tableName = TableName.valueOf(<span class="string">"ns1:students"</span>);</span><br><span class="line">    <span class="keyword">if</span> (admin.tableExists(tableName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!admin.isTableDisabled(tableName)) &#123;</span><br><span class="line">            admin.disableTable(tableName);</span><br><span class="line">        &#125;</span><br><span class="line">        admin.deleteTable(tableName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Table-CRUD-DML-DQL"><a href="#Table-CRUD-DML-DQL" class="headerlink" title="Table-CRUD(DML+DQL)"></a>Table-CRUD(DML+DQL)</h2><h3 id="修改HbaseUtil工具类型"><a href="#修改HbaseUtil工具类型" class="headerlink" title="修改HbaseUtil工具类型"></a>修改HbaseUtil工具类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HbaseUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection conn;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">            conf.set(<span class="string">"hbase.zookeeper.quorum"</span>, <span class="string">"master:2181,slave1:2181,slave2:2181"</span>);</span><br><span class="line">            conn = ConnectionFactory.createConnection(conf);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Admin <span class="title">getAdmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeAdmin</span><span class="params">(Admin admin)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 获取Table对象的方法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Table <span class="title">getTable</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Table table = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将表名转成TableName对象</span></span><br><span class="line">            TableName tableName = TableName.valueOf(name);</span><br><span class="line">            <span class="comment">// 通过连接对象，获取Table对象</span></span><br><span class="line">            table = conn.getTable(tableName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**  关闭表对象 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeTable</span><span class="params">(Table table)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (table != <span class="keyword">null</span>) &#123;</span><br><span class="line">                table.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写Junit执行代码模板-1"><a href="#编写Junit执行代码模板-1" class="headerlink" title="编写Junit执行代码模板"></a>编写Junit执行代码模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableCRUDandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Table table;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAdmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        table = HbaseUtil.getTable(<span class="string">"ns1:students"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HbaseUtil.closeTable(table);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向table中添加数据：put"><a href="#向table中添加数据：put" class="headerlink" title="向table中添加数据：put"></a>向table中添加数据：put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取Put对象,指定rowkey</span></span><br><span class="line">    Put put = <span class="keyword">new</span> Put(Bytes.toBytes(<span class="string">"rk00001"</span>));</span><br><span class="line">    <span class="comment">//2. 指定列族名，列名，列值</span></span><br><span class="line">    put.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"name"</span>), Bytes.toBytes(<span class="string">"zhangfei"</span>));</span><br><span class="line">    put.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"age"</span>), Bytes.toBytes(<span class="string">"15"</span>));</span><br><span class="line">    put.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"gender"</span>), Bytes.toBytes(<span class="string">"m"</span>));</span><br><span class="line">    <span class="comment">//3. 提交</span></span><br><span class="line">    table.put(put);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量增加数据："><a href="#批量增加数据：" class="headerlink" title="批量增加数据："></a>批量增加数据：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putData2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    List&lt;Put&gt; list = <span class="keyword">new</span> ArrayList&lt;Put&gt;();</span><br><span class="line">    </span><br><span class="line">    Put put1 = <span class="keyword">new</span> Put(Bytes.toBytes(<span class="string">"rk00002"</span>));</span><br><span class="line">    put1.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"name"</span>), Bytes.toBytes(<span class="string">"zhenji"</span>));</span><br><span class="line">    put1.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"age"</span>), Bytes.toBytes(<span class="string">"23"</span>));</span><br><span class="line">    put1.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"gender"</span>), Bytes.toBytes(<span class="string">"f"</span>));</span><br><span class="line"></span><br><span class="line">    Put put2 = <span class="keyword">new</span> Put(Bytes.toBytes(<span class="string">"rk00003"</span>));</span><br><span class="line">    put2.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"name"</span>), Bytes.toBytes(<span class="string">"zhaoyun"</span>));</span><br><span class="line">    put2.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"age"</span>), Bytes.toBytes(<span class="string">"25"</span>));</span><br><span class="line">    put2.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"gender"</span>), Bytes.toBytes(<span class="string">"m"</span>));</span><br><span class="line"></span><br><span class="line">    Put put3 = <span class="keyword">new</span> Put(Bytes.toBytes(<span class="string">"rk00004"</span>));</span><br><span class="line">    put3.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"name"</span>), Bytes.toBytes(<span class="string">"liubei"</span>));</span><br><span class="line">    put3.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"age"</span>), Bytes.toBytes(<span class="string">"30"</span>));</span><br><span class="line">    put3.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"gender"</span>), Bytes.toBytes(<span class="string">"m"</span>));</span><br><span class="line"></span><br><span class="line">    list.add(put1);</span><br><span class="line">    list.add(put2);</span><br><span class="line">    list.add(put3);</span><br><span class="line">    table.put(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取指定rowkey的所有列族信息"><a href="#获取指定rowkey的所有列族信息" class="headerlink" title="获取指定rowkey的所有列族信息"></a>获取指定rowkey的所有列族信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//指定rowkey，获取get对象</span></span><br><span class="line">    Get get = <span class="keyword">new</span> Get(Bytes.toBytes(<span class="string">"rk00001"</span>));</span><br><span class="line">    <span class="comment">//调用get方法，获取结果集</span></span><br><span class="line">    Result result = table.get(get);</span><br><span class="line">    <span class="comment">//获取结果集的扫描器，即迭代器</span></span><br><span class="line">    CellScanner sc = result.cellScanner();</span><br><span class="line">    <span class="keyword">while</span> (sc.advance()) &#123;</span><br><span class="line">        <span class="comment">//取出当前单元格对象</span></span><br><span class="line">        Cell cell = sc.current();</span><br><span class="line">        <span class="comment">//使用克隆的方式，打印出来</span></span><br><span class="line">        System.out.print(<span class="keyword">new</span> String(CellUtil.cloneRow(cell))+<span class="string">"\t"</span>);</span><br><span class="line">        System.out.print(<span class="keyword">new</span> String(CellUtil.cloneFamily(cell), <span class="string">"utf8"</span>) + <span class="string">"\t"</span>);</span><br><span class="line">        System.out.print(<span class="keyword">new</span> String(CellUtil.cloneQualifier(cell), <span class="string">"utf8"</span>) + <span class="string">"\t"</span>);</span><br><span class="line">        System.out.print(<span class="keyword">new</span> String(CellUtil.cloneValue(cell), <span class="string">"utf8"</span>)+ <span class="string">"\t"</span>);</span><br><span class="line">        System.out.println(CellUtil.getCellKeyAsString(cell));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改HbaseUtil工具类：将打印单元格的内容进行封装"><a href="#修改HbaseUtil工具类：将打印单元格的内容进行封装" class="headerlink" title="修改HbaseUtil工具类：将打印单元格的内容进行封装"></a>修改HbaseUtil工具类：将打印单元格的内容进行封装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printResult</span><span class="params">(Result rs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    CellScanner sc = rs.cellScanner();</span><br><span class="line">    <span class="keyword">while</span> (sc.advance()) &#123;</span><br><span class="line">        Cell cell = sc.current();</span><br><span class="line">        System.out.print(<span class="keyword">new</span> String(CellUtil.cloneRow(cell)) + <span class="string">"\t"</span>);</span><br><span class="line">        System.out.print(<span class="keyword">new</span> String(CellUtil.cloneFamily(cell), <span class="string">"utf8"</span>) + <span class="string">"\t"</span>);</span><br><span class="line">        System.out.print(<span class="keyword">new</span> String(CellUtil.cloneQualifier(cell), <span class="string">"utf8"</span>) + <span class="string">"\t"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(CellUtil.cloneValue(cell), <span class="string">"utf8"</span>) + <span class="string">"\t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取多行的所有列族信息"><a href="#获取多行的所有列族信息" class="headerlink" title="获取多行的所有列族信息"></a>获取多行的所有列族信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MultigetData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    List&lt;Get&gt; gets = <span class="keyword">new</span> ArrayList&lt;Get&gt;();</span><br><span class="line">    Get get1 = <span class="keyword">new</span> Get(Bytes.toBytes(<span class="string">"rk00001"</span>));</span><br><span class="line">    Get get2 = <span class="keyword">new</span> Get(Bytes.toBytes(<span class="string">"rk00002"</span>));</span><br><span class="line">    Get get3 = <span class="keyword">new</span> Get(Bytes.toBytes(<span class="string">"rk00003"</span>));</span><br><span class="line">    Get get4 = <span class="keyword">new</span> Get(Bytes.toBytes(<span class="string">"rk00004"</span>));</span><br><span class="line">    gets.add(get1);</span><br><span class="line">    gets.add(get2);</span><br><span class="line">    gets.add(get3);</span><br><span class="line">    gets.add(get4);</span><br><span class="line">    <span class="comment">//获取多行的结果集</span></span><br><span class="line">    Result[] result = table.get(gets);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">        HbaseUtil.printResult(result[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用scan对表进行扫描"><a href="#使用scan对表进行扫描" class="headerlink" title="使用scan对表进行扫描"></a>使用scan对表进行扫描</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//获取Scan对象，指定扫描范围：开始行号和结束行号。小技巧\000</span></span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan(Bytes.toBytes(<span class="string">"rk00001"</span>), Bytes.toBytes(<span class="string">"rk00003"</span> + <span class="string">"\001"</span>));</span><br><span class="line">    ResultScanner rScanner = table.getScanner(scan);</span><br><span class="line">    Iterator&lt;Result&gt; iterable = rScanner.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterable.hasNext()) &#123;</span><br><span class="line">        Result result = iterable.next();</span><br><span class="line">        HbaseUtil.printResult(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除指定行"><a href="#删除指定行" class="headerlink" title="删除指定行"></a>删除指定行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Delete delete = <span class="keyword">new</span> Delete(Bytes.toBytes(<span class="string">"rk00001"</span>));</span><br><span class="line">    table.delete(delete);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除指定单元格"><a href="#删除指定单元格" class="headerlink" title="删除指定单元格"></a>删除指定单元格</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteDataC</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Delete delete = <span class="keyword">new</span> Delete(Bytes.toBytes(<span class="string">"rk000003"</span>));</span><br><span class="line">    delete.addColumn(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"age"</span>));</span><br><span class="line">    table.delete(delete);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-11-批量删除"><a href="#5-3-11-批量删除" class="headerlink" title="5.3.11 批量删除"></a>5.3.11 批量删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MultideleteData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;Delete&gt; list = <span class="keyword">new</span> ArrayList&lt;Delete&gt;();</span><br><span class="line">    Delete delete1 = <span class="keyword">new</span> Delete(Bytes.toBytes(<span class="string">"rk00001"</span>));</span><br><span class="line">    Delete delete2 = <span class="keyword">new</span> Delete(Bytes.toBytes(<span class="string">"rk000010"</span>));</span><br><span class="line">    Delete delete3 = <span class="keyword">new</span> Delete(Bytes.toBytes(<span class="string">"rk000011"</span>));</span><br><span class="line">    Delete delete4 = <span class="keyword">new</span> Delete(Bytes.toBytes(<span class="string">"rk000012"</span>));</span><br><span class="line">    list.add(delete1);</span><br><span class="line">    list.add(delete2);</span><br><span class="line">    list.add(delete3);</span><br><span class="line">    list.add(delete4);</span><br><span class="line"></span><br><span class="line">    table.delete(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HBASE-过滤器（重要）"><a href="#HBASE-过滤器（重要）" class="headerlink" title="HBASE 过滤器（重要）"></a>HBASE 过滤器（重要）</h2><h3 id="结构过滤器：FilterList"><a href="#结构过滤器：FilterList" class="headerlink" title="结构过滤器：FilterList"></a>结构过滤器：FilterList</h3><p>1) 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个结构过滤器，指定满足所有条件 MUST_PASS_ALL/ MUST_PASS_ONE</span></span><br><span class="line">    FilterList list = <span class="keyword">new</span> FilterList(FilterList.Operator.MUST_PASS_ALL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用单列过滤器进行设置条件, 比较关系：CompareOp.EQUAL ,CompareOp.GREATER_OR_EQUAL</span></span><br><span class="line">    SingleColumnValueFilter nameFilter = <span class="keyword">new</span> SingleColumnValueFilter(</span><br><span class="line">        Bytes.toBytes(<span class="string">"f1"</span>),</span><br><span class="line">        Bytes.toBytes(<span class="string">"name"</span>),CompareOp.EQUAL,Bytes.toBytes(<span class="string">"zhaoyun"</span>));</span><br><span class="line">    SingleColumnValueFilter ageFilter = <span class="keyword">new</span> SingleColumnValueFilter(</span><br><span class="line">        Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"age"</span>),CompareOp.EQUAL, Bytes.toBytes(<span class="string">"25"</span>));</span><br><span class="line">    <span class="comment">/* 设置不满组条件的过滤掉，因为：如果某一行中，没有指定的字段，表示满足条件。</span></span><br><span class="line"><span class="comment">    可以设置缺失字段，进行过滤*/</span></span><br><span class="line">    nameFilter.setFilterIfMissing(<span class="keyword">true</span>);</span><br><span class="line">    ageFilter.setFilterIfMissing(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 将单列过滤器添加到结构过滤器上</span></span><br><span class="line">    list.addFilter(nameFilter);</span><br><span class="line">    list.addFilter(ageFilter);</span><br><span class="line">    <span class="comment">// 获取浏览对象，</span></span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">    <span class="comment">// 添加过滤条件</span></span><br><span class="line">    scan.setFilter(list);</span><br><span class="line">    ResultScanner rScanner = table.getScanner(scan);</span><br><span class="line">    Iterator&lt;Result&gt; it = rScanner.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Result result = it.next();</span><br><span class="line">        HbaseUtil.printResult(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 遍历到某一行键时，如果包含了两个列，age和name，就会对比值，不满足条件就将其过滤，满足条件就获取。</span><br><span class="line">- 如果包含其中一个列，name或者age，只要其中一个列满足条件就会，就会获取。</span><br><span class="line">- 如果name和age都没有，那么视为该行满足条件</span><br></pre></td></tr></table></figure><p>3) 解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在某个单值过滤器总添加</span><br><span class="line">ageFilter.setFilterIfMissing(true);</span><br><span class="line">nameFilter.setFilterIfMissing(true);</span><br></pre></td></tr></table></figure><h3 id="单列过滤器"><a href="#单列过滤器" class="headerlink" title="单列过滤器"></a>单列过滤器</h3><p>1) 先修改HbaseUtil工具类，将扫描结果集对象的打印行为，封装到HbaseUtil工具类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printResultScanner</span><span class="params">(ResultScanner rScanner)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Iterator&lt;Result&gt; iterator = rScanner.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Result rs = iterator.next();</span><br><span class="line">        HbaseUtil.printResult(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) <strong>SingleColumnValueFilter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSingleColumnValueFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SingleColumnValueFilter filter = <span class="keyword">new</span> </span><br><span class="line">        SingleColumnValueFilter(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"age"</span>),</span><br><span class="line">                                CompareFilter.CompareOp.GREATER_OR_EQUAL, </span><br><span class="line">                                Bytes.toBytes(<span class="string">"16"</span>));</span><br><span class="line">    filter.setFilterIfMissing(<span class="keyword">true</span>);</span><br><span class="line">    testScan(filter); <span class="comment">//调用扫描行为</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将扫描行为再次封装。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testScan</span><span class="params">(Filter filter)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">    scan.setFilter(filter);</span><br><span class="line">    ResultScanner rScanner = table.getScanner(scan);</span><br><span class="line">    HbaseUtil.printResultScanner(rScanner);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列值比较器"><a href="#列值比较器" class="headerlink" title="列值比较器"></a>列值比较器</h3><p>1) <strong>RegexStringComparator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRegex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//正则表达式比较器</span></span><br><span class="line">    RegexStringComparator comp = <span class="keyword">new</span> RegexStringComparator(<span class="string">"^zhao"</span>);</span><br><span class="line">    SingleColumnValueFilter nameFilter = <span class="keyword">new</span></span><br><span class="line">        SingleColumnValueFilter(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"name"</span>),</span><br><span class="line">                                CompareFilter.CompareOp.EQUAL, comp);</span><br><span class="line">    nameFilter.setFilterIfMissing(<span class="keyword">true</span>);</span><br><span class="line">    testScan(nameFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) <strong>SubstringComparator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSubstringComparator</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//子串比较器， 在构造器里给一个字符串，如果这个字符串是另外一个字符串的子串，就满足条件</span></span><br><span class="line">    SubstringComparator comp = <span class="keyword">new</span> SubstringComparator(<span class="string">"zh"</span>);</span><br><span class="line">    SingleColumnValueFilter nameFilter = <span class="keyword">new</span></span><br><span class="line">        SingleColumnValueFilter(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"name"</span>),</span><br><span class="line">                                CompareFilter.CompareOp.EQUAL, comp);</span><br><span class="line">    nameFilter.setFilterIfMissing(<span class="keyword">true</span>);</span><br><span class="line">    testScan(nameFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3) <strong>BinaryPrefixComparator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBinaryPrefixComparator</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//二进制前缀比较器</span></span><br><span class="line">    BinaryPrefixComparator comp = <span class="keyword">new</span> BinaryPrefixComparator(Bytes.toBytes(<span class="string">"zh"</span>));</span><br><span class="line">    SingleColumnValueFilter nameFilter = <span class="keyword">new</span></span><br><span class="line">        SingleColumnValueFilter(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"name"</span>),</span><br><span class="line">                                CompareFilter.CompareOp.EQUAL, comp);</span><br><span class="line">    nameFilter.setFilterIfMissing(<span class="keyword">true</span>);</span><br><span class="line">    testScan(nameFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4) <strong>BinaryComparator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBinaryComparator</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//二进制比较器，</span></span><br><span class="line">    BinaryComparator comp = <span class="keyword">new</span> BinaryComparator(Bytes.toBytes(<span class="string">"xiaoniu"</span>));</span><br><span class="line">    <span class="comment">//如果使用二进制比较器，匹配的是字段的整个值的二进制进行比较，不是模糊匹配。是全匹配</span></span><br><span class="line">    SingleColumnValueFilter nameFilter = <span class="keyword">new</span></span><br><span class="line">        SingleColumnValueFilter(Bytes.toBytes(<span class="string">"f1"</span>), Bytes.toBytes(<span class="string">"name"</span>),</span><br><span class="line">                                CompareFilter.CompareOp.EQUAL, comp);</span><br><span class="line">    nameFilter.setFilterIfMissing(<span class="keyword">true</span>);</span><br><span class="line">    testScan(nameFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KeyValue元数据过滤器"><a href="#KeyValue元数据过滤器" class="headerlink" title="KeyValue元数据过滤器"></a>KeyValue元数据过滤器</h3><p>1) <strong>FamilyFilter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列族过滤器，查询指定列族下的所有单元格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFamily</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//RegexStringComparator comp = new RegexStringComparator("f1");</span></span><br><span class="line">    <span class="comment">//SubstringComparator comp = new SubstringComparator("f1");</span></span><br><span class="line">    <span class="comment">//BinaryPrefixComparator comp = new BinaryPrefixComparator(Bytes.toBytes("f1"));</span></span><br><span class="line">    BinaryComparator comp = <span class="keyword">new</span> BinaryComparator(Bytes.toBytes(<span class="string">"f2"</span>));</span><br><span class="line">    FamilyFilter filter = <span class="keyword">new</span> FamilyFilter(CompareFilter.CompareOp.EQUAL, comp);</span><br><span class="line">    testScan(filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2)  <strong>QualifierFilter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * QualifierFilter过滤器是用来查询符合条件的单元格数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQualifierFilter1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SubstringComparator substringComparator = <span class="keyword">new</span> SubstringComparator(<span class="string">"na"</span>);</span><br><span class="line">    QualifierFilter qualifierFilter = <span class="keyword">new</span> QualifierFilter(</span><br><span class="line">        CompareFilter.CompareOp.EQUAL, substringComparator);</span><br><span class="line">    testScan(qualifierFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3)  <strong>ColumnPrefixFilter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列名前缀过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testColumnPrefixFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建ColumnPrefixFilter</span></span><br><span class="line">    ColumnPrefixFilter columnPrefixFilter = <span class="keyword">new</span> ColumnPrefixFilter(Bytes.toBytes(<span class="string">"a"</span>));</span><br><span class="line">    <span class="comment">// 2. 打印</span></span><br><span class="line">    testScan(columnPrefixFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4)  <strong>MultipleColumnPrefixFilter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMultipleColumnPrefixFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建ColumnPrefixFilter</span></span><br><span class="line">    <span class="keyword">byte</span>[][] prefixes = <span class="keyword">new</span> <span class="keyword">byte</span>[][] &#123; Bytes.toBytes(<span class="string">"a"</span>), Bytes.toBytes(<span class="string">"n"</span>) &#125;;</span><br><span class="line">    MultipleColumnPrefixFilter multipleColumnPrefixFilter = <span class="keyword">new</span></span><br><span class="line">        MultipleColumnPrefixFilter(prefixes);</span><br><span class="line">    testScan(multipleColumnPrefixFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5)  <strong>ColumnRangeFilter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找以"age"到"name"的列的信息</span></span><br><span class="line"><span class="comment">     *  minColumnInclusive:true为包含，false为不包含</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testColumnRangeFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建ColumnPrefixFilter</span></span><br><span class="line">    ColumnRangeFilter columnRangeFilter = <span class="keyword">new</span> ColumnRangeFilter(</span><br><span class="line">        Bytes.toBytes(<span class="string">"age"</span>), <span class="keyword">true</span>, Bytes.toBytes(<span class="string">"name"</span>),<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 2. 打印</span></span><br><span class="line">    testScan(columnRangeFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RowKey过滤器"><a href="#RowKey过滤器" class="headerlink" title="RowKey过滤器"></a>RowKey过滤器</h3><p>1）<strong>RowFilter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRowFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建RowFilter</span></span><br><span class="line">    BinaryComparator binaryComparator = <span class="keyword">new</span> BinaryComparator(Bytes.toBytes(<span class="string">"rk00002"</span>));</span><br><span class="line">    RowFilter rowFilter = <span class="keyword">new</span> RowFilter(CompareFilter.CompareOp.EQUAL, binaryComparator);</span><br><span class="line">    testScan(rowFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Utility过滤器"><a href="#Utility过滤器" class="headerlink" title="Utility过滤器"></a>Utility过滤器</h3><p>1)   <strong>FirstKeyOnlyFilter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FirstKeyOnlyFilter</span></span><br><span class="line"><span class="comment">     * 功能：查询行内的所有单元格进行排序的第一个单元格的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFirstKeyOnlyFilter</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FirstKeyOnlyFilter firstKeyOnlyFilter = <span class="keyword">new</span> FirstKeyOnlyFilter();</span><br><span class="line">    <span class="comment">// 2. 打印</span></span><br><span class="line">    testScan(firstKeyOnlyFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分页过滤器"><a href="#分页过滤器" class="headerlink" title="分页过滤器"></a>分页过滤器</h3><p>1)  <strong>PageFilter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 需求：每页显示3条记录</span></span><br><span class="line"><span class="comment">  * 将全部的数据分页显示出来</span></span><br><span class="line"><span class="comment">  * 思路：</span></span><br><span class="line"><span class="comment">  * 1. 第一页：</span></span><br><span class="line"><span class="comment">  * select * from user_info where rowkey &gt; \001 limit 3;</span></span><br><span class="line"><span class="comment">  * 2. 其他页</span></span><br><span class="line"><span class="comment">  * select * from user_info where rowkey &gt; 前一页的maxrowkey limit 3;</span></span><br><span class="line"><span class="comment">  * 3. 循环什么时候结束？</span></span><br><span class="line"><span class="comment">  * while(true) &#123;</span></span><br><span class="line"><span class="comment">  * select * from user_info where rowkey &gt; 前一页的maxrowkey limit 3;</span></span><br><span class="line"><span class="comment">  * print 3行数据</span></span><br><span class="line"><span class="comment">  * 结束条件：count&lt;3</span></span><br><span class="line"><span class="comment">  * &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPageFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PageFilter filter = <span class="keyword">new</span> PageFilter(<span class="number">3</span>);</span><br><span class="line">    Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line">    scan.setFilter(filter);</span><br><span class="line">    String maxkey = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每三页一查询</span></span><br><span class="line">        ResultScanner rScanner = table.getScanner(scan);</span><br><span class="line">        Iterator&lt;Result&gt; iterator = rScanner.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Result result = iterator.next();</span><br><span class="line">            count++;<span class="comment">//统计打印次数</span></span><br><span class="line">            maxkey = Bytes.toString(result.getRow());</span><br><span class="line">            HbaseUtil.printResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//如果不足三页，结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为下一页的查询做准备，下一页的开始rowkey要大于当前页的最后一行的rowkey</span></span><br><span class="line">        scan.setStartRow(Bytes.toBytes(maxkey + <span class="string">"\001"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(四)HBASE SHELL</title>
      <link href="/2023/02/16/Hbase-2023-02-16-%E5%9B%9B-HBASE-SHELL/"/>
      <url>/2023/02/16/Hbase-2023-02-16-%E5%9B%9B-HBASE-SHELL/</url>
      
        <content type="html"><![CDATA[<p>提示：可以查看命令组，或者是命令的帮助信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):000:0&gt; help</span><br><span class="line">hbase(main):000:0&gt; help 'command group'</span><br><span class="line">hbase(main):000:0&gt; help 'command'</span><br></pre></td></tr></table></figure><h2 id="Namespace操作"><a href="#Namespace操作" class="headerlink" title="Namespace操作"></a>Namespace操作</h2><p><strong>1）</strong> list_namespace:查询所有命名空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):020:0&gt; list_namespace</span><br></pre></td></tr></table></figure><p><strong>2）</strong> list_namespace_tables: 查询指定命名空间的表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):022:0&gt; list_namespace_tables 'myns'</span><br></pre></td></tr></table></figure><p><strong>3）</strong> create_namespace: 创建指定的命名空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):023:0&gt; create_namespace 'myns'</span><br><span class="line">hbase(main):024:0&gt; list_namespace</span><br></pre></td></tr></table></figure><p><strong>4）</strong>describe_namespace: 查询指定命名空间的描述信息(也叫结构信息，属性信息)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):025:0&gt; describe_namespace 'ns4'</span><br></pre></td></tr></table></figure><p><strong>5）</strong> alter_namespace ：修改命名空间的描述信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">添加描述信息</span><br><span class="line">hbase(main):026:0&gt; alter_namespace 'ns4', &#123;METHOD =&gt; 'set', 'name' =&gt; 'michael'&#125;</span><br><span class="line">hbase(main):027:0&gt; describe_namespace 'ns4'</span><br><span class="line"></span><br><span class="line">删除描述信息</span><br><span class="line">hbase(main):028:0&gt; alter_namespace 'ns4', &#123;METHOD =&gt; 'unset', NAME =&gt; 'name'&#125;</span><br><span class="line">hbase(main):029:0&gt; describe_namespace 'ns4'</span><br></pre></td></tr></table></figure><p><strong>6）</strong> drop_namespace:删除指定命名空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):030:0&gt; drop_namespace 'ns4'</span><br><span class="line">hbase(main):031:0&gt; list_namespace</span><br></pre></td></tr></table></figure><h2 id="Table的DDL操作"><a href="#Table的DDL操作" class="headerlink" title="Table的DDL操作"></a>Table的DDL操作</h2><p><strong>1）</strong> 建表：必须至少指定一个列族名</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- 直接创建</span><br><span class="line">  hbase(main):034:0&gt; create <span class="string">'ns3:emp'</span>,<span class="string">'base_info'</span></span><br><span class="line"></span><br><span class="line">- 使用变量</span><br><span class="line">  hbase(main):036:0&gt; t = create <span class="string">'ns3:employee'</span>,<span class="string">'base_info'</span></span><br><span class="line"></span><br><span class="line">- 创建多个列族名</span><br><span class="line">  hbase(main):040:0&gt; create <span class="string">'ns3:emp1'</span>,<span class="string">'f1'</span>,<span class="string">'f2'</span>,<span class="string">'f3'</span></span><br><span class="line"></span><br><span class="line">- 创建表时同时指定列族属性</span><br><span class="line">  hbase(main):043:0&gt; create <span class="string">'ns3:emp2'</span>,</span><br><span class="line">  &#123;NAME=&gt;<span class="string">'f1'</span>,VERSIONS=&gt;3,TTL=&gt;2592000,BLOCKCACHE=&gt;TRUE&#125;</span><br><span class="line"></span><br><span class="line">- 创建表同时指定分片</span><br><span class="line">  hbase(main):050:0&gt; create <span class="string">'ns3:emp3'</span>, <span class="string">'f1'</span>, SPLITS =&gt; [<span class="string">'10'</span>, <span class="string">'20'</span>, <span class="string">'30'</span>, <span class="string">'40'</span>]</span><br></pre></td></tr></table></figure><p><strong>2）</strong>查看表属性信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):051:0&gt; describe 'ns3:emp1'</span><br></pre></td></tr></table></figure><p><strong>3）</strong> 列出所有的表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):052:0&gt; list</span><br></pre></td></tr></table></figure><p><strong>4）</strong> 修改表属性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):062:0&gt; alter 'ns3:emp3',&#123;NAME=&gt;'f1',BLOOMFILTER=&gt;'rowcol',VERSIONS=&gt;5,TTL=&gt;2592000&#125;</span><br><span class="line"></span><br><span class="line">hbase(main):063:0&gt; describe 'ns3:emp3'</span><br></pre></td></tr></table></figure><p><strong>5）</strong> 追加列族：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 方式1</span><br><span class="line">  hbase(main):064:0&gt; alter 'ns3:emp3',&#123;NAME=&gt;'f2'&#125;</span><br><span class="line"></span><br><span class="line">- 方式2</span><br><span class="line">  hbase(main):066:0&gt; alter 'ns3:emp3','f3'</span><br><span class="line"></span><br><span class="line">- 方式3：</span><br><span class="line">  hbase(main):070:0&gt; alter 'ns3:emp3','f5','f6'</span><br></pre></td></tr></table></figure><p><strong>6）</strong> 删除列族</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):075:0&gt; alter 'ns3:emp3','delete'=&gt;'f6'</span><br></pre></td></tr></table></figure><p><strong>7）</strong> 删除表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先禁用，再删除</span><br><span class="line">hbase(main):076:0&gt; disable 'ns3:emp3'</span><br><span class="line">hbase(main):078:0&gt; drop 'ns3:emp3'</span><br></pre></td></tr></table></figure><h2 id="Table的CRUD操作"><a href="#Table的CRUD操作" class="headerlink" title="Table的CRUD操作"></a>Table的CRUD操作</h2><p><strong>1）</strong> 插入数据：put只能插入一个单元格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">指定 表名、行键、列名、列值、[时间戳]</span><br><span class="line"></span><br><span class="line">hbase(main):081:0&gt; put 'ns3:emp','rk0001','base_info:name','smith'</span><br><span class="line">hbase(main):084:0&gt; put 'ns3:emp','rk0001','base_info:empno','7369',1990000000</span><br></pre></td></tr></table></figure><p><strong>2）</strong> 使用scan查询数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览表所有数据：已经排过序，先按rowkey,再按列族名、然后按列名</span><br><span class="line"></span><br><span class="line">   hbase(main):085:0&gt; scan 'ns3:emp' </span><br><span class="line"></span><br><span class="line">2. 指定版本数量进行浏览</span><br><span class="line"></span><br><span class="line">   hbase(main):110:0&gt; scan 'ns3:emp',&#123;VERSIONS=&gt;3&#125;</span><br><span class="line">   hbase(main):110:0&gt; scan 'ns3:emp',VERSIONS=&gt;3</span><br><span class="line"></span><br><span class="line">3. 指定列进行浏览</span><br><span class="line"></span><br><span class="line">   hbase(main):122:0&gt; scan 'ns3:emp',&#123;COLUMNS=&gt;'base_info:empno'&#125;</span><br><span class="line">   scan 'ns3:emp',&#123;COLUMNS=&gt;['base_info:empno','extra_info:province']&#125; </span><br><span class="line"></span><br><span class="line">4. 限定行范围进行浏览(分页查询)</span><br><span class="line"></span><br><span class="line">   hbase(main):137:0&gt; scan 'ns3:emp',</span><br><span class="line">   &#123;COLUMNS=&gt;'base_info:empno',LIMIT=&gt;5,STARTROW=&gt;'rk0001'&#125;</span><br><span class="line">   </span><br><span class="line">   hbase(main):136:0&gt; scan 'ns3:emp',&#123;LIMIT=&gt;5,STARTROW=&gt;'rk0001'&#125;</span><br></pre></td></tr></table></figure><p><strong>3）</strong> 使用get进行指定行浏览该行内的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 查询指定行 hbase(main):140:0&gt; get 'ns3:emp','rk0001'</span><br><span class="line"></span><br><span class="line">2. 查询指定行中的列</span><br><span class="line"></span><br><span class="line">   hbase(main):155:0&gt; get 'ns3:emp','rk0001','base_info:empno'</span><br><span class="line">   hbase(main):155:0&gt; get 'ns3:emp','rk0001',&#123;COLUMN=&gt;'base_info:empno'&#125;</span><br><span class="line">   hbase(main):157:0&gt; get 'ns3:emp','rk0001','base_info:name','extra_info:province'    </span><br><span class="line">   hbase(main):145:0&gt; get 'ns3:emp','rk0001',&#123;COLUMN=&gt;</span><br><span class="line">   ['base_info:empno','extra_info:province']&#125;</span><br><span class="line"></span><br><span class="line">3. 指定版本号</span><br><span class="line"></span><br><span class="line">   hbase(main):146:0&gt; get 'ns3:emp','rk0001',&#123;COLUMN=&gt;['base_info:empno','extra_info:province'],VERSIONS=&gt;3&#125;</span><br><span class="line"></span><br><span class="line">4. 指定时间戳的范围</span><br><span class="line"></span><br><span class="line">   hbase(main):152:0&gt; get 'ns3:emp','rk0001',&#123;TIMERANGE=&gt;[1568619337238,1568619348753]&#125;</span><br></pre></td></tr></table></figure><p><strong>4）</strong> 更新数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 使用put</span><br><span class="line"></span><br><span class="line">   hbase(main):159:0&gt; put 'ns3:emp','rk0001','base_info:name','smith'</span><br><span class="line"></span><br><span class="line">2. 使用incr，进行自动赋值  </span><br><span class="line"></span><br><span class="line">   incr 'ns3:emp','rk0001','base_info:age'</span><br></pre></td></tr></table></figure><p><strong>5）</strong> 删除数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 删除某行内的指定key-value对</span><br><span class="line"></span><br><span class="line">   hbase(main):001:0&gt; delete 'ns3:emp','rk0001','base_info:name'</span><br><span class="line"></span><br><span class="line">2. 删除指定版本号的单元格</span><br><span class="line"></span><br><span class="line">   hbase(main):008:0&gt; delete 'ns3:emp','rk0001','base_info:empno',1568619337238</span><br><span class="line"></span><br><span class="line">3. 删除指定行</span><br><span class="line"></span><br><span class="line">   hbase(main):011:0&gt; deleteall 'ns3:emp','rk0008'</span><br></pre></td></tr></table></figure><p><strong>6）</strong> 判断表是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):013:0&gt; exists 'ns3:emp'</span><br></pre></td></tr></table></figure><p><strong>7）</strong> 禁用表和启用表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):014:0&gt; disable 'ns3:emp'</span><br><span class="line">hbase(main):016:0&gt; enable 'ns3:emp'</span><br></pre></td></tr></table></figure><p><strong>8）</strong> 统计表行数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):018:0&gt; count 'ns3:emp'</span><br></pre></td></tr></table></figure><p><strong>9）</strong> 清空表数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase(main):019:0&gt; truncate 'ns3:emp'</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(三)HBASE的安装</title>
      <link href="/2023/02/15/Hbase-2023-02-15-%E4%B8%89-HBASE%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2023/02/15/Hbase-2023-02-15-%E4%B8%89-HBASE%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">系统版本：centOS7.7</span></span><br><span class="line"><span class="attr">HBASE版本：apache-hbase-1.2.1</span></span><br><span class="line"><span class="attr">HADOOP版本：apache-hadoop-2.7.6</span></span><br><span class="line"><span class="attr">JDK版本：jdk-1.8.0_45</span></span><br><span class="line"><span class="attr">单机安装/伪分布式：1台服务器</span></span><br><span class="line"><span class="attr">全分布式：3台服务器</span></span><br></pre></td></tr></table></figure><h2 id="HBASE单机安装"><a href="#HBASE单机安装" class="headerlink" title="HBASE单机安装"></a>HBASE单机安装</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>1）解压并更名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# tar -zxvf hbase-1.2.1-bin.tar.gz -C /usr/local/</span><br><span class="line">[root@node01 ~]# cd /usr/local/</span><br><span class="line">[root@node01 local]# mv hbase-1.2.1 hbase</span><br></pre></td></tr></table></figure><p>2）配置环境变量并重新引导</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@node01 local]# vi /etc/profile</span><br><span class="line">export HBASE_HOME=/usr/local/hbase</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$HBASE_HOME/bin</span><br><span class="line"></span><br><span class="line">[hadoop@node01 local]# source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="修改-hbase-env-sh"><a href="#修改-hbase-env-sh" class="headerlink" title="修改 hbase-env.sh"></a>修改 hbase-env.sh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@node01 local]$ vi $HBASE_HOME/conf/hbase-env.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">找到下面内容，解开注释，添加具体路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The java implementation to use.  Java 1.7+ required.</span></span><br><span class="line">export JAVA_HOME=/usr/local/jdk</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tell HBase whether it should manage it<span class="string">'s own instance of Zookeeper or not.</span></span></span><br><span class="line">export HBASE_MANAGES_ZK=true #hbase内置zookeeper开启</span><br></pre></td></tr></table></figure><h3 id="配置hbase-site-xml"><a href="#配置hbase-site-xml" class="headerlink" title="配置hbase-site.xml"></a>配置hbase-site.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 属性hbase.rootdir用于指定hbase产生的数据的存储位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///usr/local/hbase/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- hbase依赖于zookeeper,需要指定内置zookeeper的数据存储位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hbase/zkdata<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="启动HBase服务"><a href="#启动HBase服务" class="headerlink" title="启动HBase服务"></a>启动HBase服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 conf]# start-hbase.sh</span><br><span class="line"></span><br><span class="line">[root@node01 hbase]# jps</span><br><span class="line">4593 HMaster</span><br><span class="line">3272 ResourceManager</span><br><span class="line">4666 Jps</span><br><span class="line">2923 NameNode</span><br><span class="line">3116 SecondaryNameNode</span><br></pre></td></tr></table></figure><h3 id="hbase的客户端连接"><a href="#hbase的客户端连接" class="headerlink" title="hbase的客户端连接"></a>hbase的客户端连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 logs]# hbase shell</span><br><span class="line">hbase(main):001:0&gt; status</span><br><span class="line">1 active master, 0 backup masters, 1 servers, 0 dead, 2.0000 average load</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">hbase(main):002:0&gt; version</span><br><span class="line">1.2.1, r8d8a7107dc4ccbf36a92f64675dc60392f85c015, Wed Mar 30 11:19:21 CDT 2016</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">hbase(main):003:0&gt; whoami</span><br><span class="line">root (auth:SIMPLE)</span><br><span class="line">    groups: root</span><br><span class="line">---------------------------------------------------------------------------------------- </span><br><span class="line">hbase(main):004:0&gt; help</span><br></pre></td></tr></table></figure><h2 id="伪分布式安装"><a href="#伪分布式安装" class="headerlink" title="伪分布式安装"></a>伪分布式安装</h2><h3 id="情况说明"><a href="#情况说明" class="headerlink" title="情况说明"></a>情况说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- Hbase的伪分布式，指的是Hbase的相关守护进程运行在一台机器上，只不过每一个守护进程都作为独立的进程运行。</span><br><span class="line">- Hbase的伪分布式数据存储可以基于本地文件系统，也可以基于分布式文件系统。</span><br><span class="line">- 基于分布式文件系统时，hbase使用内置的zookeeper或者用户自己搭建的zookeeper.</span><br><span class="line"></span><br><span class="line">下面是使用分布式文件系统和用户自己搭建的zookeeper模式。</span><br></pre></td></tr></table></figure><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p><strong>1）</strong>配置Hbase的环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]$ tar -zxvf hbase-1.2.1-bin.tar.gz -C /url/local/</span><br><span class="line">[root@node01 ~]$ cd /url/local/</span><br><span class="line">[root@node01 local]$ mv hbase-1.2.1 hbase</span><br><span class="line">[root@node01 local]$ vi /etc/profile</span><br><span class="line">.......省略.......</span><br><span class="line"><span class="meta">#</span><span class="bash">hbase environment</span></span><br><span class="line">export HBASE_HOME=/url/local/hbase</span><br><span class="line">export PATH=$HBASE_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">[root@node01 local]$ source  /etc/profile</span><br><span class="line">[root@node01 local]$ hbase version</span><br></pre></td></tr></table></figure><p><strong>2）</strong>修改hbase-env.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 local]$ vi $HBASE_HOME/conf/hbase-env.sh</span><br><span class="line">........省略...........</span><br><span class="line"><span class="meta">#</span><span class="bash">找到下面内容，解开注释，添加具体路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> The java implementation to use.  Java 1.7+ required.</span></span><br><span class="line">export JAVA_HOME=/opt/local/jdk</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tell HBase whether it should manage it<span class="string">'s own instance of Zookeeper or not.</span></span></span><br><span class="line">export HBASE_MANAGES_ZK=false       #禁止内置zookeeper</span><br></pre></td></tr></table></figure><p><strong>3）</strong>配置hbase-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 local]$ vi $HBASE_HOME/conf/hbase-site.xml</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 属性hbase.rootdir用于指定hbase产生的数据的存储位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://node01:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定hbase使用的zookeeper集群 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>node01:2181,node02:2181,node03:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启用hbase集群模式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--将属性hbase.unsafe.stream.capability.enforce 改为true --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4）</strong>启动集群</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.</span> <span class="string">注意，如果使用的zookeeper为用户自己安装的，那么需要先启动zookeeper的服务</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">再启动hbase</span></span><br><span class="line"><span class="meta">[root@node01</span> <span class="string">conf]# start-hbase.sh</span></span><br><span class="line"><span class="meta">[root@node01</span> <span class="string">conf]# jps</span></span><br></pre></td></tr></table></figure><p>5）hdfs的目录查看</p><p><img src="006.png" alt=""></p><p><strong>6）</strong>(可选)：开启备份master(backup-master)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 local]$ local-master-backup.sh start 2 3 5</span><br><span class="line"></span><br><span class="line">说明：2，3，5是端口号16010和16000的端口偏移量，生成的端口号就是：16012/16002  16013/16003  16015/16005</span><br><span class="line"></span><br><span class="line">关闭备份master：backup-master:</span><br><span class="line">查看备份master的pid，通过kill命令 来结束进程</span><br><span class="line">方法：jps  或   cat /tmp/hbase-hyxy-num-master.pid | xargs kill -9</span><br></pre></td></tr></table></figure><p><strong>7）</strong>(可选)：开启或停止其他RegionServer</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 local]$  local-regionservers.sh start 2 3 4 5</span><br><span class="line">[root@node01 local]$  local-regionservers.sh stop [num]</span><br></pre></td></tr></table></figure><h2 id="全分布式安装"><a href="#全分布式安装" class="headerlink" title="全分布式安装"></a>全分布式安装</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">HBASE是一个分布式系统</span></span><br><span class="line"><span class="meta">其中有一个管理角色：</span>  <span class="string">HMaster(一般2台，一台active，一台backup)</span></span><br><span class="line"><span class="meta">其他的数据节点角色：</span>  <span class="string">HRegionServer(很多台，看数据容量)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">实际上，您需要一个完全分布式的配置来全面测试HBase，并在实际场景中使用它。在分布式配置中，集群包含多个节点，每个节点运行一个或多个HBase守护进程。这些包括主实例和备份主实例、多个ZooKeeper节点和多个RegionServer节点。</span></span><br></pre></td></tr></table></figure><h3 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h3><p>1）角色分配</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">node01</span>: <span class="string">hmaster regionserver </span></span><br><span class="line"><span class="attr">node02</span>: <span class="string">backup master regionserver  </span></span><br><span class="line"><span class="attr">node03</span>: <span class="string">regionserver</span></span><br></pre></td></tr></table></figure><p>2） 配置hbase的环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# tar -zxvf hbase-1.2.1-bin.tar.gz -C /usr/local/</span><br><span class="line">[root@node01 ~]# cd /usr/local/</span><br><span class="line">[root@node01 local]# mv hbase-1.2.1 hbase</span><br><span class="line">[root@node01 local]# vi /etc/profile</span><br><span class="line">.......省略.......</span><br><span class="line"><span class="meta">#</span><span class="bash">hbase environment</span></span><br><span class="line">export HBASE_HOME=/usr/local/hbase</span><br><span class="line">export PATH=$HBASE_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">[root@node01 local]# source  /etc/profile</span><br><span class="line">[root@node01 local]# hbase version</span><br></pre></td></tr></table></figure><p>3）配置ssh无密码登陆(一般情况下，都在搭建HDFS时，完成)</p><p>4）配置时间同步(<font color='red'><strong>非常重要</strong></font>，也应该在搭建HDFS时，完成,时间差不能超过30s)</p><p>5）确认hbase-env.sh禁用内置的zookeeper</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 local]# vi $HBASE_HOME/conf/hbase-env.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">找到下面内容，解开注释，添加具体路径</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> The java implementation to use.  Java 1.7+ required.</span></span><br><span class="line">export JAVA_HOME=/usr/local/jdk</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tell HBase whether it should manage it<span class="string">'s own instance of Zookeeper or not.</span></span></span><br><span class="line">export HBASE_MANAGES_ZK=false       #禁止内置zookeeper</span><br></pre></td></tr></table></figure><h3 id="配置HBASE"><a href="#配置HBASE" class="headerlink" title="配置HBASE"></a>配置HBASE</h3><p>1) 修改hbase-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定hbase在HDFS上存储的路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://node01:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定hbase是分布式的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定zk的地址，多个用“,”分割 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>node01:2181,node02:2181,node03:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--将属性hbase.unsafe.stream.capability.enforce 改为true --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置regionserver所在的节点信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 apps]#  vi $HBASE_HOME/conf/regionservers</span><br><span class="line"></span><br><span class="line">删除localhost</span><br><span class="line">添加:</span><br><span class="line">node01</span><br><span class="line">    node02</span><br><span class="line">    node03</span><br></pre></td></tr></table></figure><p>3）配置备份hmaster: 创建backup-masters文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 local]#  cd $HBASE_HOME/conf/</span><br><span class="line">[root@node01 conf]#  echo "node02"&gt;&gt; backup-masters</span><br></pre></td></tr></table></figure><p>4）将hadoop的core-site.xml和hdfs-site.xml放入conf目录内</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 local]#  cd $HADOOP_HOME/etc/hadoop/</span><br><span class="line">[root@node01 hadoop]#  cp core-site.xml hdfs-site.xml $HBASE_HOME/conf/</span><br></pre></td></tr></table></figure><p>5）将hbase分发到集群其他相关节点上</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 <span class="built_in">local</span>]<span class="comment"># scp -r /usr/local/hbase node02:/usr/local</span></span><br><span class="line">[root@node01 <span class="built_in">local</span>]<span class="comment"># scp -r /usr/local/hbase node03:/usr/local</span></span><br><span class="line">[root@node01 <span class="built_in">local</span>]<span class="comment"># scp /etc/profile node02:/etc/</span></span><br><span class="line">[root@node01 <span class="built_in">local</span>]<span class="comment"># scp /etc/profile node03:/etc/</span></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">     重新引导一下各个节点的环境变量配置情况</span><br></pre></td></tr></table></figure><h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><p>1）启动集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 启动zookeeper集群</span><br><span class="line">2. 启动hdfs集群</span><br><span class="line">3. 启动hbase服务</span><br><span class="line">   </span><br><span class="line">说明： start-hbase.sh脚本开启进程的顺序</span><br><span class="line">    - 1. 主节点上的hmaster</span><br><span class="line">    - 2. regionserver</span><br><span class="line">    - 3. 备份hmaster</span><br></pre></td></tr></table></figure><p>2）查看hbase</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 local]# jps</span><br><span class="line">1888 QuorumPeerMain</span><br><span class="line">2438 ResourceManager</span><br><span class="line">2822 HMaster</span><br><span class="line">2090 NameNode</span><br><span class="line">2284 SecondaryNameNode</span><br><span class="line">3373 Jps</span><br><span class="line">2943 HRegionServer</span><br><span class="line">[root@node01 local]# netstat -nltp | grep 2822</span><br><span class="line">tcp    0    0 ::ffff:192.168.49.250:16000 :::*          LISTEN      2822/java</span><br><span class="line">tcp    0    0 :::16010                    :::*          LISTEN      2822/java</span><br></pre></td></tr></table></figure><p>3）<font color='red'>查看webui页面</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ip:16010</span><br></pre></td></tr></table></figure><p>4）<font color='red'>查看zookeeper</font></p><p>5）查看hdfs</p><p>6) hbase shell 启动</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 bin]# ./hbase shell</span><br></pre></td></tr></table></figure><p>7) HBASE的测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">help '命令组'</span><br><span class="line">e.g. </span><br><span class="line">help 'create'</span><br></pre></td></tr></table></figure><h2 id="regionserver动态上下线"><a href="#regionserver动态上下线" class="headerlink" title="regionserver动态上下线"></a>regionserver动态上下线</h2><h3 id="regionserver动态上线"><a href="#regionserver动态上线" class="headerlink" title="regionserver动态上线"></a>regionserver动态上线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Master使用Zookeeper跟踪RegionServer状态。当某个RegionServer启动时，会首先在Zookeeper上的Server目录下建立代表自己的znode，并获得该znode的独占锁。由于Master订阅了Server目录上的变更信息，当Server目录下的znode出现新增或者删除操作时，Master可以得到来自Zookeeper的实时通知。因此一旦RegionServer上线，Master能马上得到消息。如果负载平衡器开启的话，master会为新的regionserver分配region。</span><br></pre></td></tr></table></figure><p><strong>1）</strong>准备节点环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1：选择集群中正常工作的一台机器node04</span><br><span class="line">方法2：新搭建一台机器node04，保证jdk,hadoop环境配置，hdfs节点动态上线等一系列注意事项</span><br></pre></td></tr></table></figure><p><strong>2）</strong>搭建hbase环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 1. 配置hbase的环境变量</span><br><span class="line">- 2. 配置hbase的hbase-env.sh文件</span><br><span class="line">- 3. 配置hbase的hbase-site.xml文件 </span><br><span class="line"></span><br><span class="line">强调：要与hmaster节点的配置内容一致。当然可以选择copy</span><br></pre></td></tr></table></figure><p><strong>3）</strong>在节点上启动regionserver</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node04 conf]# hbase-daemon.sh start regionserver</span><br></pre></td></tr></table></figure><p><strong>4）</strong>修改conf/regionservers配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将新增节点主机名，添加到regionservers配置文件中,以便下次启动hbase时，带上node04</span></span><br><span class="line">[root@node01 conf]# vi regionservers</span><br><span class="line">node01</span><br><span class="line">node02</span><br><span class="line">node03</span><br><span class="line">node04</span><br><span class="line"></span><br><span class="line">注意：最好同步一下</span><br></pre></td></tr></table></figure><h3 id="regionserver动态下线"><a href="#regionserver动态下线" class="headerlink" title="regionserver动态下线"></a>regionserver动态下线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当regionserver断开与zookeeper的会话时，相应的znode被删除。当master通过zookeeper发现该节点不存在后，就会在平衡器的作用下，重新分配region。</span><br><span class="line"></span><br><span class="line">当RegionServer动态下线或者宕机时，它和zookeeper的会话断开，zookeeper自动释放代表这台Server的znode的独占锁，并删除该znode。而Master不断轮询Server目录下znode的锁状态时，如果发现某个RegionServer丢失自己的的独占锁，或者连续几次和RegionServer通信都无法成功，Master就尝试去获取代表这个RegionServer的读写锁。一旦获取成功，就可以确定RegionServer和zookeeper之间的网络断开或RegionServer挂了。此时Master会删除这台RegionServer的对应的znode，开始重新分配region。</span><br><span class="line"></span><br><span class="line">如果网络短暂出现问题导致RegionServer丢失它的锁，RegionServer重新连接到Zookeeper之后，只要代表它的znode还在，它就会不断尝试这个文件上的锁，一旦获取到，就可以继续提供服务。</span><br></pre></td></tr></table></figure><p><strong>1）</strong>选择要下线的机器节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如，我选择了node01</span><br></pre></td></tr></table></figure><p><strong>2）</strong>卸载该节点的region</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 conf]# graceful_stop.sh node01</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">该节点的region会逐渐迁徙到其他regionserver上</span></span><br></pre></td></tr></table></figure><p><strong>3）</strong>修改conf/regionservers配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除下线的节点主机名，同步到其他节点上</span></span><br><span class="line">[root@node01 conf]# vi regionservers</span><br><span class="line"><span class="meta">#</span><span class="bash"> node01  删除或者注释</span></span><br><span class="line">node02</span><br><span class="line">node03</span><br><span class="line">node04</span><br><span class="line"></span><br><span class="line">注意：最好同步一下</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(二)HBASEHBASE体系结构</title>
      <link href="/2023/02/15/Hbase-2023-02-15-%E4%BA%8C-HBASEHBASE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2023/02/15/Hbase-2023-02-15-%E4%BA%8C-HBASEHBASE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="RDBMS的表模型-扩展"><a href="#RDBMS的表模型-扩展" class="headerlink" title="RDBMS的表模型(扩展)"></a>RDBMS的表模型(扩展)</h2><p>我们先来了解以下传统型数据库的存储结构，也就是表模型（参考下图）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 关系型数据库采用表格的存储方式，数据按行和列进行存储，读取和查询十分方便。</span><br><span class="line">- 关系型数据库存储结构化的数据，存储前必须先定义好表结构，即各个列(字段)。</span><br></pre></td></tr></table></figure><p><img src="20190915141355.jpg" alt="img"></p><p>关系型数据库的特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 存储结构：以表格的形式存储结构化的数据，需要事先定义好表的结构(字段名称，字段类型，字段个数)，数据存储在行与列的交汇处(称之为Cell单元格)</span><br><span class="line">2. 存储规范：为了充分利用存储空间，尽可能的避免重复(数据冗余)，按照数据最小关系表的形式存储，数据清晰，一目了然</span><br><span class="line">3. 查询方式：采用结构化查询语言(SQL)对数据进行管理。</span><br><span class="line">4. 事务性：为了保证数据的商业业务逻辑以及数据安全性，支持ACID的事务特性</span><br><span class="line">5. 读写性能：关系型数据库追求的是数据实时性和数据的一致性，</span><br><span class="line"></span><br><span class="line">缺点总结：</span><br><span class="line">1. 一旦数据表中存储数据后，修改表结构变得特别困难。</span><br><span class="line">2. 如果我们想扩展字段时，会对表结构产生影响。</span><br><span class="line">3. 即使某一行中的某个字段没有赋值，也要使用null填充</span><br><span class="line">4. 一旦涉及到多张表，因为数据表存在着复杂的关系，管理非常不方便。</span><br><span class="line">5. 一旦面对海量数据的处理时,读写性能特别差，尤其在高并发这一块。</span><br></pre></td></tr></table></figure><h2 id="Hbase的表模型"><a href="#Hbase的表模型" class="headerlink" title="Hbase的表模型"></a>Hbase的表模型</h2><p>HBase是一个面向列的非关系型数据库，区别于面向行存储的关系型数据库。</p><h3 id="HBASE表模型的要点"><a href="#HBASE表模型的要点" class="headerlink" title="HBASE表模型的要点"></a>HBASE表模型的要点</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.</span> <span class="string">Hbase表的基本存储单位是一个单元格(Cell)，也可以称之为列(Column)。</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">单元格内存储的是一对key-value键值对。</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">每一个key-value键值对都有N个时间戳作为版本号(版本数量可以配置)</span></span><br><span class="line"><span class="meta">4.</span> <span class="string">为了管理不同的key-value,hbase引入了列簇(列族)的概念，</span></span><br><span class="line"><span class="meta">-</span> <span class="string">一个表可以有多个列簇（不同列簇的数据一定会存储在不同文件中，即一个列簇对应一个文件）</span></span><br><span class="line"><span class="meta">-</span> <span class="string">一个列族下可以有成千上百万个不同的key-value,即列</span></span><br><span class="line"><span class="meta">5.</span> <span class="string">为了标识某些key-value键值对是某一个事物的，引入了rowkey的概念。rowkey作为唯一标识符，不能重复。</span></span><br><span class="line"><span class="meta">6.</span> <span class="string">一张表通常由于数据量过大，会被横向切分成若干个region(用rowkey范围标识)</span></span><br><span class="line"><span class="meta">-</span> <span class="string">不同region的数据也存储在不同文件中</span></span><br><span class="line"><span class="meta">7.</span> <span class="string">hbase会对插入的数据按顺序存储：(内存)</span></span><br><span class="line">  <span class="meta">-</span> <span class="string">要点一：首先会按行键排序</span></span><br><span class="line">  <span class="meta">-</span> <span class="string">要点二：同一行里面的kv会按列簇排序，再按k排序</span></span><br></pre></td></tr></table></figure><p><img src="20190915141505.jpg" alt="img"></p><h3 id="HBASE表的物理存储结构"><a href="#HBASE表的物理存储结构" class="headerlink" title="HBASE表的物理存储结构"></a>HBASE表的物理存储结构</h3><p><img src="010.png" alt=""></p><h3 id="存储结构中的概念"><a href="#存储结构中的概念" class="headerlink" title="存储结构中的概念"></a>存储结构中的概念</h3><p><strong>Cell（单元格）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 关系型数据库中的表模型是由行和列构成，交叉点我们称之为Cell(单元格)，用于存储字段(Column)的数据。</span><br><span class="line">- Hbase的表模型与关系型数据库的表模型不同。在单元格上是以 key-value 形式来存储某一个字段(Column)数据的。</span><br><span class="line">- 版本号（Timestamp）每一个单元格都有自己的版本号。</span><br></pre></td></tr></table></figure><p><img src="20190915132457.jpg" alt="img"></p><p><strong>rowKey(行键)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 对于每个单元格(列名与值)来说，他属于哪一行记录，尤为重要，因此引入rowkey这个概念，用于区分单元格属于那一行记录，</span><br><span class="line">- 在Hbase中的表中的rowkey不能重复</span><br></pre></td></tr></table></figure><p><strong>列族(Column family)：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">思考一下，面向列的数据库，只需要有列就行了，为什么还要有列族呢？</span><br><span class="line"></span><br><span class="line">1. 列族是是多个列的集合。用于统一管理相似的列数据。</span><br><span class="line">2. Hbase会尽量把同一个列族的列放在同一个服务器上，这样可以提高存取效率，可以批量管理有关联的一堆列。</span><br><span class="line">3. 一个列族对应一个目录。不同的列族一定存储在不同的文件中</span><br><span class="line">强调：业务需求一般也都是查询相关列信息，而非select *</span><br><span class="line">4. hbase在建表时，指定的是列族，而非列，列族的个数有限制(默认是10个)</span><br><span class="line">5. 列族是由多个列组成，列族的成员可以有上百万个。</span><br><span class="line">6. 列族成员的表示方式：ColFamiName:colName</span><br></pre></td></tr></table></figure><h3 id="HBASE的表中能存储数据类型"><a href="#HBASE的表中能存储数据类型" class="headerlink" title="HBASE的表中能存储数据类型"></a>HBASE的表中能存储数据类型</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-</span> <span class="string">hbase中只支持byte[] </span></span><br><span class="line"><span class="meta">-</span> <span class="string">此处的byte[] 包括了： rowkey,key,value,列簇名,表名</span></span><br></pre></td></tr></table></figure><h3 id="HBASE与RDBMS和NOSQL区别"><a href="#HBASE与RDBMS和NOSQL区别" class="headerlink" title="HBASE与RDBMS和NOSQL区别"></a>HBASE与RDBMS和NOSQL区别</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">HBase的表数据存储在HDFS文件系统中。</span></span><br><span class="line"><span class="meta">从而，hbase具备如下特性：存储容量可以线性扩展；</span> <span class="string">数据存储的安全性可靠性极高！</span></span><br><span class="line"><span class="meta">-</span> <span class="string">hbase的表模型跟mysql之类的关系型数据库的表模型差别巨大</span></span><br><span class="line"><span class="meta">-</span> <span class="string">hbase的表模型中有：行的概念；但没有字段的概念  </span></span><br><span class="line"><span class="meta">-</span> <span class="string">行中存的都是key-value对，每行中的key-value对中的key可以是各种各样，每行中的key-value对的数量也可以是各种各样</span></span><br></pre></td></tr></table></figure><h2 id="HBASE的体系架构"><a href="#HBASE的体系架构" class="headerlink" title="HBASE的体系架构"></a>HBASE的体系架构</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="004.png" alt=""></p><h3 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.</span> <span class="string">Client : hbase客户端，</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">包含访问hbase的接口。比如，linux shell，java api。</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">除此之外，它会维护缓存来加速访问hbase的速度。比如region的位置信息。</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">Zookeeper ：</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">监控Hmaster的状态，保证有且仅有一个活跃的Hmaster。达到高可用。</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">它可以存储所有region的寻址入口。如：root表在哪一台服务器上。</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">实时监控HregionServer的状态，感知HRegionServer的上下线信息，并实时通知给Hmaster。</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">存储hbase的部分元数据。</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">HMaster :</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">1. 为HRegionServer分配Region（新建表等）。</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">2. 负责HRegionServer的负载均衡。</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">3. 负责Region的重新分配</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">HRegionServer宕机之后的Region分配，</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">HRegion裂变：当Region过大之后的拆分）。</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">4. Hdfs上的垃圾回收。</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">5. 处理schema的更新请求</span></span><br><span class="line"><span class="meta">4.</span> <span class="string">HRegionServer ：</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">1. 维护HMaster分配给的Region（管理本机的Region）。</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">2. 处理client对这些region的读写请求，并和HDFS进行交互(Hlog的写入，HFile的读写)。</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">3. 负责切分在运行过程中逐渐变大的Region。</span></span><br><span class="line"><span class="meta">5.</span> <span class="string">HLog ：</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">1. 对HBase的操作进行记录，使用WAL写数据，优先写入Hlog.</span></span><br><span class="line">   <span class="attr">比如：put操作时，先写日志再写memstore，这样可以防止数据丢失，即使丢失也可以回滚。</span></span><br><span class="line"><span class="meta">6.</span> <span class="string">HRegion ：</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">1. HBase中分布式存储和负载均衡的最小单元，它是表或者表的一部分。</span></span><br><span class="line"><span class="meta">7.</span> <span class="string">Store ：</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">1. 相当于一个列簇</span></span><br><span class="line"><span class="meta">8.</span> <span class="string">Memstore ：</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">1. 内存缓冲区，用于将数据批量刷新到hdfs中，默认大小为128M</span></span><br><span class="line"><span class="meta">9.</span> <span class="string">HStoreFile :</span></span><br><span class="line">   <span class="meta">-</span> <span class="string">1. 和HFile概念一样，不过是一个逻辑概念。HBase中的数据是以HFile存储在Hdfs上。</span></span><br></pre></td></tr></table></figure><h3 id="组件之间的关系"><a href="#组件之间的关系" class="headerlink" title="组件之间的关系"></a>组件之间的关系</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hmaster</span>:<span class="string">hregionserver=1:*</span></span><br><span class="line"><span class="attr">hregionserver</span>:<span class="string">hregion=1:*</span></span><br><span class="line"><span class="attr">hregionserver</span>:<span class="string">hlog=1:1</span></span><br><span class="line"><span class="attr">hregion</span>:<span class="string">hstore=1:*</span></span><br><span class="line"><span class="attr">store</span>:<span class="string">memstore=1:1</span></span><br><span class="line"><span class="attr">store</span>:<span class="string">storefile=1:*</span></span><br><span class="line"><span class="attr">storefile</span>:<span class="string">hfile=1:1</span></span><br></pre></td></tr></table></figure><p><img src="005.png" alt=""></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rowkey</span>:<span class="string">行键，和mysql的主键同理，不允许重复。</span></span><br><span class="line"><span class="attr">columnfamily</span>: <span class="string">列簇，列的集合之意。</span></span><br><span class="line"><span class="attr">column</span>:<span class="string">列</span></span><br><span class="line"><span class="attr">timestamp</span>:<span class="string">时间戳，默认显示最新的时间戳，可用于控制k对应的多个版本值，默认查最新的数据</span></span><br><span class="line"><span class="attr">cell</span>:<span class="string">单元格，kv就是cell</span></span><br><span class="line"></span><br><span class="line"><span class="attr">模式：无</span></span><br><span class="line"><span class="meta">数据类型</span>:<span class="string">只存储byte[]</span></span><br><span class="line"><span class="attr">多版本：每个值都可以有多个版本</span></span><br><span class="line"><span class="attr">列式存储：一个列簇存储到一个目录</span></span><br><span class="line"><span class="attr">稀疏存储：如果一个kv为null，不占用存储空间</span></span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(一)HBASE概述</title>
      <link href="/2023/02/15/Hbase-2023-02-15-%E4%B8%80-HBASE%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/02/15/Hbase-2023-02-15-%E4%B8%80-HBASE%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="HBASE来源"><a href="#HBASE来源" class="headerlink" title="HBASE来源"></a>HBASE来源</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.</span> <span class="string">hbase是一个开源的、分布式的、多版本的、可扩展的、非关系型的数据库。</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">hbase是big table的开源的java版本，建立在hdfs基础之上，提供高可靠性、高性能的、列式存储、可伸缩、近实时读写的nosql的数据库系统</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">数据量越来越大，传统的关系型数据库不能满足存储和查询的需求。而hive虽然能够满足存储的要求，但是hive的本质也是利用底层的mr程序，所以读写速度不快。而且hive不能满足非结构化的、半结构化的存储，hive的主要作用是做分析和统计，hive用于存储是无意义的。</span></span><br></pre></td></tr></table></figure><p><img src="201.png" alt=""></p><h2 id="HBase定义"><a href="#HBase定义" class="headerlink" title="HBase定义"></a>HBase定义</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">HBASE是一个数据库----可以提供数据的实时随机读写</span></span><br><span class="line"><span class="attr">HBASE与mysql、oralce、db2、sqlserver等关系型数据库不同，它是一个NoSQL数据库（非关系型数据库）</span></span><br></pre></td></tr></table></figure><p><img src="002.png" alt=""></p><h2 id="HBase特性"><a href="#HBase特性" class="headerlink" title="HBase特性"></a>HBase特性</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-</span> <span class="string">HBase的表模型与关系型数据库的表模型不同：</span></span><br><span class="line"><span class="meta">-</span> <span class="string">HBase的表没有固定的字段定义；</span></span><br><span class="line"><span class="meta">-</span> <span class="string">HBase的表中每行存储的都是一些key-value对</span></span><br><span class="line"><span class="meta">-</span> <span class="string">HBase的表中有列簇的划分，用户可以指定将哪些kv插入哪个列族</span></span><br><span class="line"><span class="meta">-</span> <span class="string">HBase的表在物理存储上，是按照列簇来分割的，不同列簇的数据一定存储在不同的文件中</span></span><br><span class="line"><span class="meta">-</span> <span class="string">HBase的表中的每一行都固定有一个行键，而且每一行的行键在表中不能重复</span></span><br><span class="line"><span class="meta">-</span> <span class="string">HBase中的数据，包含行键，包含key，包含value，都是byte[ ]类型，HBase不负责为用户维护数据类型</span></span><br><span class="line"><span class="meta">-</span> <span class="string">HBase对事务的支持很差</span></span><br><span class="line"><span class="meta">-</span> <span class="string">HBase基于hadoop : HBase的存储依赖于HDFS</span></span><br></pre></td></tr></table></figure><p><img src="003.png" alt=""></p><h2 id="HBASE应用场景"><a href="#HBASE应用场景" class="headerlink" title="HBASE应用场景"></a>HBASE应用场景</h2><p><img src="046.png" alt=""></p><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      <categories>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AbstractQueuedSynchronizer源码解析（下）</title>
      <link href="/2023/02/15/%E6%BA%90%E7%A0%81-jdk-2023-02-15-AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2023/02/15/%E6%BA%90%E7%A0%81-jdk-2023-02-15-AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p>释放锁的触发时机就是我们常用的 Lock.unLock () 方法，目的就是让线程释放对资源的访问权 （流程见整体架构图紫色路线）。</p><p>释放锁也是分为两类，一类是排它锁的释放，一类是共享锁的释放，我们分别来看下。</p><h3 id="释放排它锁-release"><a href="#释放排它锁-release" class="headerlink" title="释放排它锁 release"></a>释放排它锁 release</h3><p>排它锁的释放就比较简单了，从队头开始，找它的下一个节点，如果下一个节点是空的，就会从 尾开始，一直找到状态不是取消的节点，然后释放该节点，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unlock的基础方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// tryRelease 交给实现类去实现，一般就是用当前同步器状态减去 arg，如果返回 true 说明释放锁了</span></span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="comment">// 头节点不为空，并且不是同步节点，就去释放</span></span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">               <span class="comment">//从头开始唤醒等待锁的节点</span></span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很有意思的方法，当线程释放锁成功后，从 node 开始唤醒同步队列中的节点</span></span><br><span class="line"><span class="comment">// 通过唤醒机制,保证线程不会一直在同步队列中阻塞等待</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// node 节点是当前释放锁的节点</span></span><br><span class="line">    <span class="comment">// 把节点的状态置为初始化</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿出 node 节点的后面一个节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// s 为空，代表队列中没有其他等待的节点了</span></span><br><span class="line">    <span class="comment">// s.waitStatus 大于0，代表 s 节点已经被取消了</span></span><br><span class="line">    <span class="comment">// 遇到以上这两种情况，就从队尾开始，向前遍历，找到第一个 waitStatus 不是取消的</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 这里从尾迭代，而不是从头开始迭代是有原因的。</span></span><br><span class="line">        <span class="comment">// 主要是因为节点被阻塞的 acquireQueued 方法里面，节点在 acquireQueued 方法被阻塞，唤醒时也一定会在</span></span><br><span class="line">        <span class="comment">// acquireQueued 方法里面被唤醒，唤醒之后的条件是，判断当前节点的前置节点是否是头节点，这里是判断当前节点的</span></span><br><span class="line">        <span class="comment">// 前置节点，所以这里必须使用从尾到头的迭代顺序才行</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="comment">// t.waitStatus &lt;= 0 说明 t 没有被取消，肯定还在等待被唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒以上代码找到的线程</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了</p><h3 id="释放共享锁-releaseShared"><a href="#释放共享锁-releaseShared" class="headerlink" title="释放共享锁 releaseShared"></a>释放共享锁 releaseShared</h3><p>释放共享锁的方法是 releaseShared，主要分成两步：</p><ol><li><p>tryReleaseShared 尝试释放当前共享锁，失败返回 false，成功走 2；</p></li><li><p>唤醒当前节点的后续阻塞节点，这个方法我们之前看过了，线程在获得共享锁的时候，就 会去唤醒其后面的节点，方法名称为：doReleaseShared。</p></li></ol><p>我们一起来看下 releaseShared 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享模式下的释放</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">          <span class="comment">// 这个方法就是线程在获得锁时，唤醒后续节点时调用的方法</span></span><br><span class="line">          doReleaseShared();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h2><p>最后我们再来细说一下条件队列。在看条件队列的方法之前，我们先得弄明白为什么有了同步队列，还需要条件队列？</p><p>简单讲，一些线程在获得锁之后 发现某些条件不满足，进行自我阻塞，此时用的队列就是条件队列。比如，获得锁的多个线程在碰到队列满或者空的时候，可以使用 Condition 来 管理这些线程，让这些线程阻塞等待，然后在合适的时机后，被正常唤醒。</p><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>刚才我们看条件队列 ConditionObject 时，发现其是实现 Condition 接口的，现在我们一起来 看下 Condition 接口，其类注释上是这么写的：</p><ol><li>当 lock 代替 synchronized 来加锁时，Condition 就可以用来代替 Object 中相应的监控 方法了，比如 Object#wait ()、Object#notify、Object#notifyAll 这些方法；</li><li>提供了一种线程协作方式：一个线程被暂停执行，直到被其它线程唤醒；</li><li>Condition 实例是绑定在锁上的，通过 Lock#newCondition 方法可以产生该实例；</li></ol><p>类注释上甚至还给我们举了一个例子：</p><p>假设我们有一个有界边界的队列，支持 put 和 take 方法，需要满足： 1：如果试图往空队列上执行 take，线程将会阻塞，直到队列中有可用的元素为止； 2：如果试图往满的队列上执行 put，线程将会阻塞，直到队列中有空闲的位置为止。</p><p>1、2 中线程阻塞都会到条件队列中去阻塞。</p><p>take 和 put 两种操作如果依靠一个条件队列，那么每次只能执行一种操作，所以我们可以新建 两个条件队列，这样就可以分别执行操作了， 感兴趣的可以看看 ConditionDemo 这个测试类d除了类注释，Condition 还定义出一些方法，这些方法奠定了条件队列的基础，方法主要有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>这个方法的主要作用是：使当前线程一直等待，直到被 signalled 或被打断。</p><p>当以下四种情况发生时，条件队列中的线程将被唤醒</p><ol><li>有线程使用了 signal 方法，正好唤醒了条件队列中的当前线程；</li><li>有线程使用了 signalAll 方法；</li><li>其它线程打断了当前线程，并且当前线程支持被打断；</li><li>被虚假唤醒 (即使没有满足以上 3 个条件，wait 也是可能被偶尔唤醒，虚假唤醒定义可以 参考： <a href="https://en.wikipedia.org/wiki/Spurious_wakeup)。" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Spurious_wakeup)。</a></li></ol><p>被唤醒时，有一点需要注意的是：线程从条件队列中苏醒时，必须重新获得锁，才能真正被唤 醒，这个我们在说源码的时候，也会强调这个。</p><p>await 方法还有带等待超时时间的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回的 long 值表示剩余的给定等待时间，如果返回的时间小于等于 0 ，说明等待时间过了 // 选择纳秒是为了避免计算剩余等待时间时的截断误差 </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然入参可以是任意单位的时间，但底层仍然转化成纳秒 </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>除了等待方法，还是唤醒线程的两个方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒条件队列中的一个线程，在被唤醒前必须先获得锁 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒条件队列中的所有线程 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>接下来我们来看一下条件队列一些比较重要的方法， 以下方法都在 ConditionObject 内部类 中。</p><h3 id="入队列等待-await"><a href="#入队列等待-await" class="headerlink" title="入队列等待 await"></a>入队列等待 await</h3><p>获得锁的线程，如果在碰到队列满或空的时候，就会阻塞住，这个阻塞就是用条件队列实现的， 这个动作我们叫做入条件队列，方法名称为 await，流程见整体架构图中深绿色箭头流向，我们 一起来看下 await 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 加入到条件队列的队尾</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 加入条件队列后，会释放lock申请的资源，唤醒同步队列队列头的节点</span></span><br><span class="line">    <span class="comment">// 自己马上就要阻塞了，必须马上释放之前lock的资源，不然自己不被唤醒，别的线程永远得不到该共享资源了</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 确认node不在同步队列上，再阻塞，如果 node 在同步队列上，是不能够上锁的</span></span><br><span class="line">    <span class="comment">// 这里的情况比较特殊，目前想到的只有一种可能：</span></span><br><span class="line">    <span class="comment">// node刚被加入到条件队列中，立马就被其他线程signal转移到同步队列中去了</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// this = AbstractQueuedSynchronizer$ConditionObject</span></span><br><span class="line">        <span class="comment">// 阻塞在条件队列上</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他线程通过 signal 已经把 node 从条件队列中转移到同步队列中的数据结构中去了</span></span><br><span class="line">    <span class="comment">// 所以这里节点苏醒了，直接尝试 acquireQueued</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        <span class="comment">// 如果状态不是CONDITION，就会自动删除</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await 方法有几点需要特别注意：</p><ol><li>，节点在准备进入条件队列之前，一定会先释放当前持有的锁，不 然自己进去条件队列了，其余的线程都无法获得锁了；</li><li>Node 在条件队列中的命名，源码喜欢用 Waiter 来命名，所以我们在条件队列中看到 Waiter，其实就是 Node。</li></ol><p>await 方法中有两个重要方法：addConditionWaiter 和 unlinkCancelledWaiters， 我们一一 看下。</p><h4 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h4><p>addConditionWaiter 方法主要是把节点放到条件队列中，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加新的 waiter 到队列中，返回新添加的 waiter</span></span><br><span class="line"><span class="comment">// 如果尾节点状态不是 CONDITION 状态，删除条件队列中所有状态不是 CONDITION 的节点</span></span><br><span class="line"><span class="comment">// 如果队列为空，新增节点作为队列头节点，否则追加到尾节点上</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">    <span class="comment">// 如果尾部的 waiter 不是 CONDITION 状态了，删除</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新建条件队列 node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="comment">// 队列是空的，直接放到队列头</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="comment">// 队列不为空，直接到队列尾部</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整 体 过 程 比 较 简 单 ， 就 是 追 加 到 队 列 的 尾 部 ， 其 中 有 个 重 要 方 法 叫 做 unlinkCancelledWaiters，这个方法会删除掉条件队列中状态不是 CONDITION 的所有节点， 我们来看下 unlinkCancelledWaiters 方法的源码，如下：</p><h4 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters"></a>unlinkCancelledWaiters</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会检查尾部的 waiter 是不是已经不是CONDITION状态了</span></span><br><span class="line"><span class="comment">// 如果不是，删除所有的waiter</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    <span class="comment">// 上一个状态是,这个字段作用非常大，可以把状态都是 CONDITION 的 node 串联起来，即使 node 之间有其他节点都可以</span></span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="comment">// 当前node的状态不是CONDITION，删除自己</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            <span class="comment">//删除当前node</span></span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 如果 trail 是空的，咱们循环又是从头开始的，说明从头到当前节点的状态都不是 CONDITION</span></span><br><span class="line">            <span class="comment">// 都已经被删除了，所以移动队列头结点到当前节点的下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="comment">// 如果找到上次状态是CONDITION的节点的话，先把当前节点删掉，然后把自己挂到上一个状态是 CONDITION 的节点上</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="comment">// 遍历结束，最后一次找到的CONDITION节点就是尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 状态是 CONDITION 的 Node</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        <span class="comment">// 继续循环，循环顺序从头到尾</span></span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便大家理解这个方法，画了一个释义图，如下：</p><p><img src="image-20230220102412997.png" alt="image-20230220102412997"></p><h3 id="单个唤醒-signal"><a href="#单个唤醒-signal" class="headerlink" title="单个唤醒 signal"></a>单个唤醒 signal</h3><p>还是以阻塞队列为例，如果B线程生产完元素后 进行自我阻塞，突然队列中的元素被线程 A 消费了，线程 A 就会调用 signal 方法，唤醒之前阻塞的线 程，会从条件队列的头节点开始唤醒（流程见整体架构图中蓝色部分），源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒阻塞在条件队列中的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 从头节点开始唤醒</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// doSignal 方法会把条件队列中的节点转移到同步队列中去</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把等待队列头节点转移到同步队列去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// nextWaiter为空，说明到队尾了</span></span><br><span class="line">    <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">      lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从队列头部开始唤醒，所以直接把头结点.next 置为 null，这种操作其实就是把 node 从条件队列中移除了</span></span><br><span class="line">    <span class="comment">// 这里有个重要的点是，每次唤醒都是从队列头部开始唤醒，所以把 next 置为 null 没有关系，如果唤醒是从任意节点</span></span><br><span class="line">    <span class="comment">// 开始唤醒的话，就会有问题，容易造成链表的割裂</span></span><br><span class="line">    first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 通过while保证transferForSignal能成功</span></span><br><span class="line">    <span class="comment">// (first = firstWaiter) != null  = true 的话，表示还可以继续循环， = false 说明队列中的元素已经循环完了</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">           (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下最关键的方法：transferForSignal。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 true 表示转移成功， false 失败</span></span><br><span class="line"><span class="comment">// 大概思路：</span></span><br><span class="line"><span class="comment">// 1. node 追加到同步队列的队尾</span></span><br><span class="line"><span class="comment">// 2. 将 node 的前一个节点状态置为 SIGNAL，成功直接返回，失败直接唤醒</span></span><br><span class="line"><span class="comment">// 可以看出来 node 的状态其实仍然是 CONDITION</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="comment">// 将 node 的状态从 CONDITION 修改成初始化，失败返回 false</span></span><br><span class="line">  <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Splice onto queue and try to set waitStatus of predecessor(前任) to</span></span><br><span class="line"><span class="comment">         * indicate(表明) that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">         * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">         * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  <span class="comment">// 当前队列加入到同步队列，返回的 p 是 node 在同步队列中的前一个节点</span></span><br><span class="line">  <span class="comment">// 看命名是 p，实际是 pre 前一个单词的缩写</span></span><br><span class="line">  Node p = enq(node);</span><br><span class="line">  <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">  <span class="comment">// 状态修改成 SIGNAL，如果成功直接返回</span></span><br><span class="line">  <span class="comment">// 把当前节点的前一个节点修改成 SIGNAL 的原因，是因为 SIGNAL 本身就表示当前节点后面的节点都是需要被唤醒的</span></span><br><span class="line">  <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">    <span class="comment">// 如果 p 节点被取消，或者状态不能修改成SIGNAL，直接唤醒</span></span><br><span class="line">    LockSupport.unpark(node.thread);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全部唤醒-signalAll"><a href="#全部唤醒-signalAll" class="headerlink" title="全部唤醒 signalAll"></a>全部唤醒 signalAll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒全部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  <span class="comment">// 拿到头节点</span></span><br><span class="line">  Node first = firstWaiter;</span><br><span class="line">  <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 从头节点开始唤醒条件队列中所有的节点</span></span><br><span class="line">    doSignalAll(first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把等待队列所有节点依次转移到同步队列去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">  lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 拿出条件队列队列头节点的下一个节点</span></span><br><span class="line">    Node next = first.nextWaiter;</span><br><span class="line">    <span class="comment">// 把头节点从同步队列中删除</span></span><br><span class="line">    first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 头节点转移到同步队列中去</span></span><br><span class="line">    transferForSignal(first);</span><br><span class="line">    <span class="comment">// 开始循环头节点的下一个节点</span></span><br><span class="line">    first = next;</span><br><span class="line">  &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AbstractQueuedSynchronizer源码解析（上）</title>
      <link href="/2023/02/15/%E6%BA%90%E7%A0%81-jdk-2023-02-15-AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2023/02/15/%E6%BA%90%E7%A0%81-jdk-2023-02-15-AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>AQS 同步器 是一种模版方法的设计，事先准备了一些锁相关的方法 ，juc包中的很多锁都是利用AQS实现，如下图。如果我们掌握了AQS原理 也能实现一个锁。AQS方法较多 ，对于源码学习而言，一定要先熟悉原理，从原理入手，串通整个流程，放眼观全局，一定不要掉入到某个细节之中。</p></blockquote><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p><img src="image-20230215124430127.png" alt="image-20230215124430127"></p><p>这个图总结了 AQS 整体架构的组成，和部分场景的动态流向，图中两个点说明一下，方便大家 观看。</p><ol><li>AQS 中队列只有两个：同步队列 + 条件队列，底层数据结构两者都是链表；</li><li>图中有四种颜色的线代表四种不同的场景，1、2、3 序号代表看的顺序。</li><li>对于条件队列，大家可以咱先不关注，条件队列的作用类似 对象中的wait()和notify()方法，这个我们会单独进行讲解，为了更好的理解AQS，我们先重点关注 同步队列。</li><li>那么 我们对AQS的作用，进行一个概括就是：<ol><li><strong>通过一个共享变量，能够完成 线程的互斥</strong>。</li><li><strong>抢不到资源的线程要被阻塞，存放进同步队列，并且资源释放时能被唤醒</strong>。</li></ol></li></ol><h3 id="类注释信息"><a href="#类注释信息" class="headerlink" title="类注释信息"></a>类注释信息</h3><p>养成好习惯，我们还是看一下AQS的注释信息，可以更好的理解AQS的作用。 </p><ol><li>提供了一种框架，自定义了先进先出的同步队列，让获取不到锁的线程能进入同步队列中 排队；</li><li>同步器有个状态字段，我们可以通过状态字段来判断能否得到锁，此时设计的关键在于依 赖安全的 atomic value 来表示状态（虽然注释是这个意思，但实际上是通过把状态声明 为 volatile，在锁里面修改状态值来保证线程安全的）；</li><li>子类可以通过给状态 CAS 赋值来决定能否拿到锁，可以定义那些状态可以获得锁，哪些 状态表示获取不到锁（比如定义状态值是 0 可以获得锁，状态值是 1 就获取不到锁）；</li><li>子类可以新建非 public 的内部类，用内部类来继承 AQS，从而实现锁的功能；</li><li>AQS 提供了排它模式和共享模式两种锁模式。排它模式下：只有一个线程可以获得锁，共 享模式可以让多个线程获得锁，子类 ReadWriteLock 实现了两种模式；</li><li>内部类 ConditionObject 可以被用作 Condition，我们通过 new ConditionObject () 即 可得到条件队列；</li><li>AQS 实现了锁、排队、锁队列等框架，至于如何获得锁、释放锁的代码并没有实现，比如 tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared、isHeldExclusively 这些方法，AQS 中默认抛 UnsupportedOperationException 异常，都是需要子类去实 现的；</li><li>AQS 继承 AbstractOwnableSynchronizer 是为了方便跟踪获得锁的线程，可以帮助监 控和诊断工具识别是哪些线程持有了锁；</li><li>AQS 同步队列和条件队列，获取不到锁的节点在入队时是先进先出，但被唤醒时，可能并 不会按照先进先出的顺序执行。</li></ol><p>​    以上时AQS中比较重要的类信息。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>AQS 类定义代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>可以得出两点</p><ol><li><p>AQS 是个抽象类，就是给各种锁子类继承用的，AQS 定义了很多如何获得锁，如何释放 锁的抽象方法，目的就是为了让子类去实现；</p></li><li><p>继承了 AbstractOwnableSynchronizer，AbstractOwnableSynchronizer 的作用就是为 了知道当前是那个线程获得了锁，方便监控用的，代码如下：</p><p><img src="image-20230215134221441.png" alt="image-20230215134221441" style="zoom:40%;" /></p></li></ol><h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><p>AQS 的属性可简单分为四类：同步器简单属性、同步队列属性、条件队列属性、公用 Node。</p><h3 id="简单属性"><a href="#简单属性" class="headerlink" title="简单属性"></a>简单属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步器的状态，根据当前状态进行判断是否可以获得当前锁</span></span><br><span class="line"><span class="comment">// 如果当前state是0，那么可以获得锁</span></span><br><span class="line"><span class="comment">// 可重入锁，每次获得锁+1，每次释放锁-1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">// 自旋超时阀值，单位纳秒</span></span><br><span class="line"><span class="comment">// 当设置等待时间时才会用到这个属性</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br></pre></td></tr></table></figure><p>最重要的就是 state 属性，是 int 属性的，所有继承 AQS 的锁都是通过这个字段来判断能不能 获得锁，能不能释放锁。state就是咱们之前提的共享资源。</p><h3 id="同步队列属性"><a href="#同步队列属性" class="headerlink" title="同步队列属性"></a>同步队列属性</h3><p>线程获得不到锁时，就会封装成Node进入到同步队列的队尾。释放锁时，就会从同步队列头开始释放一个排队的线程，让线程重新去竞争锁。所以同步队列的主要作用阻塞获取不到锁的线程，并在适当时机释放这些线程。同步队列底层数据结构是个双向链表，我们从源码中可以看到链表的头尾，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步队列的头。</span></span><br><span class="line"><span class="comment">// 公平的锁先入先出。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待队列的尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure><p>源码中的 Node 是同步队列中的元素，但 Node 被同步队列和条件队列公用，所以我们在说完 条件队列属性之后再说 Node。</p><h3 id="条件队列属性"><a href="#条件队列属性" class="headerlink" title="条件队列属性"></a>条件队列属性</h3><p>条件队列和同步队列的功能一样，管理获取不到锁的线程，底层数据 结构也是链表队列，但条件队列不直接和锁打交道，但常常和锁配合使用，是一定的场景下，对 锁功能的一种补充。此外，条件队列底层是单链表，后面会详细介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件队列，从基础属性上可以看出是链表队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="comment">// 条件队列中第一个 node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">// 条件队列中最后一个 node</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ConditionObject&#125; instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConditionObject 是实现 Condition 接口的，Condition 接口相当于 Object 的各种监控方法， 比如 Object#wait ()、Object#notify、Object#notifyAll 这些方法，我们可以先这么理解，后 面会细说。</p><h3 id="公用Node"><a href="#公用Node" class="headerlink" title="公用Node"></a>公用Node</h3><p>Node 非常重要， 即是同步队列的节点， 又是条件队列的节点， 在入队的时候， 我们用 Node 把线程包装一下，然后把 Node 放入两个队列中，我们看下 Node 的数据结构，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同步队列单独的属性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//node 是共享模式</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//node 是排他模式</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点的前节点</span></span><br><span class="line">        <span class="comment">// 节点被 acquire 后就会变成head</span></span><br><span class="line">        <span class="comment">// head 节点不能被 cancelled</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点的下一个节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 两个队列共享的属性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 表示当前节点的状态，通过节点的状态来控制节点的行为</span></span><br><span class="line">        <span class="comment">// 普通同步节点，就是 0 ，条件节点是 CONDITION -2</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// waitStatus 的状态有以下几种</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;<span class="comment">//被取消</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态的意义：同步队列中的节点在自旋获取锁的时候，如果前一个节点的状态是 SIGNAL，那么自己就可以阻塞休息了，否则自己一直自旋尝试获得锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表示当前 node 正在条件队列中，当有节点从同步队列转移到条件队列时，就会被赋值成 CONDITION</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无条件传播,共享模式下，该状态的进程处于可运行状态</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在同步队列中，nextWaiter 并不真的是指向其下一个节点，我们用 next 表示同步队列的下一个节点，这只是表示当前 Node 是排他模式还是共享模式</span></span><br><span class="line">        <span class="comment">// 但在条件队列中，nextWaiter 就是表示下一个节点元素</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从 Node 的结构中， 我们需要重点关注 <strong>waitStatus</strong> 字段， Node 的很多操作都是围绕着 waitStatus 字段进行的。</p><p>Node 的 pre、next 属性是同步队列中的链表前后指向字段，nextWaiter 是条件队列中下一个 节点的指向字段，但在同步队列中，nextWaiter 只是一个标识符，表示当前节点是共享还是排 它模式。</p><h2 id="同步器状态"><a href="#同步器状态" class="headerlink" title="同步器状态"></a>同步器状态</h2><ol><li><p>state 是锁的状态，是 int 类型，子类继承 AQS 时，都是要根据 state 字段来判断有无得 到锁，比如当前同步器状态是 0，表示可以获得锁，当前同步器状态是 1，表示锁已经被 其他线程持有，当前线程无法获得锁；</p></li><li><p>waitStatus 是节点（Node）的状态，种类很多，一共有初始化 (0)、CANCELLED (1)、 SIGNAL (-1)、CONDITION (-2)、PROPAGATE (-3)，各个状态的含义可以见上文。</p></li></ol><h2 id="获得锁"><a href="#获得锁" class="headerlink" title="获得锁"></a>获得锁</h2><p>获取锁最直观的感受就是使用 Lock.lock () 方法来获得锁，最终目的是想让线程获得对资源的 访问权。</p><p>Lock 一般是 AQS 的子类，lock 方法根据情况一般会选择调用 AQS 的 acquire 或 tryAcquire 方法。</p><p>acquire 方法 AQS 已经实现了，tryAcquire 方法是等待子类去实现，acquire 方法制定了获取 锁的框架， 先尝试使用 tryAcquire 方法获取锁， 获取不到时， 再入同步队列中等待锁。 tryAcquire 方法 AQS 中直接抛出一个异常， 表明需要子类去实现， 子类可以根据同步器的 state 状态来决定是否能够获得锁，接下来我们详细看下 acquire 的源码解析。</p><p>acquire 也分两种，一种是排它锁，一种是共享锁，我们一一来看下：</p><h3 id="acquire-排它锁"><a href="#acquire-排它锁" class="headerlink" title="acquire 排它锁"></a>acquire 排它锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tryAcquire方法是需要实现类去实现的，实现思路一般都是 cas 给 stats 赋值来决定是否能获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// addWaiter 入参代表是排他模式</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上代码的主要步骤是（流程见整体架构图中红色场景）：</p><p>排他模式下，尝试获得锁</p><ol><li>如果执行一次tryAcquire就成功，直接返回，否则线程尝试进入同步队列，tryAcquire 交给子类去实现</li><li>addWaiter 把当前线程放到同步队列的队尾</li><li>acquireQueued 方法两个作用，1：阻塞当前节点，2：节点被唤醒时，使其能够获得锁</li><li>如果以上步骤都失败了，打断线程释放锁</li></ol><h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h4><p>代码很少，每个方法都是关键，接下来我们先来看下 addWaiter 的源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要目的: node 追加到同步队列的队尾</span></span><br><span class="line">    <span class="comment">// 入参是 Node 的模式（排他模式还是共享模式）</span></span><br><span class="line">    <span class="comment">// 出参是新增的 node</span></span><br><span class="line">    <span class="comment">// 新 node.pre = 队尾</span></span><br><span class="line">    <span class="comment">// 队尾.next = 新 node</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化 Node</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// 这里的逻辑和 enq 一致，enq 的逻辑仅仅多了队尾是空，初始化的逻辑</span></span><br><span class="line">        <span class="comment">// 这个思路在java源码中很常见，先简单的尝试放一下，成功立马返回，如果不行，再while循环</span></span><br><span class="line">        <span class="comment">// 很多时候，这种算法可以帮忙解决大部分的问题，大部分 部分的入队可能一次都能成功，无需自旋</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//自旋保证node加入到队尾</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程加入同步队列中方法，追加到队尾</span></span><br><span class="line">    <span class="comment">// 这里需要重点注意的是，返回值是添加 node 的前一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 得到队尾节点</span></span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="comment">// 如果队尾为空，说明当前同步队列都没有初始化，进行初始化</span></span><br><span class="line">            <span class="comment">// tail = head = new Node();</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">                <span class="comment">//当前节点置为队尾</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="comment">// node 追加到队尾</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    其中有一点值得我们学习的地方，是在 addWaiter 方法中，并没有进入方法后立马就自旋，而 是先尝试一次追加到队尾，如果失败才自旋，因为大部分操作可能一次就会成功，这种思路在我 们写自旋的时候可以借鉴。</p><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><p>下一步就是要阻塞当前线程了，是 acquireQueued 方法来实现的，我们来看下源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要做两件事情：</span></span><br><span class="line"><span class="comment">// 1：通过不断的自旋尝试使自己前一个节点的状态变成 signal，然后阻塞自己。</span></span><br><span class="line"><span class="comment">// 2：如果前一个节点获得锁，执行完成之后，再释放锁时，会把阻塞的 node 唤醒,唤醒之后再次自旋，再次无限 for 循环尝试获得锁</span></span><br><span class="line"><span class="comment">// 返回false表示获得锁成功，返回true表示失败</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 选上一个节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 有两种情况会走到 if：</span></span><br><span class="line">            <span class="comment">// 1:node 之前没有获得锁，进入 acquireQueued 方法时，发现他的前置节点就是头节点，于是尝试获得一次锁</span></span><br><span class="line">            <span class="comment">// 2:node 之前一直在阻塞沉睡，然后被唤醒，此时唤醒 node 的节点正是其前置节点，也能走到 if，具体见 release 方法</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果自己 tryAcquire 成功，就立马把自己设置成 head，把上一个节点移除</span></span><br><span class="line">            <span class="comment">// 如果 tryAcquire 失败，尝试进入同步队列</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 获得锁，设置成 head 节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//p被回收</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// shouldParkAfterFailedAcquire 把node的前一个节点状态置为SIGNAL</span></span><br><span class="line">            <span class="comment">// 只要前一个节点状态是SIGNAL了，那么自己就可以阻塞(park)了</span></span><br><span class="line">            <span class="comment">// parkAndCheckInterrupt 阻塞当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果获得node的锁失败，将node从队列中移除</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的注释还是很清楚的， 我们接着看下此方法的核心：shouldParkAfterFailedAcquire， 这个方法的主要目的就是把前一个节点的状态置为 SIGNAL， 只要前一个节点的状态是 SIGNAL， 当前节点就可以阻塞了（parkAndCheckInterrupt 就是使节点阻塞的方法）， 源码 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前线程可以安心等待的标准，就是前一个节点线程状态是SIGNAL了。</span></span><br><span class="line">   <span class="comment">// 入参 pred 是当前节点 node 的前一个节点</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 关键操作：</span></span><br><span class="line">   <span class="comment">// 1：确认前置节点是否有效，无效的话，一直往前找到状态不是取消的节点。</span></span><br><span class="line">   <span class="comment">// 2: 把前置节点状态置为 SIGNAL。</span></span><br><span class="line">   <span class="comment">// 1、2 两步操作，有可能一次就成功，有可能需要外部循环多次才能成功，但最后一定是可以成功的</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">       <span class="comment">// 如果前一个节点 waitStatus 状态已经是SIGNAL了，直接返回，不需要在自旋了</span></span><br><span class="line">       <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">            * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">// 如果当前节点状态已经被取消了。</span></span><br><span class="line">       <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">            * indicate retry.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="comment">// 找到前一个状态不是取消的节点，把当前 node 挂在有效节点身上</span></span><br><span class="line">           <span class="comment">// 因为节点状态是取消的话，是无效的，是不能作为 node 的前置节点的，所以必须找到 node 的有效节点才行</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               node.prev = pred = pred.prev;</span><br><span class="line">           &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">           pred.next = node;</span><br><span class="line">       <span class="comment">// 否则直接把节点状态置 为SIGNAL</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">            * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">            * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>acquire 整个过程非常长，代码也非常多，但注释很清楚，可以一行一行仔细看看代码。</p><p>总结一下，acquire 方法大致分为三步：</p><ol><li>使用 tryAcquire 方法尝试获得锁，获得锁直接返回，获取不到锁的走 2；</li><li>把当前线程组装成节点（Node），追加到同步队列的尾部（addWaiter）；</li><li>自旋，使同步队列中当前节点的前置节点状态为 signal 后，然后阻塞自己。</li></ol><h3 id="acquireShared-获取共享锁"><a href="#acquireShared-获取共享锁" class="headerlink" title="acquireShared 获取共享锁"></a>acquireShared 获取共享锁</h3><p>acquireShared 整体流程和 acquire 相同，代码也很相似。重复的源码就不贴了，我们就贴出 来不一样的代码来，也方便进行比较：</p><ol><li><p>第一步尝试获得锁的地方，有所不同，排它锁使用的是 tryAcquire 方法，共享锁使用的 是 tryAcquireShared 方法，如下图：</p><p><img src="image-20230218162522501.png" alt="image-20230218162522501"></p></li><li><p>第二步不同， 在于节点获得排它锁时， 仅仅把自己设置为同步队列的头节点即可 （setHead 方法），但如果是共享锁的话，还会去唤醒自己的后续节点，一起来获得该锁 （setHeadAndPropagate 方法），不同之处如下：</p><p><img src="image-20230218162646567.png" alt="image-20230218162646567"></p></li></ol><p>接下来我们一起来看下 setHeadAndPropagate 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要做两件事情</span></span><br><span class="line"><span class="comment">// 1:把当前节点设置成头节点</span></span><br><span class="line"><span class="comment">// 2:看看后续节点有无正在等待，并且也是共享模式的，有的话唤醒这些节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated(表示指示) by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism(保守) in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// propagate &gt; 0 表示已经有节点获得共享锁了</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">//共享模式，还唤醒头节点的后置节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是共享锁独特的地方，当一个线程获得锁后，它就会去唤醒排在它后面的其它节点，让其 它节点也能够获得锁。</p>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程框架Executor家族总结</title>
      <link href="/2023/02/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2023-02-13-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%86%E6%9E%B6Executor%E5%AE%B6%E6%97%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2023/02/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2023-02-13-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%86%E6%9E%B6Executor%E5%AE%B6%E6%97%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="Executor框架的结构主要包括3个部分"><a href="#Executor框架的结构主要包括3个部分" class="headerlink" title="Executor框架的结构主要包括3个部分"></a>Executor框架的结构主要包括3个部分</h3><ol><li>任务：包括被执行任务需要实现的接口：Runnable接口或Callable接口</li><li>执行(线程池)：<ul><li>Executor</li><li>以及继承自Executor的EexcutorService接口</li><li>ExecutorService接口的实现类（ThreadPoolExecutor和ScheduledThreadPoolExecutor）</li></ul></li><li>结果：包括接口Future和实现Future接口的FutureTask类</li></ol><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="image-20230213210458549.png" alt="image-20230213210458549"></p><h3 id="重要的工具类"><a href="#重要的工具类" class="headerlink" title="重要的工具类"></a>重要的工具类</h3><p> <strong>CompletableFuture</strong> : 组装异步计算单元</p><p> <strong>Executors</strong> : 生产线程池的重要工具类</p><p><img src="image-20230213212440411.png" alt="image-20230213212440411"></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程状态Blocked和Waiting</title>
      <link href="/2023/02/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2023-02-13-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81Blocked%E5%92%8CWaiting/"/>
      <url>/2023/02/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2023-02-13-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81Blocked%E5%92%8CWaiting/</url>
      
        <content type="html"><![CDATA[<p><img src="image-20230213190241261.png" alt="image-20230213190241261"></p><p>入口区:    等待获取锁的线程状态为Blocked，获取锁失败，然后线程就排队等待</p><p>等待区:    等待被唤醒的线程状态为Waiting(Time_Waiting)，线程在获取锁后调用自身的wait()方法，然后释放锁，进入等待区等待</p><p>Java线程状态中,有blocked和wating状态，都是阻塞态 但阻塞的原因有所不同，对于等待取，线程A已经获得锁，其它线程 在尝试拿锁时，就会阻塞，在java中就是实用synchronized关键字 进行加锁，失败就会阻塞进入entrySet。此时线程状态就是Blocked状态。</p><p>​    如果线程A调用了wait()方法，那么就会释放锁，自己进入waitSet，此时线程状态就是waiting状态。</p><p>还有需要注意的是，某个线程B想要获得对象锁，一般情况下有两个先决条件，一是对象锁已经被释放了（如曾经持有锁的前任线程A执行完了synchronized代码块或者调用了wait()方法等等），二是线程B已处于RUNNABLE状态。</p><p>​    那么这两类集合中的线程都是在什么条件下可以转变为RUNNABLE呢？</p><p>​    对于Entry Set中的线程，当对象锁被释放的时候，JVM会唤醒处于Entry Set中的某一个线程，这个线程的状态就从BLOCKED转变为RUNNABLE。</p><p>​    对于Wait Set中的线程，当对象的notify()方法被调用时，JVM会唤醒处于Wait Set中的某一个线程，这个线程的状态就从WAITING转变为RUNNABLE；或者当notifyAll()方法被调用时，Wait Set中的全部线程会转变为RUNNABLE状态。所有Wait Set中被唤醒的线程会被转移到Entry Set中</p><p><img src="state-machine-example-java-6-thread-states.png" alt="Protocol state machine example - Thread states and life cycle in Java."></p><blockquote><p>参考:<a href="https://www.uml-diagrams.org/java-thread-uml-state-machine-diagram-example.html" target="_blank" rel="noopener">https://www.uml-diagrams.org/java-thread-uml-state-machine-diagram-example.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML中的几种关系</title>
      <link href="/2023/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2023-02-08-UML%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%85%B3%E7%B3%BB/"/>
      <url>/2023/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2023-02-08-UML%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>前言</p><p>​    开发过程中，画类图 梳理关系，尤其应用设计模式时，经常要使用UML中的这些箭头，这些箭头多种多样并且表示的含义也不一样，今天就梳理一下，方便记忆。</p><h3 id="1-泛化"><a href="#1-泛化" class="headerlink" title="1 泛化"></a>1 泛化</h3><blockquote><p>概念：泛化表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对<code>继承</code>进行建模的<code>UML元素</code>。在Java中，用<code>extends</code>关键字表示。</p></blockquote><p><strong>表示方式：</strong>用实线空心箭头表示。</p><p><img src="1.webp" alt="img"></p><p><strong>注意：</strong>箭头方向是<code>子类</code>指向<code>父类</code>。</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2 实现"></a>2 实现</h3><blockquote><p>概念：实现是一种<code>类与接口</code>的关系，表示类是接口所有特征和行为的实现，在程序中一般通过<code>类实现接口</code>来描述。</p></blockquote><p><strong>表示方式：</strong>用虚线空心三角形箭头表示，实现类指向接口。</p><p><img src="2.jpg" alt="img"></p><h3 id="3-依赖"><a href="#3-依赖" class="headerlink" title="3 依赖"></a>3 依赖</h3><blockquote><p>概念：是一种<code>使用</code>的关系，即一个类的实现需要另一个类的协助。在Java中，方法参数需要传入另一个类的对象，就表示依赖这个类。</p></blockquote><p><strong>表示方式：</strong>虚线箭头。</p><p><img src="3.jpg" alt="img"></p><p><strong>注意：</strong>类A需要用到类B，类A指向类B。</p><h3 id="4-关联"><a href="#4-关联" class="headerlink" title="4 关联"></a>4 关联</h3><blockquote><p>概念：表示类与类之间的联接,它使一个类知道另一个类的属性和方法，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的。</p><p>在Java中，一个类的全局变量引用了另一个类，就表示关联了这个类</p></blockquote><p><strong>表示方式：</strong>实线箭头。</p><p><img src="3.jpg" alt="img"></p><p><strong>注意：</strong>类A中用到类B属性，类A指向类B。</p><h3 id="5-聚合"><a href="#5-聚合" class="headerlink" title="5 聚合"></a>5 聚合</h3><blockquote><p>概念：聚合关联关系的一种特例，是强的关联关系。聚合是整体和个体之间的关系，即has-a的关系，整体与个体可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。程序中聚合和关联关系是一致的，只能从语义级别来区分。</p></blockquote><p><strong>表示方式：</strong>尾部为空心菱形的实线箭头（也可以没箭头）。</p><p><img src="4.jpg" alt="img"></p><p><strong>注意：</strong>类A中用到类B属性，类A指向类B。</p><h3 id="6-组合"><a href="#6-组合" class="headerlink" title="6 组合"></a>6 组合</h3><blockquote><p>概念：组合也是关联关系的一种特例。组合是一种整体与部分的关系，即contains-a的关系，比聚合更强。部分与整体的生命周期一致，整体的生命周期结束也就意味着部分的生命周期结束，组合关系不能共享。程序中组合和关联关系是一致的，只能从语义级别来区分。</p></blockquote><p><strong>表示方式：</strong>尾部为实心菱形的实现箭头（也可以没箭头）。</p><p><img src="4.jpg" alt="img"></p><p><strong>注意：</strong>Head是Dog的一部分，Dog指向Head。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    本篇文章简单介绍了UML图六种箭头含义，做一个笔记方便进行记忆。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数仓中的全量表&amp;快照表&amp;流水表&amp;拉链表</title>
      <link href="/2023/02/02/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-02-02-%E6%95%B0%E4%BB%93%E4%B8%AD%E7%9A%84%E5%85%A8%E9%87%8F%E8%A1%A8-%E5%BF%AB%E7%85%A7%E8%A1%A8-%E6%B5%81%E6%B0%B4%E8%A1%A8-%E6%8B%89%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/02/02/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-02-02-%E6%95%B0%E4%BB%93%E4%B8%AD%E7%9A%84%E5%85%A8%E9%87%8F%E8%A1%A8-%E5%BF%AB%E7%85%A7%E8%A1%A8-%E6%B5%81%E6%B0%B4%E8%A1%A8-%E6%8B%89%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>​    数仓设计中经常会听到各种类型表，今天我们对这其中几种表做一下解释，通过一个例子看一下它能解决什么问题。</p><p>​    假设数据库中有一张user_balance表，用来记录用户的存款余额。</p><ol><li>2019-01-01，13点时，插入了两条数据。</li></ol><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>money</th><th>time</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>100</td><td>2019-01-01</td></tr><tr><td>002</td><td>李四</td><td>100</td><td>2019-01-01</td></tr></tbody></table></div><ol><li>2019-01-02，13点时李四又存了100，money修改为200。然后14点，李四又存了100，money修改为300。</li></ol><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>money</th><th>time</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>100</td><td>2019-01-01</td></tr><tr><td>002</td><td>李四</td><td>300</td><td>2019-01-02</td></tr></tbody></table></div><ol><li>2019-01-03，15点，新增了用户王五，他存了200</li></ol><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>money</th><th>time</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>100</td><td>2019-01-01</td></tr><tr><td>002</td><td>李四</td><td>300</td><td>2019-01-02</td></tr><tr><td>003</td><td>王五</td><td>200</td><td>2019-01-03</td></tr></tbody></table></div><p>此时就是这张表的最终状态，也是最新的记录，这就是一张<strong>全量表</strong>，对此的定义是:<strong>只记录所有数据的最新状态。</strong></p><p>可是此时有一个问题，我们发现，无法追溯历史了，比如 我此时想看李四 在2019-01-01日的余额是多少，此时已经变成最新的02日的结果了。</p><p>​    那么如何解决呢？有两个办法</p><blockquote><ol><li>快照表:把表做成分区表，并且每天定时存下当天的状态，相当于每个分区是一个快照。</li><li>拉链表:快照表每天一个快照，有些没有变更的记录也重复存了。冗余太高。所以我们希望减少冗余，对没有变化的记录 只存一条。</li></ol></blockquote><p>快照表用分区就能实现，我们看下如果使用拉链表。</p><p>拉链表带两个 start和end的字段，表示生效的开始和结束时间。</p><ol><li>2019-01-01，13点时，插入了两条数据</li></ol><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>money</th><th>start_time</th><th>end_time</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>100</td><td>2019-01-01</td><td>9999-01-01</td></tr><tr><td>002</td><td>李四</td><td>100</td><td>2019-01-01</td><td>9999-01-01</td></tr></tbody></table></div><p>2.2019-01-02，13点时李四又存了100，money修改为200。然后14点，李四又存了100，money修改为300。</p><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>money</th><th>start_time</th><th>end_time</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>100</td><td>2019-01-01</td><td>9999-01-01</td></tr><tr><td>002</td><td>李四</td><td>100</td><td>2019-01-01</td><td>2019-01-01</td></tr><tr><td>002</td><td>李四</td><td>300</td><td>2019-01-02</td><td>9999-01-01</td></tr></tbody></table></div><ol><li>2019-01-03，15点，新增了用户王五，他存了200。</li></ol><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>money</th><th>start_time</th><th>end_time</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>100</td><td>2019-01-01</td><td>9999-01-01</td></tr><tr><td>002</td><td>李四</td><td>100</td><td>2019-01-01</td><td>2019-01-01</td></tr><tr><td>002</td><td>李四</td><td>300</td><td>2019-01-02</td><td>9999-01-01</td></tr><tr><td>003</td><td>王五</td><td>200</td><td>2019-01-03</td><td>9999-01-01</td></tr></tbody></table></div><p>此时我们看到，拉链表就存下了每天的变化，能看到01号李四的余额了。</p><p>此时 又出现了一个问题，实际上李四在02号是发生了多笔交易的，我想看02号李四余额变化怎么办呢？拉链表之所以看不到02号的变化，是因为此时的拉链表 是天级别的粒度，如果让拉链表以小时级别的粒度去记录，那此时就能看到每个小时的变化，当然小时之内的变化依然看不到。其实最细粒度就是每次变化都记录下来，这样任意时刻的余额都能看到，这时候 这个表也叫做<strong>流水表</strong>。所以流水表的定义就是:<strong>记录用户的每一次修改</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离线数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hudi-增量查询</title>
      <link href="/2023/01/29/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-29-Hudi-%E5%A2%9E%E9%87%8F%E6%9F%A5%E8%AF%A2/"/>
      <url>/2023/01/29/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-29-Hudi-%E5%A2%9E%E9%87%8F%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p>前面的文章中提到过 快照查询，优化查询 其实都是对MOR类型表提的，还有一种增量查询，下面详细介绍一下。</p><h3 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h3><p>这个功能提供给用户“读取任意两个commit之间差分数据<strong>”</strong>的能力。这个功能也是基于TimeLine 的“多版本数据管理”实现的</p><p>我们还是以之前的例子，假设我们想要读取v1 → v2之间的差分数据</p><p><img src="6184128b7813f4787d776f224eacae6a.png" alt="img"></p><p><strong>Hudi会计算出v2到v1之间的差异是两个文件：fileId01_002和fileId03_001，然后client从这两个文件中读到的就是增量数据。</strong></p><p>当然我们知道，fileId01_002里面包含了两条老数据txn_id=1和txn_id=2，不属于v2到v1的差分数据，不应该被读取。确实如此。其实Hudi对每一条数据，都有<strong>一个隐藏字段_hoodie_commit_time用于记录commit时间</strong>，这个字段会和其他数据字段一起保存在parquet文件里。Hudi在读取parquet文件时，会同时用这个字段对结果进行过滤，把不属于时间范围内的记录都过滤掉。</p><h3 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h3><ol><li><p>插入一批数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">1</span>,<span class="string">"user_id"</span>:<span class="string">"ww1"</span>,<span class="string">"amount"</span>:<span class="number">90</span>,<span class="string">"date"</span>:<span class="string">"20210708"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">2</span>,<span class="string">"user_id"</span>:<span class="string">"ww2"</span>,<span class="string">"amount"</span>:<span class="number">35</span>,<span class="string">"date"</span>:<span class="string">"20210708"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">3</span>,<span class="string">"user_id"</span>:<span class="string">"ww3"</span>,<span class="string">"amount"</span>:<span class="number">35</span>,<span class="string">"date"</span>:<span class="string">"20210708"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">4</span>,<span class="string">"user_id"</span>:<span class="string">"ww4"</span>,<span class="string">"amount"</span>:<span class="number">45</span>,<span class="string">"date"</span>:<span class="string">"20210709"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">5</span>,<span class="string">"user_id"</span>:<span class="string">"ww5"</span>,<span class="string">"amount"</span>:<span class="number">25</span>,<span class="string">"date"</span>:<span class="string">"20210709"</span>&#125;</span><br></pre></td></tr></table></figure><p> 执行结果:</p><p><img src="image-20230129143834143.png" alt="image-20230129143834143"></p><p>此时记录的元数据记录:</p><p><img src="image-20230129143935411.png" alt="image-20230129143935411"></p><ol><li><p>更新txn_id=3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">3</span>,<span class="string">"user_id"</span>:<span class="string">"ww333"</span>,<span class="string">"amount"</span>:<span class="number">25</span>,<span class="string">"date"</span>:<span class="string">"20210708"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">6</span>,<span class="string">"user_id"</span>:<span class="string">"ww6"</span>,<span class="string">"amount"</span>:<span class="number">25</span>,<span class="string">"date"</span>:<span class="string">"20210710"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">7</span>,<span class="string">"user_id"</span>:<span class="string">"ww7"</span>,<span class="string">"amount"</span>:<span class="number">25</span>,<span class="string">"date"</span>:<span class="string">"20210710"</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230129144111622.png" alt="image-20230129144111622"></p></li></ol></li></ol><p>​        <img src="image-20230129144158388.png" alt="image-20230129144158388"></p><ol><li><p>进行增量查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxd.prac.hudi</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.SparkSession</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Intellij IDEA.</span></span><br><span class="line"><span class="comment"> * User:  张晓东</span></span><br><span class="line"><span class="comment"> * Date:  2022/5/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">object IncrementalQueryFromHudi &#123;</span><br><span class="line">  <span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span>: Unit </span>= &#123;</span><br><span class="line">    val session: SparkSession = SparkSession.builder().master(<span class="string">"local"</span>)</span><br><span class="line">      .config(<span class="string">"spark.serializer"</span>,<span class="string">"org.apache.spark.serializer.KryoSerializer"</span>)</span><br><span class="line">      .appName(<span class="string">"test"</span>).getOrCreate()</span><br><span class="line">    val basePath = <span class="string">"hdfs://localhost:8020/hudi_batch_tb"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第1步、加载Hudi表数据，获取commit time时间，作为增量查询数据阈值</span></span><br><span class="line">    <span class="keyword">import</span> org.apache.hudi.DataSourceReadOptions._</span><br><span class="line">    <span class="keyword">import</span> session.implicits._</span><br><span class="line"></span><br><span class="line">    session.read</span><br><span class="line">      .format(<span class="string">"hudi"</span>)</span><br><span class="line">      .load(basePath)</span><br><span class="line">      .createOrReplaceTempView(<span class="string">"view_temp_hudi"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第2步、设置Hudi数据CommitTime时间阈值，进行增量数据查询</span></span><br><span class="line">    val incrementalDF = session.read</span><br><span class="line">      .format(<span class="string">"hudi"</span>)</span><br><span class="line">      <span class="comment">// 设置查询数据模式为：incremental，增量读取</span></span><br><span class="line">      .option(QUERY_TYPE.key(), QUERY_TYPE_INCREMENTAL_OPT_VAL)</span><br><span class="line">      <span class="comment">// 设置增量读取数据时开始时间-commitTime</span></span><br><span class="line">      .option(BEGIN_INSTANTTIME.key(),<span class="number">20230129144059250L</span>)</span><br><span class="line">      .load(basePath)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第3步、将增量查询数据注册为临时视图 进行sql查询</span></span><br><span class="line">    incrementalDF.createOrReplaceTempView(<span class="string">"hudi_incremental"</span>)</span><br><span class="line">    session</span><br><span class="line">      .sql(</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">  |select</span></span><br><span class="line"><span class="string">  | _hoodie_commit_time,_hoodie_record_key,user_id,txn_id</span></span><br><span class="line"><span class="string">  |from</span></span><br><span class="line"><span class="string">  |  hudi_incremental</span></span><br><span class="line"><span class="string">          |</span></span><br><span class="line"><span class="string">  |"</span><span class="string">""</span>.stripMargin</span><br><span class="line">      )</span><br><span class="line">      .show();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意代码中设置的INSTANTIME时间戳，结果如下:</p><p><img src="image-20230129144831627.png" alt="image-20230129144831627"></p><p>在修改时间戳，改成一个更早的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option(BEGIN_INSTANTTIME.key(),<span class="number">20230129140059250L</span>)</span><br></pre></td></tr></table></figure><p>结果如下:</p><p><img src="image-20230129145106698.png" alt="image-20230129145106698"></p></li></ol><p>利用BEGIN_INSTANTTIME与END_INSTANTTIME 可以选择某一段时间的增量数据，并结合SQL中的过滤条件进行筛选，找到想要的数据.</p>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hudi-事务原理详解</title>
      <link href="/2023/01/14/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-14-Hudi-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/01/14/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-14-Hudi-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>​    之前的文章对Hudi的更新操作原理进行了较为详细的讲解，接下来是Hudi的另一大特色-事务功能。</p><h2 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h2><p>Hudi的事务功能被称为Timeline，因为Hudi把所有对一张表的操作都保存在一个时间线对象里面。Hudi官方文档中对于Timeline功能的介绍稍微有点复杂，不是很清晰。其实从用户角度来看的话，Hudi提供的事务相关能力主要是这些：</p><div class="table-container"><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">原子性</td><td style="text-align:left">写入即使失败，也不会造成数据损坏</td></tr><tr><td style="text-align:left">隔离性</td><td style="text-align:left">读写分离，写入不影响读取，不会读到写入中途的数据</td></tr><tr><td style="text-align:left">回滚</td><td style="text-align:left">可以回滚变更，把数据恢复到旧版本</td></tr><tr><td style="text-align:left">时间旅行</td><td style="text-align:left">可以读取旧版本的数据（但太老的版本会被清理掉）</td></tr><tr><td style="text-align:left">存档</td><td style="text-align:left">可以长期保存旧版本数据（存档的版本不会被自动清理）</td></tr><tr><td style="text-align:left">增量读取</td><td style="text-align:left">可以读取任意两个版本之间的差分数据</td></tr></tbody></table></div><p>介绍完功能清单，接下来就讲一讲事务的实现原理。内容以COW表为主，但MOR表也可以由此类推，因为MOR表本质上是对COW表的优化。</p><p>假设我们还是5条初始数据:</p><div class="table-container"><table><thead><tr><th style="text-align:left">txn_id</th><th style="text-align:left">user_id</th><th style="text-align:left">item_id</th><th style="text-align:left">amount</th><th style="text-align:left">date</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">2</td><td style="text-align:left">20220101</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">2</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">20220101</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">1</td><td style="text-align:left">2</td><td style="text-align:left">3</td><td style="text-align:left">20220101</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">1</td><td style="text-align:left">3</td><td style="text-align:left">1</td><td style="text-align:left">20220102</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">2</td><td style="text-align:left">3</td><td style="text-align:left">2</td><td style="text-align:left">20220102</td></tr></tbody></table></div><p>实际存储的目录结构是这样的（文件名做了简化）</p><p>warehouse<br>├── .hoodie<br>├── 20220101<br>│   ├── fileId1_001.parquet<br>│   └── fileId1_002.parquet<br>├── 20220102<br>│   └── fileId2_001.parquet<br>└── 20220103<br>    └── fileId3_001.parquet</p><p>它的数据保存在fileId1_001和fileId2_001两个文件里。</p><p><img src="56c63fed2fbf6a7aa2d61dffde656a0c.png" alt="img"></p><p>我们称呼这个版本为v1。接下来我们写入3条新的数据，其中1条是更新，2条是新增。</p><div class="table-container"><table><thead><tr><th style="text-align:left">txn_id</th><th style="text-align:left">user_id</th><th style="text-align:left">item_id</th><th style="text-align:left">amount</th><th style="text-align:left">date</th></tr></thead><tbody><tr><td style="text-align:left">3</td><td style="text-align:left">1</td><td style="text-align:left">2</td><td style="text-align:left">5</td><td style="text-align:left">20220101</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">1</td><td style="text-align:left">4</td><td style="text-align:left">1</td><td style="text-align:left">20220103</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">2</td><td style="text-align:left">3</td><td style="text-align:left">2</td><td style="text-align:left">20220103</td></tr></tbody></table></div><p>写入后的目录结构如下</p><p>warehouse<br>├── .hoodie<br>├── 20220101<br>│   ├── fileId1_001.parquet<br>│   └── fileId1_002.parquet<br>├── 20220102<br>│   └── fileId2_001.parquet<br>└── 20220103<br>    └── fileId3_001.parquet</p><p>更新的1条数据（txn_id=3）保存在fileId1_002这个文件里，而新增的2条数据（txn_id=6和txn_id=7）则被保存在fileId3_001。</p><p><img src="fa7801402d780c592c07db317b401dd5.png" alt="img"></p><p>我们称呼更新后的版本为v2。</p><p>Hudi在这张表的timeline里（实际存放在.hoodie目录下）会记录下v1和v2对应的文件列表。<strong>当client读取数据时，首先会查看timeline里最新的commit是哪个，从最新的commit里获得对应的文件列表，再去这些文件读取真正的数据。</strong></p><p><img src="6184128b7813f4787d776f224eacae6a.png" alt="img"></p><p>v1和v2对应的文件</p><p>Hudi通过这种方式实现了多版本隔离的能力。当一个client正在读取v1的数据时，另一个client可以同时写入新的数据，新的数据会被写入新的文件里，不影响v1用到的数据文件。只有当数据全部写完以后，v2才会被commit到timeline里面。后续的client再读取时，读到的就是v2的数据。</p><p>顺带一提的是，尽管Hudi具备多版本数据管理的能力，但旧版本的数据不会无限制地保留下去。Hudi会在新的commit完成时开始清理旧的数据，默认的策略是“<strong>清理早于10个commit前的数据</strong>”。</p><h3 id="TimeLine"><a href="#TimeLine" class="headerlink" title="TimeLine"></a>TimeLine</h3><p>概念</p>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hudi-MOR优化原理详解</title>
      <link href="/2023/01/14/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-14-Hudi-MOR%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/01/14/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-14-Hudi-MOR%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>Merge on Read</strong>（简称MOR表），是Hudi最初开源时尚处于“实验阶段”的新功能，在开源后的0.3.5版本开始才告完成。<strong>现在则是Hudi最常用的表类型。</strong></p><p>Merge on Read是对Copy on Write的优化。优化了什么呢？主要是写入性能。</p><p>导致COW表写入慢的原因，是因为<strong>COW表每次在写入时，会把新写入的数据和老数据合并以后，再写成新的文件。</strong>单单是写入的过程（不包含前期的repartition和tagging过程），就包含至少三个步骤：</p><ol><li>读取老数据的<a href="https://so.csdn.net/so/search?q=parquet&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">parquet</a>文件（涉及对parquet文件解码，<strong>不轻松</strong>）</li><li>将老数据和新数据合并</li><li>将合并后的数据重新写成parquet文件（又涉及parquet文件编码，<strong>也不轻松</strong>）</li></ol><p>种种原因导致COW表的写入速度始终快不起来，限制了其在时效性要求高，写入量巨大的场景下的应用。</p><h2 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h2><p>​    为了解决COW表写入速度上的瓶颈，Hudi采用了另一种写入方式：<strong>upsert时把变更内容写入log文件，然后定期合并log文件和base文件。</strong>这样的好处是避免了写入时读取老数据，也就避免了parquet文件<strong>不轻松</strong>的编解码过程，只需要把变更记录写入一个文件即可（而且是顺序写入）。显然是<strong>轻松了不少</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">warehouse</span><br><span class="line">├── .hoodie</span><br><span class="line">├── 20220101</span><br><span class="line">│   ├── fileId1_001.parquet</span><br><span class="line">│   ├── .fileId1_20220312163419285.log</span><br><span class="line">│   └── .fileId1_20220312172212361.log</span><br><span class="line">└── 20220102</span><br><span class="line">├── fileId2_001.parquet</span><br><span class="line">    └── .fileId2_20220312163512913.log</span><br></pre></td></tr></table></figure><p><em>典型的MOR表的目录，注意log文件包含写入的时间戳</em></p><p>这时或许会有疑问，“这样写入固然是轻松了，但怎么读到最新的数据呢？”<strong>是个好问题。</strong>为了解决读取最新数据的问题，Hudi提供了好几种机制，但从原理上来说只有两种：</p><ol><li><strong>读取数据时，同时从base文件和log文件读取，并把两边的数据合并</strong></li><li><strong>定期地、异步地把log文件的数据合并到base文件（这个过程被称为compaction）</strong></li></ol><p>第一种机制也是Merge on Read这个名字的由来，因为<strong>Hudi的读取过程是实时地把base数据和log数据合并起来，并返回给用户</strong>。注意这两种机制不是非此即彼的，而是互为补充。Hudi的默认配置就是同时使用这两种机制，即：<strong>读取时merge，同时定期地compact。</strong></p><p>在读取时合并数据，听起来很影响效率。<strong>事实也是如此</strong>，因为实时合并的实现方式是把所有log文件读入内存，放在一个HashMap里，然后遍历base文件，把base数据和缓存在内存里的log数据进行join，最后才得到合并后的结果。难免会影响到读取效率。</p><p>COW影响写入，MOR影响读取，那有没有什么办法可以兼顾读写，鱼与熊掌能不能得兼？<strong>目前来说不能</strong>，好在Hudi把选择权留给了用户，让用户可以根据自身的业务需求，选择不同的query类型。</p><p>对于MOR表，Hudi支持3种query类型，分别是</p><ol><li>Snapshot Query</li><li>Incremental Query</li><li>Read Optimized Query</li></ol><p>其中1和3就是为了平衡读和写之间的取舍。这两者的区别是：Snapshot Query和上文所说的一样，读取时进行“实时合并”；Read Optimized Query则不同，<strong>只读取base文件，不读取log文件</strong>，因此读取效率和COW表相同，但读到的数据可能不是最新的。</p><p>官方对两种query类型的解释如下:</p><p><img src="0e2694ad19e84802d8cb206b3394f81d.png" alt="img"></p><h2 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h2><p>写入代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxd.prac.hudi</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hudi.DataSourceWriteOptions</span><br><span class="line"><span class="keyword">import</span> org.apache.hudi.DataSourceWriteOptions.&#123;MOR_TABLE_TYPE_OPT_VAL, PARTITIONPATH_FIELD, PRECOMBINE_FIELD, RECORDKEY_FIELD, TABLE_NAME, TABLE_TYPE&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.hudi.config.HoodieWriteConfig</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;DataFrame, SaveMode, SparkSession&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Intellij IDEA.</span></span><br><span class="line"><span class="comment"> * User:  dante</span></span><br><span class="line"><span class="comment"> * Date:  2022/5/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">object InsertDataToHudi &#123;</span><br><span class="line">  <span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span>: Unit </span>= &#123;</span><br><span class="line">    System.getProperties.setProperty(<span class="string">"HADOOP_USER_NAME"</span>, <span class="string">"james"</span>)</span><br><span class="line">    val session: SparkSession = SparkSession.builder().master(<span class="string">"local"</span>).appName(<span class="string">"test"</span>)</span><br><span class="line">      .config(<span class="string">"spark.serializer"</span>, <span class="string">"org.apache.spark.serializer.KryoSerializer"</span>)</span><br><span class="line">      .getOrCreate()</span><br><span class="line">    session.sparkContext.setLogLevel(<span class="string">"Error"</span>)</span><br><span class="line"></span><br><span class="line">    val df: DataFrame = session.read.json(<span class="string">"file:///Users/james/IdeaProjects/Learn-Advance/Spark-Plus/src/main/resources/appendData1.json"</span>)</span><br><span class="line">    <span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line">    val newdf: DataFrame = df.withColumn(</span><br><span class="line">      <span class="string">"partition_key"</span>,col(<span class="string">"date"</span>)</span><br><span class="line">    )</span><br><span class="line">    newdf.show()</span><br><span class="line"></span><br><span class="line">    newdf.write.format(<span class="string">"hudi"</span>)</span><br><span class="line">      .option(RECORDKEY_FIELD.key(),<span class="string">"txn_id"</span>)</span><br><span class="line">      .option(PRECOMBINE_FIELD.key(),<span class="string">"date"</span>)</span><br><span class="line">      .option(PARTITIONPATH_FIELD.key(),<span class="string">"partition_key"</span>)</span><br><span class="line">      .option(<span class="string">"hoodie.upsert.shuffle.parallelism"</span>,<span class="string">"2"</span>)</span><br><span class="line">      .option(<span class="string">"hoodie.insert.shuffle.parallelism"</span>,<span class="string">"2"</span>)</span><br><span class="line">      .option(<span class="string">"hoodie.parquet.small.file.limit"</span>,<span class="string">"0"</span>)</span><br><span class="line">      .option(<span class="string">"hoodie.table.name"</span>,<span class="string">"batch_tb"</span>)</span><br><span class="line">      .option(TABLE_TYPE.key(),MOR_TABLE_TYPE_OPT_VAL)</span><br><span class="line">      .mode(SaveMode.Append)</span><br><span class="line">      .save(<span class="string">"hdfs://localhost:8020/hudi_data/batch_tb"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>第一次写入，观察base文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">1</span>,<span class="string">"user_id"</span>:<span class="string">"ww1"</span>,<span class="string">"amount"</span>:<span class="number">90</span>,<span class="string">"date"</span>:<span class="string">"20210708"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">2</span>,<span class="string">"user_id"</span>:<span class="string">"ww2"</span>,<span class="string">"amount"</span>:<span class="number">35</span>,<span class="string">"date"</span>:<span class="string">"20210708"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">3</span>,<span class="string">"user_id"</span>:<span class="string">"ww3"</span>,<span class="string">"amount"</span>:<span class="number">35</span>,<span class="string">"date"</span>:<span class="string">"20210708"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">4</span>,<span class="string">"user_id"</span>:<span class="string">"ww4"</span>,<span class="string">"amount"</span>:<span class="number">45</span>,<span class="string">"date"</span>:<span class="string">"20210709"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">5</span>,<span class="string">"user_id"</span>:<span class="string">"ww5"</span>,<span class="string">"amount"</span>:<span class="number">25</span>,<span class="string">"date"</span>:<span class="string">"20210709"</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230114225053604.png" alt="image-20230114225053604"></p></li><li><p>第二次写入，观察增量log文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">3</span>,<span class="string">"user_id"</span>:<span class="string">"ww333"</span>,<span class="string">"amount"</span>:<span class="number">25</span>,<span class="string">"date"</span>:<span class="string">"20210708"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">6</span>,<span class="string">"user_id"</span>:<span class="string">"ww6"</span>,<span class="string">"amount"</span>:<span class="number">25</span>,<span class="string">"date"</span>:<span class="string">"20210710"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">7</span>,<span class="string">"user_id"</span>:<span class="string">"ww7"</span>,<span class="string">"amount"</span>:<span class="number">25</span>,<span class="string">"date"</span>:<span class="string">"20210710"</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230114225208581.png" alt="image-20230114225208581"></p></li><li><p>观察快照读，txn_id=3的user_id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxd.prac.hudi</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hudi.DataSourceReadOptions.&#123;QUERY_TYPE, QUERY_TYPE_SNAPSHOT_OPT_VAL&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.hudi.&#123;DataSourceReadOptions, DataSourceWriteOptions&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.hudi.config.HoodieWriteConfig</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;DataFrame, SaveMode, SparkSession&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Intellij IDEA.</span></span><br><span class="line"><span class="comment"> * User:  dante</span></span><br><span class="line"><span class="comment"> * Date:  2022/5/31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">object ReadHudi &#123;</span><br><span class="line">  <span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span>: Unit </span>= &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val session: SparkSession = SparkSession.builder().master(<span class="string">"local"</span>)</span><br><span class="line">      .config(<span class="string">"spark.serializer"</span>,<span class="string">"org.apache.spark.serializer.KryoSerializer"</span>)</span><br><span class="line">      .appName(<span class="string">"test"</span>).getOrCreate()</span><br><span class="line">    val basePath = <span class="string">"hdfs://localhost:8020/hudi_data/batch_tb"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    val snapshotDF = session.</span><br><span class="line">      read</span><br><span class="line">      .format(<span class="string">"hudi"</span>)</span><br><span class="line">      .option(QUERY_TYPE.key(),QUERY_TYPE_SNAPSHOT_OPT_VAL)</span><br><span class="line">      .load(basePath)</span><br><span class="line"></span><br><span class="line">      snapshotDF.createOrReplaceTempView(<span class="string">"hudi_tmp_table"</span>)</span><br><span class="line">      session.sql(<span class="string">"select user_id from  hudi_tmp_table where txn_id = 3"</span>).show()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------+</span><br><span class="line">|user_id|</span><br><span class="line">+-------+</span><br><span class="line">|  ww333|</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure></li><li><p>观察优化读</p><p>修改查询类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   val snapshotDF = session.</span><br><span class="line">      read</span><br><span class="line">      .format(<span class="string">"hudi"</span>)</span><br><span class="line"><span class="comment">//      .option(QUERY_TYPE.key(),QUERY_TYPE_SNAPSHOT_OPT_VAL)</span></span><br><span class="line">      .option(QUERY_TYPE.key(),QUERY_TYPE_READ_OPTIMIZED_OPT_VAL)</span><br><span class="line">      .load(basePath)</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------+</span><br><span class="line">|user_id|</span><br><span class="line">+-------+</span><br><span class="line">|    ww3|</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure><p> 显然，此时读的不是最新结果</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hudi-Upsert操作原理详解</title>
      <link href="/2023/01/13/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-13-Hudi-Upsert%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/01/13/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-13-Hudi-Upsert%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    首先介绍下Hudi的背景，因为背景对理解一个项目很关键。<br>​    Hudi，正式的全称是Hadoop Upsert Delete and Incremental。其实关于这个名字也不用太较真，因为都是后来附会上去的，从源代码里可以看到这个项目最初的名字是hoodie和现在的名字发音相同。但这个名字还是透露了一些信息的，那就是Hudi项目最初的设计目标:在hadoop上实现update和delete操作。<br>​    为什么会有update和delete的需求? uber在开源Hudi的文章中解释了:</p><blockquote><p>最初uber使用的是Lambda架构，但是有个问题是计算逻辑分为批量和实时两种，要保持两者的逻辑完全一致很困难(毕竟是两套代码)。<br>然后uber转向了Kappa架构，使得两套代码变为-套，但是存储依然有两套，分别支持实时写入和批量写入。</p></blockquote><p>为了把存储也统-起来，减少运维的压力，就需要让负责批量写入的存储系统也能支持实时写入，这就产生了update和delete的需求。为什么呢?有多种原因，例如实时计算常有的迟到数据，还有业务时效性要求以及一些合规需求(GDPR要 求平台允许用户删除自己的数据)。而众所众知的是，无论是HDFS还是云平台的对象存储(例如aws的s3，阿里云的oss等)，都不支持update而只 能overwrite,因此要实现update和delete功能，就必须在底层存储之上做文章。Hudi于 是应运而生。</p><h2 id="Upsert原理解释"><a href="#Upsert原理解释" class="headerlink" title="Upsert原理解释"></a>Upsert原理解释</h2><p>Upsert可以说是Hudi的招牌，正如上⼀节所说，Hudi最初的设计⽬标就是在hadoop上实现数据的update。于是这⾥的核⼼问题就是：</p><blockquote><p>如何在⼀个只能overwrite的⽂件系统上实现update操作？</p></blockquote><p>Hudi解决了这个问题，使⽤了⼀种很简单的思想，那就是：</p><blockquote><p>把⼀个完整的⽂件拆分为多个“⼩⽂件”，当需要更新其中某条记录时，只要把包含这条记录的“⼩⽂件”给重写⼀遍即可。</p></blockquote><p>Hudi最大的特征就是表类型有两种 COW和MOR，我们以COW表来举例说明更新写入原理。之所以先讲COW表，是因为这种类型的表原理更加简单，也是MOR表的基础。⽽且Hudi最初的版本只⽀持COW表，可 见这是Hudi的⽴项之本。</p><p>接下来⽤⼀个例⼦直观地展⽰下COW表的upsert是如何实现的。</p><p>⾸先，假设我们向⼀张Hudi表中预先写⼊了5⾏数据，如下</p><div class="table-container"><table><thead><tr><th>txn_id</th><th>user_id</th><th>item_id</th><th>amount</th><th>date</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>2</td><td>20220101</td></tr><tr><td>2</td><td>2</td><td>1</td><td>1</td><td>20220101</td></tr><tr><td>3</td><td>1</td><td>2</td><td>3</td><td>20220101</td></tr><tr><td>4</td><td>1</td><td>3</td><td>1</td><td>20220102</td></tr><tr><td>5</td><td>2</td><td>3</td><td>2</td><td>20220102</td></tr></tbody></table></div><p>这时在我们的hdfs⾥⾯，会有下⾯2个⽬录，以及1个隐藏的.hoodie⽬录。</p><p>warehouse</p><p>├── .hoodie</p><p>├── 20220101</p><p>│ └── fileId1_001.parquet </p><p>└── 20220102</p><p>​     └── fileId2_001.parquet</p><p>⽂件名分为两部分，fileId是Hudi中的⼀个概念，后⾯会做解释，001则是commitId。</p><p>画成图就是</p><p><img src="image-20230113161324925.png" alt="image-20230113161324925" style="zoom: 80%;" /></p><p>​    可以看到，属于20220101分区的3条数据保存在⼀个parquet⽂件：fileId1_001.parquet，属于20220102分区的2条数据则保存在另 ⼀个parquet⽂件：fileId2_001.parquet。</p><p>然后我们再写⼊3条新的数据。其中有2条数据是新增，1条数据是更新。写⼊的数据如下</p><div class="table-container"><table><thead><tr><th>txn_id</th><th>user_id</th><th>item_id</th><th>amount</th><th>date</th></tr></thead><tbody><tr><td>3</td><td>1</td><td>2</td><td>5</td><td>20220101</td></tr><tr><td>6</td><td>1</td><td>4</td><td>1</td><td>20220103</td></tr><tr><td>7</td><td>2</td><td>3</td><td>2</td><td>20220103</td></tr></tbody></table></div><p>写⼊完成后，hdfs⾥⾯的⽂件结构会变成这样</p><p>warehouse</p><p>├── .hoodie</p><p>├── 20220101</p><p>│ ├── fileId1_001.parquet </p><p>│ └── fileId1_002.parquet </p><p>├── 20220102</p><p>│ └── fileId2_001.parquet </p><p>└── 20220103</p><p> └── fileId3_001.parquet</p><p>注意.hoodie这个⽬录，⾥⾯保存了hudi的元数据。</p><p>画成图就是</p><p><img src="image-20230113161715887.png" alt="image-20230113161715887"></p><p>可以看到，更新的那⼀条记录，实际被写⼊到了同⼀个分区下的新⽂件：fileId1_002.parquet。这个新⽂件的fileId和上⼀个相同，只不过 commitId变成了002。同时还有⼀个新⽂件：fileId3_001.parquet。</p><p>update到这⾥就算完成了，那么使⽤这张表的⽤户⼜是如何读到更新以后的数据呢？Hudi客户端在读取这张表时，会根据.hoodie⽬录下保 存的元数据信息，获知需要读取的⽂件是：fileId1_002.parquet，fileId2_001.parquet，fileId3_001.parquet。这些⽂件⾥保存的正是 最新的数据。</p><p><img src="image-20230113161759476.png" alt="image-20230113161759476"></p><p>读取的是最新的⽂件</p><p>以上就是Hudi实现update的原理。在有了相对直观的理解之后，可以为我们后续学习Hudi打下扎实的基础</p><h2 id="写入原理小结"><a href="#写入原理小结" class="headerlink" title="写入原理小结"></a>写入原理小结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df.write.format(<span class="string">"hudi"</span>).</span><br><span class="line">option(RECORDKEY_FIELD_OPT_KEY, <span class="string">"txn_id"</span>)</span><br><span class="line">.option(PARTITIONPATH_FIELD_OPT_KEY, <span class="string">"date"</span>)</span><br><span class="line">.option(TABLE_NAME, tableName)</span><br><span class="line">.mode(Overwrite)</span><br><span class="line">.save()</span><br></pre></td></tr></table></figure><p>注意到这⾥有两个必填的配置项：RECORDKEY_FIELD_OPT_KEY和PARTITIONPATH_FIELD_OPT_KEY，它们的含义是“作为 recordKey的字段名”，“作为partitionPath的字段名”。请记住这两个字段，在后⾯的写⼊过程中有⾮常重要的作⽤。</p><p>Upsert的过程整体分为3步（这⾥省略了很多不太重要的步骤）：</p><ol><li><p>根据partitionPath进⾏重新分区。</p></li><li><p>根据recordKey确定哪些记录需要插⼊，哪些记录需要更新。对于需要更新的记录，还需要找到旧的记录所在的⽂件。（这个过程被 称为tagging）</p></li><li><p>把记录写⼊实际的⽂件。</p><ol><li><p>Step1. 重新分区 ⽆论DataFrame在写⼊前是如何分区的，Hudi都会对它们进⾏重新分区。重新分区的依据就是partitionPath。partitionPath相同的 record都会被分到同⼀个partition，并交给⼀个executor负责写⼊。上⾯例⼦中的配置项PARTITIONPATH_FIELD_OPT_KEY就是⽤来 指定record⾥⾯的哪个字段作为partitionPath。 </p></li><li><p>Step2. Tagging 在确定了每个record的partition之后，接下来做的就是tagging。tagging是写⼊过程中最重要的⼀步，核⼼逻辑是确定每条record是 insert还是update，以及如果是update，则定位到上次写⼊时的fileId。 Hudi如何确定⼀条record是insert还是update？是通过recordKey。⽤户在写⼊时需要指定每条record的recordKey，Hudi会⽤这个 recordKey和现有的数据进⾏⽐对，如果找到⼀条key相同的record，则认为这次新的写⼊是update，否则就是insert。 对于⼀条update的数据，也就是说之前曾经插⼊过相同key的record，那么Hudi会把旧的record的fileId取出来，作为这条新record的 fileId。之前⼀直没有解释fileId的含义，现在可以解释下了。fileId是Hudi为每条record赋予的id，⽤于标识这条record被保存在哪个⽂件 ⾥，或者更严格地说，是“哪⼀批⽂件”⾥。由于每次update都会⽣成⼀个新的⽂件，但是共享同⼀个fileId，所以最终会变成⼀批⽂件。 Hudi把具有相同fileId的⼀批⽂件称为file group。最后，fileId本⾝是⼀个uuid，是全局唯⼀的.</p><p>warehouse</p><p>├── .hoodie</p><p>├── 20220101</p><p>│ ├── fileId1_001.parquet </p><p>│ └── fileId1_002.parquet </p><p>├── 20220102</p><p>│ └── fileId2_001.parquet </p><p>└── 20220103</p><p>​    └── fileId3_001.parquet</p><p>⽂件名⾥包含fileId1的2个⽂件就是⼀个file group</p><p>整个tagging过程还有⼀个显⽽易见的问题，那就是tagging需要在已有的数据⾥寻找key相同的record，如果表的数据量⽐较⼤时会⾮常 耗时。为了解决这个问题，Hudi引⼊了index机制，这个后续再谈。</p></li><li><p>Step3. 写⼊⽂件</p><p>当tagging完成以后，就会开始真正地写⼊数据。Hudi会把需要写⼊的数据分为insert和update两部分，update的数据会⽤原来的fileId进 ⾏写⼊，insert的数据则会⽣成⼀个新的fileId⽤于写⼊。值得⼀提的是，insert的数据也不会全部写⼊到同⼀个⽂件，⽽是到达了⼀定阈值 （由hoodie.parquet.max.file.size配置项控制）以后，关闭当前⽂件，换⼀个新的⽂件继续写⼊（同时也会⽣成⼀个新的fileId）。</p></li></ol></li></ol><h2 id="实践验证"><a href="#实践验证" class="headerlink" title="实践验证"></a>实践验证</h2><p>写入代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxd.prac.hudi</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hudi.DataSourceWriteOptions</span><br><span class="line"><span class="keyword">import</span> org.apache.hudi.DataSourceWriteOptions.&#123;PARTITIONPATH_FIELD, PRECOMBINE_FIELD, RECORDKEY_FIELD, TABLE_NAME&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.hudi.config.HoodieWriteConfig</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;DataFrame, SaveMode, SparkSession&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Intellij IDEA.</span></span><br><span class="line"><span class="comment"> * User:  dante</span></span><br><span class="line"><span class="comment"> * Date:  2022/5/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">object InsertDataToHudi &#123;</span><br><span class="line">  <span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span>: Unit </span>= &#123;</span><br><span class="line">    System.getProperties.setProperty(<span class="string">"HADOOP_USER_NAME"</span>, <span class="string">"james"</span>)</span><br><span class="line">    val session: SparkSession = SparkSession.builder().master(<span class="string">"local"</span>).appName(<span class="string">"test"</span>)</span><br><span class="line">      .config(<span class="string">"spark.serializer"</span>, <span class="string">"org.apache.spark.serializer.KryoSerializer"</span>)</span><br><span class="line">      .getOrCreate()</span><br><span class="line">    session.sparkContext.setLogLevel(<span class="string">"Error"</span>)</span><br><span class="line"></span><br><span class="line">    val df: DataFrame = session.read.json(<span class="string">"file:///Users/james/IdeaProjects/Learn-Advance/Spark-Plus/src/main/resources/appendData4.json"</span>)</span><br><span class="line">    <span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line">    val newdf: DataFrame = df.withColumn(</span><br><span class="line">      <span class="string">"partition_key"</span>,col(<span class="string">"date"</span>)</span><br><span class="line">    )</span><br><span class="line">    newdf.show()</span><br><span class="line"></span><br><span class="line">    newdf.write.format(<span class="string">"hudi"</span>)</span><br><span class="line">      .option(RECORDKEY_FIELD.key(),<span class="string">"txn_id"</span>)</span><br><span class="line">      .option(PRECOMBINE_FIELD.key(),<span class="string">"date"</span>)</span><br><span class="line">      .option(PARTITIONPATH_FIELD.key(),<span class="string">"partition_key"</span>)</span><br><span class="line">      .option(<span class="string">"hoodie.upsert.shuffle.parallelism"</span>,<span class="string">"2"</span>)</span><br><span class="line">      .option(<span class="string">"hoodie.insert.shuffle.parallelism"</span>,<span class="string">"2"</span>)</span><br><span class="line">      .option(<span class="string">"hoodie.parquet.small.file.limit"</span>,<span class="string">"0"</span>)</span><br><span class="line">      .option(<span class="string">"hoodie.table.name"</span>,<span class="string">"batch_tb"</span>)</span><br><span class="line">      .mode(SaveMode.Append)</span><br><span class="line">      .save(<span class="string">"hdfs://localhost:8020/hudi_data/batch_tb"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>插入第一批数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">1</span>,<span class="string">"user_id"</span>:<span class="string">"ww1"</span>,<span class="string">"amount"</span>:<span class="number">90</span>,<span class="string">"date"</span>:<span class="string">"20210708"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">2</span>,<span class="string">"user_id"</span>:<span class="string">"ww2"</span>,<span class="string">"amount"</span>:<span class="number">35</span>,<span class="string">"date"</span>:<span class="string">"20210708"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">3</span>,<span class="string">"user_id"</span>:<span class="string">"ww3"</span>,<span class="string">"amount"</span>:<span class="number">35</span>,<span class="string">"date"</span>:<span class="string">"20210708"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">4</span>,<span class="string">"user_id"</span>:<span class="string">"ww4"</span>,<span class="string">"amount"</span>:<span class="number">45</span>,<span class="string">"date"</span>:<span class="string">"20210709"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">5</span>,<span class="string">"user_id"</span>:<span class="string">"ww5"</span>,<span class="string">"amount"</span>:<span class="number">25</span>,<span class="string">"date"</span>:<span class="string">"20210709"</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><p>​    执行完成后,看一下效果图</p><p><img src="image-20230113222733751.png" alt="image-20230113222733751"></p><p><img src="image-20230113222750700.png" alt="image-20230113222750700"></p><p>2.插入第二批数据，其中txn_id为3的是更新操作，6 7为新增</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">3</span>,<span class="string">"user_id"</span>:<span class="string">"ww333"</span>,<span class="string">"amount"</span>:<span class="number">25</span>,<span class="string">"date"</span>:<span class="string">"20210708"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">6</span>,<span class="string">"user_id"</span>:<span class="string">"ww6"</span>,<span class="string">"amount"</span>:<span class="number">25</span>,<span class="string">"date"</span>:<span class="string">"20210710"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">7</span>,<span class="string">"user_id"</span>:<span class="string">"ww7"</span>,<span class="string">"amount"</span>:<span class="number">25</span>,<span class="string">"date"</span>:<span class="string">"20210710"</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230113223205259.png" alt="    "></p><p> 我们看到08分区，此时又生成了一个parquent文件，我们不妨来看一下，第一个,第二个文件的内容都是什么 </p><p>第一个文件内容:</p><p><img src="image-20230113223912600.png" alt="image-20230113223912600">    </p><p>第二个文件内容:</p><p><img src="image-20230113224110404.png" alt="image-20230113224110404"></p><p> 我们可以清晰的看到，更新的数据发生了变更，而老数据也保留了下来，所以说此时，最新的commit_id代表最新的状态，而file_id代表这插入的第一批数据即 txn_id $ \subset $  {1,2,3,4,5}</p><ol><li>假如我们第三次插入,此时为新增操作，依然重点观察08分区</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">8</span>,<span class="string">"user_id"</span>:<span class="string">"ww8"</span>,<span class="string">"amount"</span>:<span class="number">25</span>,<span class="string">"date"</span>:<span class="string">"20210708"</span>&#125;</span><br><span class="line">&#123;<span class="string">"txn_id"</span>:<span class="number">9</span>,<span class="string">"user_id"</span>:<span class="string">"ww9"</span>,<span class="string">"amount"</span>:<span class="number">25</span>,<span class="string">"date"</span>:<span class="string">"20210708"</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20230113225214127.png" alt="image-20230113225214127"></p><p>  我们看一下最新的文件内容</p><p><img src="image-20230113225421927.png" alt="image-20230113225421927"></p><p>可以看到只有最新这次插入的数据，相当于此次插入的数据是新的一批数据。</p>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Huid-表类型</title>
      <link href="/2023/01/12/Huid-%E8%A1%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/01/12/Huid-%E8%A1%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hudi-查询类型</title>
      <link href="/2023/01/12/Hudi-%E6%9F%A5%E8%AF%A2%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/01/12/Hudi-%E6%9F%A5%E8%AF%A2%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hudi-核心概念</title>
      <link href="/2023/01/12/Hudi-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/01/12/Hudi-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Huid-数据管理</title>
      <link href="/2023/01/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2023-01-12-Huid-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
      <url>/2023/01/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2023-01-12-Huid-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hudi介绍</title>
      <link href="/2023/01/12/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-12-Hudi%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/01/12/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-12-Hudi%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="数据湖框架"><a href="#数据湖框架" class="headerlink" title="数据湖框架"></a>数据湖框架</h2><p>目前市面上流行的三大开源数据湖方案分别为：<strong>Delta Lake、Apache Iceberg和Apache Hudi</strong>。</p><ul><li><p>Delta Lake：DataBricks公司推出的一种数据湖方案，网址：<a href="https://delta.io/" target="_blank" rel="noopener">https://delta.io/</a> </p><p><img src="image-20230112191104747.png" alt="image-20230112191104747" style="zoom: 50%;" /></p></li><li><p>Apache Iceberg：以类似于SQL的形式高性能的处理大型的开放式表，网址：<a href="https://iceberg.apache.org/" target="_blank" rel="noopener">https://iceberg.apache.org/</a></p><p><img src="image-20230112192733730.png" alt="image-20230112192733730" style="zoom:30%;" /></p></li><li><p>Apache Hudi：Hadoop Upserts anD Incrementals，管理大型分析数据集在HDFS上的存储，网址：<a href="https://hudi.apache.org/" target="_blank" rel="noopener">https://hudi.apache.org/</a></p><p><img src="image-20230112192901158.png" alt="image-20230112192901158" style="zoom:20%;" /></p><p>这三种技术中，我们重点介绍Hudi技术。</p><h3 id="Apache-Hudi"><a href="#Apache-Hudi" class="headerlink" title="Apache Hudi"></a>Apache Hudi</h3><ul><li>Apache Hudi：提供的fast upsert/delete以及compaction等功能，管理存储在HDFS上数据，设计目标正如其名，Hadoop Upserts Deletes and Incrementals（原为 Hadoop Upserts anD Incrementals）。</li></ul><p><img src="image-20230112193620181.png" alt="image-20230112193620181" style="zoom: 33%;" /></p><ul><li><p>强调其主要支持Upserts、Deletes和Incrementa数据处理，支持三种数据写入方式：UPSERT，INSERT 和 BULK_INSERT。</p><p><img src="image-20230112194812579.png" alt="image-20230112194812579" style="zoom:67%;" /></p></li></ul></li></ul><h2 id="Apache-Hudi-基本介绍"><a href="#Apache-Hudi-基本介绍" class="headerlink" title="Apache Hudi 基本介绍"></a><strong>Apache Hudi 基本介绍</strong></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>Hudi（Hadoop Upserts anD Incrementals缩写）：用于管理分布式文件系统DFS上大型分析数据集存储。</li><li>一言以蔽之，Hudi是一种针对分析型业务的、扫描优化的数据存储抽象，它能够使DFS数据集在分钟级的时延内支持变更，也支持下游系统对这个数据集的增量处理。</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>Hudi是在大数据存储上的一个数据集，可以将Change Logs通过upsert的方式合并进Hudi；</li><li>Hudi 对上可以暴露成一个普通Hive或Spark表，通过API或命令行可以获取到增量修改的信息，继续供下游消费；</li><li>Hudi 保管修改历史，可以做时间旅行或回退；</li><li>Hudi 内部有主键到文件级的索引，默认是记录到文件的布隆过滤器；</li></ul><p>​    <img src="image-20230112194625805.png" alt="image-20230112194625805" style="zoom:25%;" /></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>​    Apache Hudi使得用户能在Hadoop兼容的存储之上存储大量数据，同时它还提供两种原语，不仅可以批处理，还可以在数据湖上进行流处理。</p><ul><li>Update/Delete记录：Hudi使用细粒度的文件/记录级别索引来支持Update/Delete记录，同时还提供写操作的事务保证。查询会处理最后一个提交的快照，并基于此输出结果。</li><li>变更流：Hudi对获取数据变更提供了一流的支持：可以从给定的时间点获取给定表中已updated/inserted/deleted的所有记录的增量流，并解锁新的查询姿势（类别）。</li></ul><p>​    <img src="image-20230112195821168.png" alt="image-20230112195821168" style="zoom:50%;" /></p><h3 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h3><ul><li>通过DeltaStreammer、Flink、Spark等工具，将数据摄取到数据湖存储，可使用HDFS作为数据湖的数据存储；</li><li>基于HDFS可以构建Hudi的数据湖；</li><li>Hudi提供统一的访问Spark数据源和Flink数据源；</li><li>外部通过不同引擎，如：Spark、Flink、Presto、Hive、Impala、Aliyun DLA、AWS Redshit访问接口；</li></ul><p>​    <img src="image-20230112201813832.png" alt="image-20230112201813832" style="zoom:30%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据为什么需要数据湖？</title>
      <link href="/2023/01/12/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-12-%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%E6%B9%96/"/>
      <url>/2023/01/12/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-12-%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%E6%B9%96/</url>
      
        <content type="html"><![CDATA[<p>​    当前基于Hive的离线数据仓库已经非常成熟，在传统的离线数据仓库中对记录级别的数据进行更新是非常麻烦的，需要对待更新的数据所属的整个分区，甚至是整个表进行全面覆盖才行，由于离线数仓多级逐层加工的架构设计，数据更新时也需要从贴源层开始逐层反应到后续的派生表中去。</p><p>​    随着实时计算引擎的不断发展以及业务对于实时报表的产出需求不断膨胀，业界最近几年就一直聚焦并探索于实时数仓建设。根据数仓架构演变过程，在Lambda架构中含有离线处理与实时处理两条链路，其架构图如下：</p><p><img src="image-20230112160105041.png" alt="image-20230112160105041"></p><p>正是由于两条链路处理数据导致数据不一致等一些列问题所以才有了Kappa架构，Kappa架构如下：</p><p><img src="image-20230112160321996.png" alt="image-20230112160321996"></p><p>Kappa架构可以称为真正的实时数仓，目前在业界最常用实现就是Flink + Kafka，然而基于Kafka+Flink的实时数仓方案也有几个非常明显的缺陷，所以在目前很多企业中实时数仓构建中经常使用混合架构，没有实现所有业务都采用Kappa架构中实时处理实现。Kappa架构缺陷如下：</p><ul><li>Kafka无法支持海量数据存储。对于海量数据量的业务线来说，Kafka一般只能存储非常短时间的数据，比如最近一周，甚至最近一天。</li><li>Kafka无法支持高效的OLAP查询，大多数业务都希望能在DWD\DWS层支持即席查询的，但是Kafka无法非常友好地支持这样的需求。</li><li>无法复用目前已经非常成熟的基于离线数仓的数据血缘、数据质量管理体系。需要重新实现一套数据血缘、数据质量管理体系。</li><li>Kafka不支持update/upsert，目前Kafka仅支持append。</li></ul><p>​        为了解决Kappa架构的痛点问题，业界最主流是采用“批流一体”方式，这里批流一体可以理解为批和流使用SQL同一处理，也可以理解为处理框架的统一，例如：Spark、Flink，但这里更重要指的是存储层上的统一，只要存储层面上做到“批流一体”就可以解决以上Kappa遇到的各种问题。数据湖技术可以很好的实现存储层面上的“批流一体”，这就是为什么大数据中需要数据湖的原因。</p>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据湖技术的发展</title>
      <link href="/2023/01/12/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-12-%E6%95%B0%E6%8D%AE%E6%B9%96%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95/"/>
      <url>/2023/01/12/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-12-%E6%95%B0%E6%8D%AE%E6%B9%96%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h2 id="数据湖的定义"><a href="#数据湖的定义" class="headerlink" title="数据湖的定义"></a>数据湖的定义</h2><p>Wikipedia是这样定义的:</p><blockquote><p>数据湖是一类存储数据自然/原始格式的系统或存储，通常是对象块或者文件。数据湖通常是企业中全量数据的单一存储 。<font color=red>全量数据包括原始系统所产生的原始数据拷贝以及为了各类任务而产生的转换数据，各类任务包括报表、可视化、高级分析和机器学习</font>。数据湖中包括来自于关系型数据库中的结构化数据(行和列)、半结构化数据(如CSV、日志、XML、JSON)、非结构化数据(如email、 文档、PDF等)和二进制数据(如图像、音频、视频)。数据沼泽是一种退化的、缺乏管理的数据湖，数据沼泽对于用户来说要么是不可访问的要么就是无法提供足够的价值。</p></blockquote><p>可能看了这段定义，我们还是不清楚这个数据湖到底是什么东西，我们可以通过对比数据仓库来进一步的解释，要注意数据湖依然是一个概念，需要具体的技术来实现，当然越是概念的东西，越容易让人感到模糊。</p><h2 id="数据仓库VS数据湖"><a href="#数据仓库VS数据湖" class="headerlink" title="数据仓库VS数据湖"></a>数据仓库VS数据湖</h2><h3 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h3><ul><li><p>数据仓库 是一个用于<strong>存储、分析、报告的数据系统</strong>。 </p></li><li><p>数据仓库的目的是构建<strong>面向分析</strong>的集成化数据环境，分析结果<strong>为企业提供决策支持</strong></p></li><li><p>数据仓库的特点是本身不生产数据，也不最终消费数据</p></li><li><p>每个企业根据自己的业务需求可以分成不同的层次。但是最基础的分层思想，理论上分为三个层：操作型数据层（ ODS<strong>）、数据仓库层(</strong>DW<strong>)和数据应用层(</strong>DA)。 </p><p><img src="image-20230112110629654.png" alt="image-20230112110629654" style="zoom:80%;" /></p></li></ul><h3 id="数据湖"><a href="#数据湖" class="headerlink" title="数据湖"></a>数据湖</h3><ul><li>数据湖（Data Lake）和数据库、数据仓库一样，都是数据存储的设计模式，现在企业的数据仓库都会通过分层的方式将数据存储在文件夹、文件中。</li><li>数据湖是一个集中式数据存储库，用来存储大量的原始数据，使用平面架构来存储数据。</li><li>数据湖越来越多的用于描述任何的大型数据池，数据都是以原始数据方式存储，知道需要查询应用数据的时候才会开始分析数据需求和应用架构。</li></ul><p>通俗的解释，数据湖就是用来存原始数据的一个文件系统，其实也是为了弥补数仓的缺陷，数仓是分层的，是一个纵向的，需要对原始数据进行一系列处理才能使用，而且只能处理格式化数据。而对于机器学习，数据分析这类技术，更多的使用原始数据，可能不需进数仓，随着机器学习，数据挖掘的火爆，就越来越需要这样一个对原始数据进行存放，组织的地方，数据湖技术因此诞生。</p><p><img src="image-20230112141937021.png" alt="image-20230112141937021" style="zoom:30%;" /></p><h3 id="数据仓库与数据湖的比较"><a href="#数据仓库与数据湖的比较" class="headerlink" title="数据仓库与数据湖的比较"></a>数据仓库与数据湖的比较</h3><p><img src="image-20230112142159045.png" alt="image-20230112142159045"></p><p>通过对比，数据仓库和数据湖面向的主体不一样，也有各自的优劣。所以又提出了“湖仓一体”的概念，下文我们进行解释。</p><h2 id="数据湖的演进"><a href="#数据湖的演进" class="headerlink" title="数据湖的演进"></a>数据湖的演进</h2><p><img src="image-20230112142703183.png" alt="image-20230112142703183"></p><p>​    通过上图，我们可以较清晰的看到，从数仓到湖仓一体整个发展过程，已经起的作用。而现在大火的湖仓一体的概念，其实离不开 数据仓库本身的发展，此时湖仓一体中的”仓“ 指的就是真正的实时数仓，也就是图中的Streaming Analytics 。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>数据湖本质上就是一个数据存储，利用hdfs 通过简单的规划组织，就成为了一个数据湖。而湖仓一体概念，面向的群众就不止是大数据，包括算法、数据分析人员。</li><li>数据湖技术在大数据领域中，可以用来解决 “流批一体”中的存储问题。</li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各大公司实时数仓实践</title>
      <link href="/2023/01/10/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-10-%E5%90%84%E5%A4%A7%E5%85%AC%E5%8F%B8%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/01/10/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-10-%E5%90%84%E5%A4%A7%E5%85%AC%E5%8F%B8%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="网易实时数仓实践"><a href="#网易实时数仓实践" class="headerlink" title="网易实时数仓实践"></a>网易实时数仓实践</h2><p><img src="image-20230110200432765.png" alt="image-20230110200432765"></p><p>​    此架构是基于Kudu的实时数据数仓，通过Data Stream自己写的数据采集工具来采集日志数据写入Kafka，使用NDC(类似CDC)服务可以将binlog数据推送到Kafka，通过Flink读取Kafka数据结果写入Kudu,基于Kudu构建实时数仓好处就是延迟低（毫秒/秒级）；支持upsert；支持水平扩展。但是也存在一些问题，例如：</p><ul><li>突然数据量增多，基于内存会有很大的Compaction操作，会造成数据服务不可用;</li><li>数据孤岛问题，Kudu很难与HDFS中的数据做贯通，形成数据孤岛；</li><li>不支持更新主键。</li></ul><h2 id="汽车之家实时数仓实践"><a href="#汽车之家实时数仓实践" class="headerlink" title="汽车之家实时数仓实践"></a>汽车之家实时数仓实践</h2><p><img src="image-20230110200608945.png" alt="image-20230110200608945"></p><p>​        在2016年汽车之家使用Storm构建实时平台，存在很多痛点，例如：纯编码方式开发，开发成本高；Storm不支持状态，当有状态业务是借助Redis实现，计算效率低，假设数据扩增多，Redis集群扩容不及时容易产生问题；Storm不支持SQL开发，对数仓不友好等。</p><p>​        2019年之后所有实时业务转向Flink处理，使用以上架构，以上架构中数据接入包含三部分：Client log 、Server log 、DB CDC，三部分数据内容如下：</p><ul><li>Client log:在汽车之家大部分数据都是端的数据，例如：用户手机端,PC端，数据包含用户行为数据，例如：浏览数据，播放数据时长日志。</li><li>Server log:包含数据质量监控的日志，服务端的日志，主要用来做一些监控报警，例如：Nginx日志，各种web应用的日志，各种中间件的日志，大数据各种应用的底层日志。</li><li>DB CDC:  各种实时大屏，日志看板，例如：实时订单展示。</li></ul><p>​        在上面架构中数据接收后通过Flink处理写入Kafka主要原因是来自Client log 、Server log 、DB CDC 数据格式是不统一的，通过Flink处理后，将格式统一成规范的json数据再写入Kafka。数据写入Redis和ES的主要作用是做实时数据缓存。最终这些Flink处理后的数据用来BI展示、推荐、风险控制、实时监控。</p><h2 id="顺丰实时数仓实践"><a href="#顺丰实时数仓实践" class="headerlink" title="顺丰实时数仓实践"></a>顺丰实时数仓实践</h2><p>​        顺丰是国内领先的快递物流综合服务商， 顺丰使用大数据服务支撑了高质量的物流服务，其快递流转过程如下：<img src="image-20230110200754760.png" alt="image-20230110200754760"></p><p>​        正是由于复杂的业务所以构建数仓。早期采用了Lambda架构构建数仓，随着实时业务增多，Lambda架构的弊端也慢慢凸显，后期改为实时数仓。</p><p>​        实时数仓和离线数仓实际上解决的都是相同的业务问题，最大的区别在于时效性，离线数仓有小时级和天级的延迟，而实时数仓则是秒级和分钟级的延迟，其他部分都相似，例如：数据源、数据存储、数据开发都是比较相近。为了解决开发者的割裂感，将离线和实时业务进行统一，并且可以通过实时的引擎来加速离线报表产出。 顺丰实时数仓架构如下：</p><p><img src="image-20230110200815297.png" alt="image-20230110200815297"></p><p>以上架构中 使用Hudi来加速宽表数据，这个是如何实现的？</p><p>Hudi的关键特性如下：</p><ul><li>可回溯历史数据</li><li>在大规模数据集中更新删除</li><li>根据主键更新删除</li><li>在数据写入时支持复制</li><li>在数据读取时支持聚合</li><li>支持视图，增量视图和实时视图</li><li>Hudi可以作为数据源发出增量数据</li><li>异步压缩小文件，合并小文件</li></ul><p>​    以ODS层为例，在ODS层引入Hudi可以使原来ODS层T+1抽取数据变为实时抽取数据，同时使用Flink消费Kafka中的数据，获取增量数据，通过Hudi将数据增量更新到Hive DWD等宽表中，将离线增量转变为实时增量。    </p><p>​    <img src="image-20230110201439921.png" alt="image-20230110201439921"></p><p>​    注意：Hudi写入的过程是批处理的过程，且Hudi强依赖于Spark，顺丰对Hudi进行了修改完善。</p><h2 id="腾讯实时数仓实践"><a href="#腾讯实时数仓实践" class="headerlink" title="腾讯实时数仓实践"></a>腾讯实时数仓实践</h2><p>​        腾讯内部有QQ音乐、腾讯广告、腾讯看点、小程序、视频号等业务线每天数据量在万亿级别，这些服务线在构建各自的数据分析平台时采用的数据平台架构如下：        <img src="image-20230110201606795.png" alt="image-20230110201606795"></p><p>​        以上数据平台架构中，常常会使用一些离线调度系统定期调度Spark任务进行数据接入、ELT、展示过程，例如针对腾讯看点业务线，数据前方会有埋单，通过数据服务将数据接入到数据仓库，再通过ES/MySQL/ClickHouse对外提供数据展示。整个过程中,对于离线平台，数据接入、处理数据延迟一般是小时级别或者T+1级别，为了一些实时性需求，最初采用的是Lambda架构，分为批流两条线路，在实时链路中采用Flink处理，离线中使用Spakr进行处理，Lambda架构有一些痛点，例如：大大增加数据仓库阶段中组件复杂度、运维成本增加、数据不一致等，所以后期转换到基于Flink+Kafka的Kappa架构，在Kappa架构中也有痛点，例如：</p><ul><li>对消息队列存储要求高，消息队列的回溯能力不及离线存储</li><li>消息队列本身对数据存储有时效性，且当前无法使用OLAP引擎直接分析消息队列中的数据</li><li>全链路依赖消息队列的实时计算可能因为数据的时序性导致结果不正确</li></ul><p>最后决定升级改造Kappa架构，基于Flink+Iceberg来针对实时数据流构建实时数仓，架构如下：</p><p><img src="image-20230110201838142.png" alt="image-20230110201838142"></p><p>​    腾讯采用的是Flink+Iceberg方式构建实时数仓，其架构图如上，即将原有Kappa架构中的Kafka替换成了Iceberg,有如下好处：</p><ul><li>实现了存储层的流批统一，存储成本降低</li><li>中间层支持OLAP分析，可以基于Iceberg针对实时数仓中的某些层做一些OLAP分析，将结果输出到下游。</li><li>Iceberg底层存储依赖于HDFS并且支持列式存储，可以基于中间某些层使用Flink做一些计算，那么可以将原来Kappa架构中离线链路中天级别延时降低到小时级别或者分钟级别。 </li></ul><p>​    将Kappa架构改造之后实际上也带来了一些缺点，例如：向Kafka中写数据与向HDFS中写数据相对比，肯定是向Kafka中写数据更快，所以将Kafka替换成Iceberg之后，数据延迟从实时变成近实时；Iceberg对接其他数据系统需要额外的开发工作，不如Kafka完善。这些缺点可以认为是Iceberg目前发展不完善导致，随着Iceberg的发展，这些问题也会一一得到解决。</p><h2 id="滴滴实时数仓实践"><a href="#滴滴实时数仓实践" class="headerlink" title="滴滴实时数仓实践"></a>滴滴实时数仓实践</h2><p>​    在2019年之前，滴滴内部都是自建的实时服务，没有统一规定实时引擎，这些自建服务中包含Spark和Flink任务，开发成本比较高，使用低级api的方式进行业务开发。这个阶段更多的是业务驱动，没有专门的实时数仓概念,大家都是分散建设。</p><p>​    在2019年之后，公司内部统一了实时计算的引擎为Flink,并且对Flink引擎内部做了一些增强，实时数仓正式在某些业务上进行实践。在2020年下半年，公司内部对实时开发平台进行升级，实时数仓建设主要集中在任务统一规划和数仓规范性建设方面。目前，在滴滴中每日运行核心作业150+，覆盖的核心指标有200+(包括了公司各个业务线的产品)，资源总量10000+（core），各个业务线产品包含：滴滴出行（网约车，拼车各个业务线）、滴滴顺风车独立业务线、DIDI广告业务独立业务线、橙心优选独立业务线，体系架构如下：</p><p><img src="image-20230110202343782.png" alt="image-20230110202343782"></p><p>​    以上体系架构图就是滴滴整体业务架构图，底层是数据源，中间也做了数据仓库分层，包括ODS层，DWD明细层是将ODS层数据库binlog、Public Log、Topic、消息队列同步过来，DWD包含三类数据：业务数据（订单交易），流量数据（主要是埋点获取用户行为数据，用作用户分析），维度数据（用户数据、司机数据、车辆行驶数据、拍照数据等维度数据），DWM层就是指标汇总层，对一些核心的指标做一些汇总，包括：冒泡、呼单、完单、PV、UV、财务、安全等。APP层更多是关于数据展现，包括数据看板，数据产品，还包含实时接口服务（主要提供给数据使用方，例如数据监管，保证数据一致性等），OLAP分析（数据检验，临时性业务分析）等。最上面是面向某些特定用户提供平台使用，如：高管、运营、业务、分析、开发。左侧数据体系建设规范包括表命名规范，字段命名规范，任务调度规范，数据规范、运维规范等。右侧是内部开发计算引擎平台。</p><p>滴滴整体数据链路架构图如下：</p><p><img src="image-20230110202406262.png" alt="image-20230110202406262"></p><p>​        数据链路最左侧是数据源，通过平台任务汇集到ODS层Kafka、DDMQ(滴滴内部自研消息队列) ，后经Flink进行数据清洗和维度建设，维度存入HBase，数据经过清洗落入DWD层，再经过一些核心Flink任务，数据落入DWS层，在这两层有一些OLAP任务（部分核心任务基于DWD、DWS层进行OLAP查询分析），针对DWS层再经过一些Flink任务数据还会做一些指标汇总形成DM汇聚层，这一层对外提供数据服务形成APP层，APP层主要是一些产品、看板、报表、接口调度服务，主要是数据应用，包括构建指标体系，帮助业务同学看清业务发展情况、针对营销活动（补贴，营销活动），看到活动效果，快速进行策略调整、针对反作弊场景，构建算法策略，快速识别风险。目前消息队列使用的是Kafka和DDMQ,维度数据存入HBase, OLAP引擎正在由Druid向ClickHouse迁移。</p>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实时数仓的发展趋势-流批一体</title>
      <link href="/2023/01/10/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-10-%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93%E7%9A%84%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF-%E6%B5%81%E6%89%B9%E4%B8%80%E4%BD%93/"/>
      <url>/2023/01/10/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-10-%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93%E7%9A%84%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF-%E6%B5%81%E6%89%B9%E4%B8%80%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="实时数仓现状"><a href="#实时数仓现状" class="headerlink" title="实时数仓现状"></a>实时数仓现状</h2><p>当前基于Hive的离线数据仓库已经非常成熟，随着实时计算引擎的不断发展以及业务对于实时报表的产出需求不断膨胀，业界最近几年就一直聚焦并探索于实时数仓建设。根据数仓架构演变过程，在Lambda架构中含有离线处理与实时处理两条链路，其架构图如下：</p><p><img src="image-20230110192027938.png" alt="image-20230110192027938"></p><p>​    正是由于两条链路处理数据导致数据不一致等一些列问题所以才有了Kappa架构，Kappa架构如下：</p><p><img src="image-20230110192101609.png" alt="image-20230110192101609"></p><p>​        Kappa架构可以称为真正的实时数仓，目前在业界最常用实现就是Flink + Kafka，然而基于Kafka+Flink的实时数仓方案也有几个非常明显的缺陷，所以在目前很多企业中实时数仓构建中经常使用混合架构，没有实现所有业务都采用Kappa架构中实时处理实现。Kappa架构缺陷如下：</p><ul><li><p>Kafka无法支持海量数据存储。对于海量数据量的业务线来说，Kafka一般只能存储非常短时间的数据，比如最近一周，甚至最近一天。</p></li><li><p>Kafka无法支持高效的OLAP查询，大多数业务都希望能在DWD\DWS层支持即席查询的，但是Kafka无法非常友好地支持这样的需求。</p></li><li><p>无法复用目前已经非常成熟的基于离线数仓的数据血缘、数据质量管理体系。需要重新实现一套数据血缘、数据质量管理体系。</p></li><li>Kafka不支持update/upsert，目前Kafka仅支持append。实际场景中在DWS轻度汇聚层很多时候是需要更新的，DWD明细层到DWS轻度汇聚层一般会根据时间粒度以及维度进行一定的聚合，用于减少数据量，提升查询性能。假如原始数据是秒级数据，聚合窗口是1分钟，那就有可能产生某些延迟的数据经过时间窗口聚合之后需要更新之前数据的需求。这部分更新需求无法使用Kafka实现。</li></ul><p>​        所以实时数仓发展到现在的架构，一定程度上解决了数据报表时效性问题，但是这样的架构依然存在不少问题，随着技术的发展，相信基于Kafka+Flink的实时数仓架构也会进一步往前发展，那么到底往哪些方向发展，我们可以结合大公司中技术选型可以推测实时数仓的发展大致会走向“批流一体”。</p><h2 id="流批一体"><a href="#流批一体" class="headerlink" title="流批一体"></a>流批一体</h2><p>​        最近一两年中和实时数仓一样火的概念是“批流一体”，那么到底什么是“批流一体”？在业界中很多人认为批和流在开发层面上都统一到相同的SQL上处理是批流一体，也有一些人认为在计算引擎层面上批和流可以集成在同一个计算引擎是批流一体，比如：Spark/SparkStreaming/Structured Streaming/Flink框架在计算引擎层面上实现了批处理和流处理集成。</p><p>​        以上无论是在业务SQL使用上统一还是计算引擎上的统一，都是批流一体的一个方面，除此之外，批流一体还有一个最核心的方面就是存储层面上的统一。这个方面上也有一些流行的技术：delta/hudi/iceberg,存储一旦能够做到统一，例如：一些大型公司使用Iceberg作为存储，那么Kappa架构中很多问题都可以得到解决，Kappa架构将变成个如下模样：</p><p>​        <img src="image-20230110192245658.png" alt="image-20230110192245658"></p><p>​        这条架构中无论是流处理还是批处理，数据存储都统一到数据湖Iceberg上，这一套结构将存储统一后，解决了Kappa架构很多痛点，解决方面如下：</p><ul><li>可以解决Kafka存储数据量少的问题。目前所有数据湖基本思路都是基于HDFS之上实现的一个文件管理系统，所以数据体量可以很大。</li><li>DW层数据依然可以支持OLAP查询。同样数据湖基于HDFS之上实现，只需要当前的OLAP查询引擎做一些适配就可以进行OLAP查询。</li><li>批流存储都基于Iceberg/HDFS存储之后，就完全可以复用一套相同的数据血缘、数据质量管理体系。</li><li>实时数据的更新。</li></ul><p>上述架构也可以认为是Kappa架构的变种，也有两条数据链路，一条是基于Spark的离线数据链路，一条是基于Flink的实时数据链路，通常数据都是直接走实时链路处理，而离线链路则更多的应用于数据修正等非常规场景。这样的架构要成为一个可以落地的实时数仓方案、可以做到实时报表产生，这得益于Iceberg技术：</p><ul><li><p>支持流式写入-增量拉取</p><p>流式写入其实现在基于Flink就可以实现，无非是将checkpoint间隔设置的短一点，比如1分钟，就意味每分钟生成的文件就可以写入到HDFS，这就是流式写入。但是这里有两个问题，第一个问题是小文件很多，但这不是最关键的，第二个问题才是最致命的，就是上游每分钟提交了很多文件到HDFS上，下游消费的Flink是不知道哪些文件是最新提交的，因此下游Flink就不知道应该去消费处理哪些文件。这个问题才是离线数仓做不到实时的最关键原因之一，离线数仓的玩法是说上游将数据全部导入完成了，告诉下游说这波数据全部导完了，你可以消费处理了，这样的话就做不到实时处理。</p><p>数据湖就解决了这个问题。实时数据链路处理的时候上游Flink写入的文件进来之后，下游就可以将数据文件一致性地读走。这里强调一致性地读，就是不能多读一个文件也不能少读一个文件。上游这段时间写了多少文件，下游就要读走多少文件。我们称这样的读取叫增量拉取</p></li><li><p>解决小文件多的问题</p><p>数据湖实现了相关合并小文件的接口，Spark/Flink上层引擎可以周期性地调用接口进行小文件合并。</p></li><li><p>支持批量以及流式的Upsert(Delete)功能</p><p>批量Upsert/Delete功能主要用于离线数据修正。流式upsert场景上文介绍了，主要是流处理场景下经过窗口时间聚合之后有延迟数据到来的话会有更新的需求。这类需求是需要一个可以支持更新的存储系统的，而离线数仓做更新的话需要全量数据覆盖，这也是离线数仓做不到实时的关键原因之一，数据湖是需要解决掉这个问题的。</p></li><li><p>支持比较完整的OLAP生态</p><p>比如支持Hive/Spark/Presto/Impala等OLAP查询引擎，提供高效的多维聚合查询性能。</p><p>目前Iceberg部分功能还在开发中，有一些功能还不完善，但是整体实时数仓的发展会大致朝着这个方向行进。目前业界大多数公司还是处于Lambda架构，使用Kappa架构的公司一般都是实时业务居多的公司，随着数据湖技术的发展，这些公司实时数仓的构建慢慢会走向最终的“批流一体”。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实时数仓建设思考</title>
      <link href="/2023/01/09/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-09-%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93%E5%BB%BA%E8%AE%BE%E6%80%9D%E8%80%83/"/>
      <url>/2023/01/09/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-09-%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93%E5%BB%BA%E8%AE%BE%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="离线数仓与实时数仓区别"><a href="#离线数仓与实时数仓区别" class="headerlink" title="离线数仓与实时数仓区别"></a>离线数仓与实时数仓区别</h2><div class="table-container"><table><thead><tr><th><strong><em>对比方面</em></strong></th><th><strong><em>离线数仓</em></strong></th><th><strong><em>实时数仓</em></strong></th></tr></thead><tbody><tr><td><strong><em>架构选择</em></strong></td><td>传统大数据架构</td><td>Kappa架构</td></tr><tr><td><strong><em>建设方法</em></strong></td><td>传统数仓主题建模理论</td><td>传统数仓主题建模理论</td></tr><tr><td><strong><em>准确性</em></strong></td><td>准确度高</td><td>准确度随着技术发展，准确度高</td></tr><tr><td><strong><em>实时性</em></strong></td><td>T+1</td><td>分钟级别、秒级别</td></tr><tr><td><strong><em>稳定性</em></strong></td><td>稳定性好，方便重算</td><td>对数据敏感稳定性差，需要考虑数据重新计算</td></tr><tr><td><strong><em>数据存储</em></strong></td><td>HDFS/Hive</td><td>Kafka/HBase/Redis/Druid</td></tr><tr><td><strong><em>吞吐量</em></strong></td><td>高</td><td>较高</td></tr></tbody></table></div><p>其实为什么要有实时数仓，个人觉得主要是两个方面：</p><ul><li>实时性。指标应该更加实时，多实时呢？ 理论来说 应该是一种消息驱动型的 ，上游数据发生变更，就应该有应用的指标产出，即CDC技术。</li><li>复用思想。多链路开发，难免会进行交叉，包括处理逻辑的交叉，结果的交叉，甚至是不同部门间的数据交叉处理等等，而数仓的思想就是 进行数据的沉淀，从而避免重复处理，甚至是实时中，也可以复用离线数仓的维度建模思想。</li></ul><h2 id="实时数仓建设思路"><a href="#实时数仓建设思路" class="headerlink" title="实时数仓建设思路"></a>实时数仓建设思路</h2><p>​        在实时数仓中计算框架选型建议优先选择 Flink，其具有“流批一体”特性，并且在 处理复杂业务场景上性能优异，在实时处理中有逐渐替代 spark 的趋势。</p><p>​        在实时数仓分层方面，实时数仓可采用离线数仓的数据模型进行分层处理，目前建议选择 Kafka，实时数仓的数据来源可以为 kafka 消息队列，这样可以做到队列中的数据既可 以写入 HDFS 用于批量分析，也可以实时处理，下游可以写入数据集市供业务使用。如果实 时数据量不大也可以将实时明细层写入 ClickHouse、Druid 等查询效率高的存储方便下 游使用，轻度汇总层对数据进行汇总分析后供下游使用。</p><p>​        在数据存储选型中首要考虑查询效率，其次是插入、更新等问题，这里说的存储时最终 计算数据结果的存储，可选择 ClickHouse、Hbase、apache Druid、Redis 等，频繁 更新的数据建议不要采用 ClickHouse 与 Druid。当然存储这块需要具体问题具体分析， 不同场景下 hbase、redis 等都是可选项。</p>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据仓库的架构演变</title>
      <link href="/2023/01/09/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-09-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E7%9A%84%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/"/>
      <url>/2023/01/09/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93-2023-01-09-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E7%9A%84%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<h2 id="数据仓库演变"><a href="#数据仓库演变" class="headerlink" title="数据仓库演变"></a>数据仓库演变</h2><p>​        20世纪70年代，MIT(麻省理工)的研究员致力于研究一种优化的技术架构，该架构试图将业务处理系统和分析系统分开，即将业务处理和分析处理分为不同层次，针对各自的特点采取不同的架构设计原则，MIT的研究员认为这两种信息处理的方式具有显著差别，以至于必须采取完全不同的架构和设计方法。但受限于当时的信息处理能力，这个研究仅仅停留在理论层面。</p><p>​        1991年，比尔·恩门（Bill Inmon）出版了他的第一本关于数据仓库的书《Building the Data Warehouse》，标志着数据仓库概念的确立。该书定义了数据仓库非常具体的原则，这些原则到现在仍然是指导数据仓库建设的最基本原则。比尔·恩门（Bill Inmon）主张自上而下的建设企业级数据仓库EDW （Enterprise Data Warehouse），这个过程中信息存储符合第三范式，结构如下：</p><p><img src="1.jpg" alt="image-20230109224427900"></p><p>​        由于企业级数据仓库的设计、实施很困难，很重要的原因是因为其数据模型设计，在企业级数据仓库中，Inmon推荐采用3范式进行数据建模，从而无法支持决策支持（DSS -Decision Suport System ）系统的性能和数据易访问性的要求，即：数据存储方式严格按照范式建模方式，导致数据分析效率低下。很多公司按照这种方式构建数据仓库遭到失败。</p><p>​        同时期，拉尔夫·金博尔（Ralph Kimball）提出自下而上的建立数据仓库，整个过程中信息存储采用维度建模而非三范式，思路如下：</p><p>​    <img src="image-20230109224505660.png" alt="image-20230109224505660"></p><p>​        维度建模方式没有采用三范式方式设计存储数据，适用于数据分析场景，以上设计方式构建数据仓库实施难度大大降低，并且能够满足公司内部部分业务部门的迫切需求，在初期获得了较大成功。但是很快，他们也发现自己陷入了某种困境：随着数据集市的不断增多，这种架构的缺陷也逐步显现，公司内部独立建设的数据集市由于遵循不同的标准和建设原则，以致多个数据集市的数据混乱和不一致，解决以上问题，还需回归到范式建模。</p><p>​        1998年，Bill Inmon提出了新的BI架构CIF(Corporation information factory)，CIF的核心是将数仓架构划分为不同的层次以满足不同场景的需求，比如常见的ODS、DW、DM等，每层根据实际场景采用不同的建设方案，现在CIF已经成为建设数据仓库的框架指南。</p><p>​        随着时代的发展，到今天数据仓库建设理论也是基于CIF架构建设方案演化而来。同时数据仓库的概念越来越精确，数据仓库定义如下：</p><p>​        数据仓库，Data Warehouse，可简写为DW或DWH。数据仓库是面向主题的、集成的（非简单的数据堆积）、相对稳定的、反应历史变化的数据集合，数仓中的数据是有组织有结构的存储数据集合，用于对管理决策过程的支持。</p><p>​    <img src="image-20230109224538446.png" alt="image-20230109224538446"></p><h2 id="传统离线大数据架构"><a href="#传统离线大数据架构" class="headerlink" title="传统离线大数据架构"></a>传统离线大数据架构</h2><p>​        21世纪初随着互联网时代的到来，数据量暴增，大数据时代到来。Hadoop生态群及衍生技术慢慢走向“舞台”，Hadoop是以HDFS为核心存储，以MapReduce（简称MR）为基本计算模型的批量数据处理基础设施，围绕HDFS和MR，产生了一系列的组件，不断完善整个大数据平台的数据处理能力，例如面向KV操作的HBase、面向SQL分析的Hive、面向工作流的PIG等。以Hadoop为核心的数据存储及数据处理技术逐渐成为数据处理中的“中流砥柱”，部分技术栈如下图所示：</p><p><img src="image-20230109224957715.png" alt="image-20230109224957715"></p><p>​        这个时期，在企业信息化的过程中，随着信息化工具的升级和新工具的应用，数据量变的越来越大，数据格式越来越多，决策要求越来越苛刻，数据仓库技术在大数据场景中被广泛使用。大数据中的数据仓库构建就是基于经典数仓架构而来，使用大数据中的工具来替代经典数仓中的传统工具，架构建设上没有根本区别。在离线大数据架构中离线数仓结构如下:</p><p>​        <img src="image-20230109225021753.png" alt="image-20230109225021753"></p><p>​        随着数据处理能力和处理需求的不断变化，越来越多的用户发现，批处理模式无论如何提升性能，也无法满足一些实时性要求高的处理场景，流式计算引擎应运而生，例如Storm、Spark Streaming、Flink等。</p><p>以上离线大数据架构不能够处理实时性业务，早期，很过公司都是基于Storm来处理处理实时性比较强的业务场景，随着越来越多的应用上线，大家发现，其实批处理和流计算配合使用，才能满足大部分应用需求。而对于用户而言，其实他们并不关心底层的计算模型是什么，用户希望无论是批处理还是流计算，都能基于统一的数据模型来返回处理结果，于是Lambda架构被提出。</p><h2 id="Lambda架构"><a href="#Lambda架构" class="headerlink" title="Lambda架构"></a>Lambda架构</h2><p>​        在Lambda架构中，为了计算一些实时指标，就在原来的离线数仓基础之上增加了一个实时计算的链路，并对数据源做流式改造：把消息发送到消息队列中（大数据中常用Kafka），实时计算去消费消息队列中的数据，完成实时指标计算，推送到下游的数据服务中去，由数据服务层完成离线与实时结果的合并。</p><p>Lambda架构中数据从底层的数据源开始，经过各种各样的格式进入大数据平台，在大数据平台中经过Kafka、Flume等数据组件进行收集，然后分成两条线进行计算。一条线是进入流式计算平台（例如 Storm、Flink或者Spark Streaming），去计算实时的一些指标，保证数据实时性；另一条线进入批量数据处理离线计算平台（例如Mapreduce、Hive，Spark SQL），去计算T+1的相关业务指标，这些指标需要隔日才能看见，保证数据有效、准确性。</p><p>​        根据实时业务统计的复杂程度Lambda架构也分为以下两种情况。</p><h3 id="离线数据-实时处理链路-传统实时开发"><a href="#离线数据-实时处理链路-传统实时开发" class="headerlink" title="离线数据+实时处理链路(传统实时开发)"></a>离线数据+实时处理链路(传统实时开发)</h3><p>根据实时链路中实时指标计算的复杂程度，开始实时业务不复杂，都是“烟囱（cong）式”开发设计，不需要构建实时数仓，我们可以选择不分层，这种场景下Lambda架构中是由离线数仓和实时业务处理部分组成，这部分实时还达不到叫做实时数仓阶段，只能叫做实时处理链路，其结构如下：</p><p><img src="image-20230109225412501.png" alt="image-20230109225412501"></p><p><img src="image-20230109225422726.png" alt="image-20230109225422726"></p><p>​    注意：“烟囱式”开发：在一个有一定规模的企业中，通常都会存在各种各样的应用系统，它们分别由企业的各个不同部门、在各种不同历史时期、为满足各种不同业务目的而开发。由于数据格式没有统一规范，相互之间没有联通、数据更没有整合，像一个个烟囱，因此称其为“烟囱式系统”。同样，在数据处理过程中，各个数据处理程序之间不能很好做到数据规范统一、处理数据流程统一、数据复用，各自独立，叫做“烟囱式”开发。</p><h3 id="离线数仓-实时数仓"><a href="#离线数仓-实时数仓" class="headerlink" title="离线数仓+实时数仓"></a>离线数仓+实时数仓</h3><p>​        随着企业实时业务增多，统计的实时指标越来越多，复杂程度也越来越高，为了在实时链路中更好的复用数据，这是就有必要在实时链路中加入数据分层设计，构建真正的实时数仓。这种场景下Lambda架构中是由离线数仓和实时数仓两部分组成，其结构如下：</p><p>​        <img src="image-20230109225821491.png" alt="image-20230109225821491"></p><p>​        以上Lambda架构中“实时处理链路”这种传统实时与“实时数仓”区别在于，传统实时“烟囱式”开发导致代码耦合问题严重，当需求越来越多，有时需要明细数据，有时需要OLAP分析，这种模式难以应付这些需求，缺少完善的规范。“实时数仓”在保证数据实时性的前提下，实现了数据基于数据仓库管理，更加统一规范化，稳定性和业务性更强。</p><p>​        在Lambda架构中流处理计算的指标批处理依然计算，最终以批处理结果为准，即每次批处理计算后会覆盖流处理的结果，这是由于流处理过程中不完善做的折中办法，由数据服务处理，其功能主要是合并离线计算和实时计算结果。例如：在统计实时交易订单时，可能实时统计的结果需要当日分钟级别向外展示，T+1后才能展示昨日总的交易订单数，显然，后者是T+1每日离线批处理统计结果，那么假设当日有些用户进行了订单取消有可能T+1后统计统计结果与当日实时展示数据出现不一致问题，那么这里就需要使用数据服务来进行处理，统一数据，决定如何使用数据。</p><p>​        Lambda数据架构成为每一个公司大数据平台必备的架构，它解决了一个公司大数据批量离线处理和实时数据处理的需求。Lambda架构的核心理念是“流批一体”，如上图所示，整个数据流向自左向右流入平台。进入平台后一分为二，一部分走批处理模式，一部分走流式计算模式。无论哪种计算模式，最终的处理结果都通过统一服务层对应用提供，确保访问的一致性，底层到底是批或流对用户透明。经历多年的发展，Lambda架构优点是稳定，对于实时计算部分的计算成本可控，批量处理可以用晚上的时间来整体批量计算，这样把实时计算和离线计算高峰分开，但是它也有一些致命缺点：</p><ul><li>同样的需求需要开发两套一样的代码</li></ul><p>​    这是Lambda架构最大的问题，针对同一个需求需要开发两套代码，一个在批处理引擎上实现，一个在流处理引擎上实现，在写好代码后还需构造数据测试保证两者结果一致，另外，两套代码对于后期维护也非常麻烦，一旦需求变更，两套代码都需要修改，并且两套代码也需同时上线。</p><ul><li><p>集群资源使用增多</p><p>同样的逻辑需要计算两次，整体占用资源会增多。虽然离线部分是在凌晨运行，但是有可能任务多，在凌晨时造成集群资源使用暴增，报表产出效率就有可能下降，报表延迟对后续展示也有影响。</p></li><li><p>离线结果和实时结果不一致</p><p>在此架构中经常我们看到次日统计的结果比昨晚的结果要少，原因就在于次日统计结果和昨日统计结果走了两条线的计算方式：次日统计结果是按照批处理得到了更为准确的批量处理结果。昨晚看的结果是通过流式运行的结果，依靠实时链路统计出的实时结果（实时结果统计累加），牺牲了部分准确性。对于这种来自批量和实时的数据结果对不上的问题，无解。</p></li><li><p>批量计算T+1可能计算不完</p><p>随着物联网时代的到来，一些企业中数据量级越来越大，经常发现夜间运行批量任务已经无法完成白天20多个小时累计的数据，保证早上上班前准时出现数据已成为部分大数据团队头疼的问题。</p></li><li><p>服务器存储大</p><p>由于批流两个过程都需要将数据存储在集群中，并且中间也会产生大量临时数据，会造成数据急速膨胀，加大服务器存储压力。</p></li></ul><h3 id="Kappa架构"><a href="#Kappa架构" class="headerlink" title="Kappa架构"></a>Kappa架构</h3><p>​        随着Flink等流式处理引擎的不断完善，流处理技术相关的技术成熟发展（例如：Kafka、ClickHouse），针对Lambda架构的需要维护两套程序等以上缺点，LinkedIn的Jay Kreps结合实际经验和个人体会提出了Kappa架构。</p><p>​        Kappa架构的核心思想是通过改进流计算系统来解决数据全量处理的问题，使得实时计算和批处理过程使用同一套代码。此外Kappa架构认为只有在有必要的时候才会对历史数据进行重复计算，而如果需要重复计算时，Kappa架构下可以启动很多个实例进行重复计算,方式是通过上游重放完成(从数据源拉取数据重新计算)。</p><p>​        Kappa架构就是基于流来处理所有数据，流计算天然的分布式特征，注定了他的扩展性更好，通过加大流计算的并发性，加大流式数据的“时间窗口”，来统一批处理与流式处理两种计算模式。其架构如下:</p><p><img src="image-20230109230738135.png" alt="image-20230109230738135"></p><p>​        Kappa架构构建的数仓当之无愧称为实时数仓，Kappa架构最大的问题是流式重新处理历史的吞吐能力会低于批处理，但这个可以通过增加计算资源来弥补。重新处理数据看似比较麻烦，但在Kappa架构中并不复杂，其步骤如下：</p><p><img src="image-20230109230754253.png" alt="image-20230109230754253">      </p><ol><li><p>选择一个具有重放功能，能够保存历史数据的消息队列，根据要求设置历史数据保存时长，例如:Kafka，可以设置保存全部历史数据。</p></li><li><p>当某个或某些指标有重新处理的需求时，按照新逻辑编写新的作业，然后从上游消息队列最开始地方重新消费数据，把结果写往一个新的下游结果表。</p></li><li>当新作业赶上进度后，切换数据源，读取新作业产生的结果表。</li><li>停止老的作业，删除老的结果表。</li></ol><p>​        另外，Kappa 架构并不是中间结果完全不落地，现在很多大数据系统都需要支持机器学习（离线训练），所以实时中间结果需要落地对应的存储引擎供机器学习使用，另外有时候还需要对明细数据查询，这种场景也需要把实时明细层写出到对应的引擎中</p><p>​        Kappa架构也有一定的缺点，其缺点例如：Kappa架构由于采集的数据格式不统一，每次都需要开发不同的Streaming程序，导致开发周期长。更多Kappa架构的问题在后续文章中讨论。</p><h3 id="混合架构"><a href="#混合架构" class="headerlink" title="混合架构"></a>混合架构</h3><p>​        传统离线大数据架构已经不能满足一些公司中实时业务需求，因为随着互联网及物联网发展，越来越多的公司多多少少涉及一些流式业务处理场景。由Lambda离线数仓+实时数仓架构到Kappa实时数仓架构，都涉及到实时数仓开发，那么现实业务开发中到底使用Lambda架构还是Kappa架构？</p><p>​        我们可以先看下以上三个架构之间的区别:</p><div class="table-container"><table><thead><tr><th><strong><em>对比项</em></strong></th><th><strong><em>传统离线大数据架构</em></strong></th><th><strong><em>Lambda架构</em></strong></th><th><strong><em>Kappa架构</em></strong></th></tr></thead><tbody><tr><td><strong><em>实时性</em></strong></td><td>离线（无法处理实时业务）</td><td>离线+实时</td><td>实时（批流一体）</td></tr><tr><td><strong><em>计算资源</em></strong></td><td>只有批处理</td><td>批和流同时运行，资源消耗大</td><td>只有流处理，资源开销小</td></tr><tr><td><strong><em>重新计算时吞吐量</em></strong></td><td>批处理全量处理，吞吐量大</td><td>批处理全量处理，吞吐量大</td><td>流式全量处理，吞吐较批处理全量要低一些</td></tr><tr><td><strong><em>开发、测试难度</em></strong></td><td>批处理一套代码，开发、测试、上线难度小</td><td>批处理和流处理相同逻辑两条代码，开发、测试、上线难度大</td><td>只需实现一套代码，开发、测试、上线难度相对较小</td></tr><tr><td><strong><em>运维成本</em></strong></td><td>维护一套引擎，运维成本小</td><td>维护两套引擎，运维成本大</td><td>维护一套引擎，运维成本小</td></tr></tbody></table></div><p>通过以上对比来看，三者对比结果如下：</p><p><strong><em>从架构上来看</em></strong>，三套架构有比较明显区别，真正的实时数仓以Kappa架构为主，而离线数仓以传统离线大数据架构为主，Lambda架构可以认为是两者的中间态。目前在业界中所说的实时数仓大多是Lambda架构，这是由需求决定的。</p><p><strong><em>从建设方法上来看</em></strong>，实时数仓和离线数仓基本还是沿用传统的数仓主题建模理论，产出事实宽表。另外实时数仓中实时流数据的join有隐藏时间语义，在建设中需注意。</p><p><strong><em>从数据保障上来看</em></strong>，实时数仓因为要保证实时性，所以对数据量的变化较为敏感，在大促等场景下需要提前做好压测和主备保障工作，这是与离线数仓较为明显的一个区别。</p><p>目前在一些没有实时数据处理场景公司中，使用传统离线大数据架构居多，在这些公司中离线大数据架构性价比高，比较实用。</p><p>在一些涉及到实时业务场景的公司，在实际工作中到底选择哪种架构，需要根据具体业务需求来决定。很多时候并不是完全规范的Lambda架构或者Kappa架构，可以是两者的混合，比如大部分实时指标统计使用Kappa架构完成计算，少量关键指标使用Lambda架构用批处理重新计算，增加一次校对过程。为了应对更广泛的场景，大多数公司采用这种混合架构，离线和实时数据链路都存在，根据每个业务需求选择在合适的链路上来实现。注意：这种方式并不是Lambda架构，例如：某企业有多个业务模块，某些业务模块需要运行在Lambda架构中，某些业务模块需要运行在Kappa架构中。</p>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CI、CD系列四之质量检测SonarQube</title>
      <link href="/2022/12/21/LINUX%E8%BF%90%E7%BB%B4-2022-12-21-CI%E3%80%81CD%E7%B3%BB%E5%88%97%E5%9B%9B%E4%B9%8B%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8BSonarQube/"/>
      <url>/2022/12/21/LINUX%E8%BF%90%E7%BB%B4-2022-12-21-CI%E3%80%81CD%E7%B3%BB%E5%88%97%E5%9B%9B%E4%B9%8B%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8BSonarQube/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SonarQube是代码质量检测的利器，可以说自动化运维工具必备，下面我们就使用它对开源项目进行检测，观察一下。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 sonarqube-7.7]# pwd</span><br><span class="line">/opt/apps/sonarqube-7.7</span><br><span class="line">[root@linx01 conf]# vim sonar.properties</span><br></pre></td></tr></table></figure><p><img src="image-20221221212350654.png" alt="image-20221221212350654"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[sonar@localhost linux-x86-64]$ ./sonar.sh start</span><br><span class="line">Starting SonarQube...</span><br><span class="line">Started SonarQube.</span><br></pre></td></tr></table></figure><p><img src="image-20221221215007422.png" alt="image-20221221215007422"></p><h2 id="分析java项目"><a href="#分析java项目" class="headerlink" title="分析java项目"></a>分析java项目</h2><p>首先创建项目，用来绑定要检查的项目，查看结果的</p><p><img src="image-20221221215335236.png" alt="image-20221221215335236"></p><p><img src="image-20221221215432390.png" alt="image-20221221215432390"></p><p>提示使用这串命令来编译项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn sonar:sonar \</span><br><span class="line">  -Dsonar.projectKey=java-simple \</span><br><span class="line">  -Dsonar.host.url=http://192.168.1.7:29000 \</span><br><span class="line">  -Dsonar.login=a74d6b221e2154c48632e1b85f5940beabe91205</span><br></pre></td></tr></table></figure><p>我们在gitlab拉取下来的项目，进行分析</p><p><img src="image-20221221222744652.png" alt="image-20221221222744652"></p><p>在sonar的页面山也显示了扫描的结果</p><p><img src="image-20221221222854103.png" alt="image-20221221222854103"></p><p> 可以看到具体的bug</p><p><img src="image-20221221222911136.png" alt="image-20221221222911136"></p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CI、CD系列三之全流程部署开源项目zrlog</title>
      <link href="/2022/12/20/LINUX%E8%BF%90%E7%BB%B4-2022-12-20-CI%E3%80%81CD%E7%B3%BB%E5%88%97%E4%B8%89%E4%B9%8B%E5%85%A8%E6%B5%81%E7%A8%8B%E9%83%A8%E7%BD%B2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEzrlog/"/>
      <url>/2022/12/20/LINUX%E8%BF%90%E7%BB%B4-2022-12-20-CI%E3%80%81CD%E7%B3%BB%E5%88%97%E4%B8%89%E4%B9%8B%E5%85%A8%E6%B5%81%E7%A8%8B%E9%83%A8%E7%BD%B2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEzrlog/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    我们以java开源项目zrlog为例，进行一次完整的部署，实现一套完整的CICD流程。</p><p>​    整个过程如下：</p><ol><li><p>开发提交代码至gitlab</p></li><li><p>jenkins拉取获取代码</p></li><li><p>代码的质量检测;</p></li><li><p>代码的编译;</p></li><li><p>发布。</p></li></ol><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="源码准备"><a href="#源码准备" class="headerlink" title="源码准备"></a>源码准备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost code]# git clone https://gitee.com/94fzb/zrlog.git</span><br><span class="line">[root@localhost zrlog]# yum install -y nodejs npm </span><br><span class="line">[root@localhost zrlog]# npm install -g yarn</span><br></pre></td></tr></table></figure><h3 id="JDK-准备"><a href="#JDK-准备" class="headerlink" title="JDK 准备"></a>JDK 准备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# java -version</span><br><span class="line">java version "1.8.0_351"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_351-b10)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.351-b10, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="maven准备"><a href="#maven准备" class="headerlink" title="maven准备"></a>maven准备</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost opt]# wget -P /apps/tools/ https://archive.apache.org/dist/maven/maven3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz </span><br><span class="line"><span class="meta">#</span><span class="bash">配置 maven源</span></span><br><span class="line">&lt;mirror&gt; </span><br><span class="line">&lt;id&gt;aliyunmaven&lt;/id&gt; </span><br><span class="line">&lt;mirrorOf&gt;*&lt;/mirrorOf&gt; </span><br><span class="line">&lt;name&gt;阿里云公共仓库&lt;/name&gt;</span><br><span class="line">&lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; </span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure><h4 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h4><p><img src="image-20221221112148589.png" alt="image-20221221112148589"></p><h3 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; create database zrlog ;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; grant all on zrlog.* to zrlog@&#39;%&#39; identified by &#39;123456&#39;;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure><h3 id="推送Gitlab"><a href="#推送Gitlab" class="headerlink" title="推送Gitlab"></a>推送Gitlab</h3><p><img src="image-20221221103226086.png" alt="image-20221221103226086"></p><p>如图，我们给源码打一个tag 部署时候，就按照标签进行构建。</p><h2 id="Jenkins构建"><a href="#Jenkins构建" class="headerlink" title="Jenkins构建"></a>Jenkins构建</h2><h3 id="整合gitlab"><a href="#整合gitlab" class="headerlink" title="整合gitlab"></a>整合gitlab</h3><p><img src="image-20221221103901057.png" alt="image-20221221103901057"></p><p><img src="image-20221221104109071.png" alt="image-20221221104109071"></p><p>  这个地方,我们调整参数化构建，拉取指定的tag版本。</p><p><img src="image-20221221110504480.png" alt="image-20221221110504480"></p><p> 接下来，就可以进行构建了。</p><p><img src="image-20221221110617350.png" alt="image-20221221110617350"></p><p>查看日志</p><p><img src="image-20221221111051117.png" alt="image-20221221111051117"></p><p>现在 构建过程主要是，拉取git代码，进行maven编译</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CI、CD系列二之实现CD</title>
      <link href="/2022/12/19/LINUX%E8%BF%90%E7%BB%B4-2022-12-19-CI%E3%80%81CD%E7%B3%BB%E5%88%97%E4%BA%8C%E4%B9%8B%E5%AE%9E%E7%8E%B0CD/"/>
      <url>/2022/12/19/LINUX%E8%BF%90%E7%BB%B4-2022-12-19-CI%E3%80%81CD%E7%B3%BB%E5%88%97%E4%BA%8C%E4%B9%8B%E5%AE%9E%E7%8E%B0CD/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    上篇文章我们对CI、CD的概念进行了大致的解释，这次我们就用Jenkins 利用脚本的方式进行自动化部署。在这之前我们再来解释一下。所谓CI就是持续集成，说白了就是你的代码存放在哪，现在企业中gitlab用的较多。我们将一个静态网页项目放在gitlab中。CD就是持续交付，持续部署。这次我们演示持续部署，即如何自动化的将代码从gitlab中拉取然后部署到服务器上。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>​    假设，我们已经开发完毕一套项目。一个简单的静态网站,并搭建一个gitlab 上传。</p><p><img src="image-20221219222439420.png" alt="image-20221219222439420"></p><h2 id="手动部署脚本实现"><a href="#手动部署脚本实现" class="headerlink" title="手动部署脚本实现"></a>手动部署脚本实现</h2><p>​    我们要进行网站的部署了，如果我们没有引入CD的概念。这个过程应该是手动的拉取代码，分发到服务器进行部署等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">01. 下载代码 </span></span><br><span class="line">git clone git@gitlab.danteblog.com:data_dev/monitor_platform.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">02. 代码打包</span></span><br><span class="line">tar zcf web_html-$(date +%F).tar.gz web_html/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">03. 推送代码包 scp :推送到web服务器的/opt</span></span><br><span class="line">for ip in 128 :</span><br><span class="line">do scp web_html -$(date +%F).tar.gz   172.16.190.$&#123;ip&#125;:/opt/pks/ ;done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">04. 解压,修改目录名字,创建软连接</span></span><br><span class="line">for ip in 7 8</span><br><span class="line">do ssh 172.16.1.$ip</span><br><span class="line">"cd /opt  &amp;&amp;\</span><br><span class="line">tar xf web_html-$(date +%F).tar.gz &amp;&amp;\</span><br><span class="line">mv web_html  we _htmL-$(date +%F) &amp;&amp;\</span><br><span class="line">rm -f /code /html</span><br><span class="line">ln -s /opt/web_html-$(date +%F)  /code/html “</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这需要我们一条一条输入，可以再自动化一点，变成一个脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">author:dante</span></span><br><span class="line"><span class="meta">#</span><span class="bash">desc: 通过脚本,打包,分发,解压,连接,代码 </span></span><br><span class="line">App_time=`date +%F`</span><br><span class="line">App_home=/opt/</span><br><span class="line">App_dir=/opt </span><br><span class="line">App_web_servers="172.16.190.130"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app_pack() &#123;</span><br><span class="line"><span class="meta">#</span><span class="bash">01. 克隆代码并打包</span></span><br><span class="line">git clone git@gitlab.danteblog.com:data_dev/monitor_platform.git</span><br><span class="line">cd $&#123;App_home&#125;</span><br><span class="line">tar zcf $&#123;App_dir&#125;/monitor_platform-$&#123;App_time&#125;.tar.gz ./</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app_scp() &#123;</span><br><span class="line"><span class="meta">#</span><span class="bash">02. 分发代码</span></span><br><span class="line">for ip in $&#123;App_web_servers&#125;</span><br><span class="line">do </span><br><span class="line">scp $&#123;App_dir&#125;/monitor_platform-$&#123;App_time&#125;.tar.gz  $&#123;ip&#125;:$&#123;App_dir&#125;</span><br><span class="line">done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app_deploy() &#123;</span><br><span class="line"><span class="meta">#</span><span class="bash">03. 解压,修改目录名字,创建软连接</span></span><br><span class="line">for ip in $&#123;App_web_servers&#125;</span><br><span class="line">do ssh $ip "cd $&#123;App_dir&#125;  &amp;&amp;\</span><br><span class="line">tar xf monitor_platform-$&#123;App_time&#125;.tar.gz &amp;&amp;\</span><br><span class="line">mv monitor_platform  monitor_platform-$&#123;App_time&#125; &amp;&amp;\</span><br><span class="line">rm -f /app/dante/monitor &amp;&amp;\</span><br><span class="line">ln -s $&#123;App_dir&#125;/monitor_platform-$&#123;App_time&#125;  /app/dante/monitor "</span><br><span class="line">done</span><br><span class="line">&#125;</span><br><span class="line">main() &#123;</span><br><span class="line">app_pack </span><br><span class="line">app_scp </span><br><span class="line">app_deploy</span><br><span class="line">&#125;</span><br><span class="line">main</span><br></pre></td></tr></table></figure><h2 id="利用Jenkins实现自动部署"><a href="#利用Jenkins实现自动部署" class="headerlink" title="利用Jenkins实现自动部署"></a>利用Jenkins实现自动部署</h2><p>其实，上述的脚本已经相对算是自动化了，对运维工作而言已经减轻了很大的负担，但有了Jenkins平台，我们更可以通过图形化的方式，点点的方式来实现整个流程 </p><p><img src="image-20221220115643909.png" alt="image-20221220115643909" style="zoom:50%;" /></p><p> 之后就是整个构建的过程</p><p><img src="image-20221220115747642.png" alt="image-20221220115747642" style="zoom:50%;" /></p><p>由于我们现在所有的操作都是在shell里写好的,所以只需要在构建时使用shell即可，但我们还是来挨个看一下来熟悉一下jenkins</p><p><img src="image-20221220120157731.png" alt="image-20221220120157731" style="zoom:50%;" /></p><p>这的参数化构建用的比较多，可以添加外部参数.</p><p><img src="image-20221220120318524.png" alt="image-20221220120318524" style="zoom: 67%;" /></p><p>这的源码管理就是为了整合gitlab等仓库实际工作中也是整合使用的。构建触发器中，可以标记当代码有推送时，自动进行构建 也就是自动进行发布，这个可以在测试环境这样操作，后面我们也会有演示。</p><p><img src="image-20221220124603192.png" alt="image-20221220124603192" style="zoom:50%;" /></p><p>到了构建环节了，填入指令即可了。</p><p><img src="image-20221220134820568.png" style="zoom: 67%;" /></p><p><img src="image-20221220134726098.png" alt="image-20221220134726098" style="zoom:67%;" /></p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CI、CD系列一之实现方式</title>
      <link href="/2022/12/19/LINUX%E8%BF%90%E7%BB%B4-2022-12-19-CI%E3%80%81CD%E7%B3%BB%E5%88%97%E4%B8%80%E4%B9%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/12/19/LINUX%E8%BF%90%E7%BB%B4-2022-12-19-CI%E3%80%81CD%E7%B3%BB%E5%88%97%E4%B8%80%E4%B9%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="CI、CD概述"><a href="#CI、CD概述" class="headerlink" title="CI、CD概述"></a>CI、CD概述</h2><p>​    CI、CD是现在互联网公司中很普遍的技术了。它指的是持续集成，持续交付，持续部署。所谓的持续，说白了就是让开发，测试，上线部署整个过程能像流水一样持续的进行下去。假如没有CI、CD ，那项目的开发，开发完成后的测试，那这个过程涉及到的源码就需要我们手动拷贝，等测试完成后，代码上线部署，依然需要我们打包，编译最终传到服务器部署，将是一个完全靠人力的过程，费时费力。而CI、CD的发展就是为了将这一系列动作能够自动发展下去。 </p><p>​    更深层次的阐述，可以参考下面这篇文章，而此次我们更希望的是希望通过简单的案例，更好的来理解什么是CICD。</p><blockquote><p><a href="https://baijiahao.baidu.com/s?id=1692918919767968490&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1692918919767968490&amp;wfr=spider&amp;for=pc</a></p></blockquote><ul><li><p>持续集成: 开发的代码集成到代码仓库。 </p></li><li><p>持续交付: 从代码仓库拉取代码部署到测试环境。 </p></li><li><p>持续部署: 从代码仓库拉取代码部署到生产环境。</p></li></ul><h2 id="代码发布方式"><a href="#代码发布方式" class="headerlink" title="代码发布方式"></a>代码发布方式</h2><h3 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h3><ul><li><p>手动发布有如下几种方式 </p><ul><li>方案1.拿到代码:开发通过QQ、weixin发送代码压缩 包，rz上传，解压部署</li><li>方案2.代码上传到web服务器上面: scp/rsync方式上线代码。 xftp/ftp方式上线代码。 </li><li>方案3: 登陆代码托管平台，手动执行git pull。 </li></ul></li><li><p>手动上线方案缺点</p><p>1.全程运维参与，占用大量时间。</p><p>2.如果节点多，上线速度慢。</p><p>3.人为失误多，目录管理混乱。</p><p>4.回滚不及时，或者难以回退。</p></li></ul><h3 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h3><p>前置概念: 持续集成,持续交付,持续部署</p><ul><li>持续集成git  gitlab/gitee/github/…. </li><li>持续交付:cd   sonarqube jenkins代码质量检查 jenkins maven ….</li><li>持续部署:cd  jenkins maven ….</li></ul><p>常用发布策略: 目标尽量不影响用户使用的前提下,完成测试并完成发布.</p><ul><li>蓝绿发布 </li><li>金丝雀发布(灰度发布) </li><li>A/B发布</li></ul><h2 id="CD的几种方案"><a href="#CD的几种方案" class="headerlink" title="CD的几种方案"></a>CD的几种方案</h2><div class="table-container"><table><thead><tr><th>CD方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>使用Jenkins执行shell命令脚本</td><td>简单</td><td>shell编程，节点多时效率低下</td></tr><tr><td>通过Jenkins的插件Publish Over SSH实现与分发</td><td>简单</td><td>需要在Jenkins页面配置所有被管理节点</td></tr><tr><td>使用Jenkins执行Ansible剧本</td><td>批量管理与维护</td><td>需要掌握Ans剧本</td></tr><tr><td>使用Jenkins执行Docker指令（依托docker部署）</td><td>更简单</td><td>需要掌握dockerfile，docker-compose</td></tr><tr><td>Jenkins 交付到k8s</td><td>…</td><td>…</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP连接状态图解</title>
      <link href="/2022/12/19/LINUX%E8%BF%90%E7%BB%B4-2022-12-19-TCP%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E5%9B%BE%E8%A7%A3/"/>
      <url>/2022/12/19/LINUX%E8%BF%90%E7%BB%B4-2022-12-19-TCP%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E5%9B%BE%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​    TCP的连接过程与状态管理只要了解过网络的伙伴应该都听说过，tcp的连接与断开过程主要就是三次握手与四次分手，整个过程可以通过抓包 观察，网上的资料也比较多，今天重点来梳理一下，整个过程中相关的进程状态的变化，主要是方便以后工作中对网络故障的排查。</p><h3 id="连接建立与结束"><a href="#连接建立与结束" class="headerlink" title="连接建立与结束"></a>连接建立与结束</h3><h4 id="三次握手示例"><a href="#三次握手示例" class="headerlink" title="三次握手示例"></a>三次握手示例</h4><ul><li><p>用户：向服务器发出建立连接的请求（SYN请求） ，随机序列号seq=100</p></li><li><p>服务端： 我收到你的请求，同意，并且我也要与你创建连接 （ACK,SYN请求），随机序列号seq=300 ,ack=101 </p></li><li><p>用户：我收到了你确认，我也愿意，准备开始传输数据（ACK请求）， seq=101, ack=301</p></li></ul><h4 id="四次挥手示例"><a href="#四次挥手示例" class="headerlink" title="四次挥手示例"></a>四次挥手示例</h4><ul><li><p>用户: 发出断开连接的请求(FIN,ACK) seq=41 ack=3</p></li><li><p>服务端: 收到断开请求,同意(ACK) seq=3 ack=42</p></li><li><p>服务端: 发出断开连接的请求(FIN,ACK) seq=3 ack=42 </p></li><li>用户: 确认断开(ACK) seq=42 ack=4</li></ul><h3 id="TCP连接状态"><a href="#TCP连接状态" class="headerlink" title="TCP连接状态"></a>TCP连接状态</h3><p><img src="1.jpg" alt="WeChatbbd93b8280a6c4151cd67041d76001b2"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">TCP三次握手状态转换简单说明：</span></span><br><span class="line">01. 首先，建立连接之前服务器和客户端的状态都为CLOSED。</span><br><span class="line">02. 服务器创建socket后开始监听(启动服务)，变为LISTEN状态。</span><br><span class="line">03. 客户端请求建立连接，向服务器发送SYN报文，客户端的状态变为SYN_SENT。</span><br><span class="line">04. 服务器收到客户端的报文后向客户端发送ACK和SYN报文，此时服务器的状态变为SYN_RCVD。 </span><br><span class="line">05. 然后，客户端收到ACK、SYN，就向服务器发送ACK，客户端状态变为ESTABLISHED</span><br><span class="line">06. 服务器收到客户端的ACK后也变为ESTABLISHED。</span><br><span class="line">此时3次握手完成，连接建立！</span><br></pre></td></tr></table></figure><h3 id="TCP挥手状态"><a href="#TCP挥手状态" class="headerlink" title="TCP挥手状态"></a>TCP挥手状态</h3><p><img src="2.jpg" alt="WeChat90934320794a7c6b52cb913c9eebcd2e"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">01.客户端先向服务器发送FIN报文，请求断开连接，其状态变为FIN_WAIT1。</span><br><span class="line">02.服务器收到FIN后向客户端发送ACK，服务器状态变为CLOSE_WAIT。</span><br><span class="line">03.客户端收到ACK后就进入FIN_WAIT2状态。此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送。</span><br><span class="line">04.直到发完了，就发送FIN报文，此时服务器进入LAST_ACK状态。</span><br><span class="line">05.客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态,再过了2MSL长的时间后进入CLOSED状态。</span><br><span class="line">06.服务器收到客户端的ACK就进入CLOSED状态。</span><br><span class="line"></span><br><span class="line">CLOSING状态表示： 客户端发了FIN，但FIN_WAIT1状态时没有收到服务器的ACK确认字段，却收到了服务器的FIN字段，这种情况发生在服务 器发送的ACK丢包的时候，因为网络传输有时会有意外。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统负载高的原因及排查思路</title>
      <link href="/2022/12/15/LINUX%E8%BF%90%E7%BB%B4-2022-12-15-%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/"/>
      <url>/2022/12/15/LINUX%E8%BF%90%E7%BB%B4-2022-12-15-%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="平均负载概述"><a href="#平均负载概述" class="headerlink" title="平均负载概述"></a>平均负载概述</h2><p>系统负载反映机器的压力情况，是日常工作中需要重点关注的指标，利用<code>uptime</code>命令可以进行查看如下 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# uptime</span><br><span class="line"> 21:45:08 up  4:51,  2 users,  load average: 0.08, 0.04, 0.05</span><br></pre></td></tr></table></figure><p>从左到右含义依次是 当前时间、系统运行时间、正在登录用户数。过去 1 分钟、5 分钟、15 分钟的平均负载。</p><p>那平均负载的含义该如何理解呢？</p><p><em>平均负载是指单位时间内，系统处于可运行状态(R,S)和不可中断状态(D)的平均进程数，也就是平均活跃进程数</em></p><ul><li><p>可运行状态： 进程状态种的S R 占用与消耗cpu资源</p></li><li><p>不可中断状态: 进程状态是D ,占用IO(input/output 读写)</p></li></ul><p>因此你可以简单理解为，<strong>平均负载其实就是单位时间内的活跃进程数。</strong></p><p>详细的可以参考这篇文章</p><blockquote><p><a href="https://developer.aliyun.com/article/294493" target="_blank" rel="noopener">https://developer.aliyun.com/article/294493</a></p></blockquote><h2 id="阀值分析"><a href="#阀值分析" class="headerlink" title="阀值分析"></a>阀值分析</h2><p>通过概述，我们大概知道，负载反应的值与正在活跃的进程数有关，那最理想的状态是每个 CPU核心 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。所以在评判平均负载时，首先你要知道系统有几个 CPU 核心，这可以通过 top 命令获取，或grep ‘model name’ /proc/cpuinfo</p><p>假设现在在 4、2、1核的CPU上，如果平均负载为 2 时，意味着什么呢？</p><ul><li><p>在4 个 核心的系统上，意味着 CPU 有 50% 的空闲。 2/4 50% 系统的cpu核心总数利用50% </p></li><li><p>在2 个 核心 的系统上，意味着所有的 CPU 都刚好被完全占用。2/2 100% 每个核心都有任务,刚刚好.</p></li><li><p>而1 个核心 的系统上，则意味着有一半的进程竞争不到 核心。 2/1 200% 每个核心都有2个任务,超载.</p></li></ul><p>假设我们在有2个 核心 系统上看到平均负载为 2.73，6.90，12.98 </p><ul><li><p>那么说明在过去1 分钟内，系统有 136% 的超载 (2.73/2=136%)</p></li><li><p>而在过去 5 分钟内，有 345% 的超载 (6.90/2=345%) </p></li><li>而在过去15 分钟内，有 649% 的超载，(12.98/2=649%)</li></ul><p>但从整体趋势来看，系统的负载是在逐步的降低。</p><p>在工作中，当平均负载高于 cpu核心总数量 70% 的时候，你就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功 能。 但 70% 这个数字并不是绝对的，最推荐的方法，还是把系统的平均负载监控起来，然后根据更多的历史数据，判断负载的变化趋势。当发现负载有明 显升高趋势时，比如说负载翻倍了，你再去做分析和调查。</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>下面，我们以三个示例分别来看这三种情况，并用 stress、mpstat、pidstat 等工具，找出平均负载升高的根源</p><ul><li>stress 是 Linux 系统压力测试工具，这里我们用作异常进程模拟平均负载升高的场景。</li><li>mpstat 是多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标</li><li>pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。</li></ul><h3 id="CPU密集型进程"><a href="#CPU密集型进程" class="headerlink" title="CPU密集型进程"></a>CPU密集型进程</h3><ol><li><p>开第一个终端模拟进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# stress --cpu 1 --timeout 600</span><br><span class="line">stress: info: [20186] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure></li><li><p>开第二个终端观察负载变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# watch -d uptime</span><br><span class="line">Every 2.0s: uptime                                                      Wed Dec 14 22:14:10 2022</span><br><span class="line"></span><br><span class="line"> 22:14:10 up  5:20,  4 users,  load average: 0.79, 0.27, 0.13</span><br></pre></td></tr></table></figure></li><li><p>开第三个终端 查看cpu情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# mpstat -P ALL 5</span><br><span class="line">Linux 3.10.0-1160.el7.x86_64 (linx01)   2022年12月14日  _x86_64_        (1 CPU)</span><br><span class="line"></span><br><span class="line">22时15分02秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">22时15分07秒  all   99.60    0.00    0.40    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">22时15分07秒    0   99.60    0.00    0.40    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br></pre></td></tr></table></figure></li><li><p>使用pidstat进行排查</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# pidstat -u 5 1</span><br><span class="line">Linux 3.10.0-1160.el7.x86_64 (linx01)   2022年12月14日  _x86_64_        (1 CPU)</span><br><span class="line"></span><br><span class="line">22时17分56秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">22时18分01秒     0     20187   98.80    0.00    0.00   98.80     0  stress</span><br><span class="line">22时18分01秒     0     20366    0.00    0.20    0.00    0.20     0  kworker/0:0</span><br><span class="line"></span><br><span class="line">平均时间:   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">平均时间:     0     20187   98.80    0.00    0.00   98.80     -  stress</span><br><span class="line">平均时间:     0     20366    0.00    0.20    0.00    0.20     -  kworker/0:0</span><br></pre></td></tr></table></figure></li></ol><h3 id="IO密集型进程"><a href="#IO密集型进程" class="headerlink" title="IO密集型进程"></a>IO密集型进程</h3><ol><li><p>使用stress 模拟IO操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# stress --io 1 --timeout 600s</span><br><span class="line">stress: info: [20740] dispatching hogs: 0 cpu, 1 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure></li><li><p>第二个终端观察负载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# watch -d uptime</span><br><span class="line">Every 2.0s: uptime                                                      Wed Dec 14 22:23:11 2022</span><br><span class="line"></span><br><span class="line"> 22:23:11 up  5:29,  6 users,  load average: 1.39, 1.08, 0.60</span><br></pre></td></tr></table></figure></li><li><p>查看cpu 情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# mpstat -P ALL 5</span><br><span class="line">Linux 3.10.0-1160.el7.x86_64 (linx01)   2022年12月14日  _x86_64_        (1 CPU)</span><br><span class="line"></span><br><span class="line">22时23分37秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">22时23分42秒  all    2.20    0.00   97.80    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">22时23分42秒    0    2.20    0.00   97.80    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br></pre></td></tr></table></figure><p>发现cpu sys内核台占用cpu高，而io操作就是内核来操作的。</p></li><li><p>利用pidstat 排查导致sys高的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]#  pidstat -u 5 1</span><br><span class="line">Linux 3.10.0-1160.el7.x86_64 (linx01)   2022年12月14日  _x86_64_        (1 CPU)</span><br><span class="line"></span><br><span class="line">22时25分02秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">22时25分07秒     0         5    0.00    9.00    0.00    9.00     0  kworker/u256:0</span><br><span class="line">22时25分07秒     0      1276    0.00    0.20    0.00    0.20     0  sshd</span><br><span class="line">22时25分07秒     0     16304    0.00    5.80    0.00    5.80     0  loop0</span><br><span class="line">22时25分07秒     0     19077    0.00    9.20    0.00    9.20     0  kworker/u256:2</span><br><span class="line">22时25分07秒     0     19950    0.00    0.20    0.00    0.20     0  kworker/0:2</span><br><span class="line">22时25分07秒     0     20741    2.00   73.40    0.00   75.40     0  stress</span><br><span class="line">22时25分07秒     0     20855    0.00    0.20    0.00    0.20     0  kworker/0:0</span><br><span class="line">22时25分07秒     0     20963    0.00    0.20    0.00    0.20     0  pidstat</span><br></pre></td></tr></table></figure><p>明显看到stress进程%system 占用较高</p></li></ol><h3 id="高并发场景"><a href="#高并发场景" class="headerlink" title="高并发场景"></a>高并发场景</h3><ol><li><p>stress 开多线程模拟</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# stress -c 4 --timeout 600</span><br><span class="line">stress: info: [21233] dispatching hogs: 4 cpu, 0 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure></li><li><p>查看负载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# watch -d uptime</span><br><span class="line">Every 2.0s: uptime                                                      Wed Dec 14 22:30:13 2022</span><br><span class="line"></span><br><span class="line"> 22:30:13 up  5:36,  6 users,  load average: 3.30, 1.78, 1.04</span><br></pre></td></tr></table></figure><p>由于我是虚拟机 只有1core，应付并发 负载已经很高了</p></li><li><p>查看一下进程情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# pidstat -u 5 1</span><br><span class="line">Linux 3.10.0-1160.el7.x86_64 (linx01)   2022年12月14日  _x86_64_        (1 CPU)</span><br><span class="line"></span><br><span class="line">22时32分55秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">22时33分00秒     0         1    0.00    0.20    0.00    0.20     0  systemd</span><br><span class="line">22时33分00秒     0     21154    0.00    0.20    0.00    0.20     0  kworker/0:1</span><br><span class="line">22时33分00秒     0     21234   24.65    0.20    0.00   24.85     0  stress</span><br><span class="line">22时33分00秒     0     21235   25.05    0.00    0.00   25.05     0  stress</span><br><span class="line">22时33分00秒     0     21236   24.85    0.00    0.00   24.85     0  stress</span><br><span class="line">22时33分00秒     0     21237   25.05    0.00    0.00   25.05     0  stress</span><br><span class="line">22时33分00秒     0     21452    0.00    0.20    0.00    0.20     0  pidstat</span><br></pre></td></tr></table></figure><p>很明显，4个stress进程分了cpu</p></li></ol><h2 id="排查流程总结"><a href="#排查流程总结" class="headerlink" title="排查流程总结"></a>排查流程总结</h2><p> 前面我们对不同的进程进行了演示，可以看到造成负载高的原因可能是IO或者CPU占用高，接下来我们总结一下排查流程以及要熟记的命令</p><p><img src="1.jpg" alt="linshi" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘使用流程及企业分区方案</title>
      <link href="/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="磁盘使用流程概述"><a href="#磁盘使用流程概述" class="headerlink" title="磁盘使用流程概述"></a>磁盘使用流程概述</h2><p>其实磁盘的使用，主要就是三个步骤，分区、格式化、挂载</p><ol><li><p>磁盘分区 :有了一块地,划分隔断. fdisk/parted</p></li><li><p>格式化（创建文件系统） :对房间进行装修. mkfs</p></li><li><p>挂载 :安装门窗,可以入住与使用. mount Linux下面设备必须要挂载才能访问与使用,没有挂载相当于房子没 有门窗. 挂载相当于给设备设置了一个入口.</p></li></ol><h2 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h2><h3 id="磁盘分区-对新添加的sdb磁盘划分一个分区"><a href="#磁盘分区-对新添加的sdb磁盘划分一个分区" class="headerlink" title="磁盘分区 对新添加的sdb磁盘划分一个分区"></a>磁盘分区 对新添加的sdb磁盘划分一个分区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@linx01 ~]# fdisk -l</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sda：21.5 GB, 21474836480 字节，41943040 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x000e3ccf</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     2099199     1048576   83  Linux</span><br><span class="line">/dev/sda2         2099200    37742591    17821696   83  Linux</span><br><span class="line">/dev/sda3        37742592    39831551     1044480   82  Linux swap / Solaris</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line"></span><br><span class="line">[root@linx01 ~]# fdisk /dev/sdb</span><br><span class="line">欢迎使用 fdisk (util-linux 2.23.2)。</span><br><span class="line"></span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">使用磁盘标识符 0x139651f9 创建新的 DOS 磁盘标签。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">分区号 (1-4，默认 1)：1</span><br><span class="line">起始 扇区 (2048-10485759，默认为 2048)：</span><br><span class="line">将使用默认值 2048</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-10485759，默认为 10485759)：</span><br><span class="line">将使用默认值 10485759</span><br><span class="line">分区 1 已设置为 Linux 类型，大小设为 5 GiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">正在同步磁盘。</span><br><span class="line">[root@linx01 ~]# fdisk -l</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sda：21.5 GB, 21474836480 字节，41943040 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x000e3ccf</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     2099199     1048576   83  Linux</span><br><span class="line">/dev/sda2         2099200    37742591    17821696   83  Linux</span><br><span class="line">/dev/sda3        37742592    39831551     1044480   82  Linux swap / Solaris</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x139651f9</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048    10485759     5241856   83  Linux</span><br><span class="line">[root@linx01 ~]#</span><br></pre></td></tr></table></figure><h3 id="格式化操作"><a href="#格式化操作" class="headerlink" title="格式化操作"></a>格式化操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# mkfs.xfs /dev/sdb1</span><br><span class="line">meta-data=/dev/sdb1              isize=512    agcount=4, agsize=327616 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0, sparse=0</span><br><span class="line">data     =                       bsize=4096   blocks=1310464, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line">log      =internal log           bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# mount /dev/sdb1 /mnt</span><br><span class="line">[root@linx01 ~]# df -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs        710M     0  710M    0% /dev</span><br><span class="line">tmpfs           721M   12K  721M    1% /dev/shm</span><br><span class="line">tmpfs           721M  9.7M  711M    2% /run</span><br><span class="line">tmpfs           721M     0  721M    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda2        17G  8.1G  8.9G   48% /</span><br><span class="line">/dev/sda1      1014M  138M  877M   14% /boot</span><br><span class="line">tmpfs           145M     0  145M    0% /run/user/0</span><br><span class="line">/dev/sdb1       5.0G   33M  5.0G    1% /mnt</span><br></pre></td></tr></table></figure><h4 id="永久挂载"><a href="#永久挂载" class="headerlink" title="永久挂载"></a>永久挂载</h4><p>上述演示的只是临时挂载，要想永久挂载，一般有两种方法:</p><ol><li>修改/etc/rc.local</li></ol><ul><li>存放的命令,脚本会在开机的时候自动运行.</li><li><p>第1次使用,需要给 /etc/rc.d/rc.local 加上执行权限. chmod +x /etc/rc.d/rc.local</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdb1 /mnt  #写入到/etc/rc.local</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>修改/etc/fstab(推荐)</p><p><img src="image-20221214214951906.png" alt="image-20221214214951906"></p></li></ol><h2 id="磁盘分区相关指令总结"><a href="#磁盘分区相关指令总结" class="headerlink" title="磁盘分区相关指令总结"></a>磁盘分区相关指令总结</h2><ul><li>fdisk</li><li>lsblk</li><li>mount 、umount</li><li>mkfs  mkfs.xfs 、mkfs.ext3、mkfs.ext4</li></ul><h2 id="企业分区的通用方案"><a href="#企业分区的通用方案" class="headerlink" title="企业分区的通用方案"></a>企业分区的通用方案</h2><p>磁盘分区整个过程还是比较简单的，在这总结了 企业中常见的分区方案，给大家做一个建议。</p><h3 id="物理机"><a href="#物理机" class="headerlink" title="物理机"></a>物理机</h3><h4 id="方案01-测试环境，不太重要的环境"><a href="#方案01-测试环境，不太重要的环境" class="headerlink" title="方案01:测试环境，不太重要的环境"></a>方案01:测试环境，不太重要的环境</h4><div class="table-container"><table><thead><tr><th>分区</th><th>解释</th></tr></thead><tbody><tr><td>/boot 分区</td><td>用于引导系统启动,linux内核文件。 1G即可（如果需要升级linux内核） (200MB)</td></tr><tr><td>/swap 分区</td><td>内存不足的时候，swap    空间临时充当内存使用。<br />内存小于8G swap 可以给内存的1.5倍或2倍。 最大控制在8-16G <br />内存大于8G swap 给8G 8-16G<br />在一些生产环境中为了极致的速度、性能。会关闭<br />注意:swap 云服务器默认没有swap</td></tr><tr><td>/</td><td>剩余多少给多少</td></tr></tbody></table></div><h4 id="方案02-生产环境，有重要数据的环境"><a href="#方案02-生产环境，有重要数据的环境" class="headerlink" title="方案02:生产环境，有重要数据的环境"></a>方案02:生产环境，有重要数据的环境</h4><p></p><div class="table-container"><table><thead><tr><th>分区</th><th>解释</th></tr></thead><tbody><tr><td>/boot 分区</td><td>用于引导系统启动,linux内核文件。 1G即可（如果需要升级linux内核） (200MB)</td></tr><tr><td>/swap分区</td><td>内存不足的时候，swap    空间临时充当内存使用。<br />内存小于8G swap 可以给内存的1.5倍或2倍。 最大控制在8-16G <br />内存大于8G swap 给8G 8-16G<br />在一些生产环境中为了极致的速度、性能。会关闭<br /></td></tr><tr><td>/ 分区</td><td>根分区40-100G</td></tr><tr><td>/data 数据分区</td><td>重要数据放在/data 目录、分区中。</td></tr></tbody></table></div><h4 id="方案03-可能会有重要数据"><a href="#方案03-可能会有重要数据" class="headerlink" title="方案03:可能会有重要数据"></a>方案03:可能会有重要数据</h4><div class="table-container"><table><thead><tr><th></th><th>解释</th></tr></thead><tbody><tr><td>/boot 分区</td><td>用于引导系统启动,linux内核文件。 1G即可（如果需要升级linux内核） (200MB)</td></tr><tr><td>/swap分区</td><td>内存不足的时候，swap    空间临时充当内存使用。<br />内存小于8G swap 可以给内存的1.5倍或2倍。 最大控制在8-16G <br />内存大于8G swap 给8G 8-16G<br />在一些生产环境中为了极致的速度、性能。会关闭<br /></td></tr><tr><td>/ 分区</td><td>根分区40-100G</td></tr><tr><td>剩余暂不分配</td></tr></tbody></table></div><h3 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h3><p>根据需求，规划好。所需要的磁盘空间。 如果后期添加，扩容云服务器都很方便。</p><p>/ 系统分区 根分区 40-100G  /dev/sda</p><p>/data 数据分区 数据分区 不限制。</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘空间不足案例分析</title>
      <link href="/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
      <url>/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 工作中可能会遇到no space left on device 这个问题  也就是磁盘满了，原因有很多种，下面进行分析并对问题进行复现，最后对排查问题的方法以及使用到的命令进行总结。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="大文件造成block不足"><a href="#大文件造成block不足" class="headerlink" title="大文件造成block不足"></a>大文件造成block不足</h3><p>这种算是真实的磁盘用满了</p><h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# df -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs        710M     0  710M    0% /dev</span><br><span class="line">tmpfs           721M   12K  721M    1% /dev/shm</span><br><span class="line">tmpfs           721M  9.8M  711M    2% /run</span><br><span class="line">tmpfs           721M     0  721M    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda2        17G  9.1G  8.0G   54% /</span><br><span class="line">/dev/sda1      1014M  138M  877M   14% /boot</span><br><span class="line">tmpfs           145M     0  145M    0% /run/user/0</span><br><span class="line">/dev/sdb1       5.0G   33M  5.0G    1% /mnt</span><br><span class="line"><span class="meta">#</span><span class="bash">磁盘打满</span></span><br><span class="line">[root@linx01 ~]# dd if=/dev/zero of=/mnt/test count=5120 bs=1M</span><br><span class="line">dd: 写入"/mnt/test" 出错: 设备上没有空间</span><br><span class="line">记录了5077+0 的读入</span><br><span class="line">记录了5076+0 的写出</span><br><span class="line">5322637312字节(5.3 GB)已复制，5.20924 秒，1.0 GB/秒</span><br><span class="line"><span class="meta">#</span><span class="bash">写文件失败</span></span><br><span class="line">[root@linx01 ~]# cp 1g /mnt/</span><br><span class="line">cp: 写入"/mnt/1g" 出错: 设备上没有空间</span><br><span class="line">cp: 扩展"/mnt/1g" 失败: 设备上没有空间</span><br></pre></td></tr></table></figure><h4 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">整体看一下 哪个分区满</span></span><br><span class="line">[root@linx01 ~]# df -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs        710M     0  710M    0% /dev</span><br><span class="line">tmpfs           721M   12K  721M    1% /dev/shm</span><br><span class="line">tmpfs           721M  9.8M  711M    2% /run</span><br><span class="line">tmpfs           721M     0  721M    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda2        17G  9.1G  8.0G   54% /</span><br><span class="line">/dev/sda1      1014M  138M  877M   14% /boot</span><br><span class="line">tmpfs           145M     0  145M    0% /run/user/0</span><br><span class="line">/dev/sdb1       5.0G  5.0G   28K  100% /mnt</span><br><span class="line"><span class="meta">#</span><span class="bash">根据有问题的分区,详细,一层一层排查,排查到具体目录或文件. </span></span><br><span class="line">[root@linx01 ~]# du -sh /mnt/*</span><br><span class="line">4.0K    /mnt/1</span><br><span class="line">704K    /mnt/1g</span><br><span class="line">5.0G    /mnt/test</span><br></pre></td></tr></table></figure><h3 id="Inode结点用完"><a href="#Inode结点用完" class="headerlink" title="Inode结点用完"></a>Inode结点用完</h3><h4 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">模拟创建小的磁盘分区. 进行挂载 在这个磁盘分区中,创建文件,占用inode.模拟inode耗尽.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">01通过dd来创建文件,格式化,挂载. </span></span><br><span class="line">dd if=/dev/zero of=/tmp/inode bs=1k count=2000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">格式化 </span></span><br><span class="line">[root@linx01 ~]# dd if=/dev/zero of=/tmp/inode bs=1k count=2000</span><br><span class="line">记录了2000+0 的读入</span><br><span class="line">记录了2000+0 的写出</span><br><span class="line">2048000字节(2.0 MB)已复制，0.00512224 秒，400 MB/秒</span><br><span class="line">[root@linx01 ~]# mkfs.ext4 /tmp/inode</span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">/tmp/inode is not a block special device.</span><br><span class="line">无论如何也要继续? (y,n) y</span><br><span class="line"></span><br><span class="line">文件系统小得无法记录日志</span><br><span class="line">Discarding device blocks: 完成                            </span><br><span class="line">文件系统标签=</span><br><span class="line">OS type: Linux</span><br><span class="line">块大小=1024 (log=0)</span><br><span class="line">分块大小=1024 (log=0)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">256 inodes, 2000 blocks</span><br><span class="line">100 blocks (5.00%) reserved for the super user</span><br><span class="line">第一个数据块=1</span><br><span class="line">Maximum filesystem blocks=2097152</span><br><span class="line">1 block group</span><br><span class="line">8192 blocks per group, 8192 fragments per group</span><br><span class="line">256 inodes per group</span><br><span class="line"></span><br><span class="line">Allocating group tables: 完成                            </span><br><span class="line">正在写入inode表: 完成                            </span><br><span class="line">Writing superblocks and filesystem accounting information: 完成</span><br><span class="line"><span class="meta">#</span><span class="bash">挂载</span></span><br><span class="line">[root@linx01 ~]# mkdir -p /inode</span><br><span class="line">[root@linx01 ~]# mount /tmp/inode /inode/</span><br><span class="line">[root@linx01 inode]# touch test&#123;00..300&#125;</span><br><span class="line">touch: 无法创建"test245": 设备上没有空间</span><br><span class="line">touch: 无法创建"test246": 设备上没有空间</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="排查-1"><a href="#排查-1" class="headerlink" title="排查"></a>排查</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看磁盘空间</span></span><br><span class="line">[root@linx01 inode]# df -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs        710M     0  710M    0% /dev</span><br><span class="line">tmpfs           721M   12K  721M    1% /dev/shm</span><br><span class="line">tmpfs           721M  9.8M  711M    2% /run</span><br><span class="line">tmpfs           721M     0  721M    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda2        17G  9.1G  8.0G   54% /</span><br><span class="line">/dev/sda1      1014M  138M  877M   14% /boot</span><br><span class="line">tmpfs           145M     0  145M    0% /run/user/0</span><br><span class="line">/dev/sdb1       5.0G   33M  5.0G    1% /mnt</span><br><span class="line">/dev/loop0      2.0M   34K  1.8M    2% /inode</span><br><span class="line"><span class="meta">#</span><span class="bash">查看inode占用情况</span></span><br><span class="line">[root@linx01 inode]# df -i</span><br><span class="line">文件系统         Inode 已用(I) 可用(I) 已用(I)% 挂载点</span><br><span class="line">devtmpfs        181681     394  181287       1% /dev</span><br><span class="line">tmpfs           184363       2  184361       1% /dev/shm</span><br><span class="line">tmpfs           184363     784  183579       1% /run</span><br><span class="line">tmpfs           184363      16  184347       1% /sys/fs/cgroup</span><br><span class="line">/dev/sda2      8910848  170067 8740781       2% /</span><br><span class="line">/dev/sda1       524288     326  523962       1% /boot</span><br><span class="line">tmpfs           184363       1  184362       1% /run/user/0</span><br><span class="line">/dev/sdb1      2620928       5 2620923       1% /mnt</span><br><span class="line">/dev/loop0         256     256       0     100% /inode</span><br></pre></td></tr></table></figure><h3 id="文件没有被彻底删除导致"><a href="#文件没有被彻底删除导致" class="headerlink" title="文件没有被彻底删除导致"></a>文件没有被彻底删除导致</h3><p>文件删除条件:</p><ul><li>硬链接数为0: 没有入口了(硬链接数为0,rm删除.) </li><li>文件打开数为0: 这个文件没有任何调用(服务软件/命令)</li></ul><h4 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 inode]# dd if=/dev/zero of=/mnt/test count=5120 bs=1M</span><br><span class="line">dd: 写入"/mnt/test" 出错: 设备上没有空间</span><br><span class="line">记录了5077+0 的读入</span><br><span class="line">记录了5076+0 的写出</span><br><span class="line">5322571776字节(5.3 GB)已复制，6.73888 秒，790 MB/秒</span><br><span class="line">[root@linx01 inode]# cd /mnt/</span><br><span class="line">[root@linx01 mnt]# ls</span><br><span class="line">1  1g  test</span><br><span class="line"><span class="meta">#</span><span class="bash">/sdb1已经被占满</span></span><br><span class="line">[root@linx01 mnt]# df -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs        710M     0  710M    0% /dev</span><br><span class="line">tmpfs           721M   12K  721M    1% /dev/shm</span><br><span class="line">tmpfs           721M  9.8M  711M    2% /run</span><br><span class="line">tmpfs           721M     0  721M    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda2        17G  9.1G  8.0G   54% /</span><br><span class="line">/dev/sda1      1014M  138M  877M   14% /boot</span><br><span class="line">tmpfs           145M     0  145M    0% /run/user/0</span><br><span class="line">/dev/sdb1       5.0G  5.0G   92K  100% /mnt</span><br><span class="line">/dev/loop0      2.0M   34K  1.8M    2% /inode</span><br><span class="line"><span class="meta">#</span><span class="bash">进程监控文件 打开文件<span class="built_in">test</span></span></span><br><span class="line">[root@linx01 mnt]# tail -f test &amp;</span><br><span class="line">[1] 19185</span><br><span class="line">[root@linx01 bin]# df -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs        710M     0  710M    0% /dev</span><br><span class="line">tmpfs           721M     0  721M    0% /dev/shm</span><br><span class="line">tmpfs           721M  9.8M  711M    2% /run</span><br><span class="line">tmpfs           721M     0  721M    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda2        17G  9.1G  8.0G   54% /</span><br><span class="line">/dev/sda1      1014M  138M  877M   14% /boot</span><br><span class="line">tmpfs           145M     0  145M    0% /run/user/0</span><br><span class="line">/dev/sdb1       5.0G  5.0G   92K  100% /mnt</span><br><span class="line">/dev/loop0      2.0M   34K  1.8M    2% /inode</span><br><span class="line">[root@linx01 bin]# du -sh /mnt/*</span><br><span class="line">4.0K    /mnt/1</span><br><span class="line">704K    /mnt/1g</span><br></pre></td></tr></table></figure><h4 id="排查-2"><a href="#排查-2" class="headerlink" title="排查"></a>排查</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">df 发现占满,du却查不到</span></span><br><span class="line">[root@linx01 bin]# df -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs        710M     0  710M    0% /dev</span><br><span class="line">tmpfs           721M     0  721M    0% /dev/shm</span><br><span class="line">tmpfs           721M  9.8M  711M    2% /run</span><br><span class="line">tmpfs           721M     0  721M    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda2        17G  9.1G  8.0G   54% /</span><br><span class="line">/dev/sda1      1014M  138M  877M   14% /boot</span><br><span class="line">tmpfs           145M     0  145M    0% /run/user/0</span><br><span class="line">/dev/sdb1       5.0G  5.0G   92K  100% /mnt</span><br><span class="line">/dev/loop0      2.0M   34K  1.8M    2% /inode</span><br><span class="line">[root@linx01 bin]# du -sh /mnt/*</span><br><span class="line">4.0K    /mnt/1</span><br><span class="line">704K    /mnt/1g</span><br><span class="line"><span class="meta">#</span><span class="bash">查看被删除没有释放掉的文件</span></span><br><span class="line">[root@linx01 bin]# lsof |grep delete</span><br><span class="line">tail      19185                root    3r      REG               8,17 5322571776         67 /mnt/test (deleted)</span><br><span class="line"><span class="meta">#</span><span class="bash">杀死或重启对应进程</span></span><br><span class="line">[root@linx01 bin]# kill 19185</span><br><span class="line">[root@linx01 bin]# df -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs        710M     0  710M    0% /dev</span><br><span class="line">tmpfs           721M     0  721M    0% /dev/shm</span><br><span class="line">tmpfs           721M  9.9M  711M    2% /run</span><br><span class="line">tmpfs           721M     0  721M    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda2        17G  9.1G  8.0G   54% /</span><br><span class="line">/dev/sda1      1014M  138M  877M   14% /boot</span><br><span class="line">tmpfs           145M     0  145M    0% /run/user/0</span><br><span class="line">/dev/sdb1       5.0G   33M  5.0G    1% /mnt</span><br><span class="line">/dev/loop0      2.0M   34K  1.8M    2% /inode</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><div class="table-container"><table><thead><tr><th>磁盘空间不足原因</th><th>现象</th><th>排查</th><th>解决</th></tr></thead><tbody><tr><td>常规大文件(大量文件) block不足.</td><td>创建文件或使用服务 报错提示磁盘空间不足  no space left on  device</td><td>df -h ; du -sh 一层一层排 查. 最终精确到文件或目录.</td><td>确认后删除.</td></tr><tr><td>大量inode使用,inode不足.</td><td>创建文件提示磁盘空间不足. df -h 磁盘没 满.</td><td>df -i ; 哪个分区inode满 了. 使用find找分区中大于 1MB目录.</td><td>确认后删除目录中大量 小文件.</td></tr><tr><td>文件未彻底删除导致的磁盘 空间不足.</td><td>提示磁盘空间不足. df -h 真的不足. du -sh 看还有剩余.</td><td>lsof ｜grep delete</td><td>重启对应的服务/进程.</td></tr></tbody></table></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>fdisk磁盘分区实战</title>
      <link href="/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%AE%9E%E6%88%98/"/>
      <url>/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>​    此次我们在虚拟机上添加磁盘进行操作。具体的添加操作，由于不同的虚拟机添加方法不一样就不在叙述了。</p><p>添加完磁盘后，使用lsblk命令可以查看所以的块设备</p><p><img src="image-20221214192320994.png" alt="image-20221214192320994"></p><p>可以看到，当前虚拟机上共有三块设备，两块硬盘，一块光盘，只要能看到自己添加的硬盘即可。</p><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><h3 id="fdisk分区指令"><a href="#fdisk分区指令" class="headerlink" title="fdisk分区指令"></a>fdisk分区指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk [选项][参数]</span><br></pre></td></tr></table></figure><p>​    fdisk 指令是 Linux 下通用的磁盘分区工具，它可以操纵硬盘分区表，完成对硬盘分区进行管理的各种操作。</p><p>它也是交互的，在进行分区的时候会有提示。在分区之前 可以使用 fdisk -l 查看磁盘的所有分区列表。</p><p><img src="image-20221214192950364.png" alt="image-20221214192950364"></p><h3 id="分区案例演示"><a href="#分区案例演示" class="headerlink" title="分区案例演示"></a>分区案例演示</h3><p>​    接下来。我以第二块硬盘sdb 逐步进行分区演示。</p><p>Case01:创建一个100M的分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# fdisk /dev/sdb</span><br><span class="line">欢迎使用 fdisk (util-linux 2.23.2)。</span><br><span class="line"></span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：m</span><br><span class="line">命令操作</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create an IRIX (SGI) partition table</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   print this menu</span><br><span class="line">   n   add a new partition</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   print the partition table</span><br><span class="line">   q   quit without saving changes</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition's system id</span><br><span class="line">   u   change display/entry units</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   w   write table to disk and exit</span><br><span class="line">   x   extra functionality (experts only)</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：p</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0xf6a444cb</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">分区号 (1-4，默认 1)：</span><br><span class="line">起始 扇区 (2048-10485759，默认为 2048)：</span><br><span class="line">将使用默认值 2048</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-10485759，默认为 10485759)：100M</span><br><span class="line">值超出范围。</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-10485759，默认为 10485759)：+100M</span><br><span class="line">分区 1 已设置为 Linux 类型，大小设为 100 MiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line"></span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: 设备或资源忙.</span><br><span class="line">The kernel still uses the old table. The new table will be used at</span><br><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span><br><span class="line">正在同步磁盘。</span><br></pre></td></tr></table></figure><p>上述整个过程可以看到，我们通过交互命令打印出，当前分区为0，然后添加了一个100M的分区</p><p>其中上述的交互命令，常用的有如下这些</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p (print) 显示当前磁盘分区信息.</span><br><span class="line">n (new) 创建磁盘分区.</span><br><span class="line">d (delete) 删除分区.</span><br><span class="line">q (quit) 退出不保存.</span><br><span class="line">w (write) 保存并退出. 让磁盘分区生效.</span><br></pre></td></tr></table></figure><p>Case02:删除创建的一个分区,再创建 1个主分区500M，2个逻辑分区分别为1G、500M</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# fdisk /dev/sdb</span><br><span class="line">欢迎使用 fdisk (util-linux 2.23.2)。</span><br><span class="line"></span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：p</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0xf6a444cb</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048      206847      102400   83  Linux</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：d</span><br><span class="line">已选择分区 1</span><br><span class="line">分区 1 已删除</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">分区号 (1-4，默认 1)：</span><br><span class="line">起始 扇区 (2048-10485759，默认为 2048)：</span><br><span class="line">将使用默认值 2048</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-10485759，默认为 10485759)：+500M  </span><br><span class="line">分区 1 已设置为 Linux 类型，大小设为 500 MiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): e</span><br><span class="line">分区号 (2-4，默认 2)：</span><br><span class="line">起始 扇区 (1026048-10485759，默认为 1026048)：</span><br><span class="line">将使用默认值 1026048</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (1026048-10485759，默认为 10485759)：+2G</span><br><span class="line">分区 2 已设置为 Extended 类型，大小设为 2 GiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 1 extended, 2 free)</span><br><span class="line">   l   logical (numbered from 5)</span><br><span class="line">Select (default p): l</span><br><span class="line">添加逻辑分区 5</span><br><span class="line">起始 扇区 (1028096-5220351，默认为 1028096)：</span><br><span class="line">将使用默认值 1028096</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (1028096-5220351，默认为 5220351)：+1G</span><br><span class="line">分区 5 已设置为 Linux 类型，大小设为 1 GiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 1 extended, 2 free)</span><br><span class="line">   l   logical (numbered from 5)</span><br><span class="line">Select (default p): l</span><br><span class="line">添加逻辑分区 6</span><br><span class="line">起始 扇区 (3127296-5220351，默认为 3127296)：</span><br><span class="line">将使用默认值 3127296</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (3127296-5220351，默认为 5220351)：+1G</span><br><span class="line">值超出范围。</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (3127296-5220351，默认为 5220351)：+500M  </span><br><span class="line">分区 6 已设置为 Linux 类型，大小设为 500 MiB</span><br><span class="line">命令(输入 m 获取帮助)：p</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0xf6a444cb</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048     1026047      512000   83  Linux</span><br><span class="line">/dev/sdb2         1026048     5220351     2097152    5  Extended</span><br><span class="line">/dev/sdb5         1028096     3125247     1048576   83  Linux</span><br><span class="line">/dev/sdb6         3127296     4151295      512000   83  Linux</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line"></span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: 设备或资源忙.</span><br><span class="line">The kernel still uses the old table. The new table will be used at</span><br><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span><br><span class="line">正在同步磁盘。</span><br></pre></td></tr></table></figure><p>可以看到。在创建扩展分区之后，在进行创建时候就看到逻辑分区了。这就是因为逻辑分区是依赖扩展分区的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>我们看到整个分区的过程还是比较简单的，分区就类似给房子打隔断，打完隔断就变成一个一个的房间，但这时候还是不能用的，还需要格式化 类似于装修，最后挂载相当于装门，就可以用了。完整的流程我们后面还会总结。</li><li>fdisk 分区是mbr各式的，除了fdisk指令还有其它指令我们总结如下:</li></ul><div class="table-container"><table><thead><tr><th>指令</th><th>分区格式</th><th>限制</th></tr></thead><tbody><tr><td>fdisk</td><td>mbr</td><td>磁盘不能大于2tb</td></tr><tr><td>parted</td><td>mbr(msdos)、gpt</td><td>支持2tb以上</td></tr><tr><td>gdisk</td><td>gpt</td><td>2tb以上</td></tr></tbody></table></div><p> 大于2tb的磁盘需要用gpt的分区格式，所以通常用 parted或者gdisk指令 。其实只要熟练掌握一种指令 其它都是类似的。</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SWAP分区实战</title>
      <link href="/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-SWAP%E5%88%86%E5%8C%BA%E5%AE%9E%E6%88%98/"/>
      <url>/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-SWAP%E5%88%86%E5%8C%BA%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>swap 交换分区.内存不足的时候临时充当内存.</p><h2 id="创建swap分区"><a href="#创建swap分区" class="headerlink" title="创建swap分区"></a>创建swap分区</h2><h3 id="通过文件创建swap分区"><a href="#通过文件创建swap分区" class="headerlink" title="通过文件创建swap分区"></a>通过文件创建swap分区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# dd if=/dev/zero of=/tmp/t count=100 bs=10M</span><br><span class="line">记录了100+0 的读入</span><br><span class="line">记录了100+0 的写出</span><br><span class="line">1048576000字节(1.0 GB)已复制，1.28384 秒，817 MB/秒</span><br><span class="line">[root@linx01 ~]# swapon</span><br><span class="line">NAME      TYPE       SIZE  USED PRIO</span><br><span class="line">/dev/sda3 partition 1020M 43.5M   -2</span><br><span class="line">[root@linx01 ~]# mkswap /tmp/t</span><br><span class="line">正在设置交换空间版本 1，大小 = 1023996 KiB</span><br><span class="line">无标签，UUID=ca9c6c30-32b3-4236-89bc-ee396dff8bec</span><br><span class="line">[root@linx01 ~]# swapon</span><br><span class="line">NAME      TYPE       SIZE  USED PRIO</span><br><span class="line">/dev/sda3 partition 1020M 43.5M   -2</span><br><span class="line">[root@linx01 ~]# swapon /tmp/t</span><br><span class="line">swapon: /tmp/t：不安全的权限 0644，建议使用 0600。</span><br><span class="line">[root@linx01 ~]# swapon</span><br><span class="line">NAME      TYPE       SIZE  USED PRIO</span><br><span class="line">/dev/sda3 partition 1020M 43.5M   -2</span><br><span class="line">/tmp/t    file      1000M    0B   -3</span><br></pre></td></tr></table></figure><h3 id="通过磁盘分区创建swap"><a href="#通过磁盘分区创建swap" class="headerlink" title="通过磁盘分区创建swap"></a>通过磁盘分区创建swap</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建 1G分区</span></span><br><span class="line">[root@linx01 ~]# fdisk /dev/sdb</span><br><span class="line">欢迎使用 fdisk (util-linux 2.23.2)。</span><br><span class="line"></span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p):      </span><br><span class="line">Using default response p</span><br><span class="line">分区号 (1-4，默认 1)：</span><br><span class="line">起始 扇区 (2048-10485759，默认为 2048)：</span><br><span class="line">将使用默认值 2048</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-10485759，默认为 10485759)：+1G</span><br><span class="line">分区 1 已设置为 Linux 类型，大小设为 1 GiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line"></span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: 设备或资源忙.</span><br><span class="line">The kernel still uses the old table. The new table will be used at</span><br><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span><br><span class="line">正在同步磁盘。</span><br><span class="line"><span class="meta">#</span><span class="bash">格式化 swap分区</span></span><br><span class="line">[root@linx01 ~]# mkswap /dev/sdb1</span><br><span class="line">mkswap: /dev/sdb1: warning: wiping old xfs signature.</span><br><span class="line">正在设置交换空间版本 1，大小 = 5241852 KiB</span><br><span class="line">无标签，UUID=60ad3453-f89f-4c83-867f-68a93e95eccf</span><br><span class="line">[root@linx01 ~]# swapon</span><br><span class="line">NAME      TYPE       SIZE USED PRIO</span><br><span class="line">/dev/sda3 partition 1020M  54M   -2</span><br><span class="line">/tmp/t    file      1000M   0B   -3</span><br><span class="line"><span class="meta">#</span><span class="bash">激活交换分区</span></span><br><span class="line">[root@linx01 ~]# swapon /dev/sdb1</span><br><span class="line">[root@linx01 ~]# swapon</span><br><span class="line">NAME      TYPE       SIZE USED PRIO</span><br><span class="line">/dev/sda3 partition 1020M  54M   -2</span><br><span class="line">/tmp/t    file      1000M   0B   -3</span><br><span class="line">/dev/sdb1 partition    5G   0B   -4</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>创建swap分区的流程主要就三步： 创建分区（文件或磁盘分区）、格式化swap文件系统、激活swap分区对应的命令是 fdisk(dd)、mkswap、swapon</p></li><li><p>swap分区是内存不够用了 没办法的事情，通常情况，我们不会用，尤其云服务器默认就不带swap分区的，因为云服务器扩资源比较容易。不仅如此，如果有发现 swap分区占用，内存还很充足 就要降低swap的使用度在/etc/sysctl.conf 文件里添加如下参数：vm.swappiness=10</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的磁盘管理体系</title>
      <link href="/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-Linux%E7%9A%84%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB/"/>
      <url>/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-Linux%E7%9A%84%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="　前言"></a>　前言</h2><p>磁盘相关的知识是Linux系统中的重头戏，需要了解的点比较多。但现在随着云计算的兴起，在很多企业中很少碰到物理服务器了也就不会接触到屋里磁盘。所以更多的是停留在使用的层面。下面我们就系统的回顾一下linux的磁盘知识。</p><h2 id="磁盘管理基础"><a href="#磁盘管理基础" class="headerlink" title="磁盘管理基础"></a>磁盘管理基础</h2><h3 id="磁盘分类与接口"><a href="#磁盘分类与接口" class="headerlink" title="磁盘分类与接口"></a>磁盘分类与接口</h3><p>磁盘分类:</p><ul><li>机械硬盘HDD</li><li>固态硬盘SSD</li></ul><p>磁盘接口分类:</p><div class="table-container"><table><thead><tr><th>类型</th><th>磁盘类型</th><th>适应场景</th></tr></thead><tbody><tr><td>sata</td><td>机械、固态</td><td>家用更多</td></tr><tr><td>sas(由scsi改进而来)</td><td>机械、固态</td><td>企业更多</td></tr><tr><td>pic-e</td><td>固态</td><td>企业、家用</td></tr></tbody></table></div><p>注:以上只列举了目前家庭企业比较常见的，实际上现在还有较新的M2接口，速度也更快，感兴趣的可以自己了解下。</p><h3 id="企业磁盘选型"><a href="#企业磁盘选型" class="headerlink" title="企业磁盘选型"></a>企业磁盘选型</h3><p>在企业场景中，选择磁盘的时候 要考虑很多方面，包括性能、性价比等，要根据不同的场景选择合适的磁盘，也是为了节省成本。</p><div class="table-container"><table><thead><tr><th>接口</th><th>应用场景</th><th></th></tr></thead><tbody><tr><td>sata</td><td>企业内部使用,存放备份. 线下业务(给自己内部人员使用)</td><td>4tb 6tb 7.2k转 * 8</td></tr><tr><td>SAS</td><td>企业标配,线上业务(线上环境,生产环境)使用(提供给用户环境)</td><td>300g 600g 900g 15k硬盘 *8</td></tr><tr><td>固态硬盘(pci- e/sas/sata)</td><td>访问量巨大(并发高). 数据量不是很大. (架构优化策略:把用户经常访问的数据存 放在固态)</td><td>500g 1tb 2tb *4</td></tr></tbody></table></div><h3 id="磁盘内部结构"><a href="#磁盘内部结构" class="headerlink" title="磁盘内部结构"></a>磁盘内部结构</h3><p>机械硬盘:</p><p><img src="20191123182101621.png" alt="img"></p><p>固态硬盘: 闪存颗粒 nand flash</p><p>上述只是粗略的描述，固态硬盘的内部结构比较复杂。感兴趣的可以寻找其他资料。</p><h3 id="固态VS机械"><a href="#固态VS机械" class="headerlink" title="固态VS机械"></a>固态VS机械</h3><div class="table-container"><table><thead><tr><th>指标</th><th>机械硬盘</th><th>固态硬盘</th></tr></thead><tbody><tr><td>性价比</td><td>容量大价格低</td><td>容量小价格高</td></tr><tr><td>稳定性</td><td>抗击打能力弱</td><td>抗击打能力高</td></tr><tr><td>速度</td><td>读写速度稍慢</td><td><strong>读写速度很快</strong></td></tr><tr><td>数据安全</td><td>数据恢复易</td><td>数据恢复难</td></tr><tr><td>寿命</td><td>无限</td><td>1-2w次</td></tr></tbody></table></div><h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p>​    我们都知道现在的互联网时代，尤其对于一家互联网公司而言，数据就是核心，数据存储在磁盘上，如果磁盘坏掉了 那公司不是要瘫痪掉吗。所以RAID技术就是来解决数据安全的。如果一块磁盘坏掉，我们是不是有其他方案能替换掉这块磁盘来作一个兜底。RAID相当于是一个节点上的磁盘的保障方案。同理，如果一个节点坏掉呢？那么就要使用其他节点 也就是分布式了。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>磁盘冗余阵列 RAID 物理服务器的硬盘,通过raid管理,才能使用。</li><li>常见的raid级别: raid 0 , raid 1 , raid 5,raid 10</li></ul><div class="table-container"><table><thead><tr><th></th><th>至少几块硬盘</th><th>容量</th><th>冗余</th><th>性能</th></tr></thead><tbody><tr><td>raid 0 (条 带)</td><td>1</td><td>所有硬盘容量总和.</td><td>最低,没有冗余.</td><td>最快的.</td></tr><tr><td>raid 1 (镜 像)</td><td>2块硬盘(制作的时候,1次只能给2块硬 盘做raid1)</td><td>一半.</td><td>冗余100%</td><td>写入性能较慢,读取类似于单 块硬盘.</td></tr><tr><td>raid 5</td><td>至少3块硬盘</td><td>损失n-1 (n硬盘总 数,n&gt;=3)</td><td>损坏1块.</td><td>读取性能还可以,写入较慢.</td></tr><tr><td>raid 10</td><td>至少需要4块硬盘</td><td>减半</td><td>损坏一半,但是不能在1 个组里.</td><td>读写性能强悍</td></tr></tbody></table></div><p>我们来看几张图，更容易理解 ：</p><p><img src="1.jpg" alt="img" style="zoom:50%;" /></p><p><img src="2.jpg" alt="img" style="zoom:50%;" /></p><p><img src="3.jpg" alt="img"></p><p><img src="4.jpg" alt="img"></p><h3 id="RAID与LVM"><a href="#RAID与LVM" class="headerlink" title="RAID与LVM"></a>RAID与LVM</h3><p>​    RAID相当于在物理层面，将多块磁盘进行组合给上层使用。而LVM 逻辑卷 是在软件层面也就是 逻辑上的 去进行多个磁盘块的整合 以达到屏蔽效果，它的好处是 可以支持动态扩容磁盘。缺点就是 使用起来会慢。由关LVM的细节，此处就不多介绍了，以后会详细介绍。</p><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><h3 id="磁盘分区概述"><a href="#磁盘分区概述" class="headerlink" title="磁盘分区概述"></a>磁盘分区概述</h3><ul><li>磁盘的第1个扇区: 0磁头(盘面)0磁道1扇区 1个扇区 512字节 <ul><li>MBR 磁盘的引导程序(主引导记录) : 引导系统启动. </li><li>分区表:存放分区开始结束信息</li></ul></li></ul><p><img src="5.jpg" alt="image-20221214155901109" style="zoom:50%;" /></p><h3 id="主分区-扩展分区-逻辑分区·"><a href="#主分区-扩展分区-逻辑分区·" class="headerlink" title="主分区,扩展分区,逻辑分区·"></a>主分区,扩展分区,逻辑分区·</h3><ul><li>主分区: 最多有4个,每个占用16字节分区表空间 </li><li><p>扩展分区:主要用来解决主分区最多4个. 主分区无法直接存放数据与使用. 如果要使用需要在扩展分区中创建逻辑分区. 扩展分区在一个磁盘中只有1个.</p></li><li><p>逻辑分区:需要先创建扩展分区. 使用逻辑分区存放数据.</p></li></ul><p><img src="image-20221214160133501.png" alt="image-20221214160133501"></p><h3 id="分区命名规则"><a href="#分区命名规则" class="headerlink" title="分区命名规则"></a>分区命名规则</h3><p> 磁盘名字:/dev/sda(第一块磁盘不做分区) 、/dev/sda1、/dev/sda2 </p><ul><li><p>第1块硬盘 /dev/sda </p></li><li><p>第2块硬盘 /dev/sdb</p></li></ul><p>分区命名规则:</p><ul><li>主分区或扩展分区 1-4  /dev/sda1-4</li><li>逻辑分区从5开始 /dev/sda5</li></ul><p>例子:</p><ul><li>第3块sata硬盘的第1个主分区 /dev/sdc1 </li><li>第4块sas硬盘的第2个逻辑分区 /dev/sdd6</li></ul><h3 id="MBR-vs-GPT"><a href="#MBR-vs-GPT" class="headerlink" title="MBR vs GPT"></a>MBR vs GPT</h3><p>MBR与GPT可以理解分两种磁盘分区的标准GPT可以解决MBR的问题。</p><ul><li>MBR主引导记录,磁盘分区格式 。磁盘大小不能大于2tb,如果大于2tb则无法使用.</li><li>GPT分区表格式,解决问题. 解决系统支持大硬盘的问题。主分区随便用,不用区分主分区,扩展分区逻辑分区.</li></ul><div class="table-container"><table><thead><tr><th>MBR VS GPT</th><th>支持的主分区数量</th><th>支持的硬盘大小</th><th>磁盘分区命令</th></tr></thead><tbody><tr><td>MBR</td><td>支持的主分区+扩展分区 最多 4个</td><td>小于2tb硬盘</td><td>fdsik 只支持mbr</td></tr><tr><td>GPT</td><td>可以理解无限</td><td>可以各种容量的磁盘</td><td>parted/gdisk 支持 gpt和mbr</td></tr></tbody></table></div><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>格式化的目的就是创建一个文件系统，分区之后必须要格式化才能使用。</p><div class="table-container"><table><thead><tr><th>系统类型</th><th>文件系统</th></tr></thead><tbody><tr><td>Linux</td><td>ext3(centOS5)、ext4 (C6 ) 、xfs(C7),btrfs</td></tr><tr><td>Windows</td><td>fat32, ntfs</td></tr></tbody></table></div><p>格式化常用的命令就是mkfs。 日后我们会在实战中详细的进行 的演示。</p><h2 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h2><p>Swap 是在 内存不足的时候临时充当内存 </p><p><img src="image-20221214162643361.png" alt="image-20221214162643361"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>我们这次只是对磁盘体系进行一个概要的梳理，命令的使用是细节，更重要的是让知识成体系</p><p><img src="6.jpg" alt="image-20221214163042509"></p></li><li><p>简单来讲，对于一块磁盘使用，只需要三步走</p><ol><li>分区 :fdisk/parted/gdisk,</li><li>格式化 :mkfs.xfs</li><li>挂载 ：  临时挂载:mount/umount 永久挂载： /etc/rc.local /etc/fstab</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sed、awk的混合使用</title>
      <link href="/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-sed%E3%80%81awk%E7%9A%84%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-sed%E3%80%81awk%E7%9A%84%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的正则表达式</title>
      <link href="/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-Linux%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-Linux%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux的特殊符号总结</title>
      <link href="/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-Linux%E7%9A%84%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E6%80%BB%E7%BB%93/"/>
      <url>/2022/12/14/LINUX%E8%BF%90%E7%BB%B4-2022-12-14-Linux%E7%9A%84%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>linux系统中充满着各种各式的符号，尤其是在书写shell脚本时候，更是明显，今天索性把所有常见的符号进行总结，方便记忆。</p><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><div class="table-container"><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>反引号:`` 或 $()</td><td>优先执行,先执行里面的命令. 一般创建/打包的时候给文件名加上个日期.</td></tr><tr><td>单引号: ‘’</td><td>所见即所得,单引号里面的内容会原封不动的输出.</td></tr><tr><td>双引号: “”</td><td>与单引号类似,但是对引号的里面特殊符号会进行解析(运行)</td></tr><tr><td>不加引号:</td><td>与双引号类似,同时支持{}.</td></tr></tbody></table></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">case01:单引号,所见及所得</span></span><br><span class="line">[root@linx01 ~]# echo 'root $UID `whoami` &#123;1..5&#125;'</span><br><span class="line">root $UID `whoami` &#123;1..5&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">case02:双引号 ，会进行解析</span></span><br><span class="line">[root@linx01 ~]# echo "root $UID `whoami` &#123;1..5&#125;"</span><br><span class="line">root 0 root &#123;1..5&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">case03:反引号 运行指令的</span></span><br><span class="line">[root@linx01 ~]# echo "root $UID whoami &#123;1..5&#125;"</span><br><span class="line">root 0 whoami &#123;1..5&#125;</span><br></pre></td></tr></table></figure><h2 id="重定向符号"><a href="#重定向符号" class="headerlink" title="重定向符号"></a>重定向符号</h2><div class="table-container"><table><thead><tr><th>重定向符号</th><th>含义</th></tr></thead><tbody><tr><td>&gt;或 1&gt;</td><td>标准输出重定向,先清空文件内容,然后写入.</td></tr><tr><td>&gt;&gt;或 1&gt;&gt;</td><td>标准输出追加重定向, 把内容追加到文件末尾.</td></tr><tr><td>2&gt;</td><td>标准错误输出重定向, 先清空文件,然后写入错误信息到文件.</td></tr><tr><td>2&gt;&gt;</td><td>标准错误追加输出重定向, ,把错误信息追加到文件末尾.</td></tr><tr><td>&gt; test.log 2&gt;&amp;1</td><td>把标准错误输出与标准输出合并,然后重定向到test.log中.</td></tr><tr><td>&gt;&gt; test.log 2&gt;&amp;1</td><td>追加到test.log中.</td></tr><tr><td>&amp;&gt;test.txt</td><td>正确输出和错误输出重定向到test.txt中</td></tr><tr><td><strong>&amp;&gt;&gt;test.txt</strong></td><td>正确输出和错误输出 追加到test.txt中</td></tr><tr><td>&lt;或0&lt;</td><td>标准输入重定向</td></tr><tr><td>&lt;&lt;或0&lt;&lt;</td><td>标准输入追加重定向</td></tr></tbody></table></div><p>补充：0,1,2都是文件打开的描述符 每个程序都自带这3个打开描述符号。</p><p>以上都比较简单，就不给事例了。</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><div class="table-container"><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>匹配任意0个或多个字符 字符串</td></tr><tr><td>?</td><td><strong>匹配任意1个字符，有且只有一个字符  </strong> 千万不要和正则混了</td></tr><tr><td>{}</td><td>生成序列</td></tr><tr><td>?</td><td>任意一个字符</td></tr><tr><td>[]</td><td>其中一个即可</td></tr><tr><td><sup><a href="#fn_" id="reffn_"></a></sup></td><td>排除其中的</td></tr><tr><td>\</td><td></td><td>管道符号</td></tr><tr><td>～</td><td>用户的家目录，超级用户为 /root， 普通用户为 /用户名</td></tr><tr><td>-</td><td>代表上一次（相对于当前路径） 用户所在的路径</td></tr><tr><td>.</td><td>代表当前目录(正则中的任意字符)</td></tr><tr><td>..</td><td>代表上一级目录</td></tr></tbody></table></div><p>我们对其中一些字符进行演示</p><h3 id="、"><a href="#、" class="headerlink" title="{}、*"></a>{}、*</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> * 匹配所有文件</span></span><br><span class="line">[root@linx01 dev]# rm -rf *    </span><br><span class="line"><span class="meta">#</span><span class="bash"> &#123;&#125; 生成序列</span></span><br><span class="line">[root@linx01 dev]# touch test&#123;1..10&#125;</span><br><span class="line">[root@linx01 dev]# ls</span><br><span class="line">test1  test10  test2  test3  test4  test5  test6  test7  test8  test9</span><br><span class="line"><span class="meta">#</span><span class="bash"> 利用*匹配特定的文件</span></span><br><span class="line">[root@linx01 dev]# ls test1*</span><br><span class="line">test1  test10</span><br></pre></td></tr></table></figure><h3 id="、-1"><a href="#、-1" class="headerlink" title="[]、"></a>[]、<sup><a href="#fn_" id="reffn_"></a></sup></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">利用 &#123;&#125;生成文件</span></span><br><span class="line">[root@linx01 dev]# touch &#123;a..z&#125;.sh</span><br><span class="line">[root@linx01 dev]# ls</span><br><span class="line">a.sh  c.sh  e.sh  g.sh  i.sh  k.sh  m.sh  o.sh  q.sh  s.sh  u.sh  w.sh  y.sh</span><br><span class="line">b.sh  d.sh  f.sh  h.sh  j.sh  l.sh  n.sh  p.sh  r.sh  t.sh  v.sh  x.sh  z.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">利用[] 匹配开头是a-c其中，以sh结尾的文件</span></span><br><span class="line">[root@linx01 dev]# ls [a-c].sh</span><br><span class="line">a.sh  b.sh  c.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">利用[^] 匹配开头不是a-c其中并且以sh结尾的文件</span></span><br><span class="line">[root@linx01 dev]# ls [^a-y].sh</span><br><span class="line">z.sh</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title="-"></a>-</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# pwd</span><br><span class="line">/opt/dev</span><br><span class="line">[root@linx01 dev]# cd /etc/sysconfig/network-scripts/</span><br><span class="line">[root@linx01 network-scripts]# pwd</span><br><span class="line">/etc/sysconfig/network-scripts</span><br><span class="line"><span class="meta">#</span><span class="bash"> 利用- 跳回上次所在路径</span></span><br><span class="line">[root@linx01 network-scripts]# cd -</span><br><span class="line">/opt/dev</span><br><span class="line">[root@linx01 dev]# pwd</span><br><span class="line">/opt/dev</span><br></pre></td></tr></table></figure><h3 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h3><p>查找 /etc 目录下包含 hosts 字符串的所有文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# find /etc/ -type f -name "*host.*"</span><br><span class="line">/etc/host.conf</span><br></pre></td></tr></table></figure><p>查找 /etc 目录下的所有文件，规则是文件名的第一个字符为任意字符，第二个字符为o、p、q中的任意一个字符，第三个字符不能在a到r之间，结尾是ts。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# find /etc/ -type f -name "?[opq][^a-r]ts"</span><br><span class="line">/etc/hosts</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的12位权限体系</title>
      <link href="/2022/12/13/LINUX%E8%BF%90%E7%BB%B4-2022-12-13-Linux%E7%9A%8412%E4%BD%8D%E6%9D%83%E9%99%90%E4%BD%93%E7%B3%BB/"/>
      <url>/2022/12/13/LINUX%E8%BF%90%E7%BB%B4-2022-12-13-Linux%E7%9A%8412%E4%BD%8D%E6%9D%83%E9%99%90%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    LINUX权限管理也是linux系统管理中很重要的一部分，通过权限管理最终保障系统网站的安全。接下来我们系统的总结一下linux权限相关的知识点，以及遇到权限问题的排查思路，可以应对工作中常见的权限问题。</p><h2 id="LINUX基础权限"><a href="#LINUX基础权限" class="headerlink" title="LINUX基础权限"></a>LINUX基础权限</h2><h3 id="rwx权限与用户"><a href="#rwx权限与用户" class="headerlink" title="rwx权限与用户"></a>rwx权限与用户</h3><div class="table-container"><table><thead><tr><th>权限的字符</th><th>含义与说明</th></tr></thead><tbody><tr><td>r</td><td>read 读,是否可以读取内容</td></tr><tr><td>w</td><td>write 写, 是否可以修改内容</td></tr><tr><td>x</td><td>executable执行, 是否可以执行内容? 一般执行命令,脚本(shell脚本).</td></tr><tr><td>-</td><td>没有权限</td></tr></tbody></table></div><p><img src="image-20221213185155306.png" alt="image-20221213185155306"></p><p>从左到右依次是:所有者权限、用户权限、其他人权限、所有者、用户组</p><h3 id="Linux的默认权限"><a href="#Linux的默认权限" class="headerlink" title="Linux的默认权限"></a>Linux的默认权限</h3><ul><li><p>创建文件,文件权限是644 </p></li><li><p>创建目录,目录权限是755 </p></li></ul><p>这个是由umask 反掩码(控制Liunx系统默认的权限) 决定的.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# umask</span><br><span class="line">0022</span><br></pre></td></tr></table></figure><p>文件的默认权限则是 666-umask ,结果若为奇数还需要加一.</p><p>目录的默认权限则是777-umask。</p><p>Eg:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">文件的默认权限 </span></span><br><span class="line">666</span><br><span class="line">- 022</span><br><span class="line">---</span><br><span class="line">644</span><br><span class="line"><span class="meta">#</span><span class="bash">文件的默认权限 </span></span><br><span class="line">  666</span><br><span class="line">- 032</span><br><span class="line">  ---</span><br><span class="line">  634 </span><br><span class="line">+ 1</span><br><span class="line">  ---</span><br><span class="line">  644</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">目录的默认权限 </span></span><br><span class="line"> 777</span><br><span class="line">-032</span><br><span class="line"> ---</span><br><span class="line"> 745</span><br></pre></td></tr></table></figure><p>上述了解即可,一般情况不需要改动。</p><p>此外 在/etc/bashrc 中，可以得到这样一段shell</p><p><img src="image-20221213213919204.png" alt="image-20221213213919204"></p><p>可以得出 root用户的umask 是 022 其他用的umask 002。当然umask可以直接用命令修改的，但通常也用不到。</p><h3 id="设置权限常用的命令"><a href="#设置权限常用的命令" class="headerlink" title="设置权限常用的命令"></a>设置权限常用的命令</h3><div class="table-container"><table><thead><tr><th>chown:修改所有者</th><th></th></tr></thead><tbody><tr><td>基本用法 chown 用户.用户组 文件/目录</td><td></td></tr><tr><td>-R</td><td>递归修改所有者.</td></tr></tbody></table></div><p>用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">chown 用户 文件/目录 </span><br><span class="line">chown 用户.用户组 文件/目录</span><br><span class="line"><span class="meta">#</span><span class="bash">修改文件</span></span><br><span class="line">[root@linx01 dev]# ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r-- 1 root root 0 12月 13 08:53 data</span><br><span class="line">[root@linx01 dev]# chown test.test data</span><br><span class="line">[root@linx01 dev]# ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r-- 1 test test 0 12月 13 08:53 data</span><br><span class="line"><span class="meta">#</span><span class="bash">修改目录</span></span><br><span class="line">[root@linx01 dev]# ll -d /root/dev</span><br><span class="line">drwxr-xr-x 2 root root 18 12月 13 08:53 /root/dev</span><br><span class="line">[root@linx01 dev]# chown test.test /root/dev</span><br><span class="line"><span class="meta">#</span><span class="bash">递归修改</span></span><br><span class="line">[root@linx01 dev]# chown test.test -R /root/dev</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>chmod</th><th></th><th></th></tr></thead><tbody><tr><td>chmod 权限 文件/目录</td><td></td><td></td></tr><tr><td>-R</td><td>递归修改权限</td></tr></tbody></table></div><ul><li>通过数字修改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# touch b</span><br><span class="line">[root@linx01 dev]# chmod 777 b</span><br><span class="line">[root@linx01 dev]# ll</span><br><span class="line">总用量 0</span><br><span class="line">-rwxrwxrwx 1 root root 0 12月 13 09:00 b</span><br></pre></td></tr></table></figure><ul><li>通过字符修改</li></ul><p>​    chmod命令  ugo  +/- r/w/x 文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r-- 1 root root 0 12月 13 09:02 a</span><br><span class="line">[root@linx01 dev]# chmod g+w a</span><br><span class="line">[root@linx01 dev]# ll</span><br><span class="line">-rw-rw-r-- 1 root root 0 12月 13 09:02 a</span><br></pre></td></tr></table></figure><h2 id="文件及目录权限"><a href="#文件及目录权限" class="headerlink" title="文件及目录权限"></a>文件及目录权限</h2><h3 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h3><div class="table-container"><table><thead><tr><th>文件的rwx</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>读,是否能查看文件内容(显示与查看)</td></tr><tr><td>w</td><td>写,是否能修改文件内容</td></tr><tr><td>x</td><td>执行, 是否能执行这个文件(命令,脚本)</td></tr></tbody></table></div><p>:warning:对普通用户而言,执行文件只有x权限，没有r权限依然不能执行，见下方验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# touch t.sh</span><br><span class="line">[root@linx01 dev]# chown test.test t.sh</span><br><span class="line">[root@linx01 dev]# ll</span><br><span class="line">总用量 0</span><br><span class="line">---xr--r-- 1 test test 0 12月 13 09:13 t.sh</span><br><span class="line">[root@linx01 dev]# su - test</span><br><span class="line">上一次登录：二 12月 13 09:11:10 EST 2022pts/1 上</span><br><span class="line">[test@linx01 ~]$ cd /opt/dev</span><br><span class="line">[test@linx01 dev]$ sh t.sh</span><br><span class="line">sh: t.sh: Permission denied</span><br></pre></td></tr></table></figure><h3 id="目录的权限"><a href="#目录的权限" class="headerlink" title="目录的权限"></a>目录的权限</h3><p>:star2:生产中是不会用root用户的，使用普通用户的时候经常遇到Permission Denied 问题，熟悉目录的权限是熟练解决Permission Denied 问题的基础。</p><div class="table-container"><table><thead><tr><th>目录rwx</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>查看,查看目录内容.(站在门口看看屋里的内容)</td></tr><tr><td>w</td><td>修改,在目录中创建,删除,重命名文件的权限.</td></tr><tr><td>x</td><td>是否可以进入目录权限.</td></tr></tbody></table></div><ul><li>目录的r权限只能查看内部的文件名字。不能查看详细信息，需要配合x权限1</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# ll -d /opt/dev</span><br><span class="line">drwxr-xr-x 2 root root 18 12月 13 09:13 /opt/dev</span><br><span class="line">[root@linx01 dev]# chmod u=r /opt/dev</span><br><span class="line">[root@linx01 dev]# chown test.test /opt/dev</span><br><span class="line">[test@linx01 opt]$ ll /opt</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x   4 root root 162 Dec  8 07:33 apps</span><br><span class="line">dr--r-xr-x   2 test test  18 Dec 13 09:13 dev</span><br><span class="line">[test@linx01 opt]$ ll  /opt/dev</span><br><span class="line">ls: cannot access /opt/dev/t.sh: Permission denied</span><br><span class="line">total 0</span><br><span class="line">-????????? ? ? ? ?            ? t.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">增加x权限</span></span><br><span class="line">[root@linx01 dev]# chmod u+x /opt/dev</span><br><span class="line">[test@linx01 opt]$ ll  /opt/dev</span><br><span class="line">total 0</span><br><span class="line">---xr--r-- 1 test test 0 Dec 13 09:13 t.sh</span><br></pre></td></tr></table></figure><ul><li><p>目录只有w权限无法操作，需要x配合</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[test@linx01 opt]$ ll -d /opt/dev</span><br><span class="line">d-w-r-xr-x 2 test test 18 Dec 13 09:13 /opt/dev</span><br><span class="line">[test@linx01 opt]$ touch /opt/dev/t</span><br><span class="line">touch: cannot touch ‘/opt/dev/t’: Permission denied</span><br></pre></td></tr></table></figure></li></ul><p>:star2:删除文件或目录要对文件或目录所在目录拥有w(rwx)权限.</p><h2 id="权限问题总结-star2"><a href="#权限问题总结-star2" class="headerlink" title="权限问题总结:star2:"></a>权限问题总结:star2:</h2><h3 id="操作与权限"><a href="#操作与权限" class="headerlink" title="操作与权限"></a>操作与权限</h3><div class="table-container"><table><thead><tr><th></th><th>文件rwx</th><th>目录rwx含义</th></tr></thead><tbody><tr><td>r</td><td>是否可以查看内容</td><td>查看,查看目录内容.(站在门口看看屋里的内容),需要x权限配合.</td></tr><tr><td>w</td><td>是否可以修改文件内容(需要r)</td><td>修改,在目录中创建,删除,重命名文件的权限.需要x配合,(工作一般要rx配合)</td></tr><tr><td>x</td><td>是否可以执行文件(需要r)</td><td>是否可以进入目录权限. 能否查看或修改目录中文件属性信息.</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>日常操作</th><th>需要的权限</th></tr></thead><tbody><tr><td>查看文件的内容</td><td>文件要有r权限.</td></tr><tr><td>编辑或修改文件内容</td><td>文件要有rw权限.</td></tr><tr><td>执行脚本/命令</td><td>文件需要有rx权限.</td></tr><tr><td>查看目录内容</td><td>目录要有rx权限</td></tr><tr><td>创建文件,删除文件</td><td>文件所在目录要有rwx权限</td></tr><tr><td>重命名</td><td>文件所在目录要有rwx权限</td></tr></tbody></table></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">缺少查看权限</span></span><br><span class="line">[test@linx01 dev]$ ll /root</span><br><span class="line">ls: cannot open directory /root: Permission denied</span><br><span class="line">[test@linx01 dev]$ ll -d /root</span><br><span class="line">dr-xr-x---. 8 root root 4096 Dec 13 08:52 /root</span><br><span class="line"><span class="meta">#</span><span class="bash">缺少写权限</span></span><br><span class="line">[test@linx01 dev]$ echo 1 &gt; /etc/passwd</span><br><span class="line">-bash: /etc/passwd: Permission denied</span><br><span class="line">[test@linx01 dev]$ ll /etc/passwd</span><br><span class="line">-rw-r--r-- 1 root root 2174 Dec 13 04:10 /etc/passwd</span><br></pre></td></tr></table></figure><h2 id="三个特殊权限位"><a href="#三个特殊权限位" class="headerlink" title="三个特殊权限位"></a>三个特殊权限位</h2><p>除了能直接看到的9位权限外，其实还有3位 ，分别是:suid,sgid,sticky</p><h3 id="uid"><a href="#uid" class="headerlink" title="uid"></a>uid</h3><p>​    uid ( setuid) 位通过S字符标识，存在于基本权限的用户权限位的×权限对应的位<br>置，如果用户权限位对应的x权限位上有x权限，则 suid 就用小写的s标识，suid 的<br>对应的数字权限为4，完整权限用八进制数 4000 表示。</p><p>​     suid 的作用就是让普通用户可以在执行某个设置了 suid 位的命令或程序时，拥<br>有和 root 管理员一样的身份和权限（默认)。</p><p>可以看一下passwd命令。这样普通用户就可以利用passwd命令来修改自己的密码</p><p><img src="image-20221213225638896.png" alt="image-20221213225638896"></p><h3 id="suid"><a href="#suid" class="headerlink" title="suid"></a>suid</h3><p>​    suid 的作用就是让普通用户可以在执行某个设置了 suid 位的命令或程序时，拥<br>有和 root 管理员一样的身份和权限（默认)。<br>对于二进制命令或者程序来说，sgid 的功能和 suid 基本相同，唯一的区别是 suid<br>是获得命令所属用户的身份和权限，而 sgid 是获得命令的所属用户组的身份和权限</p><h3 id="sbit"><a href="#sbit" class="headerlink" title="sbit"></a>sbit</h3><p>粘贴位的用途一般是把一个文件夹的权限都打开，然后来共享文件，像/tmp 目录一样。虽然方便，但是带来了一定的安全險患，生产环境应禁止设置粘滞位权限。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次我们总结了Linux权限相关的点。对于3个特殊权限 并没有过多的介绍，因为目前生产中也用的极少极少，通常解决问题的方法有很多种，这种不常用的不了解也罢，而像目录权限，文件权限这种基础的知识更应该掌握熟练。</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux用户管理</title>
      <link href="/2022/12/13/LINUX%E8%BF%90%E7%BB%B4-2022-12-13-Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>/2022/12/13/LINUX%E8%BF%90%E7%BB%B4-2022-12-13-Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    用户管理体系是linux系统中一样很重要的内容，不同的用户分配不同等级的权限可以保障系统的安全，问题发生以后也方便追溯问题的原因。接下来总结一下与用户管理相关的一些比较重要的内容。</p><h2 id="用户分类"><a href="#用户分类" class="headerlink" title="用户分类"></a>用户分类</h2><div class="table-container"><table><thead><tr><th>用户分类</th><th style="text-align:center">含义</th><th>uid</th></tr></thead><tbody><tr><td>root用户</td><td style="text-align:center">最高权限用户。</td><td>0</td></tr><tr><td>虚拟用户（傀儡用 户）</td><td style="text-align:center">这种用户存在是用于让一些服务正常运行。一些服务运行需要指定 的用户。</td><td>uid是1-999 （非唯一判断标准）</td></tr><tr><td>普通用户</td><td style="text-align:center">只对自己家目录拥有权限的用户。</td><td>1000开始 （CentOS 7. 8. ) C5 c6 (从500开始）</td></tr></tbody></table></div><h3 id="补充：最小化原则"><a href="#补充：最小化原则" class="headerlink" title="补充：最小化原则"></a>补充：最小化原则</h3><p> Linux中，像文件、进程 天生就要有主人，一定要有归属的用户，文件要有属主，进程要有启动用户，目的就是为了安全，不要让别人看一些不该看的东西，也不要让一些进程做你不应该做的。</p><ol><li>安装软件最小化</li><li>登录安全最小化（普通用户）</li><li>进程启动权限最小化。</li><li>权限最小化</li></ol><p>​    linux中使用命令的时候应该时刻想到最小化原则,比如一个进程需要启动，那么就只给这个用户启动这个进程的权限就好，不要扩大权限。再比如使用find命令 查找文件继而进行删除的时候，find查找的范围要尽可能的精确多使用参数来控制比如文件类型、修改时间、文件大小等等，避免误删这也是最小化原则。</p><h2 id="用户相关的配置文件"><a href="#用户相关的配置文件" class="headerlink" title="用户相关的配置文件"></a>用户相关的配置文件</h2><h3 id="直接相关文件"><a href="#直接相关文件" class="headerlink" title="直接相关文件"></a>直接相关文件</h3><div class="table-container"><table><thead><tr><th>文件名</th><th>含义</th></tr></thead><tbody><tr><td>/etc/passwd</td><td>用户主配置文件，用户的各种属性（UID,GID,家目录，登录SHELL）</td></tr><tr><td>/etc/shadow</td><td>用户密码文件，存放密码及密码的属性（失效时间，修改密码时间等）。</td></tr><tr><td>/etc/group</td><td>组文件，存放用户组及属性。</td></tr><tr><td>/etc/gshadow</td><td>用户组的密码文件（废弃）</td></tr></tbody></table></div><h3 id="创建用户相关的文件"><a href="#创建用户相关的文件" class="headerlink" title="创建用户相关的文件"></a>创建用户相关的文件</h3><div class="table-container"><table><thead><tr><th>文件名</th><th>含义</th></tr></thead><tbody><tr><td>/etc/default/useradd</td><td>创建用户命令useradd的配置文件</td></tr><tr><td>/etc/skel</td><td>创建用户环境变量原始文件存放地。</td></tr><tr><td>/etc/login.defs</td><td>创建用户系统配置对应文件。</td></tr></tbody></table></div><h3 id="环境变量丢失问题"><a href="#环境变量丢失问题" class="headerlink" title="环境变量丢失问题"></a>环境变量丢失问题</h3><p>对于创建用户的三个文件，我们来看一个常见的问题来深入理解一下。</p><p>问题: 使用test用户登录到Linux系统后，发现提示符为如下所示异常情况，    请问如何恢复到正常的Linux命令行提示符情况？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.1$ </span><br><span class="line">-bash-4.1$</span><br></pre></td></tr></table></figure><p>解答:</p><p>我们来复现一下 </p><p><img src="image-20221213170640466.png" alt="image-20221213170640466"></p><p>我们看到一句重要的提示 “不再向其中复制任何文件”，可以看到家目录内也是空的。</p><p><img src="image-20221213171128265.png" alt="image-20221213171128265"></p><p>我们先来解决这个问题再来解释</p><p><img src="image-20221213171832654.png" alt="image-20221213171832654"></p><p>我们从/etc/skel/目录下 将bash的几个文件拷贝拷贝到家目录就好了，这几个文件是控制用户环境变量的，如果没有这几个文件 ，家目录是有问题的 就会出现-bash-4.2$的问题。那至于为什么要从/etc/skel中拷贝也是 linux事先在配置文件中规定好的,查看useradd文件</p><p><img src="image-20221213172329965.png" alt="image-20221213172329965"></p><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><p>这些命令都比较简单，就不再进行演示了，感兴趣的可以自己操作一下。</p><h2 id="增加用户"><a href="#增加用户" class="headerlink" title="增加用户"></a>增加用户</h2><div class="table-container"><table><thead><tr><th>useradd 选项</th><th>含义</th><th></th></tr></thead><tbody><tr><td>基本用法: useradd 用户名</td><td></td><td></td></tr><tr><td>-s</td><td>添加用户的时候指定用户的命令解释器，如果不指定默认是/bin/bash.</td><td></td></tr><tr><td>-M</td><td>添加的用户的时候不创建家目录。（一般与-sM搭配使用)</td><td></td></tr><tr><td>-u</td><td>添加用户的时候指定uid。</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>-g</td><td>主要组（原生组） 替换默认创建的组。</td><td></td></tr><tr><td>-G</td><td>附加组（额外组）添加用户的时候，让用户属于多个组</td></tr></tbody></table></div><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><div class="table-container"><table><thead><tr><th>userdel 删除用户 宣传</th><th></th></tr></thead><tbody><tr><td>-r</td><td>删除用户及用户相关数据（家目录，邮箱） 极其危险。</td></tr></tbody></table></div><p>⚠️工作中一般不会使用这种操作，最简单的做法就是在passwd文件中注释此用户即可。</p><h3 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h3><ul><li>usermod 修改已存在的用户的信息，useradd添加用户时候设置的信息，usermod都可以改。</li><li>uesrmod的选项与useradd 类似。</li></ul><h2 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h2><h4 id="查看用户基本信息"><a href="#查看用户基本信息" class="headerlink" title="查看用户基本信息"></a>查看用户基本信息</h4><ul><li>whoami 显示当前用户的名字。</li><li>id 查看当前或指定用户的信息（uid,gid,用户组信息）</li></ul><h4 id="查看用户登录情况"><a href="#查看用户登录情况" class="headerlink" title="查看用户登录情况"></a>查看用户登录情况</h4><ul><li>w </li><li>last 查看用户的登录情况。</li><li>lastlog 查看所有用户最近1次的登录情况。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hive中四种有效的SQL优化</title>
      <link href="/2022/10/09/%E5%A4%A7%E6%95%B0%E6%8D%AE-2022-10-09-hive%E4%B8%AD%E5%9B%9B%E7%A7%8D%E6%9C%89%E6%95%88%E7%9A%84SQL%E4%BC%98%E5%8C%96/"/>
      <url>/2022/10/09/%E5%A4%A7%E6%95%B0%E6%8D%AE-2022-10-09-hive%E4%B8%AD%E5%9B%9B%E7%A7%8D%E6%9C%89%E6%95%88%E7%9A%84SQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>首先虚拟一张表user，字段为：</p><p>（1）<strong>user_id</strong>（用户的id）；</p><p>（2）<strong>age</strong>（用户的年龄）；</p><p>（3）<strong>sex</strong>（用户的性别）；</p><p>（4）<strong>order_id</strong>（用户的订单编号，一个用户可能有多个订单编号）。</p><p>另设一张表，叫order，里面包含order_id, order_date两个字段。</p><h3 id="multi-table-insert优化union-all"><a href="#multi-table-insert优化union-all" class="headerlink" title="multi-table-insert优化union all"></a>multi-table-insert优化union all</h3><p><strong>原SQL</strong>（目标是往一个新表user_new里，插入最大值和最小值的数据）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> user_new</span><br><span class="line"><span class="keyword">select</span> sex, <span class="keyword">max</span>(age) <span class="keyword">as</span> stat, <span class="string">'max'</span> <span class="keyword">as</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> sex, <span class="keyword">min</span>(age) <span class="keyword">as</span> stat, <span class="string">'min'</span> <span class="keyword">as</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure><p><strong>优化SQL</strong>（完成相同的目标，使用multi-table-insert写法）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from user</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> user_new</span><br><span class="line"><span class="keyword">select</span> sex, <span class="keyword">max</span>(age) <span class="keyword">as</span> stat, <span class="string">'max'</span> <span class="keyword">as</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> user_new</span><br><span class="line"><span class="keyword">select</span> sex, <span class="keyword">min</span>(age) <span class="keyword">as</span> stat, <span class="string">'min'</span> <span class="keyword">as</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure><p>如果SQL是在MapReduce上运行的话，进行这种改写可以减少中间结果的产生，即降低了读写（I/O）资源的消耗，提升程序的效率和速度。具体原理是减少了MapReduce作业数量。</p><h3 id="使用grouping-sets替代union-all"><a href="#使用grouping-sets替代union-all" class="headerlink" title="使用grouping sets替代union all"></a>使用grouping sets替代union all</h3><p><strong>原SQL</strong>（目标是进行2个group by，但后一个的分组字段是前者的子集）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (</span><br><span class="line">  <span class="keyword">select</span> sex, age, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> user_num</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> sex, age</span><br><span class="line">  <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">  <span class="keyword">select</span> sex, <span class="literal">null</span> <span class="keyword">as</span> age, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> user_num</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> sex) a;</span><br></pre></td></tr></table></figure><p><strong>优化SQL</strong>（完成相同的目标，使用grouping sets写法）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, age, <span class="keyword">count</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex, age</span><br><span class="line"><span class="keyword">grouping</span> <span class="keyword">sets</span>((sex),(sex,age));</span><br></pre></td></tr></table></figure><h3 id="使用子查询对count-distinct-可能造成的数据倾斜进行优化"><a href="#使用子查询对count-distinct-可能造成的数据倾斜进行优化" class="headerlink" title="使用子查询对count(distinct)可能造成的数据倾斜进行优化"></a><strong>使用子查询对count(distinct)可能造成的数据倾斜进行优化</strong></h3><p><strong>原SQL</strong>（统计每种性别有多少种不同年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="keyword">count</span>(<span class="keyword">distinct</span> age) <span class="keyword">as</span> age_num</span><br><span class="line"><span class="keyword">from</span> sex</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure><p><strong>优化SQL</strong>（完成相同的目标，使用子查询避免数据出现倾斜而导致性能问题）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> age_num</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">  <span class="keyword">select</span> sex, age, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> <span class="keyword">num</span></span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> sex, age</span><br><span class="line">) a;</span><br></pre></td></tr></table></figure><h3 id="使用left-join替代not-in完成取A表中没有但B表中有的数据"><a href="#使用left-join替代not-in完成取A表中没有但B表中有的数据" class="headerlink" title="使用left join替代not in完成取A表中没有但B表中有的数据"></a>使用left join替代not in完成取A表中没有但B表中有的数据</h3><p><strong>原SQL</strong>（查找订单日期不在2020-10-23日的用户的user_id）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> order_id <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">  <span class="keyword">select</span> order_id <span class="keyword">from</span> <span class="keyword">order</span></span><br><span class="line">  <span class="keyword">where</span> order_date != <span class="string">'2020-10-23'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>优化SQL</strong>（完成相同的目标，用left join去实现，避免not in不走索引带来的问题）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.user_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span> a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line"><span class="keyword">order</span> b</span><br><span class="line"><span class="keyword">on</span> a.order_id = b.order_id <span class="keyword">and</span> b.order_date != <span class="string">'2020-10-23'</span></span><br><span class="line"><span class="keyword">where</span> b.user_id <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>checkpoint的生产配置</title>
      <link href="/2022/10/09/Flink-2022-10-09-checkpoint%E7%9A%84%E7%94%9F%E4%BA%A7%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/10/09/Flink-2022-10-09-checkpoint%E7%9A%84%E7%94%9F%E4%BA%A7%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Checkpoint相关配置"><a href="#Checkpoint相关配置" class="headerlink" title="Checkpoint相关配置"></a>Checkpoint相关配置</h2><div class="table-container"><table><thead><tr><th>配置项</th><th>含义</th></tr></thead><tbody><tr><td>state.backend</td><td>状态存储后端，可配置值有’jobmanager’, ‘filesystem’, ‘rocksdb’等，在checkpoint数据存储在hdfs上时，配置该值为filesystem</td></tr><tr><td>state.checkpoints.dir</td><td>checkpoints写出的目录位置，比如：hdfs://ns/flink/flink-checkpoints</td></tr><tr><td>state.savepoints.dir</td><td>savepoints写出的目录位置，比如：hdfs://ns/flink/flink-checkpoints，一般与上面的值配置一致</td></tr><tr><td>execution.checkpointing.mode</td><td>检查点模式，默认值EXACTLY_ONCE，可选项AT_LEAST_ONCE</td></tr><tr><td>execution.checkpointing.interval</td><td>checkpoint的时间间隔，单位毫秒，比如5000</td></tr><tr><td>state.checkpoints.num-retained</td><td>checkpoint保留的个数，默认值1，不过建议比如设置为3，防止想要恢复更久前的状态，或者最近的一个checkpoint被误删除等情况。</td></tr><tr><td>execution.checkpointing.externalized-checkpoint-retention</td><td>该配置项定义了在任务取消（cancel，注意不是job failed是主动的cancel）时如何清理外部化的检查点。一般我们会配置为RETAIN_ON_CANCELLATION，即cancel时保留检查点。而DELETE_ON_CANCELLATION则表示cancel任务时删除检查点，只有在任务失败时，才会被保留。</td></tr><tr><td><font color=red>execution.checkpointing.tolerable-failed-checkpoints</font></td><td>允许的连续checkpoint失败的次数，默认值是0，即只要出现checkpoint失败，作业就会失败，然后按照设置了的重启策略开始重启（setRestartStrategy），所以生产环境中一般设置2，即允许偶尔出现checkpoints失败的。</td></tr></tbody></table></div><p> <font color=red>execution.checkpointing.tolerable-failed-checkpoints</font> 需要特别注意，flink可能会因为某些原因被hang住，导致cp失败，如果不设置，容忍就是0，则会直接导致任务挂掉。严重可能导致任务连续失败。所以一定要根据任务重要程度设置一定的容忍度。</p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步IO</title>
      <link href="/2022/10/09/Flink-2022-10-09-%E5%BC%82%E6%AD%A5IO/"/>
      <url>/2022/10/09/Flink-2022-10-09-%E5%BC%82%E6%AD%A5IO/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常情况我们在进行维表关联时，是进行同步的查询，为了提高吞吐率，提高处理的数据量，可以利用异步的查询，但是有一个问题，异步访问的后的结果 如何反回到主流中？这就需要Flink给我们提供支持了。我们看一下官网的介绍。</p><p><img src="1.jpg" alt="image-20221009112349107"></p><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>引用官网的一段话:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">As illustrated in the section above, implementing proper asynchronous I/<span class="function">O to a <span class="title">database</span> <span class="params">(or key/value store)</span> <span class="keyword">requires</span> a client to that database that supports asynchronous requests. Many popular databases offer such a client.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">In the absence of such a client, one can <span class="keyword">try</span> and turn a synchronous client into a limited concurrent client by creating multiple clients and handling the synchronous calls with a thread pool. However, <span class="keyword">this</span> approach is usually less efficient than a proper asynchronous client.</span></span><br></pre></td></tr></table></figure><p>也就是说。其实Flink提供的只是如何让数据反回到主流。异步需要你自己实现。实现的方式有两种</p><ol><li>第一种比较简单，是指异步的客户端。也就说有些组建的客户端本身提供了异步查询的功能。那就省下了很多事情。</li><li>如果客户端没有异步功能，那就只能自己用多线程来实现，简单的方法就是用CompletableFuture异步编排这个类来实现异步功能。</li></ol><p>看一下 官网提供的demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncDatabaseRequest</span> <span class="keyword">extends</span> <span class="title">RichAsyncFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The database specific client that can issue concurrent requests with callbacks */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> DatabaseClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        client = <span class="keyword">new</span> DatabaseClient(host, post, credentials);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncInvoke</span><span class="params">(String key, <span class="keyword">final</span> ResultFuture&lt;Tuple2&lt;String, String&gt;&gt; resultFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// issue the asynchronous request, receive a future for result</span></span><br><span class="line">        <span class="keyword">final</span> Future&lt;String&gt; result = client.query(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set the callback to be executed once the request by the client is complete</span></span><br><span class="line">        <span class="comment">// the callback simply forwards the result to the result future</span></span><br><span class="line">        CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> result.get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                    <span class="comment">// Normally handled explicitly.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).thenAccept( (String dbResult) -&gt; &#123;</span><br><span class="line">            resultFuture.complete(Collections.singleton(<span class="keyword">new</span> Tuple2&lt;&gt;(key, dbResult)));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create the original stream</span></span><br><span class="line">DataStream&lt;String&gt; stream = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply the async I/O transformation</span></span><br><span class="line">DataStream&lt;Tuple2&lt;String, String&gt;&gt; resultStream =</span><br><span class="line">    AsyncDataStream.unorderedWait(stream, <span class="keyword">new</span> AsyncDatabaseRequest(), <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>Important note</strong>: The <code>ResultFuture</code> is completed with the first call of <code>ResultFuture.complete</code>. All subsequent <code>complete</code> calls will be ignored.</p><p>The following two parameters control the asynchronous operations:</p><ul><li><strong>Timeout</strong>: The timeout defines how long an asynchronous request may take before it is considered failed. This parameter guards against dead/failed requests.</li><li><strong>Capacity</strong>: This parameter defines how many asynchronous requests may be in progress at the same time. Even though the async I/O approach leads typically to much better throughput, the operator can still be the bottleneck in the streaming application. Limiting the number of concurrent requests ensures that the operator will not accumulate an ever-growing backlog of pending requests, but that it will trigger backpressure once the capacity is exhausted.</li></ul></blockquote><h2 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h2><p>​    当异步I/O请求超时时，默认情况下会抛出异常并重新启动作业。如果要处理超时，可以重写AsyncFunction#timeout。确保调用ResultFuture。complete() 或 ResultFuture.completeExceptionally（），以便向Flink指示此输入记录的处理已完成。如果不想在发生超时时发出任何记录，可以调用ResultFuture.complete（Collections.emptyList()）。</p><h2 id="返回顺序"><a href="#返回顺序" class="headerlink" title="返回顺序"></a>返回顺序</h2><p>​    AsyncFunction发出的并发请求通常以未定义的顺序完成，这取决于哪个请求先完成。为了控制结果记录的发出顺序，Flink提供了两种模式：</p><ul><li>Unordered：一旦异步请求完成，就会发出结果记录。流中记录的顺序在异步I/O操作符之后与之前不同。当使用处理时间作为基本时间特征时，此模式具有最低的延迟和最低的开销。对此模式使用AsyncDataStream.unorderedWait（…）。</li><li>Ordered：在这种情况下，将保留流顺序。结果记录的发出顺序与触发异步请求的顺序相同（操作员输入记录的顺序）。为了实现这一点，操作员缓冲一个结果记录，直到它前面的所有记录都被发出（或超时）。这通常会在检查点中引入一些额外的延迟和开销，因为与无序模式相比，记录或结果在检查点状态下维护的时间更长。对此模式使用AsyncDataStream.orderedWait（…）。</li></ul><p>简单来讲，就是保证发送到下游的数据是不是请求发起的顺序，如果是，那么需要额外维护这个顺序，增加一定的开销。</p><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><p>生成6条数据，从0开始递增的6个数字。模拟异步查询之后，加上时间戳输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncIODemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maxCount = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> taskNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> timeout = <span class="number">40000</span>;</span><br><span class="line"></span><br><span class="line">        DataStream&lt;Integer&gt; inputStream = env.addSource(<span class="keyword">new</span> SimpleSource(maxCount));</span><br><span class="line">        AsyncFunction&lt;Integer, String&gt; function = <span class="keyword">new</span> SampleAsyncFunction();</span><br><span class="line"></span><br><span class="line">        DataStream&lt;String&gt; result = AsyncDataStream.unorderedWait(</span><br><span class="line">                    inputStream,</span><br><span class="line">                    function,</span><br><span class="line">                    timeout,</span><br><span class="line">                    TimeUnit.MILLISECONDS,</span><br><span class="line">                    <span class="number">10</span>).setParallelism(taskNum);</span><br><span class="line"></span><br><span class="line">        result.map(<span class="keyword">new</span> MapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value + <span class="string">","</span> + System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).print();</span><br><span class="line"></span><br><span class="line">        env.execute(<span class="string">"Async IO Demo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSource</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SimpleSource</span><span class="params">(<span class="keyword">int</span> maxNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.counter = maxNum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Integer&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> ((start &lt; counter || counter == -<span class="number">1</span>) &amp;&amp; isRunning) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (ctx.getCheckpointLock()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"send data:"</span> + start);</span><br><span class="line">                    ctx.collect(start);</span><br><span class="line">                    ++start;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            isRunning = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步方法"><a href="#异步方法" class="headerlink" title="异步方法"></a>异步方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleAsyncFunction</span> <span class="keyword">extends</span> <span class="title">RichAsyncFunction</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] sleep = &#123;<span class="number">100L</span>, <span class="number">1000L</span>, <span class="number">5000L</span>, <span class="number">2000L</span>, <span class="number">6000L</span>, <span class="number">100L</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.open(parameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncInvoke</span><span class="params">(<span class="keyword">final</span> Integer input, <span class="keyword">final</span> ResultFuture&lt;String&gt; resultFuture)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">"-input:"</span> + input + <span class="string">" will sleep "</span> + sleep[input] + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        query(input, resultFuture);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">final</span> Integer input, <span class="keyword">final</span> ResultFuture&lt;String&gt; resultFuture)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(sleep[input]);</span><br><span class="line">            resultFuture.complete(Collections.singletonList(String.valueOf(input)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            resultFuture.complete(<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">asyncQuery</span><span class="params">(<span class="keyword">final</span> Integer input, <span class="keyword">final</span> ResultFuture&lt;String&gt; resultFuture)</span> </span>&#123;</span><br><span class="line">        CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(sleep[input]);</span><br><span class="line">                    <span class="keyword">return</span> input;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).thenAccept((Integer dbResult) -&gt; &#123;</span><br><span class="line">            resultFuture.complete(Collections.singleton(String.valueOf(dbResult)));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中有两个方法query()和asyncQuery()，其中Thread.sleep(sleep[input]);用来模拟查询需要等待的时间，每条数据等待的时间分别为100L, 1000L, 5000L, 2000L, 6000L, 100L毫秒。</p><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>运行query()的结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">send data:<span class="number">0</span></span><br><span class="line">send data:<span class="number">1</span></span><br><span class="line">send data:<span class="number">2</span></span><br><span class="line">send data:<span class="number">3</span></span><br><span class="line">send data:<span class="number">4</span></span><br><span class="line">send data:<span class="number">5</span></span><br><span class="line"><span class="number">1577801193230</span>-input:<span class="number">0</span> will sleep <span class="number">100</span> ms</span><br><span class="line"><span class="number">1577801193331</span>-input:<span class="number">1</span> will sleep <span class="number">1000</span> ms</span><br><span class="line"><span class="number">0</span>,<span class="number">1577801194336</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1577801194336</span></span><br><span class="line"><span class="number">1577801194336</span>-input:<span class="number">2</span> will sleep <span class="number">5000</span> ms</span><br><span class="line"><span class="number">1577801199339</span>-input:<span class="number">3</span> will sleep <span class="number">2000</span> ms</span><br><span class="line"><span class="number">2</span>,<span class="number">1577801201341</span></span><br><span class="line"><span class="number">1577801201342</span>-input:<span class="number">4</span> will sleep <span class="number">6000</span> ms</span><br><span class="line"><span class="number">3</span>,<span class="number">1577801207345</span></span><br><span class="line"><span class="number">4</span>,<span class="number">1577801207345</span></span><br><span class="line"><span class="number">1577801207346</span>-input:<span class="number">5</span> will sleep <span class="number">100</span> ms</span><br><span class="line"><span class="number">5</span>,<span class="number">1577801207451</span></span><br></pre></td></tr></table></figure><p>可以看到第一条数据进入到map算子的时间与最后一条相差了13115毫秒，执行的顺序与source中数据的顺序一致，并且是串行的。</p><p>运行asyncQuery()的结果为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">send data:<span class="number">0</span></span><br><span class="line">send data:<span class="number">1</span></span><br><span class="line">send data:<span class="number">2</span></span><br><span class="line">send data:<span class="number">3</span></span><br><span class="line"><span class="number">1577802161755</span>-input:<span class="number">0</span> will sleep <span class="number">100</span> ms</span><br><span class="line"><span class="number">1577802161756</span>-input:<span class="number">1</span> will sleep <span class="number">1000</span> ms</span><br><span class="line"><span class="number">1577802161757</span>-input:<span class="number">2</span> will sleep <span class="number">5000</span> ms</span><br><span class="line">send data:<span class="number">4</span></span><br><span class="line">send data:<span class="number">5</span></span><br><span class="line"><span class="number">1577802161783</span>-input:<span class="number">3</span> will sleep <span class="number">2000</span> ms</span><br><span class="line"><span class="number">1577802161784</span>-input:<span class="number">4</span> will sleep <span class="number">6000</span> ms</span><br><span class="line"><span class="number">1577802161785</span>-input:<span class="number">5</span> will sleep <span class="number">100</span> ms</span><br><span class="line"><span class="number">0</span>,<span class="number">1577802161859</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1577802162759</span></span><br><span class="line"><span class="number">3</span>,<span class="number">1577802163862</span></span><br><span class="line"><span class="number">5</span>,<span class="number">1577802163962</span></span><br><span class="line"><span class="number">2</span>,<span class="number">1577802166760</span></span><br><span class="line"><span class="number">4</span>,<span class="number">1577802168762</span></span><br></pre></td></tr></table></figure><p>同样第一条数据进入map算子的时间与最后一条仅相差了6903毫秒，而且输出结果的顺序并不是source中的顺序，而是按照查询时间递增的顺序输出，并且查询请求几乎是同一时间发出的。</p><p>通过上面的例子可以看出，flink所谓的异步IO，并不是只要实现了asyncInvoke方法就是异步了，这个方法并不是异步的，而是要依靠这个方法里面所写的查询是异步的才可以。否则像是上面query()方法那样，同样会阻塞查询相当于同步IO。在实现flink异步IO的时候一定要注意。官方文档也给出了相关的说明。</p><blockquote><p>For example, the following patterns result in a blocking asyncInvoke(…) functions and thus void the asynchronous behavior:Using a database client whose lookup/query method call blocks until the result has been received back.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    要注意Flink的异步IO，需要自己在算子中实现，具体的超时参数、有序无序的要求要根据场景来设置。</p><p>​    更详细的原理在flink官网推荐的博客中有比较详细的解释，喜欢研究的可以参考下。</p><blockquote><p>参考:<a href="https://cloud.tencent.com/developer/article/1780022" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1780022</a></p><p>​        <a href="https://nightlies.apache.org/flink/flink-docs-release-1.15/docs/dev/datastream/operators/asyncio/" target="_blank" rel="noopener">https://nightlies.apache.org/flink/flink-docs-release-1.15/docs/dev/datastream/operators/asyncio/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CompletableFuture详解</title>
      <link href="/2022/09/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2022-09-27-CompletableFuture%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/09/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2022-09-27-CompletableFuture%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="CompletableFuture介绍"><a href="#CompletableFuture介绍" class="headerlink" title="CompletableFuture介绍"></a>CompletableFuture介绍</h2><p>Future 是 Java 5 添加的类，用来描述一个异步计算的结果。你可以使用<code>isDone</code>方法检查计算是否完成，或者使用<code>get</code>阻塞住调用线程，直到计算完成返回结果，你也可以使用<code>cancel</code> 方法停止任务的执行。</p><p>虽然<code>Future</code>以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不 方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的 初衷相违背，轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果，为 什么不能用观察者设计模式当计算结果完成及时通知监听者呢？</p><p>很多语言，比如 Node.js，采用回调的方式实现异步编程。Java 的一些框架，比如 Netty，自 己扩展了 Java 的 <code>Future</code>接口，提供了<code>addListener</code>等多个扩展方法；Google guava 也提供了 通用的扩展 Future；Scala 也提供了简单易用且功能强大的 Future/Promise 异步编程模式。</p><p>作为正统的 Java 类库，是不是应该做点什么，加强一下自身库的功能呢？</p><p>在 Java 8 中, 新增加了一个包含 50 个方法左右的类: CompletableFuture，提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以 通过回调的方式处理计算结果，并且提供了转换和组合 CompletableFuture 的方法。 CompletableFuture 类实现了 Future 接口，所以你还是可以像以前一样通过<code>get</code>方法阻塞或 者轮询的方式获得结果，但是这种方式不推荐使用。</p><p>CompletableFuture 和 FutureTask 同属于 Future 接口的实现类，都可以获取线程的执行结果。</p><p><img src="1.jpg" alt="WeChat855e5fbbf1876597d4e703b4d87f8caf"></p><h2 id="CompletableFuture-详解"><a href="#CompletableFuture-详解" class="headerlink" title="CompletableFuture 详解"></a>CompletableFuture 详解</h2><h3 id="创建异步对象"><a href="#创建异步对象" class="headerlink" title="创建异步对象"></a>创建异步对象</h3><p>CompletableFuture 提供了四个静态方法来创建一个异步操作。</p><p><img src="2.jpg" alt="WeChat0f5a185875b9b00af5dabae5b74434f5"></p><ol><li>runXxxx 都是没有返回结果的，supplyXxx 都是可以获取返回结果的</li><li>可以传入自定义的线程池，否则就用默认的线程池；</li></ol><h3 id="计算完成时回调方法"><a href="#计算完成时回调方法" class="headerlink" title="计算完成时回调方法"></a>计算完成时回调方法</h3><p><img src="10.jpg" alt="WeChat18437bf3db525f104cb8133df7c91f02"></p><p>whenComplete 可以处理正常和异常的计算结果，exceptionally 处理异常情况。 whenComplete 和 whenCompleteAsync 的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whenComplete：是执行当前任务的线程执行继续执行 whenComplete 的任务。</span><br><span class="line">whenCompleteAsync：是执行把 whenCompleteAsync 这个任务继续提交给线程池 来进行执行。 方法不以 Async 结尾，意味着 Action 使用相同的线程执行， 而 Async 可能会使用其他线程 执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">CompletableFuture future = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Object&gt;() &#123; </span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"\t completableFuture"</span>); </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">1024</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.whenComplete(<span class="keyword">new</span> BiConsumer&lt;Object, Throwable&gt;() &#123;</span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Object o, Throwable throwable)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"-------o="</span> + o.toString()); </span><br><span class="line">  System.out.println(<span class="string">"-------throwable="</span> + throwable); </span><br><span class="line"> &#125;</span><br><span class="line"> &#125;).exceptionally(<span class="keyword">new</span> Function&lt;Throwable, Object&gt;() &#123; </span><br><span class="line">   <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">apply</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"throwable="</span> + throwable); <span class="keyword">return</span> <span class="number">6666</span>; &#125; </span><br><span class="line">   &#125;); </span><br><span class="line">  System.out.println(future.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="handle方法"><a href="#handle方法" class="headerlink" title="handle方法"></a>handle方法</h3><p><img src="3.jpg" alt="WeChat354da1ba030b0bc1395809554055b169"></p><p>和 complete 一样，可对结果做最后的处理（可处理异常），可改变返回值。</p><h3 id="线程串行化方法"><a href="#线程串行化方法" class="headerlink" title="线程串行化方法"></a>线程串行化方法</h3><p><img src="4.jpg" alt="WeChatbf6a1fc5b93b123ffb2466797903b9e0"></p><ul><li>thenApply 方法：当一个线程依赖另一个线程时，获取上一个任务返回的结果，并返回当前 任务的返回值。</li><li>thenAccept 方法：消费处理结果。接收任务的处理结果，并消费处理，无返回结果。 </li><li>thenRun 方法：只要上面的任务执行完成，就开始执行 thenRun，只是处理完任务后，执行 thenRun 的后续操作 </li><li>带有 Async 默认是异步执行的。同之前。 </li><li>以上都要前置任务成功完成。</li><li>Function&lt;? super T,? extends U&gt;<ul><li>T：上一个任务返回结果的类型</li><li>U：当前任务的返回值类型</li></ul></li></ul><h3 id="两任务组合-都要完成"><a href="#两任务组合-都要完成" class="headerlink" title="两任务组合-都要完成"></a>两任务组合-都要完成</h3><p><img src="5.jpg" alt="WeChat128b25d933d9f51c66a5beb8aad09a93"></p><p><img src="6.jpg" alt="WeChat53f817c0659a029b88ee7151e6ed1b9a"></p><p>两个任务必须都完成，触发该任务。</p><ul><li>thenCombine：组合两个 future，获取两个 future 的返回结果，并返回当前任务的返回值</li><li>thenAcceptBoth：组合两个 future，获取两个 future 任务的返回结果，然后处理任务，没有 返回值。 </li><li>runAfterBoth：组合两个 future，不需要获取 future 的结果，只需两个 future 处理完任务后， 处理该任务。</li></ul><h3 id="两任务组合-一个完成"><a href="#两任务组合-一个完成" class="headerlink" title="两任务组合- 一个完成"></a>两任务组合- 一个完成</h3><p><img src="7.jpg" alt="WeChat6f1f2f0b5e3294772ed627071cfda607"></p><p><img src="8.jpg" alt="WeChat3f9223bb296ca8133d39e4a4986e00c3"></p><p>当两个任务中，任意一个 future 任务完成的时候，执行任务。</p><ul><li>applyToEither：两个任务有一个执行完成， 获取它的返回值，处理任务并有新的返回值。</li><li>acceptEither：两个任务有一个执行完成， 获取它的返回值，处理任务，没有新的返回值。</li><li>runAfterEither：两个任务有一个执行完成， 不需要获取 future 的结果，处理任务，也没有返 回值。</li></ul><h3 id="多任务组合"><a href="#多任务组合" class="headerlink" title="多任务组合"></a>多任务组合</h3><p><img src="9.jpg" alt="WeChatecbc58603097f0359f4e715b5100e265"></p><ul><li><p>allOf：等待所有任务完成 </p></li><li><p>anyOf：只要有一个任务完成</p></li></ul><h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><p>以商城购物车添加商品为例，添加商品时，需要填充商品信息，需要做多次的远程调用，多次的调用如果没有先后关系制约，可以异步的同时进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、远程查询当前要添加的商品的信息</span></span><br><span class="line">       CartItem cartItem = <span class="keyword">new</span> CartItem();</span><br><span class="line">       CompletableFuture&lt;Void&gt; getSkuInfoTask = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">           R skuInfo = productFeignService.getSkuInfo(skuId);</span><br><span class="line">           SkuInfoVo data = skuInfo.getData(<span class="string">"skuInfo"</span>, <span class="keyword">new</span> TypeReference&lt;SkuInfoVo&gt;() &#123;</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           cartItem.setCheck(<span class="keyword">true</span>);</span><br><span class="line">           cartItem.setCount(num);</span><br><span class="line">           cartItem.setImage(data.getSkuDefaultImg());</span><br><span class="line">           cartItem.setTitle(data.getSkuTitle());</span><br><span class="line">           cartItem.setSkuId(skuId);</span><br><span class="line">           cartItem.setPrice(data.getPrice());</span><br><span class="line">       &#125;,executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//2、远程查询sku的组合信息</span></span><br><span class="line">       CompletableFuture&lt;Void&gt; getSkuSaleAttrValues = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">           List&lt;String&gt; values = productFeignService.getSkuSaleAttrValues(skuId);</span><br><span class="line">           cartItem.setSkuAttr(values);</span><br><span class="line">       &#125;, executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       CompletableFuture.allOf(getSkuInfoTask,getSkuSaleAttrValues).get();</span><br><span class="line">       String s = JSON.toJSONString(cartItem);</span><br><span class="line">       log.info(<span class="string">"cartItem:&#123;&#125;"</span>,s);</span><br><span class="line">       cartOps.put(skuId.toString(),s);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Future模式</title>
      <link href="/2022/09/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2022-09-27-Future%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/27/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2022-09-27-Future%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h2><p>​    我们了解的Thread 和 runnable，实现多线程的方式是新起线程运行 run 方法，但是 run 方法有个缺陷是没有返回值，并且主线程也并不知道新的线程何时运行完毕。Future 持有要运行的任 务，以及任务的结果。主线程只要声明了 Future 对象，并且启动新的线程运行他。那么随时能通过 Future 对象获 取另外线程运行的结果。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>​    我们通过一个简单例子来介绍一下使用方法 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; cookTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>); <span class="keyword">return</span> <span class="string">"5斤的龙虾"</span>;</span><br><span class="line">         &#125;&#125;);</span><br><span class="line"></span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"我点了5斤的龙虾。"</span>); <span class="keyword">new</span> Thread(cookTask).start();</span><br><span class="line">        System.out.println(<span class="string">"我去买牙膏。"</span>); TimeUnit.SECONDS.sleep(<span class="number">2</span>); System.out.println(<span class="string">"我买到牙膏了！"</span>);</span><br><span class="line"></span><br><span class="line">        String lunch = cookTask.get(); </span><br><span class="line">        System.out.println(<span class="string">"我点的"</span>+lunch+<span class="string">"已经OK了！"</span>);</span><br><span class="line">        Long userTime = (System.currentTimeMillis() - startTime)/<span class="number">1000</span>; System.out.println(<span class="string">"我一共用了"</span>+userTime+<span class="string">"秒买午餐并且买牙膏。"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中先了一个 FutureTask 对象，称之为 cookTask。顾名思义，这个 task 是用来做饭的。可以看到构造方法中 传入 Callable 的实现。实现的 call 方法中模拟做饭用了 3 秒钟。</p><p>主线程运行后，先点了 5 斤的龙虾，然后一个新的线程就开始去执行 cookTask 了。等会儿，到这里你一定会 问，Thread 构造方法需要传入 Runnable 的实现啊？没错，FutureTask 实现了 Runnable 接口。FutureTask 的 run方法实际执行的是 Callable 的 call 方法。那么新的线程 start 后，实际做饭的逻辑会被执行：自线程 sleep3 秒后返 回 “5 斤的龙虾”。</p><p>主线程在启动做饭的自线程后继续向下执行，去买牙膏。这里 sleep 两秒，模拟买牙膏的时间消耗。</p><p>买到牙膏接下来的一行代码 String lobster = cookTask.get (); 重点说一下，此时分两种情况：</p><ol><li>cookTask 运行的线程已经结束了，那么可以直接取到运行的结果赋值给 lunch；</li><li>cookTask 运行的线程还没有执行结束，此时主线程会阻塞，直到能取得运行结果。</li></ol><p>​    cookTask 就是你的购物小票，只要你没弄丢，随时能去取你的午饭。</p><p>​    程序最后计算了整个过程的执行时间。由于采用了多线程并发，所以执行时间应该等于耗时最长的那个任务。这个 例子中做龙虾 3 秒 &gt; 买牙膏 2 秒，所以总共耗时 3 秒，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我点了<span class="number">5</span>斤的龙虾 </span><br><span class="line">我去买牙膏 我买到牙膏了！ </span><br><span class="line">我点的<span class="number">5</span>斤的龙虾已经OK了 </span><br><span class="line">我一共用了<span class="number">3</span>秒买午餐并且买牙膏</span><br></pre></td></tr></table></figure><p>加入我调整买牙膏需要 10 秒，那么输出则如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我点了<span class="number">5</span>斤的龙虾 </span><br><span class="line">我去买牙膏 </span><br><span class="line">我买到牙膏了！ </span><br><span class="line">我点的<span class="number">5</span>斤的龙虾已经OK了 </span><br><span class="line">我一共用了<span class="number">10</span>秒买午餐并且买牙膏</span><br></pre></td></tr></table></figure><p>总共耗时 10 秒。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>Future 是一个接口，而 FutrueTask 则是他的实现，我们看一下它们的继承关系：</p><p><img src="1.jpg" alt="WeChatd192175825d8fb235fce099659172545" style="zoom:50%;" /></p><p>FutureTask 不但实现了 Future 而且实现了 Runnable 接口。这也是为什么它能作为参数传入 Thread 构造方法。我们看一下 Future 接口有哪些方法：</p><p><img src="4.jpg" alt="WeChate273a460f8bd667f2a5cf78f52db12c7"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cancel 用于尝试取消任务。</span><br><span class="line">get 用于等待并获取任务执行结果。带时间参数的 get 方法只会等待指定时间长度。</span><br><span class="line">isCancelled 返回任务在完成前是否已经被取消。</span><br><span class="line">isDone 返回任务是否完成。</span><br></pre></td></tr></table></figure><h3 id="FutureTask-构造方法"><a href="#FutureTask-构造方法" class="headerlink" title="FutureTask 构造方法"></a>FutureTask 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">    <span class="keyword">this</span>.callable = callable; </span><br><span class="line">    <span class="keyword">this</span>.state = NEW; <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要传入 Callable 的实现，Callable 是一个接口，定义了 call 方法，返回 V 类型。</p><p>然后定义了 FutureTask 的状态为 NEW。FutrueTask 定义了如下状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL = <span class="number">3</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">4</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>通过字面我们很容易理解其含义。</p><h3 id="Run方法"><a href="#Run方法" class="headerlink" title="Run方法"></a>Run方法</h3><p>FutrueTask 实现了 Runnbale 接口，所以 Thread 运行后实际上执行的是 FutrueTask 的 run 方法。我们要想了解 Future 的实现原理，那么就应该从它的 run 方法开始入手。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果此时状态不为NEW 直接结束 </span></span><br><span class="line"><span class="comment">//如果为NEW ，但是CAS操作把本线程写入为runner时，发现runner已经不为null，那么也直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset, <span class="keyword">null</span>, Thread.currentThread())) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="comment">//取得Callable对象 </span></span><br><span class="line">        Callable&lt;V&gt; c = callable; </span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">             V result; </span><br><span class="line">             <span class="keyword">boolean</span> ran; </span><br><span class="line">             <span class="keyword">try</span> &#123; </span><br><span class="line">             <span class="comment">//运行Callable对象的call方法，并且取得返回值。 </span></span><br><span class="line">             result = c.call(); </span><br><span class="line">             ran = <span class="keyword">true</span>; </span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable ex) &#123; </span><br><span class="line">                 result = <span class="keyword">null</span>; </span><br><span class="line">                 ran = <span class="keyword">false</span>; </span><br><span class="line">                 setException(ex); </span><br><span class="line">             &#125; </span><br><span class="line">             <span class="comment">//如果call方法成功执行结束，那么把执行结果设置给成员变量outcome; </span></span><br><span class="line">             <span class="keyword">if</span> (ran) </span><br><span class="line">                set(result);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to </span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run() </span></span><br><span class="line">        runner = <span class="keyword">null</span>; </span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent </span></span><br><span class="line">        <span class="comment">// leaked interrupts </span></span><br><span class="line">        <span class="keyword">int</span> s = state; </span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING) </span><br><span class="line">        handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">核心逻辑就是执行运行 Call</span><br></pre></td></tr></table></figure><h3 id="Set-方法"><a href="#Set-方法" class="headerlink" title="Set 方法"></a>Set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//状态还是NEW ，保存计算结果给outcome </span></span><br><span class="line"><span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">    outcome = v; </span><br><span class="line">    <span class="comment">//更新状态为NORMAL</span></span><br><span class="line">    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); </span><br><span class="line">    <span class="comment">// final state </span></span><br><span class="line">    <span class="comment">//唤醒等待的线程</span></span><br><span class="line">    finishCompletion(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有被取消则会保存计算结果 v 到 outcome。然后更新最终状态为 NORMAL。最后调用 finishCompletion 方法 唤醒阻塞的线程。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// assert state &gt; COMPLETING; </span></span><br><span class="line"><span class="comment">//遍历等待线程，结束等待 </span></span><br><span class="line"><span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123; </span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123; </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">            <span class="comment">//结束等待线程的挂起 </span></span><br><span class="line">            Thread t = q.thread; </span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                q.thread = <span class="keyword">null</span>; </span><br><span class="line">                LockSupport.unpark(t); </span><br><span class="line">             &#125; </span><br><span class="line">             <span class="comment">//如果没有下一个等待线程，那么结束循环 </span></span><br><span class="line">             WaitNode next = q.next; </span><br><span class="line">             <span class="keyword">if</span> (next == <span class="keyword">null</span>) </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">             q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc </span></span><br><span class="line">             q = next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//全部完成后回调FutrueTask的done方法。done方法为空，可以由子类实现。</span></span><br><span class="line">    done(); </span><br><span class="line"><span class="comment">//清除callable</span></span><br><span class="line"> callable = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>get 方法用于获取任务的返回值，如果还没有执行完成，则会阻塞，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123; </span><br><span class="line"><span class="comment">//获取当前Task的状态 </span></span><br><span class="line"><span class="keyword">int</span> s = state; </span><br><span class="line"><span class="comment">//如果还没有完成，则阻塞等待完成 </span></span><br><span class="line"><span class="keyword">if</span> (s &lt;= COMPLETING) </span><br><span class="line">    s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>); </span><br><span class="line">    <span class="comment">//获取任务执行的返回结果 </span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看 awaitDone 的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//计算等待截止时长 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>; </span><br><span class="line">WaitNode q = <span class="keyword">null</span>; </span><br><span class="line"><span class="keyword">boolean</span> queued = <span class="keyword">false</span>; </span><br><span class="line"><span class="keyword">for</span> (;;) &#123; </span><br><span class="line">    <span class="comment">//当前线程如果被打断，则不再等待。从等待链表中移除 </span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123; </span><br><span class="line">            removeWaiter(q); </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//取得目前的状态 </span></span><br><span class="line">        <span class="keyword">int</span> s = state; </span><br><span class="line">        <span class="comment">//如果已经执行完成，清空q节点保存的线程 </span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123; </span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>) </span><br><span class="line">            q.thread = <span class="keyword">null</span>; </span><br><span class="line">            <span class="keyword">return</span> s; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//如果正在执行，让出CPU执行权 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet </span></span><br><span class="line">            Thread.yield(); </span><br><span class="line">        <span class="comment">//没有进入以上分支，运行到此分支，这说明此线程确实需要开始等待了， </span></span><br><span class="line">        <span class="comment">//那么如果还未为此线程建立关联的等待节点，则进行创建。 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>) </span><br><span class="line">            q = <span class="keyword">new</span> WaitNode(); </span><br><span class="line">        <span class="comment">//通过CAS把此线程的等待node加入到连表中。失败的话，下次循环若能运行到此分支，会继续添加。 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued) </span><br><span class="line">        queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q.next = waiters, q); <span class="comment">//如果设置了超时，检查是否超时。超时的话结束等待。否则挂起超时时长 </span></span><br><span class="line">        <span class="comment">//如果没有设置超时时长，则永久挂起 </span></span><br><span class="line">        <span class="comment">//回到上面的finishCompletion方法，等到task执行完成后会执行LockSupport.unpark(t)，结束阻塞。 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;   </span><br><span class="line">            nanos = deadline - System.nanoTime(); </span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">             removeWaiter(q); </span><br><span class="line">             <span class="keyword">return</span> state; </span><br><span class="line">            &#125; </span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们看一下 report 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123; </span><br><span class="line">    <span class="comment">//获取执行结果 </span></span><br><span class="line">    Object x = outcome; </span><br><span class="line">    <span class="comment">//NORMAL为正常结束，那么直接把X转型后返回 </span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL) </span><br><span class="line">        <span class="keyword">return</span> (V)x; </span><br><span class="line">    <span class="comment">//如果任务被取消了，则抛出异常 </span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException(); </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>outcome 保存的就是任务的执行结果。根据此时的状态，选择返回执行结果还是抛出取消的异常。</p><p>最后我们总结下 FutureTask 的代码：</p><ol><li><p>FutureTask 实现 Runnable 和 Future 接口；</p></li><li><p>在线程上运行 FutureTask 后，run 方法被调用，run 方法会调用传入的 Callable 接口的 call 方法；</p></li><li>拿到返回值后，通过 set 方法保存结果到 outcome，并且唤醒所有等待的线程；</li><li>调用 get 方法获取执行结果时，如果没有执行完毕，则进入等待，直到 set 方法调用后被唤醒。</li></ol><p>下图示意了两个线程运行 task 和 get 时的程序逻辑：</p><p><img src="3.jpg" alt="WeChat2d6c1ed19feedb49de736d5f87f888da"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Future 模式在实际开发中有着大量的应用场景。比如说微服务架构中，需要调用不同服务接口获取数据，但是接口 调用间并无依赖关系，那么可以通过 FutureTask 并发调用，然后再执行后续逻辑。如果我们采用串行的方式，则 需要一个接口返回后，再调用下一个接口。FutreTask 需要结合 Callable 接口使用，示例代码中为了让大家显示的 看到 Callable 接口，所以采用匿名对象的方式。实际使用中我们可以使用 lambda 表达式来简化代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;String&gt; cookTask = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123; Thread.sleep(<span class="number">3000</span>); <span class="keyword">return</span> <span class="string">"5斤的龙虾"</span>; &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Reactor模式到Netty架构演进</title>
      <link href="/2022/09/26/IO-2022-09-26-%E4%BB%8EReactor%E6%A8%A1%E5%BC%8F%E5%88%B0Netty%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/"/>
      <url>/2022/09/26/IO-2022-09-26-%E4%BB%8EReactor%E6%A8%A1%E5%BC%8F%E5%88%B0Netty%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="单线程Reactor"><a href="#单线程Reactor" class="headerlink" title="单线程Reactor"></a>单线程Reactor</h2><h3 id="Reactor模型的朴素原型"><a href="#Reactor模型的朴素原型" class="headerlink" title="Reactor模型的朴素原型"></a>Reactor模型的朴素原型</h3><p>之前的文章探讨过IO模型，其中最优化的是基于多路复用器的NIO。Java的NIO模式的Selector网络通讯，其实就是一个简单的Reactor模型。可以说是Reactor模型的朴素原型。</p><p>我们再来回顾一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingSingleThreadv1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;   <span class="comment">//linux 多路复用器（select poll    epoll kqueue） nginx  event&#123;&#125;</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initServer();</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了。。。。。"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">                System.out.println(keys.size()+<span class="string">"   size"</span>);</span><br><span class="line">                <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();  <span class="comment">//返回的有状态的fd集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">              </span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        iter.remove(); <span class="comment">//set  不移除会重复循环处理</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;       </span><br><span class="line">                            acceptHandler(key);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            readHandler(key);           </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">            SocketChannel client = ssc.accept(); <span class="comment">//来啦，目的是调用accept接受客户端  fd7</span></span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">            System.out.println(<span class="string">"新客户端："</span> + client.getRemoteAddress());</span><br><span class="line">            <span class="keyword">final</span> String[] split = client.getRemoteAddress().toString().split(<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">if</span> (split[<span class="number">1</span>].equals(<span class="string">"15098"</span>))</span><br><span class="line">                System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                read = client.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        client.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketMultiplexingSingleThreadv1 service = <span class="keyword">new</span> SocketMultiplexingSingleThreadv1();</span><br><span class="line">        System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">        service.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单线程Reactor-1"><a href="#单线程Reactor-1" class="headerlink" title="单线程Reactor"></a>单线程Reactor</h3><p>实际上的Reactor模式，是基于Java NIO的，在他的基础上，抽象出来两个组件——Reactor和Handler两个组件：</p><p>（1）Reactor：负责响应IO事件，当检测到一个新的事件，将其发送给相应的Handler去处理；新的事件包含连接建立就绪、读就绪、写就绪等。</p><p>（2）Handler:将自身（handler）与事件绑定，负责事件的处理，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。</p><p>如下图所示:</p><p><img src="1.jpg" alt="wpsC334.tmp"></p><p>这是最简单的单Reactor单线程模型。Reactor线程是个多面手，负责多路分离套接字，Accept新连接，并分派请求到Handler处理器中。</p><p>下面的图，来自于“Scalable IO in Java”，和上面的图的意思，差不多。Reactor和Hander 处于一条线程执行。</p><p><img src="2.jpg" alt="wpsC345.tmp"></p><p>顺便说一下，可以将上图的accepter，看做是一种特殊的handler。</p><h2 id="多线程Reactor"><a href="#多线程Reactor" class="headerlink" title="多线程Reactor"></a>多线程Reactor</h2><p>​    上述的单线程Reactor虽然能使用单线程应对多个并发，但是还没有发挥出多线程的优势，现代的cpu都是多核cpu，如果只是单线程 明显发挥不出多核cpu的实力。我们尝试改造Reactor模式为多线程。<br>​    很容易想到，用一个主线程（reactor）来接收连接请求，具体的read、wirte等操作，拿一个线程池来去干活，这就可以发挥发线程的优势。</p><p>下面的图，来自于“Scalable IO in Java”,Reactor是一条独立的线程，Hander 处于线程池中执行。</p><p><img src="5.jpg" alt="wpsC376.tmp"></p><p>​    改造代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingSingleThreadv2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;   <span class="comment">//linux 多路复用器（select poll epoll） nginx  event&#123;&#125;</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            selector = Selector.open();  <span class="comment">//  select  poll  *epoll</span></span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initServer();</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了。。。。。"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (selector.select(<span class="number">50</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            acceptHandler(key);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"in....."</span>);</span><br><span class="line">                            readHandler(key);<span class="comment">//非阻塞  即便以抛出了线程去读取，但是在时差里，这个key的read事件会被重复触发</span></span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123;                    </span><br><span class="line">                            key.interestOps(key.interestOps() &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">                            writeHandler(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"write handler..."</span>);</span><br><span class="line">            SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    client.write(buffer);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">            SocketChannel client = ssc.accept();</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">            System.out.println(<span class="string">"新客户端："</span> + client.getRemoteAddress());</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"read handler....."</span>);</span><br><span class="line">            SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    read = client.read(buffer);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">" "</span> + read);</span><br><span class="line">                    <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        key.interestOps(  SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                        client.register(key.selector(),SelectionKey.OP_WRITE,buffer);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        client.close();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketMultiplexingSingleThreadv2 service = <span class="keyword">new</span> SocketMultiplexingSingleThreadv2();</span><br><span class="line">        service.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个乍一看好像没啥问题，实际运行的话是有点问题的，我们运行之后，在客户端处输入一个hello</p><p><img src="3.jpg" alt="image-20220926220333005"> <img src="4.jpg" alt="image-20220926220418249"></p><p>看到什么问题？我明明在客户端只输入了一次hello，但是确重复调用了，具体原因在代码中注释了,就是因为在切换线程处理的时候，这个空隙中 由于缓冲区没有读完，相当于read事件没有被处理完成，所以会一直调用。也就是说，每次输入，只要切换线程，这个背后可能就会调用多次epoll_wait得到read 事件。<font color=red>也就是会造成重复的系统调用</font>。</p><p>​    这样这么多浪费的系统调用被调肯定不行，并发多的时候 一定会影响性能，但我们还想利用多线程怎么办呢？</p><p>实际这个问题就是在于主线程非阻塞造成的，这一个reactor线程 判断获取了read事件、write事件 却切换了线程处理,如果我们让一个线程对此selector注册的事件负责到底，判断是read事件则进行read处理，判断是write事件就进行write处理，大不了多来几个reactor不就可以了吗？思路转，天地宽。</p><p>优化代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingThreads</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span>  Selector selector1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span>  Selector selector2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span>  Selector selector3 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            selector1 = Selector.open();</span><br><span class="line">            selector2 = Selector.open();</span><br><span class="line">            selector3 = Selector.open();</span><br><span class="line">            server.register(selector1, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketMultiplexingThreads service = <span class="keyword">new</span> SocketMultiplexingThreads();</span><br><span class="line">        service.initServer();</span><br><span class="line">        NioThread T1 = <span class="keyword">new</span> NioThread(service.selector1 ,<span class="number">2</span>);</span><br><span class="line">        NioThread T2 = <span class="keyword">new</span> NioThread(service.selector2);</span><br><span class="line">        NioThread T3 = <span class="keyword">new</span> NioThread(service.selector3);</span><br><span class="line"></span><br><span class="line">        T1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        T2.start();</span><br><span class="line">        T3.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器启动了。。。。。"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NioThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">     Selector selector = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> selectors = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">volatile</span> <span class="keyword">static</span> BlockingQueue&lt;SocketChannel&gt;[] queue;</span><br><span class="line">     <span class="keyword">static</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    NioThread(Selector sel,<span class="keyword">int</span> n ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.selector = sel;</span><br><span class="line">        <span class="keyword">this</span>.selectors =  n;</span><br><span class="line"></span><br><span class="line">        queue =<span class="keyword">new</span> LinkedBlockingQueue[selectors];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            queue[i] = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Boss 启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   NioThread(Selector sel  ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.selector = sel;</span><br><span class="line">       id = idx.getAndIncrement() % selectors  ;</span><br><span class="line">       System.out.println(<span class="string">"worker: "</span>+id +<span class="string">" 启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (selector.select(<span class="number">10</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            acceptHandler(key);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            readHandler(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( ! queue[id].isEmpty()) &#123;</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">                    SocketChannel client = queue[id].take();</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line">                    System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"新客户端："</span> + client.socket().getPort()+<span class="string">"分配到："</span>+ (id));</span><br><span class="line">                    System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">            SocketChannel client = ssc.accept();</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">int</span> num = idx.getAndIncrement() % selectors;</span><br><span class="line"></span><br><span class="line">            queue[num].add(client);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                read = client.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        client.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体架构大致如下:</p><p><img src="6.jpg" alt="image-20220926223327829"></p><p>​    我们用一个线程持有一个selector,在selector上只注册了accept事件,我们将其称为Boss,而我们再启动另外两个线程，每个线程持有一个selector，我们称其为worker线程，worker线程启动之后就负责对注册到本线程selector上的事件进行处理。</p><p>​    Boss线程接收客户端连接之后，我们直接将它注册到worker线程上selector，但是注意，直接注册由于worker调用select方法可能会阻塞，是注册不上的，此时需要唤醒操作。更好的处理方式就是代码中的通过队列解偶，让worker自己去注册即可，这就完成了一种多线程下的reactor模型。</p><h2 id="Netty-IO"><a href="#Netty-IO" class="headerlink" title="Netty IO"></a>Netty IO</h2><h3 id="Boss、Worker"><a href="#Boss、Worker" class="headerlink" title="Boss、Worker"></a>Boss、Worker</h3><p>​    多线程的reactor模式，其实重点就一个，就是让单线程持有一个selector，并且由它自己为注册到selector上的事件负责！那么，也就是说，我们将上图的Boss 变为多个线程，Worker变为更多的线程，并且Boss 线程或许也可以注册读写事件 由此来分担压力，或者 某些Worker专门注册写事件，某些Worker专门注册读事件，只要能充分利用多核cpu，可以任意组合。</p><p> 架构图:</p><p>​    <img src="7.jpg" alt="image-20220926225317405"></p><h3 id="简单的Netty实现"><a href="#简单的Netty实现" class="headerlink" title="简单的Netty实现"></a>简单的Netty实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.StandardSocketOptions;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingThreadsV2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup boss = <span class="keyword">new</span> EventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup worker = <span class="keyword">new</span> EventLoopGroup(<span class="number">3</span>);</span><br><span class="line">        ServerBootStrap b = <span class="keyword">new</span> ServerBootStrap();</span><br><span class="line">        b.group(boss, worker).bind(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerBootStrap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup group;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup chiledGroup;</span><br><span class="line">    ServerAcceptr sAcceptr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerBootStrap <span class="title">group</span><span class="params">(EventLoopGroup boss, EventLoopGroup worker)</span> </span>&#123;</span><br><span class="line">        group = boss;</span><br><span class="line">        chiledGroup = worker;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//bind 处理的是server的启动过程</span></span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        sAcceptr = <span class="keyword">new</span> ServerAcceptr(chiledGroup, server);</span><br><span class="line">        EventLoop eventloop = group.chosser();</span><br><span class="line">        <span class="comment">//把启动server，bind端口的操作变成task，推送到eventloop中执行。</span></span><br><span class="line">        eventloop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                eventloop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eventloop.name = Thread.currentThread() + eventloop.name;</span><br><span class="line">                            System.out.println(<span class="string">"bind...server...to "</span> + eventloop.name);</span><br><span class="line">                            server.register(eventloop.selector, SelectionKey.OP_ACCEPT, sAcceptr);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoopGroup</span> </span>&#123;</span><br><span class="line">    AtomicInteger cid = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    EventLoop[] childrens = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    EventLoopGroup(<span class="keyword">int</span> nThreads) &#123;</span><br><span class="line">        childrens = <span class="keyword">new</span> EventLoop[nThreads];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">            childrens[i] = <span class="keyword">new</span> EventLoop(<span class="string">"T"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventLoop <span class="title">chosser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> childrens[cid.getAndIncrement() % childrens.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doRead</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientReader</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SocketChannel key;</span><br><span class="line">    ClientReader(SocketChannel server) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = server;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ByteBuffer data = ByteBuffer.allocateDirect(<span class="number">4096</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            key.read(data);</span><br><span class="line">            data.flip();</span><br><span class="line">            <span class="keyword">byte</span>[] dd = <span class="keyword">new</span> <span class="keyword">byte</span>[data.limit()];</span><br><span class="line">            data.get(dd);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(dd));</span><br><span class="line">            data.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.put(<span class="string">"a"</span>.getBytes());</span><br><span class="line">                data.flip();</span><br><span class="line">                key.write(data);</span><br><span class="line">                data.clear();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerAcceptr</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    ServerSocketChannel key;</span><br><span class="line">    EventLoopGroup cGroup;</span><br><span class="line"></span><br><span class="line">    ServerAcceptr(EventLoopGroup cGroup, ServerSocketChannel server) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = server;</span><br><span class="line">        <span class="keyword">this</span>.cGroup = cGroup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> EventLoop eventLoop = cGroup.chosser();</span><br><span class="line">            <span class="keyword">final</span> SocketChannel client = key.accept();</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            client.setOption(StandardSocketOptions.TCP_NODELAY, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">final</span> ClientReader cHandler = <span class="keyword">new</span> ClientReader(client);</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"socket...send...to "</span> + eventLoop.name+ <span class="string">" client port : "</span> + client.socket().getPort());</span><br><span class="line"></span><br><span class="line">                        client.register(eventLoop.selector, SelectionKey.OP_READ, cHandler);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Selector selector;</span><br><span class="line">    Thread thread = <span class="keyword">null</span>;</span><br><span class="line">    BlockingQueue events = <span class="keyword">new</span> LinkedBlockingQueue();</span><br><span class="line">    <span class="keyword">int</span> NOT_STARTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> STARTED = <span class="number">2</span>;</span><br><span class="line">    AtomicInteger STAT = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventLoop</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Loop 需要一个死循环  这个死循环在哪里运行呢？当然在一个线程里，那，那个线程怎么出现的呢？？？当然是execute创建出来的。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"server已经开始："</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">//select</span></span><br><span class="line">            <span class="keyword">int</span> nums = selector.select();</span><br><span class="line">            <span class="comment">//selectedkeys to events</span></span><br><span class="line">            <span class="keyword">if</span> (nums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();  <span class="comment">//会一直阻塞，不过可以通过外界有task到达来wakeup唤醒</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    iter.remove();</span><br><span class="line">                    Handler handler = (Handler) key.attachment();</span><br><span class="line">                    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ServerAcceptr) &#123;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ClientReader) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    handler.doRead();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//run events</span></span><br><span class="line">            runrTask();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池需要持有线程和消息队列</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            events.put(task);</span><br><span class="line">            <span class="keyword">this</span>.selector.wakeup();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!inEventLoop() &amp;&amp; STAT.incrementAndGet() == STARTED) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        thread = Thread.currentThread();</span><br><span class="line">                        EventLoop.<span class="keyword">this</span>.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runrTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Runnable task = (Runnable) events.poll(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                events.remove(task);</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inEventLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thread == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="8.jpg" alt="image-20220926230127195"></p><blockquote><p>参考:<a href="https://www.cnblogs.com/crazymakercircle/p/9833847.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazymakercircle/p/9833847.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络IO-BIO、NIO</title>
      <link href="/2022/09/25/IO-2022-09-25-%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/09/25/IO-2022-09-25-%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>都是需求推动发展，网络IO模型也是一样，IO的发展都是围绕C10问题。总的来说就是如何建立高并发的连接。接下来我就看一下IO模型从最初的阻塞BIO到NIO再到多路复用器，一步一步如何发展过来。</p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="1.jpg" alt="image-20200615181255063"></p><p>看上图，所谓的BIO就是 阻塞式IO，需要一个线程监听端口，这个线程只能阻塞式的监听，再也不能干别的，当有连接上来时，linux建立对应的连接（注意这一步时内核干的，其实应用层的线程没有接受，连接也已经建立了）,这时候线程accpet即可获得一个用来读写的FD，需要一个专门的线程用来进行读写操作，并且是阻塞式的，也就说，多少个用户连接上来，需要多少个线程来进行处理。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Server:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketBIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"step1: new ServerSocket(9090) "</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket client = server.accept();  <span class="comment">//阻塞1</span></span><br><span class="line">            System.out.println(<span class="string">"step2:client\t"</span> + client.getPort());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    InputStream in = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        in = client.getInputStream();</span><br><span class="line">                        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">                        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                            String dataline = reader.readLine(); <span class="comment">//阻塞2</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(<span class="keyword">null</span> != dataline)&#123;</span><br><span class="line">                                System.out.println(dataline);</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                client.close();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">"客户端断开"</span>);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">9090</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            client.setSendBufferSize(<span class="number">20</span>);</span><br><span class="line">            client.setTcpNoDelay(<span class="keyword">true</span>);</span><br><span class="line">            OutputStream out = client.getOutputStream();</span><br><span class="line"></span><br><span class="line">            InputStream in = System.in;</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                String line = reader.readLine();</span><br><span class="line">                <span class="keyword">if</span>(line != <span class="keyword">null</span> )&#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] bb = line.getBytes();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">byte</span> b : bb) &#123;</span><br><span class="line">                        out.write(b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>上述代码对应的系统调用可用Strace命令进行查看,流程如下:</p><p><img src="2.jpg" alt="image-20220925223948199"></p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念:"></a>概念:</h3><p>​    BIO，每次上来一个用户需要开辟一个线程来维持会话，随着并发越来越大，资源开销太大了也，尽管我们可以使用线程池进行复用，可终归是治标不治本，所以我们急需一套真正的解决方法，来应付高并发。</p><p>​    我们思考一下，BIO的问题在哪？阻塞！主线程在监听端口的时候是阻塞式监听的，这就让它只能干这一个事情。同样读写的FD分配之后，持有FD的线程也是阻塞式的等待消息，不能干别的，这就是问题的根本原因。</p><p>所谓的NIO，就是非阻塞式IO（可以暂时这么理解）,我们假想一下，如果每次执行accpet、read这些系统调用都不是阻塞的，也就是说，有就有，没有就拉倒，那这个事情就太好办了。我们只需要一个线程，监听端口，然后accept 有连接就建立，没有就返回，我们把已经建立的连接，维护在一个集合里面，我们去遍历集合，挨个做读操作，因为read不阻塞，我们就可以对所有的连接进行处理了，尽管这样可能会慢一些，但相比BIO，我们已经可以用单个线程来应用多个连接，而不是一个连接需要一个线程来并发处理。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjmashibing.system.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.StandardSocketOptions;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketNIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  what   why  how</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">        LinkedList&lt;SocketChannel&gt; clients = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ss = ServerSocketChannel.open();  <span class="comment">//服务端开启监听：接受客户端</span></span><br><span class="line">        ss.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>));</span><br><span class="line">        ss.configureBlocking(<span class="keyword">false</span>); <span class="comment">//只让接受客户端  不阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            SocketChannel client = ss.accept(); <span class="comment">//不会阻塞？  -1 NULL</span></span><br><span class="line">            <span class="comment">//accept  调用内核了：非阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client.configureBlocking(<span class="keyword">false</span>); <span class="comment">//重点  socket（服务端的listen socket&lt;连接请求三次握手后，往我这里扔，我去通过accept 得到  连接的socket&gt;，连接socket&lt;连接后的数据读写使用的&gt; ）</span></span><br><span class="line">                <span class="keyword">int</span> port = client.socket().getPort();</span><br><span class="line">                System.out.println(<span class="string">"client..port: "</span> + port);</span><br><span class="line">                <span class="keyword">if</span>(port == <span class="number">15098</span>)</span><br><span class="line">                    System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">                clients.add(client);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">4096</span>);  <span class="comment">//可以在堆里   堆外</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历已经链接进来的客户端能不能读写数据</span></span><br><span class="line">            <span class="keyword">for</span> (SocketChannel c : clients) &#123;   <span class="comment">//串行化！！！！ 可以运用进多线程。灵活使用</span></span><br><span class="line">                <span class="keyword">int</span> num = c.read(buffer);  <span class="comment">// &gt;0  -1  0   //不会阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">byte</span>[] aaa = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</span><br><span class="line">                    buffer.get(aaa);</span><br><span class="line"></span><br><span class="line">                    String b = <span class="keyword">new</span> String(aaa);</span><br><span class="line">                    System.out.println(c.socket().getPort() + <span class="string">" : "</span> + b);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h3><p><img src="3.jpg" alt="image-20220925225025685"></p><h2 id="多路复用器"><a href="#多路复用器" class="headerlink" title="多路复用器"></a>多路复用器</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>​    有了NIO，我们已经可以用单个线程来应对多个连接，这样就可以极大的减少资源开销了。接下来就要考虑效率性能问题了。那如何优化呢？我们知道，我们现在一定是先触发accpet、read调用才知道到底有没有连接，有没有数据上来，换句话说，比如我们已经建立了1000个连接，但实际上并发消息并不多，可能只有1个人在频繁的发，剩余999都是沉默的状态，那我们不断的轮训，不断的对1000个FD执行read操作，实际上都是无用的，因为只有那1个才是有效的调用。</p><p>​    关键问题是，对我应用层而言，有没有消息我是先调了才知道的，我如何才能避开无效的调用呢？实际上，接下来的优化 对应用层已经没什么办法了，接下来的优化只能是内核来去做了。</p><p>​    内核如何做？接下来就是<font color=red>多路复用器</font>了</p><p>​    多路复用器的作用就是，让内核来帮你维护有事件的FD集合,线程要进行处理的时候，先做一步select操作，内核立刻返回一个集合，<font color=red>集合内是已经有事件的FD</font>，应用程序只需要遍历FD，做对应的处理即可。</p><p><img src="4.jpg" alt="image-20220926151649138" style="zoom:50%;" /></p><p>​    多路复用器的具体有3种，select、poll、epoll 在linux对应的系统调用。接下来 我们从原理上来解释一下它们的区别和演进过程。最后用一个JAVA代码来进行一个实战的应用讲解。</p><h3 id="Select、Poll"><a href="#Select、Poll" class="headerlink" title="Select、Poll"></a>Select、Poll</h3><p> select作为第一代的多路复用器，其大致原理应用程序在内存开辟一个读集合用来存放专门读的文件描述符,在开辟一个写集合专门存放用来写的集合，调用select操作时，需要将集合传递给内核，内核来线性遍历集合里的文件描述符，看看哪个已经处于就绪状态了。我们也可以从系统调用的原形上来观察。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>而 poll在本质上和select没有区别，原理是一样的。</p><p><img src="8.jpg" alt="image-20220926152357939" style="zoom:50%;" /></p><h4 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h4><p>Epoll可以说是性能最好，现在应用最广泛的多路复用器,它也是在select、poll基础上优化来的。</p><p>我们想一下，select poll有哪些可以优化的地方</p><pre><code>    1. 调用select 时，需要传递FD，从用户态传到内核态，FD多的时候 是一笔不小的开销。    1. 内核通过轮训来查看寻找就绪的FD，时间复杂度O(n),FD多了，势必会慢</code></pre><p>Epoll就解决了这两个问题。</p><p>它的原理是，首先在内核开辟一个空间用来组织所关心的文件描述符,所用的数据结构是红黑树,然后下一步，进行注册，将需要进行检测的FD 注册进红黑树,最后一步，执行类似select的操作，让内核返回就绪的文件描述符。这样，首先用户态不需要每次调用都得传递FD集合了！那么，内核是如何避免轮训查找就绪的FD呢？</p><p>​    我们思考一点，对应的FD什么时候就变的有序的呢？这里需要一点计组的前置知识。换句话说当 网卡有数据了，内核怎么知道数据到来了呢？从原始的 CPU程序式、中断式，到现在的DMA，CPU逐渐摆脱数据IO传输的工作，把更多的时间用于计算，但IO数据通过DMA搬运到内存之后，cpu还是要知道的呀，才能完成下一步的工作。也就是说，DMA把网卡数据搬运到内存之后，通过中断高知CPU数据到了内存buffer了，这时候内核就知道了哦，其对应的FD已经就绪了！所以，CPU在中断这一步就可以维护好就绪的FD，而不用后期再去轮训判断了。那Epoll的做法就是 内核维护一个链表，存放就绪的FD，中断时候就塞进链表，用户态调用Epoll_wait时候，内核直接返回此链表,O(1)</p><p>我们再来看一下 这3个重要的系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">epoll_create():内核开辟区域，建立红黑树</span><br><span class="line">epoll_ctl():用来对FD做一些操作,比如：将FD读事件 注册进红黑树 </span><br><span class="line">epoll_wait():用来获取就绪的FD集合</span><br></pre></td></tr></table></figure><p>具体流程如下 ：</p><p><img src="6.jpg" alt="image-20220926160230734"></p><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingSingleThreadv1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;   <span class="comment">//linux 多路复用器（select poll    epoll kqueue） nginx  event&#123;&#125;</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果在epoll模型下，open--》  epoll_create -&gt; fd3</span></span><br><span class="line">            selector = Selector.open();  <span class="comment">//  select  poll  *epoll  优先选择：epoll  但是可以 -D修正</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//server 约等于 listen状态的 fd4</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            register</span></span><br><span class="line"><span class="comment">            如果：</span></span><br><span class="line"><span class="comment">            select，poll：jvm里开辟一个数组 fd4 放进去</span></span><br><span class="line"><span class="comment">            epoll：  epoll_ctl(fd3,ADD,fd4,EPOLLIN</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initServer();</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了。。。。。"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  <span class="comment">//死循环</span></span><br><span class="line"></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">                System.out.println(keys.size()+<span class="string">"   size"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//1,调用多路复用器(select,poll  or  epoll  (epoll_wait))</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                select()是啥意思：</span></span><br><span class="line"><span class="comment">                1，select，poll  其实  内核的select（fd4）  poll(fd4)</span></span><br><span class="line"><span class="comment">                2，epoll：  其实 内核的 epoll_wait()</span></span><br><span class="line"><span class="comment">                *, 参数可以带时间：没有时间，0  ：  阻塞，有时间设置一个超时</span></span><br><span class="line"><span class="comment">                selector.wakeup()  结果返回0</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();  <span class="comment">//返回的有状态的fd集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">              </span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        iter.remove(); <span class="comment">//set  不移除会重复循环处理</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="comment">//看代码的时候，这里是重点，如果要去接受一个新的连接</span></span><br><span class="line">                            <span class="comment">//语义上，accept接受连接且返回新连接的FD对吧？</span></span><br><span class="line">                            <span class="comment">//那新的FD怎么办？</span></span><br><span class="line">                            <span class="comment">//select，poll，是在jvm中保存和前边的fd4那个listen的一起</span></span><br><span class="line">                            <span class="comment">//epoll： 我们希望通过epoll_ctl把新的客户端fd注册到内核空间</span></span><br><span class="line">                            acceptHandler(key);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            readHandler(key);  <span class="comment">//连read 还有 write都处理了</span></span><br><span class="line">                            <span class="comment">//在当前线程，这个方法可能会阻塞  ，如果阻塞了十年，其他的IO早就没电了。。。</span></span><br><span class="line">                            <span class="comment">//所以，为什么提出了 IO THREADS</span></span><br><span class="line">                            <span class="comment">//redis  是不是用了epoll，redis是不是有个io threads的概念 ，redis是不是单线程的</span></span><br><span class="line">                            <span class="comment">//tomcat 8,9  异步的处理方式  IO  和   处理上  解耦</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">            SocketChannel client = ssc.accept(); <span class="comment">//来啦，目的是调用accept接受客户端  fd7</span></span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);  <span class="comment">//前边讲过了</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            select，poll：jvm里开辟一个数组 fd7 放进去</span></span><br><span class="line"><span class="comment">            epoll：  epoll_ctl(fd3,ADD,fd7,EPOLLIN</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            client.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">            System.out.println(<span class="string">"新客户端："</span> + client.getRemoteAddress());</span><br><span class="line">            <span class="keyword">final</span> String[] split = client.getRemoteAddress().toString().split(<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">if</span> (split[<span class="number">1</span>].equals(<span class="string">"15098"</span>))</span><br><span class="line">                System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                read = client.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        client.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketMultiplexingSingleThreadv1 service = <span class="keyword">new</span> SocketMultiplexingSingleThreadv1();</span><br><span class="line">        System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">        service.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统调用-2"><a href="#系统调用-2" class="headerlink" title="系统调用"></a>系统调用</h3><p>上述的代码，同一套代码，底层可以选用不同的多路复用器</p><p><img src="7.jpg" alt="image-20220926164833823"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><p>select的几大缺点：</p><ul><li><p>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</p></li><li><p>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</p></li><li><p>select支持的文件描述符数量太小了，默认是1024</p></li></ul></li><li><p>poll的实现和select非常相似，只是描述fd集合的方式不同</p></li><li><p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次。</p></li><li><p>poll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生</p><ol><li>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</li><li>对于第二个缺点，epoll利用在中断时添加回调函数，这个回调函数会把就绪的fd加入一个就绪链表。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd。</li></ol></li><li>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过从BIO-&gt;NIO-&gt;多路复用器 优化过程，尽可能的理解为什么有这些东西，以及如何发展来的。网络IO模型是基石，无论mysql、redis 还是各种RPC框架，只要涉及到网络通信，都需要用到IO模型，可以说是重中之重，一定要理解到位。</p>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DMA与零拷贝技术</title>
      <link href="/2022/09/25/IO-2022-09-25-DMA%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/09/25/IO-2022-09-25-DMA%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>注意事项</strong>：除了 Direct I/O，与磁盘相关的文件读写操作都有使用到 page cache 技术。</p></blockquote><h2 id="数据的四次拷贝与四次上下文切换"><a href="#数据的四次拷贝与四次上下文切换" class="headerlink" title="数据的四次拷贝与四次上下文切换"></a>数据的四次拷贝与四次上下文切换</h2><p>很多应用程序在面临客户端请求时，可以等价为进行如下的系统调用：</p><ol><li>File.read(file, buf, len);</li><li>Socket.send(socket, buf, len);</li></ol><p>例如消息中间件 Kafka 就是这个应用场景，从磁盘中读取一批消息后原封不动地写入网卡（NIC，Network interface controller）进行发送。</p><p>在没有任何优化技术使用的背景下，操作系统为此会进行 4 次数据拷贝，以及 4 次上下文切换，如下图所示：</p><p><img src="1.jpg" alt="NoOptimization"></p><p>如果没有优化，读取磁盘数据，再通过网卡传输的场景性能比较差：</p><p>4 次 copy：</p><ul><li>物理设备 &lt;-&gt; 内存：<ul><li>CPU 负责将数据从磁盘搬运到内核空间的 Page Cache 中；</li><li>CPU 负责将数据从内核空间的 Socket 缓冲区搬运到的网络中；</li></ul></li><li>内存内部拷贝：<ul><li>CPU 负责将数据从内核空间的 Page Cache 搬运到用户空间的缓冲区；</li><li>CPU 负责将数据从用户空间的缓冲区搬运到内核空间的 Socket 缓冲区中；</li></ul></li></ul><p>4 次上下文切换：</p><ol><li>read 系统调用时：用户态切换到内核态；</li><li>read 系统调用完毕：内核态切换回用户态；</li><li>write 系统调用时：用户态切换到内核态；</li><li>write 系统调用完毕：内核态切换回用户态；</li></ol><p>我们不免发出抱怨：</p><ol><li>CPU 全程负责内存内部的数据拷贝还可以接受，因为内存的数据拷贝效率还行（不过还是比 CPU 慢很多），但是如果要 CPU 全程负责内存与磁盘、内存与网卡的数据拷贝，这将难以接受，因为磁盘、网卡的 I/O 速度远小于内存；</li><li>4 次 copy 太多了，4 次上下文切换也太频繁了；</li></ol><h2 id="DMA-参与下的数据四次拷贝"><a href="#DMA-参与下的数据四次拷贝" class="headerlink" title="DMA 参与下的数据四次拷贝"></a>DMA 参与下的数据四次拷贝</h2><p>DMA 技术很容易理解，本质上，DMA 技术就是我们在主板上放一块独立的芯片。在进行内存和 I/O 设备的数据传输的时候，我们不再通过 CPU 来控制数据传输，而直接通过 DMA 控制器（DMA Controller，简称 DMAC）。这块芯片，我们可以认为它其实就是一个协处理器（Co-Processor）。</p><p>DMAC 的价值在如下情况中尤其明显：当我们要传输的数据特别大、速度特别快，或者传输的数据特别小、速度特别慢的时候。</p><p>比如说，我们用千兆网卡或者硬盘传输大量数据的时候，如果都用 CPU 来搬运的话，肯定忙不过来，所以可以选择 DMAC。而当数据传输很慢的时候，DMAC 可以等数据到齐了，再发送信号，给到 CPU 去处理，而不是让 CPU 在那里忙等待。</p><p><strong>注意</strong>：这里面的“协”字。DMAC 是在“协助”CPU，完成对应的数据传输工作。在 DMAC 控制数据传输的过程中，DMAC 还是被 CPU 控制，只是数据的拷贝行为不再由 CPU 来完成。</p><p>原本，计算机所有组件之间的数据拷贝（流动）必须经过 CPU。以磁盘读写为例，如下图所示：</p><p><img src="2.jpg" alt="image-20210202234430674"></p><p>现在，DMAC 代替了 CPU 负责内存与磁盘、内存与网卡之间的数据搬运，CPU 作为 DMAC 的控制者，如下图所示：</p><p><img src="3.jpg" alt="image-20210202234656779"></p><p>但是 DMAC 有其局限性，DMAC 仅仅能用于设备<strong>间</strong>交换数据时进行数据拷贝，但是<strong>设备内部的数据拷贝还需要 CPU 来亲力亲为</strong>。例如， CPU 需要负责内核空间与用户空间之间的数据拷贝（内存内部的拷贝），如下图所示：</p><p><img src="4.jpg" alt="image-20210202233454550"></p><p>上图中的 read buffer 也就是 page cache，socket buffer 也就是 Socket 缓冲区。</p><h2 id="3-零拷贝技术"><a href="#3-零拷贝技术" class="headerlink" title="3. 零拷贝技术"></a>3. 零拷贝技术</h2><h3 id="3-1-什么是零拷贝技术？"><a href="#3-1-什么是零拷贝技术？" class="headerlink" title="3.1 什么是零拷贝技术？"></a>3.1 什么是零拷贝技术？</h3><p>零拷贝技术是一个思想[3]，指的是指计算机执行操作时，CPU 不需要先将数据从某处内存复制到另一个特定区域。</p><p>可见，零拷贝的特点是 CPU 不全程负责内存中的数据写入其他组件，CPU 仅仅起到管理的作用。但注意，零拷贝不是不进行拷贝，而是 CPU 不再全程负责数据拷贝时的搬运工作。<font color=color>如果数据本身不在内存中，那么必须先通过某种方式拷贝到内存中（这个过程 CPU 可以仅仅负责管理，DMAC 来负责具体数据拷贝），因为数据只有在内存中，才能被转移，才能被 CPU 直接读取计算</font>。</p><p>零拷贝技术的具体实现方式有很多，例如：</p><ul><li>sendfile</li><li>mmap</li><li>直接 Direct I/O</li><li>splice</li></ul><p>不同的零拷贝技术适用于不同的应用场景，下面依次进行 sendfile、mmap、Direct I/O 的分析。</p><p>不过，我们不妨先在这里做一个前瞻性的技术总结。</p><ul><li>DMA 技术：DMA 负责内存与其他组件之间的数据拷贝，CPU 仅需负责管理，而无需负责全程的数据拷贝；</li><li>使用 page cache 的 zero copy：<ul><li>sendfile：一次代替 read/write 系统调用，通过使用 DMA 技术以及传递文件描述符，实现了 zero copy</li><li>mmap：仅代替 read 系统调用，将内核空间地址映射为用户空间地址，write 操作直接作用于内核空间。通过 DMA 技术以及地址映射技术，用户空间与内核空间无须数据拷贝，实现了 zero copy</li></ul></li><li>不使用 page cache 的 Direct I/O：读写操作直接在磁盘上进行，不使用 page cache 机制，通常结合用户空间的用户缓存使用。通过 DMA 技术直接与磁盘/网卡进行数据交互，实现了 zero copy</li></ul><h3 id="3-2-sendfile"><a href="#3-2-sendfile" class="headerlink" title="3.2 sendfile"></a>3.2 sendfile</h3><p>snedfile 的应用场景是：<strong>用户从磁盘读取一些文件数据后不需要经过任何计算与处理就通过网络传输出去</strong>。此场景的典型应用是消息队列。</p><p>在传统 I/O 下，正如第一节所示，上述应用场景的一次数据传输需要四次 CPU 全权负责的拷贝与四次上下文切换，正如本文第一节所述。</p><p>sendfile 主要使用到了两个技术：</p><ol><li>DMA 技术；</li><li>传递文件描述符代替数据拷贝；</li></ol><p>下面依次讲解这两个技术的作用。</p><p><strong>1.利用 DMA 技术</strong></p><p>sendfile 依赖于 DMA 技术，将四次 CPU 全程负责的拷贝与四次上下文切换减少到两次，如下图所示：</p><p><img src="5.jpg" alt="img"></p><blockquote><p>利用 DMA 技术减少 2 次 CPU 全程参与的拷贝</p></blockquote><p>DMA 负责磁盘到内核空间中的 Page cache（read buffer）的数据拷贝以及从内核空间中的 socket buffer 到网卡的数据拷贝。</p><p><strong>2.传递文件描述符代替数据拷贝</strong></p><p>传递文件描述可以代替数据拷贝，这是由于两个原因：</p><ul><li>page cache 以及 socket buffer 都在内核空间中；</li><li>数据在传输中没有被更新；</li></ul><p><img src="6.jpg" alt="img"></p><blockquote><p>利用传递文件描述符代替内核中的数据拷贝</p></blockquote><p><strong>注意事项</strong>：只有网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术才可以通过传递文件描述符的方式避免内核空间内的一次 CPU 拷贝。这意味着此优化取决于 Linux 系统的物理网卡是否支持（Linux 在内核 2.4 版本里引入了 DMA 的 scatter/gather – 分散/收集功能，只要确保 Linux 版本高于 2.4 即可）。</p><p><strong>3.一次系统调用代替两次系统调用</strong></p><p>由于 sendfile 仅仅对应一次系统调用，而传统文件操作则需要使用 read 以及 write 两个系统调用。</p><p>正因为如此，sendfile 能够将用户态与内核态之间的上下文切换从 4 次讲到 2 次。</p><p><img src="7.jpg" alt="sendfile"></p><blockquote><p>sendfile 系统调用仅仅需要两次上下文切换</p></blockquote><p>另一方面，我们需要注意 sendfile 系统调用的局限性。如果应用程序需要对从磁盘读取的数据进行写操作，例如解密或加密，那么 sendfile 系统调用就完全没法用。这是因为用户线程根本就不能够通过 sendfile 系统调用得到传输的数据。</p><h3 id="3-3-mmap"><a href="#3-3-mmap" class="headerlink" title="3.3 mmap"></a>3.3 mmap</h3><p>后面单独讲</p><h3 id="3-4-Direct-I-O"><a href="#3-4-Direct-I-O" class="headerlink" title="3.4 Direct I/O"></a>3.4 Direct I/O</h3><p>Direct I/O 即直接 I/O。其名字中的”直接”二字用于区分使用 page cache 机制的缓存 I/O。</p><ul><li>缓存文件 I/O：用户空间要读写一个文件并<strong>不直接</strong>与磁盘交互，而是中间夹了一层缓存，即 page cache；</li><li>直接文件 I/O：用户空间读取的文件<strong>直接</strong>与磁盘交互，没有中间 page cache 层；</li></ul><p>“直接”在这里还有另一层语义：其他所有技术中，数据至少需要在内核空间存储一份，但是在 Direct I/O 技术中，数据直接存储在用户空间中，绕过了内核。</p><p>Direct I/O 模式如下图所示：</p><p><img src="8.jpg" alt="directIO"></p><blockquote><p>Direct I/O 示意图</p></blockquote><p>此时用户空间直接通过 DMA 的方式与磁盘以及网卡进行数据拷贝。</p><p><strong>Direct I/O 的读写非常有特点</strong>：</p><ul><li>Write 操作：由于其不使用 page cache，所以其进行写文件，如果返回成功，数据就真的落盘了（不考虑磁盘自带的缓存）；</li><li>Read 操作：由于其不使用 page cache，每次读操作是真的从磁盘中读取，不会从文件系统的缓存中读取。</li></ul><p><strong>事实上，即使 Direct I/O 还是可能需要使用操作系统的 fsync 系统调用。为什么？</strong></p><p>这是因为虽然文件的数据本身没有使用任何缓存，但是文件的元数据仍然需要缓存，包括 VFS 中的 inode cache 和 dentry cache 等。</p><p>在部分操作系统中，在 Direct I/O 模式下进行 write 系统调用能够确保文件数据落盘，但是文件元数据不一定落盘。如果在此类操作系统上，那么还需要执行一次 fsync 系统调用确保文件元数据也落盘。否则，可能会导致文件异常、元数据确实等情况。MySQL 的 O_DIRECT 与 O_DIRECT_NO_FSYNC 配置是一个具体案例[9]。</p><p>Direct I/O 的优缺点：</p><p><strong>（1）优点</strong></p><ol><li>Linux 中的直接 I/O 技术省略掉缓存 I/O 技术中操作系统内核缓冲区的使用，数据直接在应用程序地址空间和磁盘之间进行传输，从而使得自缓存应用程序可以省略掉复杂的系统级别的缓存结构，而执行程序自己定义的数据读写管理，从而<strong>降低系统级别的管理对应用程序访问数据的影响</strong>。</li><li>与其他零拷贝技术一样，避免了内核空间到用户空间的数据拷贝，如果要传输的数据量很大，使用直接 I/O 的方式进行数据传输，而不需要操作系统内核地址空间拷贝数据操作的参与，这将会大大提高性能。</li></ol><p><strong>（2）缺点</strong></p><ol><li>由于设备之间的数据传输是通过 DMA 完成的，因此<strong>用户空间的数据缓冲区内存页必须进行 page pinning（页锁定）</strong>，这是为了防止其物理页框地址被交换到磁盘或者被移动到新的地址而导致 DMA 去拷贝数据的时候在指定的地址找不到内存页从而引发缺页错误，而页锁定的开销并不比 CPU 拷贝小，所以为了避免频繁的页锁定系统调用，应用程序必须分配和注册一个持久的内存池，用于数据缓冲。</li><li>如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘进行加载，这种直接加载会非常缓慢。</li><li>在应用层引入直接 I/O 需要应用层自己管理，这带来了额外的系统复杂性；</li></ol><p><strong>谁会使用 Direct I/O？</strong></p><p>IBM[5]的一篇文章指出，自缓存应用程序（ self-caching applications）可以选择使用 Direct I/O。</p><blockquote><p>自缓存应用程序</p><p>对于某些应用程序来说，它会有它自己的数据缓存机制，比如，它会将数据缓存在应用程序地址空间，这类应用程序完全不需要使用操作系统内核中的高速缓冲存储器，这类应用程序就被称作是自缓存应用程序（ self-caching applications ）。</p><p>例如，应用内部维护一个缓存空间，当有读操作时，首先读取应用层的缓存数据，如果没有，那么就通过 Direct I/O 直接通过磁盘 I/O 来读取数据。缓存仍然在应用，只不过应用觉得自己实现一个缓存比操作系统的缓存更高效。</p><p><strong>数据库管理系统是这类应用程序的一个代表</strong>。自缓存应用程序倾向于使用数据的逻辑表达方式，而非物理表达方式；当系统内存较低的时候，自缓存应用程序会让这种数据的逻辑缓存被换出，而并非是磁盘上实际的数据被换出。自缓存应用程序对要操作的数据的语义了如指掌，所以它可以采用更加高效的缓存替换算法。自缓存应用程序有可能会在多台主机之间共享一块内存，那么自缓存应用程序就需要提供一种能够有效地将用户地址空间的缓存数据置为无效的机制，从而确保应用程序地址空间缓存数据的一致性。</p><p>page cache 是 Linux 为所有应用提供的缓存机制，但是数据库应用太特殊了，page cache 影响了数据对特性的追求。</p></blockquote><p>另一方面，目前 Linux 上的异步 IO 库，其依赖于文件使用 O_DIRECT 模式打开，它们通常一起配合使用。</p><p><strong>如何使用 Direct I/O？</strong></p><p>用户应用需要实现用户空间内的缓存区，读/写操作应当尽量通过此缓存区提供。如果有性能上的考虑，那么尽量避免频繁地基于 Direct I/O 进行读/写操作。</p><h2 id="4-典型案例"><a href="#4-典型案例" class="headerlink" title="4. 典型案例"></a>4. 典型案例</h2><h3 id="4-1-Kakfa"><a href="#4-1-Kakfa" class="headerlink" title="4.1 Kakfa"></a>4.1 Kakfa</h3><p>Kafka 作为一个消息队列，涉及到磁盘 I/O 主要有两个操作：</p><ul><li>Provider 向 Kakfa 发送消息，Kakfa 负责将消息以日志的方式持久化落盘；</li><li>Consumer 向 Kakfa 进行拉取消息，Kafka 负责从磁盘中读取一批日志消息，然后再通过网卡发送；</li></ul><p>Kakfa 服务端接收 Provider 的消息并持久化的场景下使用 mmap 机制[6]，能够基于顺序磁盘 I/O 提供高效的持久化能力，使用的 Java 类为 java.nio.MappedByteBuffer。</p><p>Kakfa 服务端向 Consumer 发送消息的场景下使用 sendfile 机制[7]，这种机制主要两个好处：</p><ul><li>sendfile 避免了内核空间到用户空间的 CPU 全程负责的数据移动；</li><li>sendfile 基于 Page Cache 实现，因此如果有多个 Consumer 在同时消费一个主题的消息，那么由于消息一直在 page cache 中进行了缓存，因此只需一次磁盘 I/O，就可以服务于多个 Consumer；</li></ul><blockquote><p>使用 mmap 来对接收到的数据进行持久化，使用 sendfile 从持久化介质中读取数据然后对外发送是一对常用的组合。但是注意，你无法利用 sendfile 来持久化数据，利用 mmap 来实现 CPU 全程不参与数据搬运的数据拷贝。</p></blockquote><h3 id="4-2-MySQL"><a href="#4-2-MySQL" class="headerlink" title="4.2 MySQL"></a>4.2 MySQL</h3><p>MySQL 的具体实现比 Kakfa 复杂很多，这是因为支持 SQL 查询的数据库本身比消息队列对复杂很多。</p><p>MySQL 的零拷贝技术使用方式请移步我的另一篇文章[8]。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>DMA 技术使得内存与其他组件，例如磁盘、网卡进行数据拷贝时，CPU 仅仅需要发出控制信号，而拷贝数据的过程则由 DMAC 负责完成。</p><p>Linux 的零拷贝技术有多种实现策略，但根据策略可以分为如下几种类型：</p><ul><li><strong>减少甚至避免用户空间和内核空间之间的数据拷贝</strong>：在一些场景下，用户进程在数据传输过程中并不需要对数据进行访问和处理，那么数据在 Linux 的 <code>Page Cache</code> 和用户进程的缓冲区之间的传输就完全可以避免，让数据拷贝完全在内核里进行，甚至可以通过更巧妙的方式避免在内核里的数据拷贝。这一类实现一般是是通过增加新的系统调用来完成的，比如 Linux 中的 mmap()，sendfile() 以及 splice() 等。</li><li><strong>绕过内核的直接 I/O</strong>：允许在用户态进程绕过内核直接和硬件进行数据传输，内核在传输过程中只负责一些管理和辅助的工作。这种方式其实和第一种有点类似，也是试图避免用户空间和内核空间之间的数据传输，只是第一种方式是把数据传输过程放在内核态完成，而这种方式则是直接绕过内核和硬件通信，效果类似但原理完全不同。</li><li><strong>内核缓冲区和用户缓冲区之间的传输优化</strong>：这种方式侧重于在用户进程的缓冲区和操作系统的页缓存之间的 CPU 拷贝的优化。这种方法延续了以往那种传统的通信方式，但更灵活。</li></ul>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件IO与PageCache</title>
      <link href="/2022/09/25/IO-2022-09-25-%E6%96%87%E4%BB%B6IO%E4%B8%8EPageCache/"/>
      <url>/2022/09/25/IO-2022-09-25-%E6%96%87%E4%BB%B6IO%E4%B8%8EPageCache/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><p><img src="1.jpg" alt="WeChat3f9442a961bae5d63735680f0da3c7f9"></p><p>如上图，首先我们从图中得知两点:</p><ol><li>PageCache 是属于内核级别的，受到内核的管理</li><li>在用户态，用户可以使用mmap映射，直接访问PageCache，而不必进行内核态的切换。</li></ol><h2 id="PageCache"><a href="#PageCache" class="headerlink" title="PageCache"></a>PageCache</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>首先我们要了解一点，现在的内存管理方案中多数是分页管理，也就是内存会划分为4k一页作为一个基本单位。而pagecache呢通常也是4KB，用来缓存文件。提高IO的速度。</p><p><img src="2.jpg" alt="image-20220925160746941"></p><p>如上图演示的流程中，两个应用程序想使用同一个文件，其文件描述符对应的是同一个PC页，在内核层面并不关心是谁使用的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p> <strong>1.加快数据访问</strong></p><p>如果数据能够在内存中进行缓存，那么下一次访问就不需要通过磁盘 I/O 了，直接命中内存缓存即可。</p><p>由于内存访问比磁盘访问快很多，因此加快数据访问是 Page Cache 的一大优势。</p><p><strong>2.减少 I/O 次数，提高系统磁盘 I/O 吞吐量</strong></p><p>得益于 Page Cache 的缓存以及预读能力，而程序又往往符合局部性原理，因此通过一次 I/O 将多个 page 装入 Page Cache 能够减少磁盘 I/O 次数， 进而提高系统磁盘 I/O 吞吐量</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>​    page cache 也有其劣势，最直接的缺点是需要占用额外物理内存空间，物理内存在比较紧俏的时候可能会导致频繁的 swap 操作，最终导致系统的磁盘 I/O 负载的上升。</p><p>​    Page Cache 的另一个缺陷是对应用层并没有提供很好的管理 API，几乎是透明管理。应用层即使想优化 Page Cache 的使用策略也很难进行。因此一些应用选择在用户空间实现自己的 page 管理，而不使用 page cache，例如 MySQL InnoDB 存储引擎以 16KB 的页进行管理。</p><p>Page Cache 最后一个缺陷是在某些应用场景下比 Direct I/O 多一次磁盘读 I/O 以及磁盘写 I/O。</p><h3 id="JAVA的IO访问"><a href="#JAVA的IO访问" class="headerlink" title="JAVA的IO访问"></a>JAVA的IO访问</h3><p><img src="3.jpg" alt="未命名文件 (7)"></p><p>图中清晰的展示了 Java中访问文件使用的访问，要注意如下几点:</p><ol><li><p>jvm的堆再java的堆里. 堆内：说的jvm的堆里的字节数组,堆外：多的是jvm堆外，也就是java进程的堆里的</p></li><li><p>mapped映射：是mmap调用的一个进程和内核共享的内存区域,且这个内存区域是pagecache/到文件的映射速度上比较是:on heap &lt; off heap &lt; mapped (file)</p></li><li>应用层面 netty :on heap , off heap.  kafka log : mmap</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们简单的梳理了下PageCache的概念以及它在linux文件系统中起到的重要作用，需要读者有计算机组成原理的知识铺垫。PageCache是文件IO的基础，IO很多的优化都是在它基础之上的</p><blockquote><p>参考:<a href="https://www.bilibili.com/read/cv13132866a" target="_blank" rel="noopener">https://www.bilibili.com/read/cv13132866a</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象布局相关问题</title>
      <link href="/2022/09/25/JVM-2022-09-25-%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/25/JVM-2022-09-25-%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有关对象的创建、对象在内存中的布局，今天我们通过几道面试题来梳理一下。</p><h2 id="请解释一下对象的创建过程？"><a href="#请解释一下对象的创建过程？" class="headerlink" title="请解释一下对象的创建过程？"></a>请解释一下对象的创建过程？</h2><ol><li>class loading</li><li>class linking (verification, preparation, resolution) - 静态变量赋默认值</li><li>class initializing- 静态变量赋初始值</li><li>申请对象内存</li><li>成员变量赋默认值</li><li>调用构造方法<init><ol><li>成员变量顺序赋初始值</li><li>执行构造方法语句</li></ol></li></ol><h2 id="对象在内存中的存储布局？"><a href="#对象在内存中的存储布局？" class="headerlink" title="对象在内存中的存储布局？"></a>对象在内存中的存储布局？</h2><h3 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h3><ol><li>对象头：markword  8</li><li>ClassPointer指针：-XX:+UseCompressedClassPointers 为4字节 不开启为8字节</li><li>实例数据<ol><li>引用类型：-XX:+UseCompressedOops 为4字节 不开启为8字节<br>Oops Ordinary Object Pointers</li></ol></li><li>Padding对齐，8的倍数</li></ol><h3 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h3><ol><li>对象头：markword 8</li><li>ClassPointer指针同上</li><li>数组长度：4字节</li><li>数组数据</li><li>对齐 8的倍数</li></ol><h2 id="对象头具体包括什么？"><a href="#对象头具体包括什么？" class="headerlink" title="对象头具体包括什么？"></a>对象头具体包括什么？</h2><p><img src="1.jpg" alt="image-20220925122509859"></p><h2 id="对象怎么定位？"><a href="#对象怎么定位？" class="headerlink" title="对象怎么定位？"></a>对象怎么定位？</h2><ol><li>句柄池</li><li>直接指针</li></ol><p>​    参考:<a href="https://blog.csdn.net/clover_lily/article/details/80095580" target="_blank" rel="noopener">https://blog.csdn.net/clover_lily/article/details/80095580</a></p><h2 id="对象怎么分配？"><a href="#对象怎么分配？" class="headerlink" title="对象怎么分配？"></a>对象怎么分配？</h2><p><img src="2.jpg" alt="image-20220925143746967"></p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized锁升级过程</title>
      <link href="/2022/09/25/JVM-2022-09-25-Synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/09/25/JVM-2022-09-25-Synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Synchronized的经过优化之后，性能提高很多，接下来我们就看一下它的优化原理。</p><h2 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h2><p>Java的锁状态其实可以分为三种，分别是偏向锁，轻量级锁和重量级锁。</p><p>在Java HotSpot VM中，每个对象前面都有一个class指针和一个Mark Word。 Mark Word存储了哈希值以及分代年龄和标记位等，通过这些值的变化，JVM可以实现对java对象的不同程度的锁定。</p><p><img src="/Users/james/blogs/blog/source/_posts/2022-09-25-Synchronized锁升级过程/1.jpg" alt="img"></p><p>javaObject对象的对象头大小根据你使用的是32位还是64位的虚拟机的不同，稍有变化。这里我们使用的是64位的虚拟机为例。</p><p>Object的对象头，分为两部分，第一部分是Mark Word，用来存储对象的运行时数据比如：hashcode，GC分代年龄，锁状态，持有锁信息，偏向锁的thread ID等等。</p><p>在64位的虚拟机中，Mark Word是64bits，如果是在32位的虚拟机中Mark Word是32bits。</p><p>第二部分就是Klass Word，Klass Word是一个类型指针，指向class的元数据，JVM通过Klass Word来判断该对象是哪个class的实例。</p><p>我们可以看到对象头中的Mark Word根据状态的不同，存储的是不同的内容。</p><p>其中锁标记的值分别是：无锁=001，偏向锁=101，轻量级锁=000，重量级锁=010。</p><h2 id="java中锁状态的变化"><a href="#java中锁状态的变化" class="headerlink" title="java中锁状态的变化"></a>java中锁状态的变化</h2><p>为什么java中的锁有三种状态呢？其本质原因是为了提升锁的效率，因为不同情况下，锁的粒度是不一样的。</p><p>通过设置不同的锁的状态，从而可以不同的情况用不同的处理方式。</p><p>下图是java中的锁状态的变化图：</p><p><img src="4.jpg" alt="img"></p><p>上面的图基本上列出了java中锁状态的整个生命周期。接下来我们一个一个的讲解。</p><h2 id="偏向锁biased-locking"><a href="#偏向锁biased-locking" class="headerlink" title="偏向锁biased locking"></a>偏向锁biased locking</h2><p><font color=red>一般来说，一个对象被一个线程获得锁之后，很少发生线程切换的情况</font>。也就是说大部分情况下，一个对象只是被一个线程锁定的。</p><p>那么这个时候我们可以通过设置Mark word的一定结构，减少使用CAS来更新对象头的频率。</p><p>为了实现这样的目标，我们看下偏向锁的Mark word的结构：</p><p><img src="5.jpg" alt="img"></p><p>当偏向线程第一次进入同步块的时候，会去判断偏向锁的状态和thread ID，如果偏向锁状态是1，并且thread ID是空的话，将会使用CAS命令来更新对象的Mark word。</p><p>设置是否偏向锁=1，锁标记=01,线程ID设置为当前锁定该对象的线程。</p><p>下一次该对象进入同步块的时候，会先去判断锁定的线程ID和当前线程ID是否相等，如果相等的话则不需要执行CAS命令，直接进入同步块。</p><p>如果这个时候有第二个线程想访问该对象的同步块，因为当前对象头的thread ID是第一个线程的ID，跟第二个线程的ID不同。</p><p>如果这个时候线程1的同步块已经执行完毕，那么需要解除偏向锁的锁定。</p><p>解除锁定很简单，就是将线程ID设置为空，并且将偏向锁的标志位设为0，</p><p>如果这个时候线程1的同步块还在执行，那么需要将偏向锁升级为轻量级锁。</p><h2 id="轻量级锁thin-lock"><a href="#轻量级锁thin-lock" class="headerlink" title="轻量级锁thin lock"></a>轻量级锁thin lock</h2><p>先看下轻量级锁的结构：</p><p><img src="2.jpg" alt="img"></p><p>可以看到Mark word中存放的是栈中锁记录的指针和锁的标记=00。</p><p>如果对象现在处于未加锁状态，当一个线程尝试进入同步块的时候，会将把对象头和当前对象的指针拷贝一份，放在线程的栈中一个叫做lock record的地方。</p><p>然后JVM通过CAS操作，将对象头中的指针指向刚刚拷贝的lock record。如果成功，则该线程拥有该对象的锁。</p><p>实际上Lock Record和Mark word形成了一个互相指向对方的情况。</p><p>下次这个线程再次进入同步块的时候，同样执行CAS，比较Mark word中的指针是否和当前thread的lock record地址一致，如果一致表明是同一个线程，可以继续持有该锁。</p><p>如果这个时候有第二个线程，也想进入该对象的同步块，也会执行CAS操作，很明显会失败，因为对象头中的指针和lock record的地址不一样。</p><p>这个时候第二个线程就会自旋等待。</p><p>那么第一个线程什么时候会释放锁呢？</p><p>轻量级锁在线程退出同步块的时候，同样需要执行CAS命令，将锁标记从00替换成01，也就是无锁状态。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>如果第二个线程自旋时间太久，就会将锁标记替换成10（重量级锁），并且设置重量级锁的指针，指向第二个线程，然后进入阻塞状态。</p><p>当第一个线程退出同步块的时候，执行CAS命令就会出错，这时候第一个线程就知道锁已经膨胀成为重量级锁了。</p><p>第一个线程就会释放锁，并且唤醒等待的第二个线程。</p><p>第二个线程被唤醒之后，重新争夺锁。</p><p>我们看下重量级锁的结构：</p><p><img src="3.jpg" alt="img"></p><h2 id="三种锁状态的不同"><a href="#三种锁状态的不同" class="headerlink" title="三种锁状态的不同"></a>三种锁状态的不同</h2><p>偏向锁，轻量级锁和重量级锁到底有什么不同了？</p><p>这里总结一下，偏向锁下次进入的时候不需要执行CAS命令，只做线程ID的比较即可。</p><p>轻量级锁进入和退出同步块都需要执行CAS命令，但是轻量级锁不会阻塞，它使用的是自旋命令来获取锁。</p><p>重量级锁不使用自旋，但是会阻塞线程！</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized关键字原理</title>
      <link href="/2022/09/25/JVM-2022-09-25-Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/25/JVM-2022-09-25-Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    java聊到并发，synchronized关键字想必肯定是再熟悉不过了，它的使用非常简单，接下来我们就重点看一下使用时候的注意点和原理。</p><h2 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h2><ol><li>选用一个锁对象，可以是任意对象；</li><li>锁对象锁的是同步代码块，并不是自己；</li><li>不同类型的多个 Thread 如果有代码要同步执行，锁对象要使用所有线程共同持有的同一个对象；</li><li>需要同步的代码放到大括号中。需要同步的意思就是需要保证原子性、可见性、有序性中的任何一种或多种。不要放不需要同步的代码进来，影响代码效率。</li></ol><h2 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h2><h3 id="字节码实现"><a href="#字节码实现" class="headerlink" title="字节码实现"></a>字节码实现</h3><p>​    Synchronized在JVM里的实现都是基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p><p>​    <font color=red>monitorenter：每个对象都是一个监视器锁（monitor）</font>。</p><p>当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p><ol><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者;</li><li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；</li><li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</li></ol><p>monitorexit：执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。<br>monitorexit，指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；</p><p>通过上面描述，我们应该能很清楚的看出Synchronized的实现原理，<strong>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，</strong>否则会抛出java.lang.IllegalMonitorStateException的异常的原因。<br>方法的同步：（加了Synchronized的方法）</p><p>​    两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p><h3 id="Mointor"><a href="#Mointor" class="headerlink" title="Mointor"></a>Mointor</h3><p>​    可以把它理解为 一个同步工具，也可以描述为 一种同步机制，它通常被 描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。也就是通常说Synchronized的对象锁，MarkWord锁标识位为10，其中指针指向的是Monitor对象的起始地址。在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）：</p><p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表（ 每个等待锁的线程都会被封装成<br>ObjectWaiter对象 ），_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时：</p><pre><code>1.    首先会进入 _EntryList 集合，当线程获取到对象的monitor后，进入 _Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1； 2.    若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒； 3.    若当前线程执行完毕，也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)； 当多个线程同时请求某个对象锁时，对象锁会设置⼏种状态⽤来区分请求的线程： Contention List：所有请求锁的线程将被⾸先放置到该竞争队列 Entry List：Contention List中那些有资格成为候选⼈的线程被移到Entry List Wait Set：那些调⽤wait⽅法被阻塞的线程被放置到Wait Set OnDeck：任何时刻最多只能有⼀个线程正在竞争锁，该线程称为OnDeck Owner：获得锁的线程称为Owner !Owner：释放锁的线程 当⼀个线程尝试获得锁时，如果该锁已经被占⽤，则会将该线程封装成⼀个 ObjectWaiter 对象插⼊到Contention List的队列的队⾸，然后调⽤ park 函数挂起当前线程。</code></pre><p>当线程释放锁时，会从Contention List或EntryList中挑选⼀个线程唤醒，被选中的线程叫做 Heir presumptive 即假定继承⼈，假定继承⼈被唤醒后会尝试获得锁，但 synchronized 是⾮公平的，所以假定继承⼈不⼀定能获得锁。这是因为对于重量级锁，线程先⾃旋尝试获得锁，这样做的⽬的是为了减少执⾏操作系统同步操作带来的开销。如果⾃旋不成功再进⼊等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有⼀个不公平的地⽅是⾃旋线程可能会抢占了Ready线程的锁。线程获得锁后调⽤ Object.wait ⽅法，则会将线程加⼊到WaitSet中，当被 Object.notify 唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调⽤⼀个锁对象的 wait 或 notify ⽅法时，如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁。</p><p>同时，Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式<br>获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。监视器Monitor有两种同步方式：互斥与协作。多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问。</p><h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><ol><li>synchronized 使用的为非公平锁，如果你需要公平锁，那么不要使用 synchronized。可以使用 ReentrantLock，设置为公平锁。关于 ReentrantLock。</li><li>锁对象不能为 null。如果锁对象为 null，何谈对象头，以及保存与其关联的 monitor 锁呢？所以代码中要确保synchronized使用的锁对象不为 null；</li><li>只把需要同步的代码放入 synchronized 代码块。如果不思考，为了线程安全把方法中全部代码都放入同步代码块，那么将会丧失多线程的优势。再多的线程也只能串行执行，这完全违背了并发的初衷；</li><li>只有使用同一个对象作为锁对象，才能同步。记住是同一个对象，而不是同一个类。有一种常犯的错误是，不同线程持有的是同一个类的不同实例。那么该对象实例用作锁对象的话，多个线程并不会同步。还一种错误是使用不同类的实例作为锁对象，但是期望不同位置的同步代码块能够同步执行。这是不可能达到你想要的效果的。</li></ol><blockquote><p>参考:<a href="https://www.cnblogs.com/freelancy/p/15625602.html" target="_blank" rel="noopener">https://www.cnblogs.com/freelancy/p/15625602.html</a></p><p>​        <a href="https://www.jianshu.com/p/b624ca34fee2" target="_blank" rel="noopener">https://www.jianshu.com/p/b624ca34fee2</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile与可见性</title>
      <link href="/2022/09/25/JVM-2022-09-25-volatile%E4%B8%8E%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
      <url>/2022/09/25/JVM-2022-09-25-volatile%E4%B8%8E%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>​    可见性指的是，某个线程对共享变量进行了修改，其它线程能够立刻看到修改后的最新值。乍一听这个定义，你可能会觉得这不是废话吗？变量被修改了，线程当然能够立刻读取到！否则即使单线程的程序也会出问题啊！没错，变量被修改后，在本线程中确实能够立刻被看到，但并不保证别的线程会立刻看到。原因就是编程领域经典的两大难题之一——缓存一致性。</p><h2 id="观察可见性"><a href="#观察可见性" class="headerlink" title="观察可见性"></a>观察可见性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">visibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowVisibility</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">private</span> Boolean flag = <span class="keyword">false</span>; </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+flag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ShowVisibility showVisibility = <span class="keyword">new</span> ShowVisibility();</span><br><span class="line">        Thread blindThread = <span class="keyword">new</span> Thread(showVisibility);</span><br><span class="line">         blindThread.start();</span><br><span class="line">        <span class="comment">//给线程启动的时间</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//更新flag</span></span><br><span class="line">        showVisibility.flag=<span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"flag is true, thread should print"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"I have slept 1 seconds. I guess there was nothing printed "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，ShowVisibility 实现 Runnable 接口，在 run 方法中判断成员变量 flag 值为 true 时进行打印。main 方法中通过 showVisibility 对象启动一个线程。主线程等待 0.5 秒后，改变 showVisibility 中 flag 的值为 true。按正常思路，此时 blindThread 应该开始打印。但是，实际情况并非如此。运行此程序，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag is <span class="keyword">true</span>, thread should print</span><br><span class="line">I have slept <span class="number">1</span> seconds. I guess there was nothing printed</span><br></pre></td></tr></table></figure><p>没错，flag 改为 true 后，blindThread 没有任何打印。也就是说 blindThread 并没有观察到到 flag 的值变化。</p><p>如果是单线程程序，做了一个变量的修改，那么程序是立即就能看到的。然而在多线程程序中并非如此。原因是 CPU 为提高计算的速度，使用了缓存。</p><h2 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h2><p>​    大家一定都知道摩尔定律。根据定律，CPU 每 18 个月速度将会翻一番。CPU 的计算速度提升了，但是内存的访问速度却没有什么大幅度的提升。这就好比一个脑瓜很聪明程序员，接到需求后很快就想好程序怎么写了。但是他的电脑性能很差，每敲一行代码都要反应好久，导致完成编码的时间依旧很长。所以人再聪明没有用，瓶颈在计算机的速度上。CPU 计算也是同样的道理，瓶颈出现在对内存的访问上。没关系，我们可以使用缓存啊，这已经是路人皆知的手段了。CPU 更狠一点，用了 L1、L2、L3，一共三级缓存。其中 L1 缓存根据用途不同，还分为 L1i 和 L1d 两种缓存。如下图：</p><p>​                                    <img src="1.jpg" alt="图片描述"></p><p>​    缓存的访问速度是主存的几分之一，甚至几十分之一。通过缓存，极大的提高了 CPU 计算速度。CPU 会先从主存中复制数据到缓存，CPU 在计算的时候就可以从缓存读取数据了，在计算完成后再把数据从缓存更新回主存。这样在计算期间，就无须访问主存了，速度大大提升。加上缓存后，CPU 的数据访问如下：</p><p><img src="2.jpg" alt="图片描述"></p><p>​    我们再回头看上文的例子。blindThread 线程启动后，就进入 while 循环中，一直进行运算，运算时把 flag 从主存拿到了自己线程中的缓存，此后就会一直从缓存中读取 flag 的值。即便是main线程修改了 flag 的值。但是 blindThread 线程的缓存并未更新，所以取到的还一直是之前的值。导致 blindThread 线程一致也不会有输出。</p><h2 id="Volatile作用"><a href="#Volatile作用" class="headerlink" title="Volatile作用"></a>Volatile作用</h2><p>​    要想解决可见性问题其实很简单。第一种方法就是解决一切并发问题的方法–同步。不过读和写都需要同步。</p><p>​    此外还有一个方法会简单很多，使用 volatile 关键字。</p><p>​    我们把例子中下面这行代码做一下修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Boolean flag = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Boolean flag = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>这样就可以正确输出了。</p><p>Volatile的原理前面的文章已经解释过，就不再重复了，它的作用可以总结如下:</p><ul><li>解决可见性问题</li><li>解决有序性问题</li></ul><p>有关有序性，之前的文章也解释了，这里我们再给出一道面试题来回顾下：</p><p>​    单例模式中，单例对象是否需要加Volatile关键字？</p><p>答案是需要的。因为new 一个对象实际上是细分了3个步骤：</p><ol><li>申请内存</li><li>初始化内存</li><li>赋值变量</li></ol><p>而一旦发生乱序，并发来的线程就可能拿到一个未被初始化过的单例对象，会发生错误。尽管这种可能性比较低，但问题确实存在的。这也称为“对象逃逸”问题。</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序性与内存屏障</title>
      <link href="/2022/09/24/JVM-2022-09-24-%E6%9C%89%E5%BA%8F%E6%80%A7%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
      <url>/2022/09/24/JVM-2022-09-24-%E6%9C%89%E5%BA%8F%E6%80%A7%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="并发三大特性"><a href="#并发三大特性" class="headerlink" title="并发三大特性"></a>并发三大特性</h2><p>所有讲并发编程的书籍都会讲到并发编程的三大特性，这是并发编程中所有问题的根源，我们只有深刻理解了这三大特性，才不会编写出漏洞百出的并发程序，才不会遇到问题时无从下手，才不会对自己的程序没有信心。</p><p>这三大特性是：</p><ol><li>原子性 : 所有操作要么全部成功，要么全部失败。</li><li><p>可见性: 一个线程对变量进行了修改，另外一个线程能够立刻读取到此变量的最新值。</p></li><li><p>有序性: 代码在执行阶段，并不一定和你的编写顺序一致。</p></li></ol><p>​    其中原子性比较简单，熟悉事务ACID的都清楚，事务最重要的就是原子性，可见性暂时跳过，我们日后在谈，这次我们重点来分析有序性问题，这个是相对较难的地方。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>学习过计算机组成原理的同学都知道，cpu为了提高效率，指令的执行并不是一条指令执行完成之后再执行下一条，而是采用流水线的方式执行的。第一条执行在读取内存的过程中，这个等待的时间就可以进行第二条执行了，也就是说发生了乱序或者叫做指令的重排。这种优化，对于单线程是没问题的，因为优化的前提一定是不能影响结果的正确输出，但对于多线程而言就不太友好了。</p><p><img src="1.jpg" alt=""></p><p>往上有一个美团工程师给出的一个实验，可以观察出乱序问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Disorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; Long.MAX_VALUE; i++) &#123;</span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">            b = <span class="number">0</span>;</span><br><span class="line">            CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">            Thread one = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    a = <span class="number">1</span>;</span><br><span class="line">                    x = b;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread other = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    b = <span class="number">1</span>;</span><br><span class="line">                    y = a;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            one.start();</span><br><span class="line">            other.start();</span><br><span class="line">            latch.await();</span><br><span class="line">            String result = <span class="string">"第"</span> + i + <span class="string">"次 ("</span> + x + <span class="string">","</span> + y + <span class="string">"）"</span>;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                System.err.println(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实验中，我们可以分析一下，理论上是不会出现x=0,y=0的情况，但只要多次运行，确实会发现有这个情况。也就证明了乱序。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>我们前面观察到了乱序的问题，这种乱序在多线程的时候可能会出问题的，那么如何解决呢？首先我们要知道volatile是可以解决有序性的问题，其实它的原理也是内存屏障。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>我们要解决乱序问题，说白了就是 我们想办法让你先后执行的两条执行就应该串行执行。而不应该打破原来的顺序。最简单的方法就是加锁。第一条指令执行的时候，直接锁定相关的区域，第二条指令想要执行只能等。但cpu为了提高执行顺序，通常会采用内存屏障。</p><p><font color=red>内存屏障</font>就是说，加这么一道指令，屏障前的指令不能跑到屏障后，屏障后的指令也不能在屏障前执行。</p><h3 id="cpu保障有序性"><a href="#cpu保障有序性" class="headerlink" title="cpu保障有序性"></a>cpu保障有序性</h3><p>不同的cpu有不同的实现，这里我们还是以intel的x86为例</p><h4 id="X86-CPU内存屏障"><a href="#X86-CPU内存屏障" class="headerlink" title="X86 CPU内存屏障:"></a>X86 CPU内存屏障:</h4><p>sfence:在sfence指令前的写操作当必须在sfence指令后的写操作前完成。</p><p>lfence：在lfence指令前的读操作当必须在lfence指令后的读操作前完成。 </p><p>mfence：在mfence指令前的读写操作当必须在mfence指令后的读写操 作前完成。</p><h4 id="intel-lock汇编指令"><a href="#intel-lock汇编指令" class="headerlink" title="intel lock汇编指令"></a>intel lock汇编指令</h4><p>​    原子指令，如x86上的”lock …” 指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺 序，甚至跨多个CPU。Software Locks通常使用 了内存屏障或原子指令来实现变量可见性和保持 程序顺序</p><h3 id="JVM内存屏障"><a href="#JVM内存屏障" class="headerlink" title="JVM内存屏障"></a>JVM内存屏障</h3><p>在JVM层面,我们看到的也仅仅是JVM规范中提的，不同的JVM有不同的实现。</p><p>JSR内存屏障:</p><ul><li><p>LoadLoad屏障： 对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p></li><li><p>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p></li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</li></ul><h3 id="Volatile的实现"><a href="#Volatile的实现" class="headerlink" title="Volatile的实现"></a>Volatile的实现</h3><h4 id="编译器层面"><a href="#编译器层面" class="headerlink" title="编译器层面"></a>编译器层面</h4><p><img src="2.jpg" alt="image-20220925000504998"></p><p>可以看到volatile关键字编译完之后，在字节码的体现是在修饰符上。</p><h4 id="JVM层面"><a href="#JVM层面" class="headerlink" title="JVM层面"></a>JVM层面</h4><p>在JVM层面是通过内存屏障:</p><p>写操作:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StoreStoreBarrier</span><br><span class="line">volatile 写操作</span><br><span class="line">StoreLoadBarrier</span><br></pre></td></tr></table></figure><p>读操作:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadLoadBarrier</span><br><span class="line">volatile 读操作</span><br><span class="line">LoadStoreBarrier</span><br></pre></td></tr></table></figure><h4 id="操作系统硬件层面"><a href="#操作系统硬件层面" class="headerlink" title="操作系统硬件层面"></a>操作系统硬件层面</h4><p>想要观察在硬件层面是如何做的，就需要查看字节码对应的汇编指令，看看是使用什么cpu指令来保证有序的。操作过程比较复杂，可以参考博客：<a href="https://www.cnblogs.com/xrq730/p/7048693.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/7048693.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000002931351</span>: lock add dword ptr [rsp],<span class="number">0</span>h  ;*putstatic instance</span><br><span class="line">                                               ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">13</span> (line <span class="number">14</span>)</span><br></pre></td></tr></table></figure><p>最终结论是: 依靠Lock 指令。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    对于有序性的解决，对cpu而言，可能会使用cpu的内存屏障或者lock指令，在JVM层面，也有相应的内存屏障。不同的的cpu有不同的实现，不同的JVM由于不同的实现，所以比较复杂 不能一概而论。但是 我们一定要注意一点，就是区分层次来看。</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMM与缓存一致性</title>
      <link href="/2022/09/24/JVM-2022-09-24-JMM%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2022/09/24/JVM-2022-09-24-JMM%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    随着CPU的不断发展，CPU的性能越来越强大，但受迫于频率提升的困难，现代CPU架构开始向多核发展。而作为软件开发人员为了充分使用CPU的性能，越来越多的开发者会选择多线程程序开发。CPU在计算时会做一些优化，这些优化对于单线程程序来说是没有问题的，但对多线程程序则不是那么的友好。接下来我们就从硬件底层来看一下硬件对多线程并发的影响。</p><h2 id="硬件层的并发优化"><a href="#硬件层的并发优化" class="headerlink" title="硬件层的并发优化"></a>硬件层的并发优化</h2><p>首先，我们来看一下硬件上的优化。</p><p><img src="1.jpg" alt="image-20220924223108249"></p><p>   首先要清楚，cpu的计算速度要远快于内存的工作速度，这也是各种引入各种缓存的原因，要尽可能节约cpu的宝贵时间。</p><p>​    <img src="2.jpg" alt="image-20220924223301679"></p><h2 id="Cache-Line"><a href="#Cache-Line" class="headerlink" title="Cache Line"></a>Cache Line</h2><p>​    此外，我们要清楚,缓存是以缓存行为单位出现的，也就是说每次缓存是缓存一个line，目前是64字节。那么，也就是说，两个变量可能会位于一个cache line，如下图:</p><p>​    <img src="3.jpg" alt="image-20220924223703696"></p><h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><p>​    缓存与一致性是分不开的。比如在上图中,cpu1 使用X变量，cpu2 使用Y变量，而cpu1修改了x变量，那么尽管cpu2关心的是变量Y，但由于缓存了与cpu1同样的cache line，为了避免产生不一致（X变量不一致)，就只能使得cpu2的缓存行失效，这时当cpu2读y变量时候发现缓存失效，不得已只能重新加载y变量。产生效率问题，这就是伪共享问题。</p><p>​    伪共享问题，是由于变量所在cache line 被其它变量影响导致失效造成的，那么就可以通过填充，让我们所使用的这个变量独自占用一个cache line来解决。</p><p>​    下图为Distuptor在解决伪共享问题时，对指针的填充.</p><p><img src="4.jpg" alt="image-20220924224539355"></p><h3 id="写合并"><a href="#写合并" class="headerlink" title="写合并"></a>写合并</h3><p>写合并也是为了提高效率的一种技术。比如当cpu 计算完一个值，需要写入缓存中，首先看L1，发现L1没有命中，就继续往L2写，但是L2可能写的比较慢，写这一次L2，可能这个值被修改好多次了，所以在L1和cpu之间加了一个缓存，就是为了把这几次的修改结果进行合并。</p><p><img src="5.jpg" alt="image-20220924225056785"></p><h2 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h2><p>使用缓存必然会带来一致性的问题，cache line 一致性的解决 大概有两种解决方案:总线锁、缓存锁</p><h3 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h3><p>总线锁比较简单，就是说，我在L2和L3之间加个锁，我cpu1使用的时候，我对cache line加锁，其它cpu不可以访问，这叫总线锁。但是尽管我使用x变量，其它cpu使用y变量依然无法访问缓存。所以这种效率比较低，是老cpu使用的。</p><p><img src="6.jpg" alt="image-20220924225645716"></p><h3 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h3><p>现代的cpu 会使用各种一致性协议来解决这个问题，有MSI、MESI、MOSI等，其中由于Intel 使用MESI，所以我们重点关注一下MESI协议。</p><p><img src="7.jpg" alt="image-20220924230053395"></p><p>MESI协议中的几种状态:</p><p><img src="8.jpg" alt="image-20220924230455970"></p><p>更多的有关MESI协议的内容，可以参考一下这篇文章:<a href="http://t.zoukankan.com/cherish010-p-8602635.html" target="_blank" rel="noopener">http://t.zoukankan.com/cherish010-p-8602635.html</a></p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class加载过程</title>
      <link href="/2022/09/24/JVM-2022-09-24-Class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/09/24/JVM-2022-09-24-Class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="3.jpg" alt="image-20220924220503969">    </p><p>在java中当我们使用某个类的时候，首先做的就是把.class文件从硬盘中加载到内存中，这一步称为加载的过程，但实际上，要做的工作不止这一些，接下来我们看一下，在一个类被使用前要做哪些准备工作呢。</p><h2 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>全盘负责：当一个类加载器加载一个类时，该类所依赖的其他类也会被这个类加载器加载到内存中。</li><li><p>缓存机制：所有的Class对象都会被缓存，当程序需要使用某个Class时，类加载器先从缓存中查找，找不到，才从class文件中读取数据，转化成Class对象，存入缓存中。</p></li><li><p>双亲委派机制</p></li></ol><h4 id="类加载器层级"><a href="#类加载器层级" class="headerlink" title="类加载器层级"></a>类加载器层级</h4><p><img src="1.jpg" alt="image-20220924213851042"></p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>​    Java虚拟机对class文件采用的是按需加载的方式,也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时, Java虚拟机采用的是双亲委派模式,即把请求交由父类处理,它是一种任务委派模式。如下图所示:</p><p><img src="2.jpg" alt="img"></p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><ol><li>继承ClassLoader</li><li>重写findClass方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"/Users/james/Desktop/Hello.class"</span>);</span><br><span class="line"></span><br><span class="line">            FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">            ByteArrayOutputStream out = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!((size = in.read(buffer)) != -<span class="number">1</span>))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    out.write(buffer, <span class="number">0</span>, size);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes = out.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader l = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        System.out.println(l.getParent());</span><br><span class="line"></span><br><span class="line">        Class clazz = l.loadClass(<span class="string">"com.zxd.jvm.Hello"</span>);</span><br><span class="line">        Class clazz1 = l.loadClass(<span class="string">"com.zxd.jvm.Hello"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz == clazz1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h3><p>尽管我们自定义了classloader，但实际我们只是重写了findclass方法，在我们使用的时候，调用的还是父类的loadclass方法，也就是说 loadclass方法中规定了加载类的步骤和流程，而 我们只是实现这个流程中要用的某一个方法，这叫模版方法设计模式。自然我们也就明白来，重写findClass方法并不会打破双亲委派。而重写classLoad方法，也就是重写设定这个加载类的流程才会打破这个机制。摘录核心源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当然一般情况下我们并不需要重写loadClass方法，那什么时候需要呢？</p><ol><li>在JDK1.2之前,在自定义类加载器时,总会去继承ClassLoader类并重写loadClass ()方法,从而实现自定义的类加载类,但是在JDK1.2之后已不再建议用户去覆盖loadClass ()方法,而是建议把自定义的类加载逻辑写在findClass ()方法中</li><li>像一些热加载的功能，代码改了之后，能自动重新load class文件，实际上，一旦load之后 加入缓存，就不会再加载了，那我们就必须打破这个过程。</li></ol><h2 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h2><p>链接又分为3个过程:</p><ol><li>Verification<ol><li>验证文件是否符合JVM规定</li></ol></li><li>Preparation<ol><li>静态成员变量赋默认值</li></ol></li><li>Resolution<ol><li>将类、方法、属性等符号引用解析为直接引用<br>常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用</li></ol></li></ol><h2 id="Initializing"><a href="#Initializing" class="headerlink" title="Initializing"></a>Initializing</h2><p>​    调用类初始化代码，给静态成员变量赋初始值</p><blockquote><p>引用:<a href="https://blog.csdn.net/m0_37450089/article/details/119962669" target="_blank" rel="noopener">https://blog.csdn.net/m0_37450089/article/details/119962669</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC包下的新型锁</title>
      <link href="/2022/09/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2022-09-23-JUC%E5%8C%85%E4%B8%8B%E7%9A%84%E6%96%B0%E5%9E%8B%E9%94%81/"/>
      <url>/2022/09/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2022-09-23-JUC%E5%8C%85%E4%B8%8B%E7%9A%84%E6%96%B0%E5%9E%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    可重入锁，就是拿到锁之后，还可以对此锁再拿一次，一层一层的加，synchronized本身就是可重入锁的一种</p><h3 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h3><ul><li>可以代替synchronied关键字，只需要在使用synchronized关键字的地方使用lock.lock()方法</li><li>synchronized关键字是自动解锁的，但是reen必须手动解锁</li><li>特别注意对于异常的处理，sync遇到异常jvm就手动释放了，reen一定要在finally里手动解开</li></ul><h3 id="与Synchronized相比的优势"><a href="#与Synchronized相比的优势" class="headerlink" title="与Synchronized相比的优势"></a>与Synchronized相比的优势</h3><ul><li>ryLock方法尝试拿锁，不管拿不拿到都能执行下去，而sync一旦拿不到就阻塞了</li><li>lockInterruptibly()可以对interrupt()方法做出响应,sync不受影响</li><li>true公平锁，可以指定不公平或者公平；sync只有不公平</li></ul><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>就是一个类似门栓的东西，定义一个初始值，每次减1，减到0，就可以放行，说白了，就是用来等待线程结束用的，可以用join方法，但它更灵活，它可以在一个线程里面铛铛铛的就减掉，可以用来做其它功能。</p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><ul><li>countDown()</li><li>await()</li></ul><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>​    类似CountDownLatch，定义三个线程，谁先干完，谁等着，满够三个(三个都调用await等着了)，再放行，不断循环这个过程</p><h3 id="核心方法-1"><a href="#核心方法-1" class="headerlink" title="核心方法"></a>核心方法</h3><p>​    await()</p><h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>​    就是CyclicBarrier的升级版，CyclicBrrier是一个栅栏循环执行，而phaser是一个一个的栅栏往前走</p><h3 id="核心方法-2"><a href="#核心方法-2" class="headerlink" title="核心方法"></a>核心方法</h3><ul><li>arriveAndAwaitAdvance()</li><li>arriveAndDeregister()</li><li>register()</li></ul><h3 id="举例：遗传算法"><a href="#举例：遗传算法" class="headerlink" title="举例：遗传算法"></a>举例：遗传算法</h3><ul><li>遗传算法有明显的阶段性</li></ul><h2 id="readwritelock（读写锁）"><a href="#readwritelock（读写锁）" class="headerlink" title="readwritelock（读写锁）"></a>readwritelock（读写锁）</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>​    共享锁+排它锁，读是共享的，写时排它，可以提高效率，毕竟读要占多数</p><h2 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>​    信号量机制，pv操作，操作系统常用的,初始值代表可用资源个数</p><h3 id="核心方法-3"><a href="#核心方法-3" class="headerlink" title="核心方法"></a>核心方法</h3><ul><li>acquire()</li><li>release()</li></ul><h2 id="exchanger"><a href="#exchanger" class="headerlink" title="exchanger"></a>exchanger</h2><p>​    两两交换：线程间通信的一种方式</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>我们简单总结了下，juc包下的一些锁，但实际上这些锁用的比较少，要求不高的话一般还是直接用synchronized关键词就可以了。主要是了解这些锁的作用，真有需要可以再看一下API。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atomic类与CAS分析</title>
      <link href="/2022/09/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2022-09-23-Atomic%E7%B1%BB%E4%B8%8ECAS%E5%88%86%E6%9E%90/"/>
      <url>/2022/09/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2022-09-23-Atomic%E7%B1%BB%E4%B8%8ECAS%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Atomic-简介"><a href="#Atomic-简介" class="headerlink" title="Atomic 简介"></a>Atomic 简介</h2><p>Atomic 相关类在 java.util.concurrent.atomic 包中。针对不同的原生类型及引用类型，有 AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference 等。另外还有数组对应类型 AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray。由于 Atomic 提供的功能类似，就不一个个过了。我们以 AtomicInteger 为例，看看 Atomic 类型变量所能提供的功能。</p><p>我们先看一个简单的例子，运算逻辑是对变量 count 的累加。假如 count 为 int 类型，多个线程并发时，可能各自读取到了同样的值，也可能 A 线程读到 2，但由于某种原因更新晚了，count 已经被其它线程更新为了 4，但是线程 A 还是继续执行了 count+1 的操作，count 反而被更新为更小的值 3。现在的多线程程序是不安全的。要处理此问题，按照我们已经学习过的知识，需要把 count=count+1 放入 synchronized 代码块中。这样做肯定能够解决问题。但是这种同步操作是悲观锁的方式，每次都认为有其它线程在和它并发操作，所以每次都要对资源进行锁定，而加锁这个操作自身就有很大消耗。而且不是每一次 count+1 时都有并发发生，无并发发生时的加锁并无必要。直接用 synchronized 进行同步，效率并不高。</p><p>下面我们看看怎么用 AtomicInteger 解决这个问题。使用 AtomicInteger 很简单，我们在声明 count 的时候，将其声明为 AtomicInteger 即可，然后把 count=count+1 的语句改为 count.incrementAndGet ()。问题就完美解决了。</p><p>接下来我们看看 Atomic 实现原子操作的原理。我们首先看看 AtomicInteger 的 incrementAndGet 方法注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>可以看到此方法以原子操作在当前 value 上加 1。count=count+1 这行语句其实隐含了两步操作，第一步取得 count 的值，第二步为 count 加 1 。而在这两步操作中间，count 的值可能已经改变了。而 AtomicInteger 提供的 incrementAndGet () 方法，则把这两步操作作为一个原子性操作来完成，则不会出现线程安全问题。</p><p>Atomic 变量的操作是如何保证原子性的呢？其实是使用了 CAS 算法。</p><h2 id="CAS-算法分析"><a href="#CAS-算法分析" class="headerlink" title="CAS 算法分析"></a>CAS 算法分析</h2><p>CAS 是 Compare and swap 的缩写，翻译过来就是比较替换。其实 CAS 是乐观锁的一种实现。而 Synchronized 则是悲观锁。这里的乐观和悲观指的是当前线程对是否有并发的判断。</p><p><font color = red>悲观锁–认为每一次自己的操作大概率会有其它线程在并发，所以自己在操作前都要对资源进行锁定，这种锁定是排他的。悲观锁的缺点是不但把多线程并行转化为了串行，而且加锁和释放锁都会有额外的开支</font>。</p><p><font color=red>乐观锁–认为每一次操作时大概率不会有其它线程并发，所以操作时并不加锁，而是在对数据操作时比较数据的版本，和自己更新前取得的版本一致才进行更新。乐观锁省掉了加锁、释放锁的资源消耗，而且在并发量并不是很大的时候，很少会发生版本不一致的情况，此时乐观锁效率会更高</font>。</p><p>Atomic 变量在做原子性操作时，会从内存中取得要被更新的变量值，并且和你期望的值进行比较，期望的值则是你要更新操作的值。如果两个值相等，那么说明没有其它线程对其更新，本线程可以继续执行。如果不等，说明有线程已经先于此线程进行了更新操作。那么则继续取得该变量的最新值，重复之前的逻辑，直至操作成功。这保证了每个线程对 Atomic 变量操作是线程安全的。</p><h2 id="Atomic-源代码分析"><a href="#Atomic-源代码分析" class="headerlink" title="Atomic 源代码分析"></a>Atomic 源代码分析</h2><p>下面我们看看 AtomicInteger 的源代码。首先，AtomicInteger 中有 3 个重要的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>第一个 Unsafe 对象，Atomic 中的原子操作都是借助 unsafe 对象所实现的；</p><p>第二个是 AtomicInteger 包装的变量在内存中的地址；</p><p>第三个是 AtomicInteger 包装的变量值，并且用 volatile 修饰，以确保变量的变化能被其它线程看到。</p><p>其实 valueOffset 就是 value 的内存地址</p><p>AtomicInteger 中有一段静态代码块如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中 unsafe 对象获取了 AtomicInteger 类中 value 这个字段的 offset。unsafe.objectFieldOffset () 是一个 native 的方法。</p><p>AtomicInteger 有一个构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到对它所包装的 int 变量 value 进行了赋值。</p><p>通过以上分析，我们来总结一下目前对 AtomicInteger 的了解：</p><ul><li>AtomicInteger 对象包装了通过构造函数传入的一个初始 int 值；</li><li>AtomicInteger 持有这个 int 变量的内存地址；</li><li>AtomicInteger 还有一个用来做原子性操作的 unsafe 对象。</li></ul><p>接下来我们以文章前面提到的 incrementAndGet 方法为例，来看看 Atomic 原子性的实现。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，调用了 <em>unsafe</em>.getAndAddInt(this, <em>valueOffset</em>, 1) 后，对其返回 +1，然后 return。</p><p>那么原子性实现的秘密就全在 <em>unsafe</em>.getAndAddInt () 这个方法中了。随便翻看一下 AtomicInteger 的源代码，这个方法被各种调用，其实我们搞清楚 <em>unsafe</em>.getAndAddInt () 的实现，谜底也就揭晓了。我们继续看 <em>unsafe</em>.getAndAddInt () 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object obj, <span class="keyword">long</span> valueOffset, <span class="keyword">int</span> <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect;</span><br><span class="line">        <span class="comment">// 利用循环，直到更新成功才跳出循环。</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 获取value的最新值</span></span><br><span class="line">            expect = <span class="keyword">this</span>.getIntVolatile(obj, valueOffset);</span><br><span class="line">            <span class="comment">// expect + var表示需要更新的值，如果compareAndSwapInt返回false，说明value值被其他线程更改了。</span></span><br><span class="line">            <span class="comment">// 那么就循环重试，再次获取value最新值expect，然后再计算需要更新的值expect + var。直到更新成功</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(obj, valueOffset, expect, expect + <span class="keyword">var</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回当前线程在更改value成功后的，value变量原先值。并不是更改后的值</span></span><br><span class="line">        <span class="keyword">return</span> expect;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为了帮助理解，我加了一些注释。三个入参，第一个 obj 传入的是 AtomicInteger 对象自己，第二个是 value 变量的内存地址，第三个则是要增加的值。</p><p>程序体中是一个循环，循环中通过 AtomicInteger 对象和 value 属性的 offset，取得到当前的 value 值，接下来调用 this.compareAndSwapInt (obj, valueOffset, expect, expect + var)。这个方法名仔细看下，是不是很熟悉？是的，就是 CAS。调用前我们已经获取到了期望值，所以在这个方法中会把期望值和你要替换掉的值做比较，如果一直则替换，否则重复 while 循环，也就是再此获取最新的期望值，然后再比较替换，直至替换成功。</p><p>你现在一定很好奇 compareAndSwapInt 的方法是如何实现的。我们点开此方法后，可以看到是一个 native 方法，native 方法使用 C 语言编写。由于 JDK 并未开源，我们只能下载开源版本的 OpenJDK。</p><p>可以看到在 compareAndSwapInt 源代码的最后，调用了 Atomic::cmpxchg (x,addr,e)。这个方法在不同的平台会有不同的实现。不过总的思想如下：</p><ol><li>判断当前系统是否为多核处理器；</li><li>执行 CPU 指令 cmpxchg，如果为多核则在 cmpxchg 加 lock 前缀。</li></ol><p>可以看到最终是通过 CPU 指令 cmpxchg 来实现比较交换。那么 Lock 前缀起到什么作用呢？加了 Lock 前缀的操作，在执行期间，所使用的缓存会被锁定，其他处理器无法读写该指令要访问的内存区域，由此保证了比较替换的原子性。而这个操作过程称之为缓存锁定。</p><h2 id="CAS-的缺点"><a href="#CAS-的缺点" class="headerlink" title="CAS 的缺点"></a>CAS 的缺点</h2><p>CAS 最终通过 CPU 指令实现，把无谓的同步消耗降到最低，但是没有银弹，CAS 也有着几个致命的缺点：</p><ol><li>比较替换如果失败，则会一直循环，直至成功。这在并发量很大的情况下对 CPU 的消耗将会非常大；</li><li>只能保证一个变量自身操作的原子性，但多个变量操作要实现原子性，是无法实现的；</li><li>ABA 问题。</li></ol><p>前两个问题比较简单，我们重点看一下第三个 ABA 问题。</p><p>假如本线程更新前取得期望值为 A，和更新操作之间的这段时间内，其它线程可能把 value 改为了 B 又改回了 A。 而本线程更新时发现 value 和期望值一样还是 A，认为其没有变化，则执行了更新操作。但其实此时的 A 已经不是彼时的 A 了。</p><p>大多数情况下 ABA 不会造成业务上的问题。但是如果你认为 ABA 问题对你的程序业务有问题，那么就需要解决。 JDK 提供了 AtomicStampedReference 类，通过对 Atomic 包装的变量增加版本号，来解决 ABA 问题，即使 value 还是 A，但如果版本变化了，也认为比较失败。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>了解Atomic的原理，底层是CAS操作</li><li>CAS是一种乐观锁，也是自旋锁，要和synchronized区分开来，使用上也有所区分<ul><li>CAS：锁定区域，代码执行时间短，并发少</li><li>synchronized ：锁定区域代码执行时间长，并发大</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础</title>
      <link href="/2022/09/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2022-09-23-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B-2022-09-23-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>线程的状态，是重点中的重点，在生产中遇到问题的时候，就需要观察线程状态来排查问题，比如用jstack查看堆栈信息时候，就需要重点关注block状态的线程。</p><h3 id="状态流转"><a href="#状态流转" class="headerlink" title="状态流转"></a>状态流转</h3><p><img src="1.jpg" alt="image-20220923140527513"></p><h3 id="状态的解释"><a href="#状态的解释" class="headerlink" title="状态的解释"></a>状态的解释</h3><ul><li>new: 线程刚刚创建，还没有启动</li><li>Runnable：可运行状态，可由线程调度器安排执行，具体分为：Ready等待调度，Running 正在执行</li><li>Waiting：等待被唤醒</li><li>Timed Waiting：隔一段时间，自动唤醒</li><li>Blocked：正在等锁</li><li>Terminated：线程结束</li></ul><h3 id="lock和synchronized的区别"><a href="#lock和synchronized的区别" class="headerlink" title="lock和synchronized的区别"></a>lock和synchronized的区别</h3><p>​    lock是用的juc的锁，基于cas实现，cas都是忙等，不是阻塞而是waiting，而synchronized是等锁，blocked，但两者都是阻塞态。</p><h2 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h2><p>介绍几种常见的线程启动的方式</p><ul><li><p>hread和Runnable 两种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MyThread().start();</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRun()).start();</span><br></pre></td></tr></table></figure></li><li><p>ThreadPool</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">service.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello ThreadPool"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>ThreadPool和Callable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">Future&lt;String&gt; f = service.submit(<span class="keyword">new</span> MyCall());</span><br><span class="line">String s = f.get();</span><br></pre></td></tr></table></figure></li><li><p>Thread和FutureTask</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCall());</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(task);</span><br><span class="line">t.start();</span><br><span class="line">System.out.println(task.get());</span><br></pre></td></tr></table></figure></li></ul><h2 id="线程打断"><a href="#线程打断" class="headerlink" title="线程打断"></a>线程打断</h2><h3 id="有关线程打断的三个方法"><a href="#有关线程打断的三个方法" class="headerlink" title="有关线程打断的三个方法"></a>有关线程打断的三个方法</h3><ul><li>interrupt方法:名为打断，但是一定注意，其本质是设置线程内部的中断标记位，发现标记修改后做什么样的反应，是线程自己实现</li><li>isInterrupt方法:查询标记位</li><li>interrupted方法:查询当前标记位是否被打断过，如果打断过，重置标记位</li></ul><h2 id="线程结束"><a href="#线程结束" class="headerlink" title="线程结束"></a>线程结束</h2><h3 id="优雅结束线程的几种方式"><a href="#优雅结束线程的几种方式" class="headerlink" title="优雅结束线程的几种方式"></a>优雅结束线程的几种方式</h3><h4 id="利用volatile变量设置标志位通知线程结束"><a href="#利用volatile变量设置标志位通知线程结束" class="headerlink" title="利用volatile变量设置标志位通知线程结束"></a>利用volatile变量设置标志位通知线程结束</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">long</span> i = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">//wait recv accept</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"end and i = "</span> + i); <span class="comment">//4168806262 4163032200</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    SleepHelper.sleepSeconds(<span class="number">1</span>);</span><br><span class="line">    running = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用interupt内部标记"><a href="#利用interupt内部标记" class="headerlink" title="利用interupt内部标记"></a>利用interupt内部标记</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//sleep wait</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"t1 end!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    SleepHelper.sleepSeconds(<span class="number">1</span>);</span><br><span class="line">    t.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用park方法配合interupt"><a href="#利用park方法配合interupt" class="headerlink" title="利用park方法配合interupt"></a>利用park方法配合interupt</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    SleepHelper.sleepSeconds(<span class="number">1</span>);</span><br><span class="line">    t.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCache 使用总结</title>
      <link href="/2022/09/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-09-22-SpringCache-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/09/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-09-22-SpringCache-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>Spring 从 3.1 开始定义了 org.springframework.cache.Cache 和 org.springframework.cache.CacheManager 接口来统一不同的缓存技术； 并支持使用 JCache（JSR-107）注解简化我们开发；</p></li><li><p>Cache 接口为缓存的组件规范定义，包含缓存的各种操作集合； Cache 接 口 下 Spring 提 供 了 各 种 xxxCache 的 实 现 ； 如 RedisCache ， EhCacheCache , ConcurrentMapCache 等；</p></li><li>每次调用需要缓存功能的方法时，Spring 会检查检查指定参数的指定的目标方法是否已 经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓 存结果后返回给用户。下次调用直接从缓存中获取。</li><li>使用 Spring 缓存抽象时我们需要关注以下两点； <ul><li>确定方法需要被缓存以及他们的缓存策略 </li><li>从缓存中读取之前缓存存储的数据</li></ul></li></ul><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><img src="1.jpg" alt="image-20220923101141154"></p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><img src="2.jpg" alt="image-20220923101355445"></p><h3 id="表达式语法"><a href="#表达式语法" class="headerlink" title="表达式语法"></a>表达式语法</h3><p><img src="4.jpg" alt="WeChatd3233d7e110a63f5fa8dfb06822727cd"></p><h3 id="缓存穿透问题解决"><a href="#缓存穿透问题解决" class="headerlink" title="缓存穿透问题解决"></a>缓存穿透问题解决</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>允许 null 值缓存</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Spring Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存使用总结</title>
      <link href="/2022/09/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-09-22-%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/09/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-09-22-%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h3><p>为了系统性能的提升，我们一般都会将部分数据放入缓存中，加速访问。而 db 承担数据落 盘工作。 哪些数据适合放入缓存？ </p><ul><li><p>即时性、数据一致性要求不高的 </p></li><li><p>访问量大且更新频率不高的数据（读多，写少）</p><p> 举例：电商类应用，商品分类，商品列表等适合缓存并加一个失效时间(根据数据更新频率 来定)，后台如果发布一个商品，买家需要 5 分钟才能看到新的商品一般还是可以接受的。</p><p><img src="1.jpg" alt="image-20220922162501682"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = cache.load(id);<span class="comment">//从缓存加载数据</span></span><br><span class="line">If(data == <span class="keyword">null</span>)&#123;</span><br><span class="line">data = db.load(id);<span class="comment">//从数据库加载数据</span></span><br><span class="line">cache.put(id,data);<span class="comment">//保存到 cache 中 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data;</span><br></pre></td></tr></table></figure><p>注意：在开发中，凡是放入缓存中的数据我们都应该指定过期时间，使其可以在系统即使没 有主动更新数据也能自动触发数据加载进缓存的流程。避免业务崩溃导致的数据永久不一致 问题。</p><h3 id="整合-redis-作为缓存"><a href="#整合-redis-作为缓存" class="headerlink" title="整合 redis 作为缓存"></a>整合 redis 作为缓存</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、引入 redis-starter</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="number">2</span>、配置 redis</span><br><span class="line">spring:</span><br><span class="line">redis:</span><br><span class="line">host: <span class="number">192.168</span><span class="number">.56</span><span class="number">.10</span></span><br><span class="line">port: <span class="number">6379</span></span><br><span class="line"><span class="number">3</span>、使用 RedisTemplate 操作 redis</span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line">StringRedisTemplate stringRedisTemplate; </span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringRedisTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); </span><br><span class="line">  ops.set(<span class="string">"hello"</span>,<span class="string">"world_"</span>+ UUID.randomUUID().toString()); </span><br><span class="line">  String hello = ops.get(<span class="string">"hello"</span>); System.out.println(hello);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span>、切换使用 jedis</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">  &lt;exclusions&gt;</span><br><span class="line">    &lt;exclusion&gt;</span><br><span class="line">      &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;/exclusion&gt;</span><br><span class="line">  &lt;/exclusions&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="缓存失效问题"><a href="#缓存失效问题" class="headerlink" title="缓存失效问题"></a>缓存失效问题</h2><p>先来解决大并发读情况下的缓存失效问题；</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><ul><li>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，但是数 据库也无此记录，我们没有将这次查询的 null 写入缓存，这将导致这个不存在的数据每次 请求都要到存储层去查询，失去了缓存的意义。 </li><li>在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是 漏洞。</li><li>解决： 缓存空结果、并且设置短的过期时间。</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ul><li>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失 效，请求全部转发到 DB，DB 瞬时压力过重雪崩。</li><li>解决： 原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的 重复率就会降低，就很难引发集体失效的事件。</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><ul><li>对于一些设置了过期时间的 key， 如果这些 key 可能会在某些时间点被超高并发地访问， 是一种非常“热点”的数据。 </li><li>这个时候，需要考虑一个问题：如果这个 key 在大量请求同时进来前正好失效，那么所 有对这个 key 的数据查询都落到 db， 我们称为缓存击穿。</li><li>解决：加锁</li></ul><h2 id="缓存数据一致性"><a href="#缓存数据一致性" class="headerlink" title="缓存数据一致性"></a>缓存数据一致性</h2><h3 id="保证一致性模式"><a href="#保证一致性模式" class="headerlink" title="保证一致性模式"></a>保证一致性模式</h3><h4 id="双写模式"><a href="#双写模式" class="headerlink" title="双写模式"></a>双写模式</h4><p><img src="2.jpg" alt="image-20220922171402508"></p><h4 id="失效模式"><a href="#失效模式" class="headerlink" title="失效模式"></a>失效模式</h4><p><img src="3.jpg" alt="image-20220922171555860"></p><h4 id="改进方法-1-分布式读写锁"><a href="#改进方法-1-分布式读写锁" class="headerlink" title="改进方法 1-分布式读写锁"></a>改进方法 1-分布式读写锁</h4><p>分布式读写锁。读数据等待写数据整个操作完成</p><h4 id="改进方法-2-使用-cananl"><a href="#改进方法-2-使用-cananl" class="headerlink" title="改进方法 2-使用 cananl"></a>改进方法 2-使用 cananl</h4><p><img src="4.jpg" alt="image-20220922194108547"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis无主模式集群</title>
      <link href="/2022/09/22/Redis-2022-09-22-Redis%E6%97%A0%E4%B8%BB%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4/"/>
      <url>/2022/09/22/Redis-2022-09-22-Redis%E6%97%A0%E4%B8%BB%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>前面的文章我们讲了Redis的主从复制模式，它是来解决单点故障问题，从节点是主节点的备份，只读。这样一来就难解决容量问题，从AKF的原则讲，我们可以从y轴、Z轴来考虑搭建不同的集群来解决这个问题。接下来我们仔细的探讨下这个问题。</p></blockquote><h2 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h2><p>在AKF Y轴方向，我们可以从业务的角度出发，用户功能一个redis实例，订单功能一个redis实例,在业务端进行实例的区分。</p><p><img src="/Users/james/blogs/blog/source/_posts/Redis/2022-09-22-Redis无主模式集群/1.jpg" alt="WeChatc79ac39fa36a93fd82b0026afc139c36"></p><h2 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h2><p>不同的功能模块，进行拆分这是很容易想到的，也是比较简单的。问题是当这个单个业务数据量巨大，单实例压力大，如何拆分呢？AKF原则Z轴指导我们从数据分片的角度进行拆分。</p><h3 id="为什么分区非常有用"><a href="#为什么分区非常有用" class="headerlink" title="为什么分区非常有用"></a>为什么分区非常有用</h3><p>Redis分区主要有两个目的:</p><ul><li>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。</li><li>分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</li></ul><h3 id="分区基本概念"><a href="#分区基本概念" class="headerlink" title="分区基本概念"></a>分区基本概念</h3><p>有许多分区标准。假如我们有4个Redis实例<strong>R0</strong>, <strong>R1</strong>, <strong>R2</strong>, <strong>R3</strong>,有一批用户数据<code>user:1</code>, <code>user:2</code>, … ,那么有很多存储方案可以选择。从另一方面说，有很多<em>different systems to map</em>方案可以决定用户映射到哪个Redis实例。</p><p>一种最简单的方法就是<strong>范围分区</strong>,就是将不同范围的对象映射到不同Redis实例。比如说，用户ID从0到10000的都被存储到<strong>R0</strong>,用户ID从10001到20000被存储到<strong>R1</strong>,依此类推。</p><p>这是一种可行方案并且很多人已经在使用。但是这种方案也有缺点，你需要建一张表存储数据到redis实例的映射关系。这张表需要非常谨慎地维护并且需要为每一类对象建立映射关系，所以redis范围分区通常并不像你想象的那样运行，比另外一种分区方案效率要低很多。</p><p>另一种可选的范围分区方案是<strong>散列分区</strong>，这种方案要求更低，不需要key必须是<code>object_name:&lt;id&gt;</code>的形式，如此简单：</p><ul><li>使用散列函数 (如 <code>crc32</code> )将键名称转换为一个数字。例：键<code>foobar</code>, 使用<code>crc32(foobar)</code>函数将产生散列值<code>93024922</code>。</li><li>对转换后的散列值进行取模，以产生一个0到3的数字，以便可以使这个key映射到4个Redis实例当中的一个。<code>93024922 % 4</code> 等于 <code>2</code>, 所以 <code>foobar</code> 会被存储到第2个Redis实例。 <strong>R2</strong> <em>注意: 对一个数字进行取模，在大多数编程语言中是使用运算符%</em></li></ul><p>​    还有很多分区方法，上面只是给出了两个简单示例。有一种比较高级的散列分区方法叫<strong>一致性哈希</strong>，并且有一些客户端和代理（proxies)已经实现。</p><p><img src="/Users/james/blogs/blog/source/_posts/Redis/2022-09-22-Redis无主模式集群/2.jpg" alt="image-20220922112656472"></p><h3 id="不同的分区实现方案"><a href="#不同的分区实现方案" class="headerlink" title="不同的分区实现方案"></a>不同的分区实现方案</h3><p>分区可以在程序的不同层次实现。</p><ul><li><strong>客户端分区</strong>就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</li></ul><p><img src="/Users/james/blogs/blog/source/_posts/Redis/2022-09-22-Redis无主模式集群/4.jpg" alt="图片"></p><ul><li><strong>代理分区</strong> 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是<a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">Twemproxy</a></li></ul><p><img src="/Users/james/blogs/blog/source/_posts/Redis/2022-09-22-Redis无主模式集群/5.jpg" alt="图片"></p><ul><li><strong>查询路由(Query routing)</strong> 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接<em>redirected</em>到正确的redis节点。</li></ul><h3 id="分区的缺点"><a href="#分区的缺点" class="headerlink" title="分区的缺点"></a>分区的缺点</h3><p>有些特性在分区的情况下将受到限制:</p><ul><li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li><li>同时操作多个key,则不能使用Redis事务.</li><li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）.</li><li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。</li><li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种<font color=red><em>预分片</em></font>的技术也可以较好的解决这个问题。</li></ul><h2 id="持久化数据还是缓存？"><a href="#持久化数据还是缓存？" class="headerlink" title="持久化数据还是缓存？"></a>持久化数据还是缓存？</h2><p>无论是把Redis当做持久化的数据存储还是当作一个缓存，从分区的角度来看是没有区别的。当把Redis当做一个持久化的存储（服务）时，一个key必须严格地每次被映射到同一个Redis实例。当把Redis当做一个缓存（服务）时，即使Redis的其中一个节点不可用而把请求转给另外一个Redis实例，也不对我们的系统产生什么影响，我们可用任意的规则更改映射，进而提高系统的<em>高可用</em>（即系统的响应能力）。</p><p>一致性哈希能够实现当一个key的首选的节点不可用时切换至其他节点。同样地，如果你增加了一个新节点，立刻就会有新的key被分配至这个新节点。</p><p>重要结论如下:</p><ul><li>如果Redis被当做缓存使用，使用一致性哈希实现<strong>动态扩容缩容</strong>。</li><li>如果Redis被当做一个持久化存储使用，<strong>必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化</strong>。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样 - Redis 集群已经可用 <a href="https://groups.google.com/d/msg/redis-db/dO0bFyD_THQ/Uoo2GjIx6qgJ" target="_blank" rel="noopener">2015.4.1</a>.</li></ul><h2 id="预分片"><a href="#预分片" class="headerlink" title="预分片"></a>预分片</h2><p>从上面获知，除非我们把Redis当做缓存使用，否则（在生产环境动态）增加和删除节点将非常麻烦，但是使用固定的keys-instances则比较简单。</p><p>一般情况下随着时间的推移，数据存储需求总会发生变化。今天可能10个Redis节点就够了，但是明天可能就需要增加到50个节点。</p><p>既然Redis是如此的轻量（单实例只使用1M内存）,为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p><p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p><p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p><p>使用Redis复制技术，你可以做到极短或者不停机地对用户提供服务：</p><ul><li>在你新服务器启动一个空Redis实例。</li><li>把新Redis实例配置为原实例的slave节点</li><li>停止你的客户端</li><li>更新你客户端配置，以便启用新的redis实例（更新IP）。</li><li>在新Redis实例中执行<code>SLAVEOF NO ONE</code>命令</li><li>（更新配置后）重启你的客户端</li><li>停止你原服务器的Redis实例</li></ul><h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><p>这里的redis cluster实际指的是redis 自带的一种模式，不需要引入其它组建。</p><h4 id="Redis集群介绍"><a href="#Redis集群介绍" class="headerlink" title="Redis集群介绍"></a>Redis集群介绍</h4><p>Redis 集群是一个提供在<strong>多个Redis间节点间共享数据</strong>的程序集。</p><p>Redis Cluster是一种<font color=red>服务器Sharding技术(分片和路由都是在服务端实现)</font>，采用多主多从，每一个分区都是由一个Redis主机和多个从机组成，片区和片区之间是相互平行的。Redis Cluster集群采用了P2P的模式，完全去中心化。</p><p><img src="/Users/james/blogs/blog/source/_posts/Redis/2022-09-22-Redis无主模式集群/3.jpg" alt="图片"></p><p>​    </p><p>Redis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.</p><p>Redis 集群通过分区来提供<strong>一定程度的可用性</strong>,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:</p><ul><li>自动分割数据到不同的节点上。</li><li>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</li></ul><h4 id="Redis-集群的数据分片"><a href="#Redis-集群的数据分片" class="headerlink" title="Redis 集群的数据分片"></a>Redis 集群的数据分片</h4><p>Redis 集群没有使用一致性hash, 而是引入了 <strong>哈希槽</strong>的概念.</p><p>Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p><ul><li>节点 A 包含 0 到 5500号哈希槽.</li><li>节点 B 包含5501 到 11000 号哈希槽.</li><li>节点 C 包含11001 到 16384号哈希槽.</li></ul><p>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p><h3 id="Redis代理"><a href="#Redis代理" class="headerlink" title="Redis代理"></a>Redis代理</h3><h4 id="为什么引入代理"><a href="#为什么引入代理" class="headerlink" title="为什么引入代理"></a>为什么引入代理</h4><p>常见的Redis代理</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitMq 实现定时任务</title>
      <link href="/2022/09/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-09-21-rabbitMq-%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2022/09/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-09-21-rabbitMq-%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>利用RabbitMq的死信特点，可以对过期消息进行单独处理，从而实现一个定时处理的任务。</p></blockquote><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p><strong>场景：</strong></p><p>​    比如未付款订单，超过一定时间后，系统自动取消订单并释放占有物品。 </p><p><strong>常用解决方案：</strong>  spring的 schedule 定时任务轮询数据库 </p><p><strong>缺点：</strong>消耗系统内存、增加了数据库的压力、存在较大的时间误差</p><p><strong>解决：</strong>rabbitmq的消息TTL和死信Exchange结合</p><h2 id="RabbitMq实现"><a href="#RabbitMq实现" class="headerlink" title="RabbitMq实现"></a>RabbitMq实现</h2><h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><p>消息的TTL就是<font color= red>消息的存活时间</font>。</p><p>• RabbitMQ可以对<font color = red>队列</font>和<font color =red>消息</font>分别设置TTL。</p><p>• 对队列设置就是队列没有消费者连着的保留时间，<font color= red >也可以对每一个单独的消息做单独的 设置</font>。超过了这个时间，我们认为这个消息就死了，称之为死信。</p><p>• 如果队列设置了，消息也设置了，那么会<font color = red>取小的</font>。所以一个消息如果被路由到不同的队 列中，这个消息死亡的时间有可能不一样（不同的队列设置）。这里单讲单个消息的 TTL，<strong>因为它才是实现延迟任务的关键</strong>。可以通过设置消息的expiration字段或者xmessage-ttl属性来设置时间，两者是一样的效果。</p><h3 id="DLX"><a href="#DLX" class="headerlink" title="DLX"></a>DLX</h3><p>一个消息在满足如下条件下，会进死信路由，记住这里是路由而不是队列， 一个路由可以对应很多队列。（什么是死信）</p><p>• 一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不 会被再次放在队列里，被其他消费者使用。（basic.reject/ basic.nack）requeue=false</p><p>• 上面的消息的TTL到了，消息过期了。</p><p>• 队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上</p><p>• Dead Letter Exchange其实就是一种普通的exchange，和创建其他 exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有 消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。</p><p>• 我们既可以控制消息在一段时间后变成死信，又可以控制变成死信的消息 被路由到某一个指定的交换机，结合二者，其实就可以实现一个延时队列</p><p>• 手动ack&amp;异常消息统一放在一个队列处理建议的两种方式</p><p>• catch异常后，手动发送到指定队列，然后使用channel给rabbitmq确认消息已消费</p><p>• 给Queue绑定死信队列，使用nack（requque为false）确认消息消费失败</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图:"></a>流程图:</h4><p><img src="1.jpg" alt="image-20220921134515621"></p><h4 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计:"></a>详细设计:</h4><p><img src="2.jpg" alt="image-20220921134600852"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Bean Binding，Queue，Exchange</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器中的 Binding，Queue，Exchange 都会自动创建（RabbitMQ没有的情况）</span></span><br><span class="line"><span class="comment"> * RabbitMQ 只要有。<span class="doctag">@Bean</span>声明属性发生变化也不会覆盖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderDelayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * x-dead-letter-exchange: order-event-exchange</span></span><br><span class="line"><span class="comment">     * x-dead-letter-routing-key: order.release.order</span></span><br><span class="line"><span class="comment">     * x-message-ttl: 60000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-exchange"</span>,<span class="string">"order-event-exchange"</span>);</span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-routing-key"</span>,<span class="string">"order.release.order"</span>);</span><br><span class="line">    arguments.put(<span class="string">"x-message-ttl"</span>,<span class="number">60000</span>);</span><br><span class="line">    <span class="comment">//String name, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.delay.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,arguments);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderReleaseOrderQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.release.order.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Exchange <span class="title">orderEventExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//String name, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"order-event-exchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderCreateOrderBingding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//String destination, DestinationType destinationType, String exchange, String routingKey,</span></span><br><span class="line">    <span class="comment">//Map&lt;String, Object&gt; arguments</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.delay.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.create.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderReleaseOrderBingding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.release.order.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.release.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> rabbitmq的消息可以过期的特点,可以比较轻松的实现延迟任务。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redission 信号量</title>
      <link href="/2022/09/21/Redis-2022-09-21-Redission-%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2022/09/21/Redis-2022-09-21-Redission-%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>信号量大家应该够不陌生，比如操作系统中的pv信号量，依据功能还可以分成同步信号量、互斥信号量。由于redis是单进程，天生具有锁的这个特性，而redisson更是对redis做了一层包装，使得api接口更适用。今天我们就看一下redisson基于redis做的信号量。</p></blockquote><h2 id="Redisson信号量"><a href="#Redisson信号量" class="headerlink" title="Redisson信号量"></a>Redisson信号量</h2><p>​    Redisson的分布式信号量（Semaphore）Java对象 RSemaphore 采用了与 java.util.concurrent.Semaphore 相似的接口和用法。同时还提供了<strong>异步（Async）、反射式（Reactive）和RxJava2标准的接口</strong>。</p><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RSemaphore semaphore = redisson.getSemaphore(<span class="string">"semaphore"</span>);</span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.acquireAsync();</span><br><span class="line">semaphore.acquire(<span class="number">23</span>);</span><br><span class="line">semaphore.tryAcquire();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.tryAcquireAsync();</span><br><span class="line">semaphore.tryAcquire(<span class="number">23</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.tryAcquireAsync(<span class="number">23</span>, TimeUnit.SECONDS);</span><br><span class="line">semaphore.release(<span class="number">10</span>);</span><br><span class="line">semaphore.release();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.releaseAsync();</span><br></pre></td></tr></table></figure><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="1、限流"><a href="#1、限流" class="headerlink" title="1、限流"></a>1、限流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信号量可以做分布式限流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/park"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">park</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    RSemaphore park = redisson.getSemaphore(<span class="string">"park"</span>);</span><br><span class="line">    park.acquire();<span class="comment">//获取一个信号量（redis中信号量值-1）,如果redis中信号量为0了，则在这里阻塞住，直到信号量大于0，可以拿到信号量，才会继续执行。</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//boolean b = park.tryAcquire();//这个就是不阻塞，能拿到信号量就为true，拿不到（信号量为0 了）就是false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//业务代码...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span> + b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/go"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">go</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    RSemaphore park = redisson.getSemaphore(<span class="string">"park"</span>);</span><br><span class="line">    park.release();<span class="comment">//释放一个信号量（redis中信号量值+1）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"走了"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、商品秒杀"><a href="#2、商品秒杀" class="headerlink" title="2、商品秒杀"></a>2、商品秒杀</h4><p>1、商品上架设置，设置信号量控制商品可以秒杀的数目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//5、使用库存作为分布式的信号量  限流；</span></span><br><span class="line"> RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + token);</span><br><span class="line"><span class="comment">//商品可以秒杀的数量作为信号量</span></span><br><span class="line">semaphore.trySetPermits(seckillSkuVo.getSeckillCount());</span><br><span class="line"><span class="comment">//TODO 设置过期时间。</span></span><br><span class="line">semaphore.expireAt(sesssion.getEndTime());</span><br></pre></td></tr></table></figure><p>2、秒杀工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//验证这个人是否已经购买过。幂等性; 如果只要秒杀成功，就去占位。  userId_SessionId_skuId</span></span><br><span class="line"><span class="comment">//SETNX</span></span><br><span class="line">  String redisKey = respVo.getId() + <span class="string">"_"</span> + skuId;</span><br><span class="line">  <span class="comment">//自动过期</span></span><br><span class="line">  Boolean aBoolean = redisTemplate.opsForValue().setIfAbsent(redisKey, num.toString(), ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">  <span class="keyword">if</span> (aBoolean) &#123;</span><br><span class="line">   <span class="comment">//占位成功说明从来没有买过</span></span><br><span class="line">      RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + randomCode);</span><br><span class="line">      <span class="comment">//120  20ms</span></span><br><span class="line">      <span class="keyword">boolean</span> b = semaphore.tryAcquire(num);</span><br><span class="line">      <span class="keyword">if</span> (b) &#123;</span><br><span class="line">       <span class="comment">//秒杀成功;</span></span><br><span class="line">       <span class="comment">//快速下单。发送MQ消息  10ms</span></span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis主从复制集群</title>
      <link href="/2022/09/21/Redis-2022-09-21-Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%9B%86%E7%BE%A4/"/>
      <url>/2022/09/21/Redis-2022-09-21-Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>主从复制，主要解决的是单点问题，从节点是主节点的备份，只读不能写，主节点可以读写。实际就是AKF原则中X轴的实现。但主从节点需要数据同步，就牵涉到数据一致性的问题，我们来看一下，集群主从集群需要注意的问题，以及redis是如何做的。</p></blockquote><h2 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h2><p>既然有从节点需要同步主节点数据，就涉及到一致性问题。</p><ul><li>强一致性（线性一致性）：即复制是同步的</li><li>弱一致性：即复制是异步的</li></ul><h3 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h3><p>所谓强一致性，以redis为例，当我们写到主节点时，主线同时去同步数据到从节点，此时主线程阻塞等待，如果一个从节点挂掉导致迟迟不能反回确认，不能同步，则导致主实例不可用，即破坏可用性。</p><p><img src="1.jpg" alt="image-20220921003822797"></p><p>这时候肯定是不行的，就是因为单点故障，我们引入主从集群，而因为保证强一致性导致 节点不可用，这不是又回去了吗？所以，我们是不能追求强一致性的。</p><h3 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h3><p>如果，采用异步的方式，即弱一致性，又容易发生丢失数据的情况。比如，主节点刚写完，还没同步挂掉了，从节点顶上来，那么未同步的数据一定就是丢失了。</p><p><img src="2.jpg" alt="image-20220921004139820"></p><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>如果我们利用上kafka这种可靠的消息组建，并且可以非常快速的返回，同步写入kafka，然后异步的进行同步，哪怕主节点挂掉，从节点上来也可以从kafka中同步消息，不至于丢失数据。</p><p><img src="3.jpg" alt="image-20220921004544714"></p><h3 id="Redis-一致性保证"><a href="#Redis-一致性保证" class="headerlink" title="Redis 一致性保证"></a>Redis 一致性保证</h3><p>下面文字引用redis中文官网</p><blockquote><p>Redis 并不能保证数据的<strong>强一致性</strong>. 这意味这在实际中集群在特定的条件下可能会丢失写操作.</p><p>第一个原因是因为集群是用了异步复制. 写操作过程:</p><ul><li>客户端向主节点B写入一条命令.</li><li>主节点B向客户端回复命令状态.</li><li>主节点将写操作复制给他得从节点 B1, B2 和 B3.</li></ul><p>主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。</p><p>举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .</p><p>Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.</p><p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项：</p></blockquote><h2 id="主节点HA"><a href="#主节点HA" class="headerlink" title="主节点HA"></a>主节点HA</h2><p>​    我们还要思考一个问题，主从集群，如果主挂掉了，那么是不是又不可用了，这就又回到单点故障问题了。</p><p>所以需要对主节点做高可用。</p><h3 id="监控节点个数"><a href="#监控节点个数" class="headerlink" title="监控节点个数"></a>监控节点个数</h3><p>​    我们思考，我们要监控主节点挂掉之后，能快速拉起从节点转为主节点，如果人工来做这件事 ，那可靠性是大有问题，你总不能24h守在机房里吧。所以我们要用专门的监控集群，比如keep alive 之类的技术，那现在问题变成，监控节点需要几个呢？如果是1个，那这一个监控节点是不是也会出现<font color=red>单点问题</font>？如果我们采用2个节点，那只有两个都回答 是死了，才能判定是死了，如果其中一个通信有问题，没法回答死了，那又没法判定是死了，又出现了<font color=red> 强一致性导致不可用</font>　，那两个只要一个判定死就死？那一个死 ，一个活 那也判定不了是死是活啊，于是我们采用3个节点，3个节点几个回答死就可以判定死了，3个？强一致性，2个呢？如果权值是一样的，2个回答死的，那从概率上讲，主节点死的概率是很大的，可以判定死。所以我们从过滤上讲，过半即可！那么，是不是越多越好，4个节点，要是3个节点都回答死 才判定死，是不是更好呢？当然会更准，但问题是，4个节点实际容忍1台监控节点发生故障，如果3个节点，2个节点判定死就死，也是容忍1个节点故障，3节点成本更低！ 而且，节点数越多，所以我们通常采用奇数节点。</p><h3 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h3><p>​    引用redis官网:</p><blockquote><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p><ul><li><strong>监控（Monitoring</strong>）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li><strong>提醒（Notification）</strong>： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>自动故障迁移（Automatic failover）</strong>： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><p>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</p><p>虽然 Redis Sentinel 释出为一个单独的可执行文件 redis-sentinel ， 但实际上它只是一个运行在特殊模式下的 Redis 服务器， 你可以在启动一个普通 Redis 服务器时通过给定 –sentinel 选项来启动 Redis Sentinel 。</p></blockquote><p> 有关Sentinel配置可以参考<a href="http://www.redis.cn/topics/sentinel.html" target="_blank" rel="noopener">官网</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集群原理-AKF原则</title>
      <link href="/2022/09/20/Redis-2022-09-20-%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/20/Redis-2022-09-20-%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我们在实际的工作中用到的组建通常会以集群的形式出现，目的就是解决单实例无法处理的情况，今天我们从AKF原则入手，总结一下 集群搭建的原理及要解决的问题。</p></blockquote><h2 id="AKF原则"><a href="#AKF原则" class="headerlink" title="AKF原则"></a>AKF原则</h2><h3 id="初识AKF"><a href="#初识AKF" class="headerlink" title="初识AKF"></a>初识AKF</h3><p>AKF原则是微服务拆分原则四条原则中的第一条，个人认为集群的搭建基本都是围绕AKF展开的。我们先思考单实例遇到的问题</p><ol><li>单点故障。一个实例挂掉，服务直接不可用了。</li><li>容量问题。以redis为例，一个实例可能10g的内存，那么20g的内存怎么办呢？</li><li>压力问题。单实例 能扛住的并发 始终是有上限的，如果想再提高并发？</li></ol><p>AKF原则就是 围绕上述3个问题展开的。<font color=red>需要注意的是，针对每一个问题可能就需要一套集群出来，AKF有3个轴，每个轴解决上述一个问题，每解决这一个问题 就需要一套集群，需要一个复杂的方案，如果想要同时解决上述3个问题，那么就需要一套组合拳，一套非常复杂的集群出来</font>。</p><h3 id="X轴"><a href="#X轴" class="headerlink" title="X轴"></a>X轴</h3><p><img src="1.jpg" alt="WeChat876d42a2a5c84f591f90d652cf9ddffc"></p><p>单点故障，我们通过备份，多个实例的数据做镜像，实例挂掉 可以再启动一个，这种集群模式叫做<font color = red> 主备模式</font>。但是，有一个问题，多个备份 如果只是作为备份，那么只有当主实例挂掉时候才能派上用场，是不是有点浪费？所以此时一般让备份实例可以作为读实例，主作为读写实例，从节点来同步主节点的数据。这种模式叫做 <font color = red>主从模式</font>。此时这套集群就看作是 主从架构的集群了。解决单点故障问题。</p><h3 id="Y轴"><a href="#Y轴" class="headerlink" title="Y轴"></a>Y轴</h3><p><img src="2.jpg" alt="WeChat705605ccda4a41743333ff78fee569a2" style="zoom:50%;"/></p><p>Y轴是说解决容量问题，redis一个实例4g内存，当存放16g数据呢？单实例放不开，我们可以找多个实例来存放。这就是Y轴要解决的问题。通常 可以按照业务功能来进行划分。比如 订单服务对应一个实例，用户服务对应一个实例，在容量是实际是划分开的。</p><h3 id="Z轴"><a href="#Z轴" class="headerlink" title="Z轴"></a>Z轴</h3><p><img src="3.jpg" alt="WeChat601e0b0d2d133f717a0a748bcfc067b0" style="zoom:50%;"/></p><p>继续来思考，如果经过Y轴拆分 ，单实例的压力还是达到瓶颈怎么办？比如用户服务的redis实例 已经撑不住了,我们是继续来一个 X、 Y的拆分吗？那这又回去了，AKF的Z轴就是解决这个问题的,我们可以利用分片再做一套集群出来，比如userid 10001~19999 一个redis 实例，20001~29999 一个实例，通过对数据进行分片来分解压力。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>AKF三条轴，围绕单点问题</p><p>X：全量，镜像</p><p>Y：业务，功能</p><p>Z：优先级，逻辑再拆分</p></li><li><p>注意，针对每一个问题，我们搭建集群来进行解决。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jstack 应用</title>
      <link href="/2022/09/20/JVM-2022-09-20-Jstack-%E5%BA%94%E7%94%A8/"/>
      <url>/2022/09/20/JVM-2022-09-20-Jstack-%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="jstack-参数"><a href="#jstack-参数" class="headerlink" title="jstack 参数"></a>jstack 参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/opt/java8/bin/jstack</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process) 连接活动线程</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process) 连接阻塞线程</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file) 连接dump的文件</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server) 连接远程服务器</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)</span><br><span class="line">    -m  to print both java and native frames (mixed mode)</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -h or -help to print this help message</span><br></pre></td></tr></table></figure><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object objA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object objB = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2());</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程1得到A对象的锁"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (objB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程1得到B对象的锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objB) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程2得到B对象的锁"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程2得到A对象的锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程1得到A对象的锁</span><br><span class="line">线程2得到B对象的锁</span><br></pre></td></tr></table></figure><h3 id="分析日志"><a href="#分析日志" class="headerlink" title="分析日志"></a>分析日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">[root@admin ~]# jps</span><br><span class="line">42576 Jps</span><br><span class="line">43616 DeadLock</span><br><span class="line">[root@admin ~]# jstack 43616</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.45-b08 mixed mode):</span><br><span class="line">"DestroyJavaVM" prio=6 tid=0x00000000047c1000 nid=0x9878 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">"Thread-1" prio=6 tid=0x0000000010aa3000 nid=0xafa0 waiting for monitor entry [0x000000001105f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at com.zaimeibian.Test$Thread2.run(Test.java:46)</span><br><span class="line">        - waiting to lock &lt;0x00000007c099cc20&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000007c099cc30&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:744)</span><br><span class="line">        </span><br><span class="line">"Thread-0" prio=6 tid=0x0000000010aa2800 nid=0xae74 waiting for monitor entry [0x0000000010f5f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at com.zaimeibian.Test$Thread1.run(Test.java:27)</span><br><span class="line">        - waiting to lock &lt;0x00000007c099cc30&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000007c099cc20&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:744)</span><br><span class="line"></span><br><span class="line">"Service Thread" daemon prio=6 tid=0x000000000f10a000 nid=0x9a8c runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C2 CompilerThread1" daemon prio=10 tid=0x000000000f109800 nid=0xaf28 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">"C2 CompilerThread0" daemon prio=10 tid=0x000000000f105800 nid=0x85dc waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">"Attach Listener" daemon prio=10 tid=0x000000000f104800 nid=0xac04 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">"Signal Dispatcher" daemon prio=10 tid=0x000000000f102000 nid=0xa678 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">"Finalizer" daemon prio=8 tid=0x000000000f0bd000 nid=0xaed8 in Object.wait() [0x000000001045f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x00000007c0905568&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:135)</span><br><span class="line">        - locked &lt;0x00000007c0905568&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:151)</span><br><span class="line">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:189)</span><br><span class="line">"Reference Handler" daemon prio=10 tid=0x000000000f0b2000 nid=0xaedc in Object.wait() [0x000000001035f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x00000007c09050f0&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.Object.wait(Object.java:503)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:133)</span><br><span class="line">        - locked &lt;0x00000007c09050f0&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">"VM Thread" prio=10 tid=0x000000000f0b0000 nid=0xaef0 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#0 (ParallelGC)" prio=6 tid=0x00000000047d6000 nid=0xacb0 runnable</span><br><span class="line">"GC task thread#1 (ParallelGC)" prio=6 tid=0x00000000047d8000 nid=0xaee0 runnable</span><br><span class="line">"GC task thread#2 (ParallelGC)" prio=6 tid=0x00000000047d9800 nid=0xaed4 runnable</span><br><span class="line">"GC task thread#3 (ParallelGC)" prio=6 tid=0x00000000047db000 nid=0xac54 runnable</span><br><span class="line">"VM Periodic Task Thread" prio=10 tid=0x000000000f132000 nid=0xaff0 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 105</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"Thread-1":</span><br><span class="line">  waiting to lock monitor 0x000000000f0ba488 (object 0x00000007c099cc20, a java.lang.Object),</span><br><span class="line">  which is held by "Thread-0"</span><br><span class="line">"Thread-0":</span><br><span class="line">  waiting to lock monitor 0x000000000f0bcf28 (object 0x00000007c099cc30, a java.lang.Object),</span><br><span class="line">  which is held by "Thread-1"</span><br><span class="line">  </span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line"></span><br><span class="line">===================================================</span><br><span class="line"></span><br><span class="line">"Thread-1":</span><br><span class="line"></span><br><span class="line">        at com.zaimeibian.Test$Thread2.run(Test.java:46)</span><br><span class="line"></span><br><span class="line">        - waiting to lock &lt;0x00000007c099cc20&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">        - locked &lt;0x00000007c099cc30&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">        at java.lang.Thread.run(Thread.java:744)</span><br><span class="line"></span><br><span class="line">"Thread-0":</span><br><span class="line"></span><br><span class="line">        at com.zaimeibian.Test$Thread1.run(Test.java:27)</span><br><span class="line"></span><br><span class="line">        - waiting to lock &lt;0x00000007c099cc30&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">        - locked &lt;0x00000007c099cc20&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">        at java.lang.Thread.run(Thread.java:744)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis应用 分布式锁实现</title>
      <link href="/2022/09/20/Redis-2022-09-20-Redis%E5%BA%94%E7%94%A8-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/09/20/Redis-2022-09-20-Redis%E5%BA%94%E7%94%A8-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Redis 除了做缓存、内存数据库之外，由于有线程的特性，经常可以拿来做分布式锁 、信号量等，应用起来也十分方便，我们来看一下一个分布式锁的简单实现。</p></blockquote><h2 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h2><blockquote><p>用redis实现分布式锁，其实我们要重点考虑3个方面问题：加锁、解锁、锁续期</p></blockquote><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>加锁要考虑的问题是，如果当前线程加锁之后挂掉了，相当于抱锁睡了，所以此时加锁时候 应该设置过期时间，保证能自动解锁。同时要注意应该是一个原子操作，否则还是有问题的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、占分布式锁。去redis占坑      设置过期时间必须和加锁是同步的，保证原子性（避免死锁）</span></span><br><span class="line">      String uuid = UUID.randomUUID().toString();</span><br><span class="line">      Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, uuid,<span class="number">300</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>加锁的本质是set nx 命令，只有锁不存在 才可以加锁成功。</p><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>解锁要考虑的是，解的一定是自己的锁才可以！比如，自己加锁之后 线程夯住，然后锁超时自动解开了，被别人抢走了，等线程活过来之后，完成业务去进行解锁操作，如果此时不加判断的解锁，解的就是别人的锁，那么就会有问题，并且判断与解锁的过程也要用原子操作，可以用lua脚本来保证。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line"><span class="comment">//删除锁</span></span><br><span class="line">stringRedisTemplate.execute(new DefaultRedisScript&lt;Long&gt;(script, Long.class), Arrays.asList("lock"), uuid);</span><br></pre></td></tr></table></figure><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p> 最后要考虑一个问题,加锁之后去执行业务，因为有自动解锁的机制，如果要解锁了，还没执行完业务呢？此时应该考虑。是否需要延时加锁时长，实际这一步就需要一个守护线程看到业务线程没执行完就要对锁进行续期。其实redisson 看门狗就是这么做的，理论是一样的，redis直接写的话代码比较复杂就不展示了，我们看一下redisson的实现。</p><h2 id="Redisson实现"><a href="#Redisson实现" class="headerlink" title="Redisson实现"></a>Redisson实现</h2><p>利用redisson 实现分布式锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建读锁</span></span><br><span class="line">    RReadWriteLock readWriteLock = redissonClient.getReadWriteLock(<span class="string">"catalogJson-lock"</span>);</span><br><span class="line"></span><br><span class="line">    RLock rLock = readWriteLock.readLock();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rLock.lock();</span><br><span class="line">        <span class="comment">//加锁成功...执行业务</span></span><br><span class="line">        dataFromDb = getCatalogJsonFromDB();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rLock.unlock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis RDB实现原理</title>
      <link href="/2022/09/19/Redis-2022-09-19-Redis-RDB%E4%B8%8EAOF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/19/Redis-2022-09-19-Redis-RDB%E4%B8%8EAOF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Redis的rdb 相信接触redis的同学都不陌生，rdb是redis持久化的快照文件。但有一个问题，时点的问题，比如redis 8点开始触发异步的持久化，假设需要十分钟的时间，那么这10分钟，主进程如果修改了内存数据，那么子进程进行持久化是写的修改后的数据吗？如果是，那此时持久化的数据就产生了脏数据,出现了数据一致性问题，如果不是，那此时内存数据被修改,又是如何做到呢？</p><p>那么通过回答这个问题来熟悉一下rdb的实现原理吧。</p></blockquote><h2 id="父子进程数据隔离"><a href="#父子进程数据隔离" class="headerlink" title="父子进程数据隔离"></a>父子进程数据隔离</h2><ol><li>$$ 与 $BASHPID均为取当前进程的PID</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bigdata ~]# echo $$</span><br><span class="line">19707</span><br><span class="line">[root@bigdata ~]# echo $BASHPID</span><br><span class="line">19707</span><br></pre></td></tr></table></figure><ol><li>| 管道会触发子进程</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bigdata ~]# echo $BASHPID</span><br><span class="line">19707</span><br><span class="line">[root@bigdata ~]# echo 1 | echo $BASHPID</span><br><span class="line">2483</span><br></pre></td></tr></table></figure><ol><li>$$ 优先级比$BASHPID要高</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@bigdata ~]# echo $$ | more</span><br><span class="line">19707</span><br><span class="line">[root@bigdata ~]# echo $BASHPID | more</span><br><span class="line">8651</span><br><span class="line">[root@bigdata ~]# echo $BASHPID | more</span><br><span class="line">8755</span><br></pre></td></tr></table></figure><p>4.父进程导出变量,子进程可以查看 不能修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@bigdata ~]# echo $$</span><br><span class="line">19707</span><br><span class="line">[root@bigdata ~]# export num</span><br><span class="line">[root@bigdata ~]# bash</span><br><span class="line">[root@bigdata ~]# echo $num</span><br><span class="line">1</span><br><span class="line">[root@bigdata ~]# num=1</span><br><span class="line">[root@bigdata ~]# num=5</span><br><span class="line">[root@bigdata ~]# exit</span><br><span class="line">exit</span><br><span class="line">[root@bigdata ~]# echo $num</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ol><li>父进程修改变量，不会影响子进程</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---子进程执行脚本</span><br><span class="line"><span class="meta">#</span><span class="bash">! bin/bash</span></span><br><span class="line">sleep 10s</span><br><span class="line">echo $$</span><br><span class="line">echo $num</span><br><span class="line">[root@bigdata ~]# sh child.sh &amp;</span><br><span class="line">[1] 21625</span><br><span class="line">[root@bigdata ~]# num=100</span><br><span class="line">[root@bigdata ~]# 21625</span><br><span class="line">10</span><br><span class="line">[1]+  完成                  sh child.sh</span><br><span class="line">[root@bigdata ~]# sh child.sh &amp;</span><br><span class="line">[1] 22285</span><br><span class="line">[root@bigdata ~]# 22285</span><br><span class="line">100</span><br><span class="line">[1]+  完成                  sh child.sh</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>​    通过shell命令的演示，可以看到linux中，父子进程的数据是导出的关系，而非共享，也就是说其中一方的修改，并不会影响另一方。</p><p>​    有linux数据隔离的支持，就为redis的异步保存快照提供了可能，同时有两个进程 主进程与异步的rdb子进程，主进程该写写，而做rdb的子进程看到的只是8点时刻的数据，并且只是进行一个读操作 。</p><h2 id="Fork系统调用"><a href="#Fork系统调用" class="headerlink" title="Fork系统调用"></a>Fork系统调用</h2><p>​    有了父子进程,通过数据隔离,就可以做异步持久化操作了,但还要考虑性能问题</p><p>​     进程都是需要进程空间的,拷贝子进程的时间？空间，如果当前redis内存占用10g，那么拷贝子进程至少拷贝10g数据，这个时间，再者，子进程也要占用10g内存，那么空间至少要啊20g才可以，这种情况下代价是不是有点大？</p><p><strong>fork()函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"this is the child process\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"this is the parent process\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1.jpg" alt="WeChat20ce515326f770bf4bde21542a0fa5ed"></p><p>linux的fork 系统调用 解决了上述的问题，fork出来的子进程，并非直接进行数据的拷贝。</p><p>linux编程中，通过fork函数会创建子进程，创建后根据写时复制策略，父子进程是共享父进程的堆与栈，当父子进程中的一方对内存进行了写操作后，父子进程的内存会分离，各自拥有自己独立的内存。</p><h2 id="COW-写时复制机制"><a href="#COW-写时复制机制" class="headerlink" title="COW 写时复制机制"></a>COW 写时复制机制</h2><p>在 Linux 系统中，调用 <code>fork</code> 系统调用创建子进程时，并不会把父进程所有占用的内存页复制一份，而是与父进程共用相同的<strong>内存页</strong>，而当子进程或者父进程对<strong>内存页</strong>进行修改时才会进行复制 —— 这就是著名的 <code>写时复制</code> 机制。</p><p><img src="2.jpg" alt="WeChat0facb54797c86a91122eae2013508029"></p><h2 id="配置及优缺点"><a href="#配置及优缺点" class="headerlink" title="配置及优缺点"></a>配置及优缺点</h2><ol><li><p>默认配置如下:</p><p>save 900 1<br>save 300 10<br>save 60 10000</p><p>从下往上，时间依次变长，只要满足一个条件就触发rdb保存。目的就是尽可能的减少数据丢失</p></li><li><p>缺点:丢失数据相对多一些 时点与时点之间窗口数据容易丢失 ,8点得到一个rdb，9点要落一个rdb，挂机了</p></li><li><p>优点：类似java中的序列化 恢复的速度相对快</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    涉及到持久化的方式 一般就两种，一种是快照 一种则是日志。今天我们介绍的就是快照的实现原理，通过linux 父子进程的数据隔离、fork系统调用以及cow机制 实现了rdb快照。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FullGC频繁排查思路</title>
      <link href="/2022/09/16/JVM-2022-09-16-FullGC%E9%A2%91%E7%B9%81%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/"/>
      <url>/2022/09/16/JVM-2022-09-16-FullGC%E9%A2%91%E7%B9%81%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://maimai.cn/article/detail?fid=1698450575&amp;efid=HoKY2iJmr6ceJpp0vT5P-Q" target="_blank" rel="noopener">https://maimai.cn/article/detail?fid=1698450575&amp;efid=HoKY2iJmr6ceJpp0vT5P-Q</a></p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>最近在整理JVM的知识体系，想到了大家平时都会讨论了一个话题，当然也是面试常问的一个话题，就是发生频繁fullGC的情况，我们应该如何应对，如何找到问题并且如何解决问题，这是让人头大的事情。</p><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a><strong>发现问题</strong></h2><p>我们先思考一下，我们平时是怎么发现频繁fullgc的，它的表现形式有哪些，这里只列举出来我能想到的几个点，可能还有其他的表现形式。</p><ol><li><p>CPU满载告警</p></li><li><p>API响应时间过长</p></li><li><p>内存反复波动</p></li><li><p>fullgc频繁告警(存在监控的情况下)</p></li></ol><p>其实发生CPU满载或者内存波动的原因可能会有很多，但是当我们发现这些情况，是可以往频繁fullgc上面想的，毕竟线上一旦出现问题，肯定要全面排查的嘛。</p><p>常用命令：</p><blockquote><p>jps：查看本机java进程信息</p><p> jstack：打印线程的栈信息，制作 线程dump文件</p><p> jmap：打印内存映射信息，制作 堆dump文件</p><p> jstat：性能监控工具</p><p>jhat：内存分析工具，用于解析堆dump文件并以适合人阅读的方式展示出来</p><p> jconsole：简易的JVM可视化工具</p><p> jvisualvm：功能更强大的JVM可视化工具</p></blockquote><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a><strong>定位问题</strong></h2><p>当我们发现了以上情况以及其他可以情况，就可以查看一下是否是频繁了fullgc，这里有个前提，就是什么频率算得上是频繁，这个要根据业务量和公司规定来的，比如我们公司，因为我们的项目是对B的，没有这么高的并发量，所以低于两天一次fullgc就属于频繁了，如果一天发生多次fullgc，那就一定出现问题了，就需要排查优化了，所以当我们确定了是频繁fullgc，就要开始定位，究竟是什么原因导致的fullgc。</p><ol><li><p>查看项目启动的GC命令，检查是否有异常指令：</p><p>比如有些同事可能对于GC参数理解的不是很透彻，本来想着优化的目的，但是却起了反作用。</p></li><li><p>查看yonggc的频率：</p><p>这一步主要是为了查看是否存在递归或者频繁创建对象，并且频繁回收，导致yonggc频繁，进而导致fullgc频繁，如果ygc频繁，则需要检查代码中是否存在不符合规范的地方了。</p></li><li><p>查看每一次fullgc的回收率：</p><p>如果ygc正常，但是fullgc频繁，那么这一步是为了查看是否存在内存泄漏，定位是否存在对象的长时间引用，内存泄露会占用大量内存空间，且无法正常回收，导致fullgc越发频繁，且stw时间越发长。</p></li><li><p>查看堆栈情况，找到占用内存较大的对象：</p><p>查看当前的堆栈信息，如果有监控工具可以直接使用，没有的话就使用JDK自带的一些命令，找到是否存在大对象的频繁创建。 </p></li><li><p>查看元数据区的回收频率：</p><p>Metadata GC Threshold，当我们发现以上情况都不存在，然后dump一下看看是否发生元数据区导致的频繁fullgc，当然这种情况很少见，但是可以定位排除一下。</p></li></ol><p>​    PS： 别忘了，还有一种可能，就是内存分配的太小了，大家往往会想到复杂的情况，也许调一下堆大小，就决解了呢。</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>minorGC前后的几种特殊情况</title>
      <link href="/2022/09/16/JVM-2022-09-16-minorGC%E5%89%8D%E5%90%8E%E7%9A%84%E5%87%A0%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5/"/>
      <url>/2022/09/16/JVM-2022-09-16-minorGC%E5%89%8D%E5%90%8E%E7%9A%84%E5%87%A0%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a><strong>大对象直接进入老年代</strong></h2><p> 相关参数 -XX:PretenureSizeThreshold</p><h2 id="动态年龄判断"><a href="#动态年龄判断" class="headerlink" title="动态年龄判断"></a><strong>动态年龄判断</strong></h2><p> minor gc 后，一批对象总大小超过了 survivor 区的 50%，那么就让大于等于这批对象年龄的对象直接进入老年代<br> 具体规则是，从年龄1的对象开始，把 年龄1 + 年龄2 + 年龄n 多个年龄的对象的总和超过survivor区的50%，就此时就会把年龄 n 以上的对象放入老年代</p><h2 id="老年代空间担保"><a href="#老年代空间担保" class="headerlink" title="老年代空间担保"></a><strong>老年代空间担保</strong></h2><p> 如果年轻代的对象需要晋升到老年代，老年代空间也可能不够。所以在执行 minor gc 之前，jvm会先检查一下老年代最大可用的连续内存空间， 是否能能放下 新生代所有的对象， 如果设置了 -XX:HandlePromotionFailure 则会进行下一步判断，看 是否大于  minor gc历次晋升到老年代对象的平均大小<br> 比如，上一次 minor gc 后有 10m 对象晋升到老年代，此时老年代最大连续可用空间大于10m，说明老年代空间是够的<br> 如果判断失败了，或者没有设置 “-XX:HandlePromotionFailure” 就会先进行一次 full gc 多腾出一些空间来， 然后在进行 mninor gc</p><blockquote><p>jdk1.6 update24之后， HandlePromotionFailure 没作用了，<br>只要老年代的连续空间大于新生代对象总大小或者历次晋升对象的平均<br>大小就可以进行 minor gc</p></blockquote><h2 id="minor-gc-后，survivor-区存放不下那部分存活对象-挪到老年代"><a href="#minor-gc-后，survivor-区存放不下那部分存活对象-挪到老年代" class="headerlink" title="minor gc 后，survivor 区存放不下那部分存活对象 挪到老年代"></a><strong>minor gc 后，survivor 区存放不下那部分存活对象 挪到老年代</strong></h2><p> a. 单个对象就比 survivor 大，直接挪到老年代<br> b. 并不是全部都挪到老年代<br> c. 如果老年代放不下所有的晋升对象 则会发生fullgc</p><p>老年代回收速度比年轻代慢 10 倍，年轻代一般就几十ms</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FullGC的发生时机</title>
      <link href="/2022/09/16/JVM-2022-09-16-FullGC%E7%9A%84%E5%8F%91%E7%94%9F%E6%97%B6%E6%9C%BA/"/>
      <url>/2022/09/16/JVM-2022-09-16-FullGC%E7%9A%84%E5%8F%91%E7%94%9F%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Major-GC-Full-GC"><a href="#Major-GC-Full-GC" class="headerlink" title="Major GC / Full GC"></a>Major GC / Full GC</h2><p>基于分代收集理论，目前的JVM堆内存大多分为了==新生代、老年代、方法区==。</p><p>JVM在进行GC时，并非每次都对上面三个内存区域（新生代、老年代；方法区）一起回收的，大部分时候回收的都是指新生代。</p><p>针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）。</p><h3 id="部分收集："><a href="#部分收集：" class="headerlink" title="部分收集："></a>部分收集：</h3><p>不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ol><li><p>新生代收集（Minor GC / Young GC）：只是新生代（Eden，s0，s1）的垃圾收集</p></li><li><p>老年代收集（Major GC / Old GC）：只是老年代的圾收集。</p></li></ol><p>​    目前，只有CMS GC会有单独收集老年代的行为。</p><p>​    注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</p><ol><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li></ol><h3 id="整堆收集（Full-GC）："><a href="#整堆收集（Full-GC）：" class="headerlink" title="整堆收集（Full GC）："></a>整堆收集（Full GC）：</h3><p>​    收集整个java堆和方法区的垃圾收集。</p><p>由于历史原因，外界各种解读，Major GC和Full GC有些混淆，下面的Full GC所指会说明，请仔细阅读。</p><h2 id="Full-GC触发机制"><a href="#Full-GC触发机制" class="headerlink" title="Full GC触发机制"></a>Full GC触发机制</h2><p>调用System.gc()时，系统建议执行Full GC，但是不必然执行<br>老年代空间不足<br>方法区空间不足<br>空间分配担保失败<br>下面逐一讲解。</p><ol><li><p>System.gc()的理解</p><blockquote><p>在默认情况下，通过<font color='red'> System.gc()</font>者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。<br>System.gc()内部实际上就是调用了<font color='red'> Runtime.getRuntime().gc()</font></p></blockquote></li></ol><p>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用（不能确保立即生效）<br>JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p><ol><li>老年代空间不足<br>何时新生代对象才会进入老年代，进一步触发老年代空间不足？</li></ol><blockquote><p>​    走正常流程，从Survivor区晋升到Old区，这时必然是伴随着Young GC才会导致Survivor区的被动回收。<br>当对象准备从Eden区经过Young GC转入Survivor区时，Survivor区空间不足，此时会直接进入老年代。<br>​    在经过Young GC后，Eden区仍然放不下新生的对象，则该对象直接进入Old区。<br>老年代空间不足所触发的其实是狭义上的Major GC</p><p>在此种情况下已经经历了Young GC，所以此时没有必要再进行一次Young GC。所以此时其实并不是整堆收集，也就不能算是狭义上的Full GC，但是由于一般都是混淆的，这里也把这种情况算入，在需要时可以特殊说明。</p><p>但如果是大对象直接分配老年代而空间不足，此时就没有经过young gc。所以尽管是只需要回收old区，但只有CMS才有专门的old区回收。</p><p>补充 进入老年代的常见四种情况:</p><p>1.躲过15次gc,达到15次高龄之后进入老年代.</p><p>2.动态年龄判定规则,如果Survivor区域内年龄1+年龄2+年龄3+年龄n的对象总和大于Survivor区的50%,此时年龄n以上的对象会进入老年代,不一定要达到15岁.</p><p>3.如果一次Young GC后存活对象太多无法进入Survivor区,此时直接进入老年代.</p><p>4.大对象直接进入老年代</p></blockquote><ol><li>方法区空间不足<br>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。</li></ol><blockquote><p>回收废弃常量与回收Java堆中的对象非常类似。也是通过可达性分析判断出常量不再被引用后进行回收。<br>类卸载的条件则相当苛刻，最困难的条件是 “加载该类的类加载器已经被回收” ，日常使用的类几乎都是通过系统类加载器或者向上的父加载器所加载，所以回收相当困难。<br>Java 8中方法区的实现改成了元空间（Meta Space），使用本地内存（Native memory）。只有在操作系统内存都被占满的情况下才可能报OOM。</p></blockquote><p>在报出OOM前必然会进行Full GC，因为方法区既不属于Young GC的回收范围，也不属于Old GC的回收范围，所以此时只有Full GC才能回收到方法区。</p><ol><li><p>空间分配担保失败</p><blockquote><p>在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看<font color='red'> -XX:HandlePromotionFailure</font>参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者<font color='red'> -XX:HandlePromotionFailure</font>设置不允许冒险，那这时就要改为进行一次Full GC。</p><p>一般空间分配担保机制都是打开的，以避免Full GC过于频繁。</p></blockquote></li></ol><p>这里的会出现Full GC的场景有两个：</p><ol><li>在开启空间分配担保机制后，老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，但这一次晋升上来的对象老年代放不下，这时会首先进行一次Young GC，若失败，则会直接进行Full GC。</li><li>未开启空间分配担保机制 / 老年代最大可用的连续空间小于历次晋升到老年代对象的平均大小。</li></ol>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM参数分类</title>
      <link href="/2022/09/15/JVM-2022-09-15-JVM%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB/"/>
      <url>/2022/09/15/JVM-2022-09-15-JVM%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM参数分类"><a href="#JVM参数分类" class="headerlink" title="JVM参数分类"></a>JVM参数分类</h2><div class="table-container"><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>标准参数（-）</td><td>所有的JVM实现都必须实现这些参数的功能，而且向后兼容；</td></tr><tr><td>非标准参数（-X）</td><td>这些参数不是虚拟机规范规定的。因此，不是所有VM的实现(如:HotSpot,JRockit,J9等)都支持这些配置参数。</td></tr><tr><td>非稳定参数（-XX）</td><td>这些参数是虚拟机规范中规定的。这些参数指定虚拟机实例在运行时的各种行为，从而对虚拟机的运行时性能有很大影响。</td></tr></tbody></table></div><p>对于-XX类型的配置选项，虚拟机规范有一些惯例，针对不同的平台虚拟机也会提供不同的默认值。</p><ol><li>对于布尔(Boolean)类型的配置选项，通过-XX:+来开启，通过-XX:-来关闭。</li><li>对于数字(Numberic)类型的配置选项，通过-XX:=来配置。后面可以携带单位字母，比如: ‘k’或者’K’代表千字节，’m’或者’M’代表兆字节，’g’或者’G’代表千兆字节。</li><li>对于字符串(String)类型的配置选项，通过-XX:=来配置。这种配置通过用来指定文件，路径或者命令列表。</li></ol><p>参考：<a href="http://www.nituchao.com/jvm-tuning/8.html" target="_blank" rel="noopener">http://www.nituchao.com/jvm-tuning/8.html</a></p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON字符串的嵌套机制</title>
      <link href="/2022/08/17/Java-2022-08-17-JSON%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B5%8C%E5%A5%97%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/08/17/Java-2022-08-17-JSON%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B5%8C%E5%A5%97%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="转义机制的嵌套："><a href="#转义机制的嵌套：" class="headerlink" title="转义机制的嵌套："></a>转义机制的嵌套：</h3><p>转义机制被任意嵌套、组合，只要识别方的处理逻辑是正确的，就不会发生命令识别错误或数据识别错误。转义机制是一个安全性完备的机制。</p><p>每增加一层转义机制，就需要增加一层还原机制。</p><h3 id="JSON字符串的多层嵌套"><a href="#JSON字符串的多层嵌套" class="headerlink" title="JSON字符串的多层嵌套"></a><strong>JSON字符串的多层嵌套</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.76&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多重嵌套转义测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multipleEscape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">    String s1 = <span class="string">"hello world."</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        jsonObject.set(<span class="string">"test"</span>, s1);</span><br><span class="line">        s1 = jsonObject.toString();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">&#123;<span class="string">"test"</span>:<span class="string">"hello world."</span>&#125;</span><br><span class="line">&#123;<span class="string">"test"</span>:<span class="string">"&#123;\"test\":\"hello world.\"&#125;"</span>&#125;</span><br><span class="line">&#123;<span class="string">"test"</span>:<span class="string">"&#123;\"test\":\"&#123;\\\"test\\\":\\\"hello world.\\\"&#125;\"&#125;"</span>&#125;</span><br><span class="line">&#123;<span class="string">"test"</span>:<span class="string">"&#123;\"test\":\"&#123;\\\"test\\\":\\\"&#123;\\\\\\\"test\\\\\\\":\\\\\\\"hello world.\\\\\\\"&#125;\\\"&#125;\"&#125;"</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac必备工具之brew</title>
      <link href="/2022/08/02/Mac%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E4%B9%8Bbrew/"/>
      <url>/2022/08/02/Mac%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E4%B9%8Bbrew/</url>
      
        <content type="html"><![CDATA[<blockquote><p>brew 是 Mac 下的一个包管理工具，类似于 centos 下的 yum，可以很方便地进行安装/卸载/更新各种软件包，例如：nodejs, elasticsearch, kibana, mysql, mongodb 等等，可以用来快速搭建各种本地环境，程序员必备工具</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>可以使用如下命令进行安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装/卸载/更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install nodejs</span><br><span class="line">brew upgrade nodejs</span><br><span class="line">brew remove  nodejs</span><br></pre></td></tr></table></figure><p>其它命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew list                   # 列出当前安装的软件</span><br><span class="line">brew search nodejs          # 查询与 nodejs 相关的可用软件</span><br><span class="line">brew info nodejs            # 查询 nodejs 的安装信息</span><br></pre></td></tr></table></figure><p>Services 命令</p><p> brew services 是一个非常强大的工具，可以用来管理各种服务的启停，有点像 linux 里面的 services</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services list    //列出当前管理的服务</span><br></pre></td></tr></table></figure><p>启动/停止/重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew start   nginx</span><br><span class="line">brew stop    nginx</span><br><span class="line">brew restart nginx</span><br></pre></td></tr></table></figure><h3 id="常见路径"><a href="#常见路径" class="headerlink" title="常见路径"></a>常见路径</h3><ul><li>配置路径：<code>/usr/local/etc/</code></li><li>日志路径：<code>/usr/local/var/log</code></li><li>安装路径   <code>/usr/local/Cellar</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组合数计算的方法总结</title>
      <link href="/2022/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-24-%E7%BB%84%E5%90%88%E6%95%B0%E8%AE%A1%E7%AE%97%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-24-%E7%BB%84%E5%90%88%E6%95%B0%E8%AE%A1%E7%AE%97%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法题目中常见的计算技巧总结</title>
      <link href="/2022/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-24-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%A1%E7%AE%97%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-24-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%A1%E7%AE%97%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天我们对算法题目中与数学运算相关的一些常用的知识进行简单总结，需要刻意记忆，如果对相关知识点不熟悉需要翻越更详细的资料。</p></blockquote><h3 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h3><h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><p>正整数a,b的最大公约数是指a与b的所有公约数中最大的那个公约数。求解最大公约数常用的是欧几里得算法(即辗转相除法),假设 a,b 均为正整数，则<code>gcd=(a,b) = gcd(b,a%b)</code></p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> b==<span class="number">0</span> ? a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h4><p>正整数a,b的最小公倍数是指a与b的所有公倍数中最小的那个公倍数。当得到a和b的最大公约数d之后,可以马上得到a和b的最小公倍数是<code>ab/d</code>,一般用lcm(a,b)来表示a和b的最小公倍数。由于<code>a*b</code>在实际运算时可能溢出 ，所以更恰当的写法是<code>a/d*b</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a/gcd(a,b)*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="素数筛选"><a href="#素数筛选" class="headerlink" title="素数筛选"></a>素数筛选</h3><p>素数又称质数，是指除了1和它自身，不能被其它数整除的数字。比较简单的做法是利用定义去挨个判断即可。但通常我们需要更快的做法去打表，以便后续更快的计算。这里我们常用是”埃氏筛法”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] primer_tb(<span class="keyword">int</span> maxn)&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] not_primer = <span class="keyword">new</span> <span class="keyword">boolean</span>[maxn]; <span class="comment">//true代表不是质数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)</span><br><span class="line">        <span class="keyword">if</span> (!not_primer[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>*i;j &lt; maxn;j += i)</span><br><span class="line">                <span class="comment">//筛掉所有i的倍数</span></span><br><span class="line">                not_primer[j] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> not_primer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="质因子分解"><a href="#质因子分解" class="headerlink" title="质因子分解"></a>质因子分解</h3><p>所谓的质因子分解是指将一个正整数n写成一个或多个质数乘积的形式，例如 <code>180 = 2 * 2 * 3 * 3 * 5</code> 也即 </p><p>180 = 2^2^ <em> 3 ^2^ </em>5^1^  ,显然 数最终都是归到不同质数的乘积，所以我们需要先得到素数表 。</p><p>此外，我们需要理解一个结论 ,如果正整数n存在1和本身之外的因子，那么一定是在 sqrt(n)的左右成对出现，这是显然的。我们把这个结论应用到质因子上面得到一个强化的结论 ：<font color = red>对于一个正整数n来说，如果它存在[2,n]范围内的质因子，要么这些质因子全部小于等于sqrt(n),要么只存在一个大于sqrt(n)的质因子，而其余质因子全部小于等于 sqrt(n)。</font></p><p>有这个结论，接下来写代码就好办了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">factor</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> x; <span class="comment">//质数</span></span><br><span class="line">       <span class="keyword">int</span> cnt; <span class="comment">//质数对应的个数</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> factor[] handle_primer(<span class="keyword">int</span> n,<span class="keyword">int</span>[] primer_tb,<span class="keyword">int</span> p_num)&#123; <span class="comment">//primer_tb是收集好的质数数组,p_num是对应的个数。</span></span><br><span class="line">       factor[] factors = <span class="keyword">new</span> factor[<span class="number">10</span>];</span><br><span class="line">       <span class="keyword">int</span> num = <span class="number">0</span>,sqr = (<span class="keyword">int</span>)Math.sqrt(n);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; p_num &amp;&amp; primer_tb[i] &lt;= sqr;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(n%primer_tb[i] == <span class="number">0</span>)&#123;</span><br><span class="line">               factors[num].x = primer_tb[i];  <span class="comment">//记录该质因子</span></span><br><span class="line">               factors[num].cnt = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">while</span> (n % primer_tb[i] == <span class="number">0</span>)&#123; <span class="comment">//计算质因子primer_tb[i]的个数</span></span><br><span class="line">                   factors[num].cnt++;</span><br><span class="line">                   n/=primer_tb[i];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           num++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(n != <span class="number">1</span>)&#123;</span><br><span class="line">           factors[num].x = n;</span><br><span class="line">           factors[num].cnt = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> factors;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="上取整"><a href="#上取整" class="headerlink" title="上取整"></a>上取整</h3><p>​    在int型计算时候比如 <code>a /b</code>,默认是下取整的,介绍一种常用的上取整的技巧,a/b的上取整结果为<code>(a+b-1)/b</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    本文介绍的都是一些简单需要刻意去记忆的一些方法，更详细的内容需要单独摘出来讨论，这里总结的都是便简单的，慢慢的会把所有用到的运算技巧总结在这个地方。</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> MATH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j日志不输出</title>
      <link href="/2022/07/24/%E9%97%AE%E9%A2%98-2022-07-24-log4j%E6%97%A5%E5%BF%97%E4%B8%8D%E8%BE%93%E5%87%BA/"/>
      <url>/2022/07/24/%E9%97%AE%E9%A2%98-2022-07-24-log4j%E6%97%A5%E5%BF%97%E4%B8%8D%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>log4j日志不输出，或者没有按照预定的级别输出</p><h3 id="常见原因"><a href="#常见原因" class="headerlink" title="常见原因"></a>常见原因</h3><p>原因一：配置文件没配置对，这种低级错误就不说了</p><p>原因二：依赖冲突</p><p>​    多半是因为，引入的底层实现类出现了冲突，这样就得排查maven的冲突，那怎么知道哪些冲突了呢？如果</p><p>真是一点一点查，那就麻烦了，注意，一定要看提示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:/Users/qindongliang/.m2/repository/org/apache/logging/log4j/log4j-slf4j-impl/2.3/log4j-slf4j-impl-2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:/Users/qindongliang/.m2/repository/org/slf4j/slf4j-log4j12/1.7.12/slf4j-log4j12-1.7.12.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#multiple_bindings for an explanation.</span></span><br><span class="line">SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]</span><br></pre></td></tr></table></figure><p>看到吗？提示两个类，一个是来自log4j-slf4j-impl/2.3/log4j-slf4j-impl-2.3.jar!/org/slf4j/impl/</p><p>一个来自org/slf4j/slf4j-log4j12/1.7.12/slf4j-log4j12-1.7.12.jar!/org/slf4j/impl/</p><p>是来自两个jar包，一个是2.x的一个是1.x的slf4j-log4j12，都是StaticLoggerBinder.class 这两个冲突了，然后有目的的去在依赖图里搜索这个jar，一般用的是2.x 把1.x的jar排除掉就可以了</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>看日志提示，看日志，看日志，看日志报错，寻找有用信息，不要盲目猜测</p></li><li><p>学会在maven 依赖中搜索</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trouble Shooting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常见报错</title>
      <link href="/2022/07/24/Java-2022-07-24-git%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99/"/>
      <url>/2022/07/24/Java-2022-07-24-git%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>错误一：Failed to connect to github.com port 443: Operation timed out</p><p>​    这个多半是由于网络问题，正常情况不会拉取，推送失败，多半是网络原因</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">考虑更换ip（自己没遇到过这个问题）：</span><br><span class="line">1、查询可以用的IP</span><br><span class="line">在https://www.ipaddress.com/上分别搜索</span><br><span class="line">github.com、github.global-ssl.fastly.net</span><br><span class="line">2、修改host文件</span><br><span class="line">     操作：sudo vi /etc/hosts，替换成以下ip即可</span><br><span class="line">151.101.185.194 github.global-ssl.fastly.net</span><br><span class="line">192.30.253.112  github.com</span><br></pre></td></tr></table></figure><p>错误二：LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 60</p><p>​     这个多半是因为自己的git仓库没有配 公钥，配一下即可              </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PrepareStatement未关闭导致内存泄漏</title>
      <link href="/2022/07/24/%E9%97%AE%E9%A2%98-2022-07-24-PrepareStatement%E6%9C%AA%E5%85%B3%E9%97%AD%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
      <url>/2022/07/24/%E9%97%AE%E9%A2%98-2022-07-24-PrepareStatement%E6%9C%AA%E5%85%B3%E9%97%AD%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>堆内存飙升，GC次数明显提升</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h3><p>第三方的数据库连接池，使用的时候，获取到Connection之后，使用完成，调用的关闭方法（close()） ，并没有将Connection关闭，只是放回到连接池中，如果调用的这个方法，而没有手动关闭PreparedStatement等，则这个PreparedStatement并没有关闭，这样会使得开发的程序内存急速增长，java的内存回收机制可能跟不上速度，最终造成Out of memory Error</p><p>今天，就犯了一个很离谱的错误，ps没关，不断new新的ps，导致堆内存不断飙升，GC就是回收不了，结果OOM～</p><p>GC不掉的原因</p><p>引用百度问答的一段话：</p><p>1.你创建了100个PS的实例，但是你只关闭了最后一个。1楼说的GC会回收另外99个，没错，但GC能自动回收的只是JAVA创建的资源。preparedstatement为jdbc得api，他还会创建跟具体数据库有关的其他资源。close方法就是用来施放那些资源的。如果你没有每个都close，会导致内存泄漏。</p><p>2.不可以。——————补充：当然有非java创建的资源 jdbc可以说是一个和数据库通信的驱动。你建立jdbc的对象，调用它的方法。jdbc会去调用你使用的数据库的api，实现对数据库的操作。那些数据库的api会创建很多资源。java的gc（垃圾回收器）只会释放掉那些java对象所占的内存。无法释放数据库api创建的资源。只有通过jdbc相关的close方法才能释放。你只要记住，所有有close方法的jdbc对象在使用完成后都需要手动释放。另外，就是内存泄漏，相应的资源在内存中没有被引用，而又没有被操作系统回收。对，就是这个意思，除了JDBC还有很多根操作系统api有关的java api都有close方法，他们都是用来释放相应的非java资源的。</p><p>引用几篇文章，了解一下这个ps和现场排查的过程</p><p><a href="https://www.jianshu.com/p/50a33f2046dd" target="_blank" rel="noopener">JDBC：深入理解PreparedStatement和Statement</a></p><p><a href="http://www.jiaqili.me/post/oom-profiling-report-20181121/" target="_blank" rel="noopener"><strong>故障分析报告 - Java应用PS未关闭导致的OOM错误</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trouble Shooting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP拆包与粘包</title>
      <link href="/2022/07/23/network-2022-07-23-TCP%E6%8B%86%E5%8C%85%E4%B8%8E%E7%B2%98%E5%8C%85/"/>
      <url>/2022/07/23/network-2022-07-23-TCP%E6%8B%86%E5%8C%85%E4%B8%8E%E7%B2%98%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h3 id="粘包产生的原因"><a href="#粘包产生的原因" class="headerlink" title="粘包产生的原因"></a>粘包产生的原因</h3><p>如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这就是TCP协议中经常会遇到的粘包以及拆包的问题。</p><h4 id="传输层的UDP协议是否会发生粘包或者拆包问题？"><a href="#传输层的UDP协议是否会发生粘包或者拆包问题？" class="headerlink" title="传输层的UDP协议是否会发生粘包或者拆包问题？"></a>传输层的UDP协议是否会发生粘包或者拆包问题？</h4><p>​    不会。UDP是基于报文发送的，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。</p><h4 id="传输层的TCP协议是否会发生粘包或者拆包问题？"><a href="#传输层的TCP协议是否会发生粘包或者拆包问题？" class="headerlink" title="传输层的TCP协议是否会发生粘包或者拆包问题？"></a>传输层的TCP协议是否会发生粘包或者拆包问题？</h4><p>会。原因有以下两点：</p><ol><li><p>TCP是基于字节流的，虽然应用层和传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；</p></li><li><p>在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。（翻阅TCP协议）</p></li></ol><h3 id="粘包-拆包的表现形式"><a href="#粘包-拆包的表现形式" class="headerlink" title="粘包/拆包的表现形式"></a>粘包/拆包的表现形式</h3><p>现在假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为三种，现列举如下：</p><p>第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象，此种情况不在本文的讨论范围内。</p><p><img src="1.png" alt="WeChat1864b7a354427497fe010c4845961b18"></p><p>第二种情况，接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p><p><img src="2.png" alt="WeChatda0ba87973b06e3a58eff0a87b7dd23f"></p><p>第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p><p><img src="3.png" alt="WeChat09cb12a8193cdd8f3b06dd8d2bf46e22"></p><h3 id="粘包-拆包发生的原因"><a href="#粘包-拆包发生的原因" class="headerlink" title="粘包/拆包发生的原因"></a>粘包/拆包发生的原因</h3><p>发生TCP粘包或拆包有很多原因，现列出常见的几点：</p><p>1、要发送的数据大于TCP发送缓冲区剩余空间大小[操作系统socket内核缓冲区是tcp协议buffer（滑动窗口）的具体实现]，将会发生拆包。</p><p>2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。</p><p>3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</p><p>4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</p><h3 id="粘包-拆包的解决办法"><a href="#粘包-拆包的解决办法" class="headerlink" title="粘包/拆包的解决办法"></a>粘包/拆包的解决办法</h3><p>通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：</p><ol><li>发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</li><li>发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li><li>可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>贴出来当时测试，包发生粘包的代码，仔细看打的日志</li></ul><p>​        <a href="https://paste.ubuntu.com/p/PxCxHhMH5R/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/PxCxHhMH5R/</a></p><ul><li>注意，一定要注意，协议本身没问题，你也不要考虑协议的什么问题，我觉着主要就是内核缓冲buffer，不一定什么时候发送，一口气发送出去，或者你这个内容太大，给你拆成两个包，结果正好一个包在接收方那端收着了，另一个还没发，这不就是拆包了，或者说，在接收方，迟迟不调接收的buffer，来了一个包的数据进到了buffer，来了一个进来了，应用级别，一读，整个buffer过去了，这不是就是相当于一个包过来的了，就是粘包，没啥好说的，主要就是内核的socket buffer不一定什么时候操作，和内核page cache一个原理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解</title>
      <link href="/2022/07/23/Java-2022-07-23-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/07/23/Java-2022-07-23-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    Java 注解是在 JDK5 时引入的新特性，注解（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。注解类型定义指定了一种新的类型，一种特殊的接口类型。 在关键词 interface 前加 @ 符号也就是用 @interface 来区分注解的定义和普通的接口声明。目前大部分框架(如 Spring Boot 等)都通过使用注解简化了代码并提高的编码效率</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><p>提供信息给编译器： 编译器可以利用注解来探测错误和警告信息，如 @Override、@Deprecated。</p></li><li><p>编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html 文档或者做其它相应处理，如 @Param、@Return、@See、@Author 用于生成 Javadoc 文档。</p></li><li><p>运行时的处理： 某些注解可以在程序运行的时候接受代码的提取，值得注意的是，注解不是代码本身的一部分。如Spring 2.5 开始注解配置，减少了配置。</p></li></ul><h3 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h3><ol><li><strong>根据注解参数的个数:</strong></li></ol><ul><li><p>标记注解:一个没有成员定义的Annotation类型被称为标记注解。</p></li><li><p>单值注解:只有一个值</p></li><li><p>完整注解:拥有多个值</p></li></ul><ol><li><strong>根据注解使用方法和用途:</strong></li></ol><ul><li><p>JDK内置系统注解</p></li><li><p>元注解</p></li><li><p>自定义注解</p></li></ul><h3 id="元数据注解"><a href="#元数据注解" class="headerlink" title="元数据注解"></a><strong>元数据注解</strong></h3><p>​    元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解有四个，</p><p>​    (这些类型和它们所支持的类在java.lang.annotation包中可以找到)</p><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a><strong>@Target</strong></h4><p>​    用于描述注解的使用范围（即：被描述的注解可以用在什么地方）。表示支持注解的程序元素的种类，一些可能的值有TYPE, METHOD, CONSTRUCTOR, FIELD等等。如果Target元注解不存在，那么该注解就可以使用在任何程序元素之上。</p><p>  取值(ElementType)有：</p><ul><li><p>CONSTRUCTOR:用于描述构造器</p></li><li><p>FIELD:用于描述属性</p></li><li>LOCAL_VARIABLE:用于描述局部变量</li><li>METHOD:用于描述方法</li><li>PACKAGE:用于描述包</li><li>PARAMETER:用于描述参数</li><li>TYPE:用于描述类、接口(包括注解类型) 或enum声明</li></ul><p>此时在空注解中加入@Target元注解如: //此注解只能用在方法上 @Target(ElementType.METHOD) @interface TestMethod {}  </p><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a><strong>@Retention</strong></h4><p>​     表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）表示注解类型保留时间的长短。</p><p>​    取值(RetentionPoicy)有：</p><ul><li><p>SOURCE:在源文件中有效（即源文件保留）</p></li><li><p>CLASS:在class文件中有效（即class保留）</p></li><li>RUNTIME:在运行时有效（即运行时保留）</li></ul><p>此时在上述注解中加入@Retention元注解如: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此注解可以用于注解类、接口(包括注解类型) 或enum声明</span></span><br><span class="line"> <span class="meta">@Target</span>(ElementType.TYPE) </span><br><span class="line"><span class="comment">//该注解运行时有效。注解处理器可以通过反射，获取到该注解的属性值，从而去做一些运行时的逻辑处理</span></span><br><span class="line"> <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="meta">@interface</span> TestRn&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a><strong>@Documented</strong></h4><p>​    表示使用该注解的元素应被javadoc或类似工具文档化，它应用于类型声明，类型声明的注解会影响客户端对注解元素的使用。如果一个类型声明添加了Documented注解，那么它的注解会成为被注解元素的公共API的一部分，@Documented是一个标记注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以被例如javadoc此类的工具文档化`</span></span><br><span class="line"><span class="meta">@Documented</span> <span class="meta">@interface</span> TestDoc&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a><strong>@Inherited</strong></h4><p>​    表示一个注解类型会被自动继承，如果用户在类声明的时候查询注解类型，同时类声明中也没有这个类型的注解，那么注解类型会自动查询该类的父类，这个过程将会不停地重复，直到该类型的注解被找到为止，或是到达类结构的顶层（Object）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被子类继承的注解</span></span><br><span class="line"><span class="meta">@Inherited</span> <span class="meta">@interface</span> TestInheri&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a><strong>注解处理器</strong></h3><p>​    说白了，注解就是一种标识，与原程序无关，那既然进行了标识，关键在于解析这些标识，具有什么样的标识，就触发什么样的逻辑。</p><p>   AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息：</p><p>① T getAnnotation(Class annotationClass): 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</p><p> ②Annotation[] getAnnotations():返回该程序元素上存在的所有注解。</p><p> ③boolean isAnnotationPresent(Class annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false.</p><p> ④Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。</p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>以token校验注解为例，看一下自定义注解的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dante</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TokenCheck &#123;</span><br><span class="line">    <span class="comment">// 是否校验token</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截器进入"</span>);</span><br><span class="line"></span><br><span class="line">        String token = request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TokenException(<span class="string">"token 为空"</span>);</span><br><span class="line"><span class="comment">////         return false;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">        Method method = handlerMethod.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(TokenCheck<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            TokenCheck annotation = method.getAnnotation(TokenCheck<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (annotation.required()) &#123;</span><br><span class="line">                <span class="comment">// 校验token</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    JwtUtil.parseToken(token);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量池</title>
      <link href="/2022/07/23/JVM-2022-07-23-%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
      <url>/2022/07/23/JVM-2022-07-23-%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>提到常量池一直容易混，今天一次性彻底搞定。</p></blockquote><h3 id="class文件常量池（class-constant-pool）"><a href="#class文件常量池（class-constant-pool）" class="headerlink" title="class文件常量池（class constant pool）"></a>class文件常量池（class constant pool）</h3><p>我们都知道，class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的<strong>各种字面量(Literal)和符号引用(Symbolic References)</strong>。字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>这个就是我们在字节码中看到的常量池，存的是字面量和符号引用。这个时候，是编译后的，还没运行呢。</p><h3 id="全局字符串池（string-pool也有叫做string-literal-pool）"><a href="#全局字符串池（string-pool也有叫做string-literal-pool）" class="headerlink" title="全局字符串池（string pool也有叫做string literal pool）"></a>全局字符串池（string pool也有叫做string literal pool）</h3><p>全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（<strong>记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。</strong>）。在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。</p><h3 id="运行时常量池（runtime-constant-pool）"><a href="#运行时常量池（runtime-constant-pool）" class="headerlink" title="运行时常量池（runtime constant pool）"></a>运行时常量池（runtime constant pool）</h3><p>当java文件被编译成class文件之后，也就是会生成我上面所说的class常量池，那么运行时常量池又是什么时候产生的呢？</p><p>jvm在执行某个类的时候，必须经过<strong>加载、连接、初始化</strong>，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"def"</span>);</span><br><span class="line">String str3 = <span class="string">"abc"</span>;</span><br><span class="line">String str4 = str2.intern();</span><br><span class="line">String str5 = <span class="string">"def"</span>;</span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true</span></span><br><span class="line">System.out.println(str2 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></code></pre><p>上面程序的首先经过编译之后，在该类的class常量池中存放一些符号引用，然后类加载之后，将class常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中str1所指向的”abc”实例对象），然后将这个对象的引用存到全局String Pool中，也就是StringTable中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询StringTable，保证StringTable里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。</p><p>回到上面的那个程序，现在就很容易解释整个程序的内存分配过程了，首先，在堆中会有一个”abc”实例，全局StringTable中存放着”abc”的一个引用值，然后在运行第二句的时候会生成两个实例，一个是”def”的实例对象，并且StringTable中存储一个”def”的引用值，还有一个是new出来的一个”def”的实例对象，与上面那个是不同的实例，当在解析str3的时候查找StringTable，里面有”abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同，str4是在运行的时候调用intern()函数，返回StringTable中”def”的引用值，如果没有就将str2的引用值添加进去，在这里，StringTable中已经有了”def”的引用值了，所以返回上面在new str2的时候添加到StringTable中的 “def”引用值，最后str5在解析的时候就也是指向存在于StringTable中的”def”的引用值，那么这样一分析之后，下面三个打印的值就容易理解了。</p><p><strong>总结</strong></p><ul><li>全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。</li><li>class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。</li><li>运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</li><li>public  String(String string)….. 构造方法，所以new 本身就是一个对象实例，实例只可能存在堆中，这是jvm规范</li><li>class常量池是编译后，字节码中提到的，每个字节码都可能存着一些字符串，这些字符串很多相同的那么这些类在运行时候，难道要在内存中保存相同的内容吗？当然不会所以，有全局字符串常量池，而运行时常量池，主要是这个类的字节码的东西，运行起来的存储，所以一个类，一个运行时常量池。</li></ul>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO实验的一些常用命令总结</title>
      <link href="/2022/07/23/IO-2022-07-23-IO%E5%AE%9E%E9%AA%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/23/IO-2022-07-23-IO%E5%AE%9E%E9%AA%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>必须熟练使用的指令以及注意事项</p><h3 id="stat：可以查看文件的详细信息"><a href="#stat：可以查看文件的详细信息" class="headerlink" title="stat：可以查看文件的详细信息"></a>stat：可以查看文件的详细信息</h3> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat msb.txt</span><br></pre></td></tr></table></figure><h3 id="ln：建立符号连接、硬连接"><a href="#ln：建立符号连接、硬连接" class="headerlink" title="ln：建立符号连接、硬连接"></a>ln：建立符号连接、硬连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln   [s]    已有的    不存在的</span><br></pre></td></tr></table></figure><h3 id="dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换"><a href="#dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换" class="headerlink" title="dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换"></a>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换</h3><blockquote><p><a href="https://www.cnblogs.com/fantasyxo/p/10519662.html" target="_blank" rel="noopener">https://www.cnblogs.com/fantasyxo/p/10519662.html</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;</span><br><span class="line">of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</span><br><span class="line">ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。</span><br><span class="line">obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。</span><br><span class="line">bs=bytes：同时设置读入/输出的块大小为bytes个字节。</span><br><span class="line">cbs=bytes：一次转换bytes个字节，即指定转换缓冲区大小。</span><br><span class="line">skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</span><br><span class="line">seek=blocks：从输出文件开头跳过blocks个块后再开始复制。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将/dev/hdb全盘数据备份到指定路径的image文件</span><br><span class="line">    heng@me: dd if=/dev/hdb of=/root/image</span><br><span class="line">测试硬盘的读写速度</span><br><span class="line">    heng@me: dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file</span><br><span class="line"> heng@me: dd if=/root/1Gb.file bs=64k | dd of=/dev/null</span><br></pre></td></tr></table></figure><h3 id="losetup"><a href="#losetup" class="headerlink" title="losetup:"></a>losetup:</h3><p>循环设备可把文件虚拟成区块设备，籍以模拟整个文件系统，让用户得以将其视为硬盘驱动器，光驱或软驱等设备，并挂入当作目录来使用</p><blockquote><p><a href="https://www.runoob.com/linux/linux-comm-losetup.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-losetup.html</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">模拟文件系统：</span><br><span class="line">生成文件 floppy.img</span><br><span class="line">mkfs.ext4 loopfile.img</span><br><span class="line">losetup /dev/loop0 floppy.img</span><br><span class="line">mount /dev/loop0 /tmp</span><br><span class="line">结束测试</span><br><span class="line">umount /tmp</span><br><span class="line">losetup -d /dev/loop1</span><br></pre></td></tr></table></figure><h3 id="exec"><a href="#exec" class="headerlink" title="exec:"></a>exec:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell的内建命令exec将并不启动新的shell，而是用要被执行命令替换当前的shell进程，并且将老进程的环境清理掉，而且exec命令后的其它命令将不再执行。 </span><br><span class="line">因此，如果你在一个shell里面，执行exec ls那么，当列出了当前目录后，这个shell就自己退出了，因为这个shell进程已被替换为仅仅执行ls命令的一个进程，执行结束自然也就退出了。为了避免这个影响我们的使用，一般将exec命令放到一个shell脚本里面，用主脚本调用这个脚本，调用点处可以用bash a.sh，（a.sh就是存放该命令的脚本），这样会为a.sh建立一个sub shell去执行，当执行到exec后，该子脚本进程就被替换成了相应的exec的命令。 </span><br><span class="line">source命令或者&quot;.&quot;，不会为脚本新建shell，而只是将脚本包含的命令在当前shell执行。 </span><br><span class="line">不过，要注意一个例外，当exec命令来对文件描述符操作的时候，就不会替换shell，而且操作完成后，还会继续执行接下来的命令。 </span><br><span class="line">  exec 3&lt;&amp;0:这个命令就是将操作符3也指向标准输入</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.exec 命令 ;命令代替shell程序，命令退出，shell 退出；比如 exec ls</span><br><span class="line">2.exec 文件重定向，可以将文件的重定向就看为是shell程序的文件重定向 比如 exec 5&lt;/dev/null;exec 5&lt;&amp;-</span><br><span class="line">另外,这个命令还可以作为find命令的一个选项,如下所示: </span><br><span class="line">(1)在当前目录下(包含子目录)，查找所有txt文件并找出含有字符串"bin"的行 </span><br><span class="line">find ./ -name "*.txt" -exec grep "bin" &#123;&#125; \; </span><br><span class="line">(2)在当前目录下(包含子目录)，删除所有txt文件 </span><br><span class="line">find ./ -name "*.txt" -exec rm &#123;&#125; \; </span><br><span class="line">exec命令                  作用</span><br><span class="line"> </span><br><span class="line">exec ls          在shell中执行ls，ls结束后不返回原来的shell中了</span><br><span class="line">exec &lt;file       将file中的内容作为exec的标准输入</span><br><span class="line">exec &gt;file       将file中的内容作为标准写出 </span><br><span class="line">exec 3&lt;file      将file读入到fd3中 </span><br><span class="line">sort &lt;&amp;3         fd3中读入的内容被分类 </span><br><span class="line">exec 4&gt;file      将写入fd4中的内容写入file中 </span><br><span class="line">ls &gt;&amp;4           Ls将不会有显示，直接写入fd4中了，即上面的file中</span><br><span class="line">exec 5&lt;&amp;4         创建fd4的拷贝fd5 </span><br><span class="line">exec 3&lt;&amp;-         关闭fd3</span><br></pre></td></tr></table></figure><h3 id="lsof："><a href="#lsof：" class="headerlink" title="lsof："></a>lsof：</h3><p>lsof(list open files)是一个列出当前系统打开文件的工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看服务器 8000 端口的占用情况：</span><br><span class="line">lsof -i:8000</span><br><span class="line">使用-p查看指定进程ID已打开的内容</span><br><span class="line">lsof -p[o] PID  :查看进程打开的所有文件，O参数是文件的偏移量</span><br></pre></td></tr></table></figure><h3 id="sysctl-a"><a href="#sysctl-a" class="headerlink" title="sysctl:  -a"></a>sysctl:  -a</h3><p>可以查看所有系统级别的参数</p><p> sysctl -a | grep dirty 可以找到所有page cache相关的参数</p><h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump:"></a>tcpdump:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">采用命令行方式对接口的数据包进行筛选抓取。</span><br><span class="line">不带任何选项的tcpdump ,默认抓取第一个网络接口。只有将tcpdump进程终止，抓包停止</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-c指定抓取包的数量，即最后显示的数量</span><br><span class="line">-i指定tcpdump监听的网卡。未指定，选择系统中最小的以配置端口。</span><br><span class="line">    -i any:监听所有网络端口 </span><br><span class="line">    -i lo:监听lookback接口。</span><br><span class="line">-nn 对监听地址以数字方式呈现，且对端口也以数字方式呈现。如果不指定 ，地址以man 主机名方式呈现，端口以服务名方式呈现</span><br><span class="line">-P指定要抓取的包是流入还是流出 （in out inout[默认]）</span><br><span class="line">-s 设置tcpdump的数据包抓取长度，默认为65535字节。</span><br><span class="line">-e输出的每行都包含数据链路层的头部信息。</span><br><span class="line">-D列出所有可以用于抓包的表达式。</span><br><span class="line">-X显示协议头和包的全部内容。</span><br><span class="line">-F从文件中读取抓包的表达式。</span><br><span class="line">应用示例：</span><br><span class="line">（1）tcpdump -i eth0 host 192.168.1.1 【过滤主机】</span><br><span class="line">         注：抓取所有经过网卡1，目的ip为192.168.1.1</span><br><span class="line">（2）tcpdump -i  eth0 dst port 22 【过滤端口】</span><br><span class="line">       注：抓取所有经过网卡1，目的端口为22的网络数据</span><br><span class="line">（3）tcpdump -i eth0 udp 【过滤协议】</span><br><span class="line">       注；抓取所有经过网卡1，协议为UDP的协议。</span><br><span class="line">（4）tcpdupmp -i lo udp 【抓取本地环路数据包】</span><br><span class="line">（5）特定协议特定端口</span><br><span class="line">           tcpdump udp port 22</span><br><span class="line">（6）抓取特定类型的数据包</span><br><span class="line">          tcpdump -i eth0 'tcp[tcpflags] = tcp-syn' (抓取所有经过网卡1的SYN类型的数据包)</span><br><span class="line">          tcpdump -i eth0 udp dst port 53(抓取经过网卡1的所有DNS数据包)</span><br><span class="line">（7）逻辑语句过滤</span><br><span class="line">          tcpdump -i eth0 '((tcp) and ((dst net 192.168.0) and (not dst host 192.168.0.2)))'</span><br><span class="line">         注：抓取所有经过网卡1，目的网络是192.168.0，但目的主机不是192.168.0.2的TCP数据。   </span><br><span class="line">（8）抓包存取</span><br><span class="line">       tcpdump -i eth0 host 192.168.1.51 and port 22 -w /tmp/tcpdump.cap</span><br><span class="line">       注：抓取所有经过网卡1，目的主机为192.168.1.51的网络数据并存储。</span><br><span class="line"> 常用 ：tcpdump -i lo/eth0 -nn -port xxx</span><br></pre></td></tr></table></figure><h3 id="strace"><a href="#strace" class="headerlink" title="strace:"></a>strace:</h3><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 通过strace可以知道应用程序打开了哪些文件,以及读写了什么内容,包括消耗的时间以及返回值等。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-f 跟踪由fork调用所产生的子进程. </span><br><span class="line">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.</span><br></pre></td></tr></table></figure><blockquote><p>一次排查问题的应用：<a href="https://blog.csdn.net/cs729298/article/details/81906375" target="_blank" rel="noopener">https://blog.csdn.net/cs729298/article/details/81906375</a></p></blockquote><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用strace调试程序：</span><br><span class="line">    我决定采用strace看一下在启动 dcopserver时到底程序做了什么：</span><br><span class="line">    strace -f -F -o ~/dcop-strace.txt dcopserver</span><br><span class="line">解决库依赖问题</span><br><span class="line">限制strace只跟踪特定的系统调用：如果你已经知道你要找什么，你可以让strace只跟踪一些类型的系统调用</span><br><span class="line">    strace -f -o configure-strace.txt -e execve ./configure</span><br><span class="line">常用：strace -ff -o out /usr/java/bin/java TestSocket</span><br></pre></td></tr></table></figure><h3 id="route："><a href="#route：" class="headerlink" title="route："></a>route：</h3><p>Linux系统的route命令用于显示和操作IP路由表（show / manipulate the IP routing table）。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。</p><blockquote><p><a href="https://blog.csdn.net/xiaozhongma/article/details/52945029?locationNum=2&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/xiaozhongma/article/details/52945029?locationNum=2&amp;fps=1</a></p></blockquote><div class="table-container"><table><thead><tr><th>Destination</th><th>目标网段或者主机</th></tr></thead><tbody><tr><td>Gateway</td><td>网关地址，”*” 表示目标是本主机所属的网络，不需要路由</td></tr><tr><td>Genmask</td><td>网络掩码</td></tr><tr><td>Flags</td><td>标记。一些可能的标记如下：</td></tr><tr><td></td><td>U — 路由是活动的</td></tr><tr><td></td><td>H — 目标是一个主机</td></tr><tr><td></td><td>G — 路由指向网关</td></tr><tr><td></td><td>R — 恢复动态路由产生的表项</td></tr><tr><td></td><td>D — 由路由的后台程序动态地安装</td></tr><tr><td></td><td>M — 由路由的后台程序修改</td></tr><tr><td></td><td>! — 拒绝路由</td></tr><tr><td>Metric</td><td>路由距离，到达指定网络所需的中转数（linux 内核中没有使用）</td></tr><tr><td>Ref</td><td>路由项引用次数（linux 内核中没有使用）</td></tr><tr><td>Use</td><td>此路由项被路由软件查找的次数</td></tr><tr><td>Iface</td><td>该路由表项对应的输出接口</td></tr></tbody></table></div><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">实例1：显示当前路由</span><br><span class="line">    route</span><br><span class="line">    route -n</span><br><span class="line">    route -n (-n 表示不解析名字,列出速度会比route 快)</span><br><span class="line">实例2：添加网关/设置网关</span><br><span class="line">    route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0</span><br><span class="line">实例3：屏蔽一条路由</span><br><span class="line">    route add -net 224.0.0.0 netmask 240.0.0.0 reject</span><br><span class="line">实例4：删除路由记录</span><br><span class="line">    route del -net 224.0.0.0 netmask 240.0.0.0</span><br><span class="line">    route del -net 224.0.0.0 netmask 240.0.0.0 reject</span><br><span class="line">实例5：删除和添加设置默认网关</span><br><span class="line">    route del default gw 192.168.120.240</span><br><span class="line">    route add default gw 192.168.120.240</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的8个变量</title>
      <link href="/2022/07/23/mysql-2022-07-23-mysql%E7%9A%848%E4%B8%AA%E5%8F%98%E9%87%8F/"/>
      <url>/2022/07/23/mysql-2022-07-23-mysql%E7%9A%848%E4%B8%AA%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>　本篇会简单介绍在 MySQL 中关于 8个 character_set 变量的基本作用。</p></blockquote><p>　使用下列<a href="https://so.csdn.net/so/search?q=SQL语句&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">SQL语句</a>可以查看 MySQL中8个 character_set 变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE&#39;%char%&#39;;</span><br></pre></td></tr></table></figure><p>8个 character_set 变量：</p><p>　　一、character_set_client</p><p>　　二、character_set_connection</p><p>　　三、character_set_database</p><p>　　四、character_set_filesystem</p><p>　　五、character_set_results</p><p>　　六、character_set_server</p><p>　　七、character_set_system</p><p>　　八、character_sets_dir</p><p><em>一、character_set_client</em></p><p>　　主要用来设置客户端使用的字符集。</p><p><em>二、character_set_connection</em></p><p>　　主要用来设置连接数据库时的字符集，如果程序中没有指明连接数据库使用的字符集类型则按照这个字符集设置。</p><p><em>三、character_set_database</em></p><p>　　主要用来设置默认创建数据库的编码格式，如果在创建数据库时没有设置编码格式，就按照这个格式设置。</p><p><em>四、character_set_filesystem</em></p><p>　　文件系统的编码格式，把操作系统上的文件名转化成此字符集，即把 character_set_client转换character_set_filesystem， 默认binary是不做任何转换的。</p><p><em>五、character_set_results</em></p><p>　　数据库给客户端返回时使用的编码格式，如果没有指明，使用服务器默认的编码格式。</p><p><em>六、character_set_server</em></p><p>　　服务器安装时指定的默认编码格式，这个变量建议由系统自己管理，不要人为定义。</p><p><em>七、character_set_system</em></p><p>　　数据库系统使用的编码格式，这个值一直是utf8，不需要设置，它是为存储系统元数据的编码格式。</p><p><em>八、character_sets_dir</em></p><p>　　这个变量是字符集安装的目录。</p><p><em>在启动mysql后，我们只关注下列变量是否符合我们的要求</em></p><ul><li>character_set_client</li><li>character_set_connection</li><li>character_set_database</li><li>character_set_results</li><li>character_set_server</li></ul><p><em>下列三个系统变量我们不需要关心，不会影响乱码等问题</em></p><ul><li>character_set_filesystem</li><li>character_set_system</li><li>character_sets_dir</li></ul><p><strong>更改以上字符集直接 set character_set_XXX = “gbk”;（XXX是写以上的变量名）</strong></p><p><em>借助网上的一个完整的用户请求的字符集转换流程来更好的理解上述几个变量：</em></p><ol><li>mysql Server收到请求时将请求数据从 <strong>character_set_client</strong> 转换为 <strong>character_set_connection</strong></li><li>进行内部操作前将请求数据从 <strong>character_set_connection</strong> 转换为内部操作字符集,步骤如下</li></ol><p>　　A. 使用每个数据字段的 <strong>CHARACTER SET</strong> 设定值；</p><p>　　B. 若上述值不存在，则使用对应数据表的字符集设定值</p><p>　　C. 若上述值不存在，则使用对应数据库的字符集设定值；</p><p>　　D. 若上述值不存在，则使用 <strong>character_set_server</strong> 设定值。</p><ol><li>最后将操作结果从内部操作字符集转换为 <strong>character_set_results</strong></li></ol><p><img src="1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql编码错进错出解释</title>
      <link href="/2022/07/23/mysql-2022-07-23-mysql%E7%BC%96%E7%A0%81%E9%94%99%E8%BF%9B%E9%94%99%E5%87%BA%E8%A7%A3%E9%87%8A/"/>
      <url>/2022/07/23/mysql-2022-07-23-mysql%E7%BC%96%E7%A0%81%E9%94%99%E8%BF%9B%E9%94%99%E5%87%BA%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h3 id="相关变量"><a href="#相关变量" class="headerlink" title="相关变量"></a>相关变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET character_set_client &#x3D; charset_name;</span><br><span class="line">SET character_set_results &#x3D; charset_name;</span><br><span class="line">SET character_set_connection &#x3D; charset_name;</span><br></pre></td></tr></table></figure><h3 id="过程复现及原理解释"><a href="#过程复现及原理解释" class="headerlink" title="过程复现及原理解释"></a>过程复现及原理解释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先假设客户端bash都是utf8</span><br><span class="line">SET character_set_client &#x3D; gbk;</span><br><span class="line">SET character_set_results &#x3D; gbk;</span><br></pre></td></tr></table></figure><ol><li><strong>客户端发送’你好’，使用utf8编码</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select hex(convert(&#39;你好&#39; using utf8));</span><br><span class="line">+-----------------------------------+</span><br><span class="line">| hex(convert(&#39;你好&#39; using utf8))   |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">| E4BDA0E5A5BD                      |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><ol><li><strong>服务端按照gbk错误解码,解出，3个字符’浣犲ソ’，由引擎进行语法解析</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select convert(0xE4BDA0E5A5BD using gbk);</span><br><span class="line">+-----------------------------------+</span><br><span class="line">| convert(0xE4BDA0E5A5BD using gbk) |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">| 浣犲ソ                            |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ol><li><strong>解析完之后，server端需要先判断 character_set_client与character_set_connection是否一致，若不一致需要编码转换（但注意最终存储是按照table的chartset 编码方式进行的）</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select hex(convert(&#39;浣犲ソ&#39; using utf8));</span><br><span class="line">+--------------------------------------+</span><br><span class="line">| hex(convert(&#39;浣犲ソ&#39; using utf8))    |</span><br><span class="line">+--------------------------------------+</span><br><span class="line">| E6B5A3E78AB2E382BD                   |</span><br><span class="line">+--------------------------------------+</span><br></pre></td></tr></table></figure><ol><li><strong>转换完成之后，准备进行存储了，再判断表的charset是什么编码，进行转换，表我们用utf8，编码一致，最终存储即 E6B5A3E78AB2E382BD，代表字符 ‘浣犲ソ’</strong></li><li>当进行查询时候，server按照character_set_results 进行编码返回，存储的是utf8，所以需要编码转换，<font color = red>注意，编码转换不是错误解码，并不是对这个二进制按照gbk解码，而是说，对‘浣犲ソ’ ，转换成在gbk编码方式下的二进制存储（这也意味着两种编码方式的字库表一定是都包含这几个字符，不然怎么转换编码？实际上，utf8兼容gbk对应编码，gbk是字库表是字符集）</font></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select hex(convert(&#39;浣犲ソ&#39; using gbk));</span><br><span class="line">+-------------------------------------+</span><br><span class="line">| hex(convert(&#39;浣犲ソ&#39; using gbk))    |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">| E4BDA0E5A5BD                        |</span><br><span class="line">+-------------------------------------+</span><br></pre></td></tr></table></figure><ol><li><strong>此时客户端收到E4BDA0E5A5BD ，在gbk编码下代表’浣犲ソ’，但是此时bash用了utf8,所以我们用了错误的编码方式</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select convert(0xE4BDA0E5A5BD using utf8);</span><br><span class="line">+------------------------------------+</span><br><span class="line">| convert(0xE4BDA0E5A5BD using utf8) |</span><br><span class="line">+------------------------------------+</span><br><span class="line">| 你好                               |</span><br><span class="line">+------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><p>character_set_client 和 character_set_results 是一定要和客户端一致，不要依赖于负负得正，character_set_connection 设置和character_set_client 不一致，有丢失数据的风险，所以尽量也一致，总之这3个值就是要一样，还要和客户端一致，所以才有了 set names 这个快捷命令。</p></li><li><p>只要保证set nams的3个变量 以及客户端bash编码一致，就不会乱码,在加上表编码也是utf8，保证这4样都是utf8，肯定不会乱码。注意表的charset要是latin1，由于支持不了中文，不如utf8字符集大，会出现有损转换，千万注意。</p></li></ol><blockquote><p>参考：<a href="https://blog.csdn.net/czh500/article/details/86665509" target="_blank" rel="noopener">https://blog.csdn.net/czh500/article/details/86665509</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解和解决MySQL乱码问题</title>
      <link href="/2022/07/23/mysql-2022-07-23-%E7%90%86%E8%A7%A3%E5%92%8C%E8%A7%A3%E5%86%B3MySQL%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/07/23/mysql-2022-07-23-%E7%90%86%E8%A7%A3%E5%92%8C%E8%A7%A3%E5%86%B3MySQL%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载网络好文:<a href="http://cenalulu.github.io/mysql/mysql-mojibake/" target="_blank" rel="noopener">http://cenalulu.github.io/mysql/mysql-mojibake/</a></p><p>本文将详细介绍MySQL乱码的成因和具体的解决方案</p><p>在阅读本文之前，强烈建议对字符集编码概念还比较模糊的同学 阅读下博主之前对相关概念的一篇科普：<a href="http://cenalulu.github.io/linux/character-encoding/" target="_blank" rel="noopener">十分钟搞清字符集和字符编码</a></p></blockquote><h2 id="MySQL出现乱码的原因"><a href="#MySQL出现乱码的原因" class="headerlink" title="MySQL出现乱码的原因"></a>MySQL出现乱码的原因</h2><p>要了解为什么会出现乱码，我们就先要理解：从客户端发起请求，到MySQL存储数据，再到下次从表取回客户端的过程中，哪些环节会有编码/解码的行为。为了更好的解释这个过程，博主制作了两张流程图，分别对应存入和取出两个阶段。</p><h4 id="存入MySQL经历的编码转换过程"><a href="#存入MySQL经历的编码转换过程" class="headerlink" title="存入MySQL经历的编码转换过程"></a>存入MySQL经历的编码转换过程</h4><p><img src="http://cenalulu.github.io/images/mysql/mojibake/flow.png" alt="mysqlflow"> 上图中有3次编码/解码的过程（红色箭头）。三个红色箭头分别对应：客户端编码，MySQL Server解码，Client编码向表编码的转换。其中Terminal可以是一个Bash，一个web页面又或者是一个APP。本文中我们假定Bash是我们的Terminal，即用户端的输入和展示界面。图中每一个框格对应的行为如下：</p><ul><li>在terminal中使用输入法输入</li><li>terminal根据字符编码转换成二进制流</li><li>二进制流通过MySQL客户端传输到MySQL Server</li><li>Server通过character-set-client解码</li><li>判断character-set-client和目标表的charset是否一致</li><li>如果不一致则进行一次从client-charset到table-charset的一次字符编码转换</li><li>将转换后的字符编码二进制流存入文件中</li></ul><h4 id="从MySQL表中取出数据经历的编码转换过程"><a href="#从MySQL表中取出数据经历的编码转换过程" class="headerlink" title="从MySQL表中取出数据经历的编码转换过程"></a>从MySQL表中取出数据经历的编码转换过程</h4><p><img src="http://cenalulu.github.io/images/mysql/mojibake/flow2.png" alt="mysqlflow"> 上图有3次编码/解码的过程（红色箭头）。上图中三个红色箭头分别对应：客户端解码展示，MySQL Server根据<code>character-set-client</code>编码，表编码向<code>character-set-client</code>编码的转换。</p><ul><li>从文件读出二进制数据流</li><li>用表字符集编码进行解码</li><li>将数据转换为character-set-client的编码</li><li>使用character-set-client编码为二进制流</li><li>Server通过网络传输到远端client</li><li>client通过bash配置的字符编码展示查询结果</li></ul><h4 id="造成MySQL乱码的原因"><a href="#造成MySQL乱码的原因" class="headerlink" title="造成MySQL乱码的原因"></a>造成MySQL乱码的原因</h4><p><em>1. 存入和取出时对应环节的编码不一致</em> 这个会造成乱码是显而易见的。我们把存入阶段的三次编解码使用的字符集编号为C1,C2,C3（图一从左到右）；取出时的三个字符集依次编号为C1’,C2’,C3’（从左到右）。那么存入的时候bash <code>C1</code>用的是UTF-8编码，取出的时候,<code>C1&#39;</code>我们却使用了windows终端（默认是GBK编码），那么结果几乎一定是乱码。又或者存入MySQL的时候<code>set names utf8</code>(<code>C2</code>)，而取出的时候却使用了<code>set names gbk</code>(<code>C2&#39;</code>)，那么结果也必然是乱码</p><p><em>2. 单个流程中三步的编码不一致</em> 即上面任意一幅图中的同方向的三步中，只要两步或者两部以上的编码有不一致就有可能出现编解码错误。如果差异的两个字符集之间无法进行无损编码转换（下文会详细介绍），那么就一定会出现乱码。例如：我们的shell是UTF8编码，MySQL的<code>character-set-client</code>配置成了GBK，而表结构却又是<code>charset=utf8</code>，那么毫无疑问的一定会出现乱码。 这里我们就简单演示下这种情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; create table charset_test_utf8 (id int primary key auto_increment, char_col varchar(50)) charset &#x3D; utf8;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; set names gbk;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; insert into charset_test_utf8 (char_col) values (&#39;中文&#39;);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; show warnings;</span><br><span class="line">+---------+------+---------------------------------------------------------------------------+</span><br><span class="line">| Level   | Code | Message                                                                   |</span><br><span class="line">+---------+------+---------------------------------------------------------------------------+</span><br><span class="line">| Warning | 1366 | Incorrect string value: &#39;\xAD\xE6\x96\x87&#39; for column &#39;char_col&#39; at row 1 |</span><br><span class="line">+---------+------+---------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; select id,hex(char_col),char_col from charset_test_utf8;</span><br><span class="line">+----+----------------+----------+</span><br><span class="line">| id | hex(char_col)  | char_col |</span><br><span class="line">+----+----------------+----------+</span><br><span class="line">|  1 | E6B6933FE69E83 | �?��        |</span><br><span class="line">+----+----------------+----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><h4 id="关于MySQL的编-解码"><a href="#关于MySQL的编-解码" class="headerlink" title="关于MySQL的编/解码"></a>关于MySQL的编/解码</h4><p>既然系统之间是按照二进制流进行传输的，那直接把这串二进制流直接存入表文件就好啦。为什么在存储之前还要进行两次编解码的操作呢？</p><ul><li>Client to Server的编解码的原因是MySQL需要对传来的二进制流做语法和词法解析。如果不做编码解析和校验，我们甚至没法知道传来的一串二进制流是<code>insert</code>还是<code>update</code>。</li><li>File to Engine的编解码是为知道二进制流内的分词情况。举个简单的例子：我们想要从表里取出某个字段的前两个字符，执行了一句形如<code>select left(col,2) from table</code>的语句，存储引擎从文件读入该column的值是<code>E4B8ADE69687</code>。那么这个时候如果我们按照GBK把这个值分割成<code>E4B8</code>,<code>ADE6</code>,<code>9687</code>三个字，并那么返回客户端的值就应该是<code>E4B8ADE6</code>；如果按照UTF8分割成<code>E4B8AD</code>,<code>E69687</code>，那么就应该返回<code>E4B8ADE69687</code>两个字。可见，如果在从数据文件读入数据后，不进行编解码的话在存储引擎内部是无法进行字符级别的操作的。</li></ul><hr><h2 id="关于错进错出"><a href="#关于错进错出" class="headerlink" title="关于错进错出"></a>关于错进错出</h2><p>在MySQL中最常见的乱码问题的起因就是把<code>错进错出</code>神话。所谓的错进错出就是，客户端(web或shell)的字符编码和最终表的字符编码格式不同，但是只要保证存和取两次的字符集编码一致就仍然能够获得没有乱码的输出的这种现象。但是，错进错出并不是对于任意两种字符集编码的组合都是有效的。我们假设客户端的编码是C，MySQL表的字符集编码是S。那么为了能够错进错出，需要满足以下两个条件</p><blockquote><p>MySQL接收请求时，从C编码后的二进制流在被S解码时能够无损 MySQL返回数据是，从S编码后的二进制流在被C解码时能够无损</p></blockquote><h4 id="编码无损转换"><a href="#编码无损转换" class="headerlink" title="编码无损转换"></a>编码无损转换</h4><p>那么什么是有损转换，什么是无损转换呢？假设我们要把用编码A表示的字符X，转化为编码B的表示形式，而编码B的字形集中并没有X这个字符，那么此时我们就称这个转换是有损的。那么，为什么会出现两个编码所能表示字符集合的差异呢？如果大家看过博主之前的那篇 <a href="http://cenalulu.github.io/linux/character-encoding/" target="_blank" rel="noopener">十分钟搞清字符集和字符编码</a>，或者对字符编码有基础理解的话，就应该知道每个字符集所支持的字符数量是有限的，并且各个字符集涵盖的文字之间存在差异。UTF8和GBK所能表示的字符数量范围如下</p><ul><li>GBK单个字符编码后的取值范围是：<code>8140</code> - <code>FEFE</code> 其中不包括<code>**7E</code>，总共字符数在27000左右</li><li>UTF8单个字符编码后，按照字节数的不同，取值范围如下表：</li></ul><p><img src="http://cenalulu.github.io/images/mysql/mojibake/utf8.png" alt="img"></p><p>由于UTF-8编码能表示的字符数量远超GBK。那么我们很容易就能找到一个从UTF8到GBK的有损编码转换。我们用字符映射器（见下图）找出了一个明显就不在GBK编码表中的字符，尝试存入到GBK编码的表中。并再次取出查看有损转换的行为 字符信息具体是：<code>ਅ GURMUKHI LETTER A Unicode: U+0A05, UTF-8: E0 A8 85</code></p><p><img src="http://cenalulu.github.io/images/mysql/mojibake/charset.png" alt="img"></p><p>在MySQL中存储的具体情况如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; create table charset_test_gbk (id int primary key auto_increment, char_col varchar(50)) charset &#x3D; gbk;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; set names utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; insert into charset_test_gbk (char_col) values (&#39;ਅ&#39;);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; show warnings;</span><br><span class="line">+---------+------+-----------------------------------------------------------------------+</span><br><span class="line">| Level   | Code | Message                                                               |</span><br><span class="line">+---------+------+-----------------------------------------------------------------------+</span><br><span class="line">| Warning | 1366 | Incorrect string value: &#39;\xE0\xA8\x85&#39; for column &#39;char_col&#39; at row 1 |</span><br><span class="line">+---------+------+-----------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; select id,hex(char_col),char_col,char_length(char_col) from charset_test_gbk;</span><br><span class="line">+----+---------------+----------+-----------------------+</span><br><span class="line">| id | hex(char_col) | char_col | char_length(char_col) |</span><br><span class="line">+----+---------------+----------+-----------------------+</span><br><span class="line">|  1 | 3F            | ?        |                     1 |</span><br><span class="line">+----+---------------+----------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>出错的部分是在编解码的第3步时发生的。具体见下图 <img src="http://cenalulu.github.io/images/mysql/mojibake/flow3.png" alt="flow2"></p><p>可见MySQL内部如果无法找到一个UTF8字符所对应的GBK字符时，就会转换成一个错误mark（这里是问号）。而每个字符集在程序实现的时候内部都约定了当出现这种情况时的行为和转换规则。例如：UTF8中无法找到对应字符时，如果不抛错那么就将该字符替换成<code>�</code>(U+FFFD)</p><p>那么是不是任何两种字符集编码之间的转换都是有损的呢？并非这样，转换是否有损取决于以下几点：</p><ul><li>被转换的字符是否同时在两个字符集中</li><li>目标字符集是否能够对不支持字符，保留其原有表达形式</li></ul><p>关于第一点，刚才已经通过实验来解释过了。这里来解释下造成有损转换的第二个因素。从刚才的例子我们可以看到由于GBK在处理自己无法表示的字符时的行为是：用<code>错误标识</code>替代，即<code>0x3F</code>。而有些字符集（例如latin1）在遇到自己无法表示的字符时，会保留原字符集的编码数据，并跳过忽略该字符进而处理后面的数据。如果目标字符集具有这样的特性，那么就能够实现这节最开始提到的<code>错进错出</code>的效果。 我们来看下面这个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; create table charset_test (id int primary key auto_increment, char_col varchar(50)) charset &#x3D; latin1;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; set names latin1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; insert into charset_test (char_col) values (&#39;中文&#39;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; select id,hex(char_col),char_col from charset_test;</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">| id | hex(char_col) | char_col |</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">|  2 | E4B8ADE69687  | 中文     |</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>具体流程图如下。可见在被MySQL Server接收到以后实际上已经发生了编码不一致的情况。但是由于Latin1字符集对于自己表述范围外的字符不会做任何处理，而是保留原值。这样的行为也使得错进错出成为了可能。 <img src="http://cenalulu.github.io/images/mysql/mojibake/flow4.png" alt="flow4"></p><hr><h2 id="如何避免乱码"><a href="#如何避免乱码" class="headerlink" title="如何避免乱码"></a>如何避免乱码</h2><p>理解了上面的内容，要避免乱码就显得很容易了。只要做到“三位一体”，即客户端，MySQL character-set-client，table charset三个字符集完全一致就可以保证一定不会有乱码出现了。而对于已经出现乱码，或者已经遭受有损转码的数据，如何修复相对来说就会有些困难。下一节我们详细介绍具体方法。</p><h2 id="如何修复已经编码损坏的数据"><a href="#如何修复已经编码损坏的数据" class="headerlink" title="如何修复已经编码损坏的数据"></a>如何修复已经编码损坏的数据</h2><p>在介绍正确方法前，我们先科普一下那些网上流传的所谓的“正确方法”可能会造成的严重后果。</p><h4 id="错误方法一"><a href="#错误方法一" class="headerlink" title="错误方法一"></a>错误方法一</h4><p>无论从语法还是字面意思来看：<code>ALTER TABLE ... CHARSET=xxx</code> 无疑是最像包治乱码的良药了！而事实上，他对于你已经损坏的数据一点帮助也没有，甚至连已经该表已经创建列的默认字符集都无法改变。我们看下面这个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; show create table charset_test;</span><br><span class="line">+--------------+--------------------------------+</span><br><span class="line">| Table        | Create Table                   |</span><br><span class="line">+--------------+--------------------------------+</span><br><span class="line">| charset_test | CREATE TABLE &#96;charset_test&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;char_col&#96; varchar(50) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;3 DEFAULT CHARSET&#x3D;latin1 |</span><br><span class="line">+--------------+--------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; alter table charset_test charset&#x3D;gbk;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; show create table charset_test;</span><br><span class="line">+--------------+--------------------------------+</span><br><span class="line">| Table        | Create Table                   |</span><br><span class="line">+--------------+--------------------------------+</span><br><span class="line">| charset_test | CREATE TABLE &#96;charset_test&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;char_col&#96; varchar(50) CHARACTER SET latin1 DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;3 DEFAULT CHARSET&#x3D;gbk |</span><br><span class="line">+--------------+--------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可见该语法紧紧修改了表的默认字符集，即只对以后创建的列的默认字符集产生影响，而对已经存在的列和数据没有变化。</p><h4 id="错误方法二"><a href="#错误方法二" class="headerlink" title="错误方法二"></a>错误方法二</h4><p><code>ALTER TABLE … CONVERT TO CHARACTER SET …</code>的相较于方法一来说杀伤力更大，因为从 <a href="http://dev.mysql.com/doc/refman/5.1/en/alter-table.html" target="_blank" rel="noopener">官方文档的解释</a> 他的作用就是用于对一个表的数据进行编码转换。下面是文档的一小段摘录：</p><blockquote><p>To change the table default character set and all character columns (CHAR, VARCHAR, TEXT) to a new character set, use a statement like this: ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name [COLLATE collation_name];</p></blockquote><p><strong>而实际上，这句语法只适用于当前并没有乱码，并且不是通过<code>错进错出</code>的方法保存的表。</strong>。而对于已经因为错进错出而产生编码错误的表，则会带来更糟的结果。我们用一个实际例子来解释下，这句SQL实际做了什么和他会造成的结果。假设我们有一张编码是latin1的表，且之前通过错进错出存入了UTF-8的数据，但是因为通过terminal仍然能够正常显示。即上文错进错出章节中举例的情况。一段时间使用后我们发现了这个错误，并打算把表的字符集编码改成UTF-8并且不影响原有数据的正常显示。这种情况下使用<code>alter table convert to character set</code>会有这样的后果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; create table charset_test_latin1 (id int primary key auto_increment, char_col varchar(50)) charset &#x3D; latin1;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; set names latin1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; insert into charset_test_latin1 (char_col) values (&#39;这是中文&#39;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; select id,hex(char_col),char_col,char_length(char_col) from charset_test_latin1;</span><br><span class="line">+----+--------------------------+--------------+-----------------------+</span><br><span class="line">| id | hex(char_col)            | char_col     | char_length(char_col) |</span><br><span class="line">+----+--------------------------+--------------+-----------------------+</span><br><span class="line">|  1 | E8BF99E698AFE4B8ADE69687 | 这是中文     |                    12 |</span><br><span class="line">+----+--------------------------+--------------+-----------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; alter table charset_test_latin1 convert to character set utf8;</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; set names utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; select id,hex(char_col),char_col,char_length(char_col) from charset_test_latin1;</span><br><span class="line">+----+--------------------------------------------------------+-----------------------------+-----------------------+</span><br><span class="line">| id | hex(char_col)                                          | char_col                    | char_length(char_col) |</span><br><span class="line">+----+--------------------------------------------------------+-----------------------------+-----------------------+</span><br><span class="line">|  1 | C3A8C2BFE284A2C3A6CB9CC2AFC3A4C2B8C2ADC3A6E28093E280A1 | è¿™æ˜¯ä¸­æ–‡                |                    12 |</span><br><span class="line">+----+--------------------------------------------------------+-----------------------------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>从这个例子我们可以看出，对于已经错进错出的数据表，这个命令不但没有起到“拨乱反正”的效果，还会彻底将数据糟蹋，连数据的二进制编码都改变了。</p><h4 id="正确的方法一-Dump-amp-Reload"><a href="#正确的方法一-Dump-amp-Reload" class="headerlink" title="正确的方法一 Dump &amp; Reload"></a>正确的方法一 Dump &amp; Reload</h4><p>这个方法比较笨，但也比较好操作和理解。简单的说分为以下三步：</p><ol><li>通过错进错出的方法，导出到文件</li><li>用正确的字符集修改新表</li><li>将之前导出的文件导回到新表中</li></ol><p>还是用上面那个例子举例，我们用UTF-8将数据“错进”到latin1编码的表中。现在需要将表编码修改为UTF-8可以使用以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; mysqldump -u root -p -t --skip-set-charset --default-character-set&#x3D;utf8 test charset_test_latin1 &gt; data.sql</span><br><span class="line">#确保导出的文件用文本编辑器在UTF-8编码下查看没有乱码</span><br><span class="line">shell&gt; mysql -uroot -p -e &#39;create table charset_test_latin1 (id int primary key auto_increment, char_col varchar(50)) charset &#x3D; utf8&#39; test</span><br><span class="line">shell&gt; mysql -uroot -p  --default-character-set&#x3D;utf8 test &lt; data.sql</span><br></pre></td></tr></table></figure><h4 id="正确的方法二-Convert-to-Binary-amp-Convert-Back"><a href="#正确的方法二-Convert-to-Binary-amp-Convert-Back" class="headerlink" title="正确的方法二 Convert to Binary &amp; Convert Back"></a>正确的方法二 Convert to Binary &amp; Convert Back</h4><p>这种方法比较取巧，用的是将二进制数据作为中间数据的做法来实现的。由于，MySQL再将有编码意义的数据流，转换为无编码意义的二进制数据的时候并不做实际的数据转换。而从二进制数据准换为带编码的数据时，又会用目标编码做一次编码转换校验。通过这两个特性就相当于在MySQL内部模拟了一次“错出”，将乱码“拨乱反正”了。</p><p>还是用上面那个例子举例，我们用UTF-8将数据“错进”到latin1编码的表中。现在需要将表编码修改为UTF-8可以使用以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE charset_test_latin1 MODIFY COLUMN char_col VARBINARY(50);</span><br><span class="line">mysql&gt; ALTER TABLE charset_test_latin1 MODIFY COLUMN char_col varchar(50) character set utf8;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ol><li><a href="http://www.psce.com/blog/2015/03/03/mysql-character-encoding-part-2/" target="_blank" rel="noopener">http://www.psce.com/blog/2015/03/03/mysql-character-encoding-part-2/</a></li><li><a href="http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php" target="_blank" rel="noopener">http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php</a></li><li><a href="http://zh.wikipedia.org/wiki/汉字内码扩展规范" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/%E6%B1%89%E5%AD%97%E5%86%85%E7%A0%81%E6%89%A9%E5%B1%95%E8%A7%84%E8%8C%83</a></li><li><a href="http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php" target="_blank" rel="noopener">http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php</a></li><li><a href="http://blog.csdn.net/ws84643557/article/details/6905167" target="_blank" rel="noopener">http://blog.csdn.net/ws84643557/article/details/6905167</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字库表、编码字符集、字符编码</title>
      <link href="/2022/07/23/mysql-2022-07-23-%E5%AD%97%E5%BA%93%E8%A1%A8%E3%80%81%E7%BC%96%E7%A0%81%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%81%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
      <url>/2022/07/23/mysql-2022-07-23-%E5%AD%97%E5%BA%93%E8%A1%A8%E3%80%81%E7%BC%96%E7%A0%81%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%81%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><strong>字库表（character repertoire）</strong>：相当于一个 <strong>所有</strong> 可读或者可显示字符的数据库（可读的字符不一定能够直观的显示出来，如回车）。其决定了编码字符集能够展示的字符的范围。每一种编码字符集，应该都对应着一个字库表。例如 ASCII 字符集，对应的字库表就是由换行、回车等控制字符，和数字、大小写字母、英文标点符号等 128 个字符组成的。且这 128 个字符，是按照一定顺序来排列的。<strong>这里需要注意，字库表本身只包含按照顺序排序的字符，而不包含标记字符位置的序号。</strong></p><p><strong>编码字符集（coded character set）</strong>：是字库表中所有字符以及对应的编码的集合（这里的 “编码”，是名词）。每一个编码（Code Point），都是一个二进制代码（因为计算机的底层就是基于二进制的），且都对应着字库表中的一个字符（就类似于摩斯电码，A 对应的代码为 ·-）。而该编码，一般取值为字符在字库表中的位置序号。</p><p>从某种形式上来说，编码字符集是字库表的扩展。</p><p><strong>字符编码</strong>：（这里的 “编码”，是动词）是一种映射规则，通过这种规则，就可以把存储二进制的数据转换成对应的字符，或者把字符转换为用于存储的二进制数据。而不是直接将编码字符集中的编码进行存储，不依照规则，则可能出现乱码。</p><p>因为字符集只规定了字符的二进制代码，却没有规定这个二进制代码如何存储。因此，就需要 “字符编码” 来处理了，即参考某一规则，将原始的二进制代码进行加工，才能进行存储。反过来，也需要根据这一规则将存储的内容进行解码，才能。另外，一个编码字符集，可以对应多种不同的字符编码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编码字符集 Unicode，有 UTF-8、UTF-16、UTF-32 等多种字符编码。</span><br><span class="line"></span><br><span class="line">编码字符集 ASCII，即对应着 ASCII 字符编码。</span><br><span class="line"></span><br><span class="line">编码字符集 CB2312，只有 EUC-CN 一种字符编码。</span><br></pre></td></tr></table></figure><p>以 Unicode 字符集举例，它对世界上大部分的文字系统进行了整理、编码，使得计算机可以用更为简单的方式来呈现和处理文字。</p><p>UTF-8 是其常用的字符编码之一。它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p><p>（1）比如 大写字母 A，其在 Unicode 字符集中对应的编码为 1000001（二进制）。经过 UTF-8 字符编码后，为 01000001。</p><p>其中 1000001 为原始 Unicode 字符集的二进制编码，01000001 为在计算器中存储时的二进制代码。这两者是要进行区别的。</p><p>（2）对于汉字 严，其在 Unicode 字符集中对应的编码为 100111000100101（二进制）。经过 UTF-8 字符编码后，为 11100100 10111000 10100101。（参考自：<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a>）</p><p>至于具体的 UTF-8 的编码规则，也可以参考 <a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p><blockquote><p><strong>参考文章：</strong></p><p>1、<a href="http://cenalulu.github.io/linux/character-encoding/" target="_blank" rel="noopener">十分钟搞清字符集和字符编码</a></p><p>2、<a href="https://blog.csdn.net/qq_29028175/article/details/52959551" target="_blank" rel="noopener">字符编码与字符集的区别</a></p><p>3、<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>screen命令</title>
      <link href="/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-screen%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-screen%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Screen简介"><a href="#Screen简介" class="headerlink" title="Screen简介"></a>Screen简介</h3><p>在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。</p><p><strong>简而言之：</strong></p><p>远程服务器的时候，断网或者手误关掉了远程终端，会导致会话中断，程序终止。</p><p>而Screen连接的终端，会话独立运行，程序会一直进行。而且会话可以恢复，还可以自行删除。</p><h3 id="常用screen命令"><a href="#常用screen命令" class="headerlink" title="常用screen命令"></a>常用screen命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">screen -S yourname           # 新建一个叫yourname的session</span><br><span class="line">screen -ls                   # 列出当前所有的session</span><br><span class="line">screen -r yourname           # 回到yourname这个session</span><br><span class="line">screen -d yourname           # 远程detach某个session    # detach快捷键 ctrl a + d</span><br><span class="line">screen -d -r yourname        # 结束当前session并回到yourname这个session</span><br><span class="line">screen -S yourname -X quit   # 删除叫yourname的session</span><br></pre></td></tr></table></figure><h4 id="恢复会话"><a href="#恢复会话" class="headerlink" title="恢复会话"></a>恢复会话</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r session_name</span><br></pre></td></tr></table></figure><p><strong>如果不能恢复：</strong></p><p>对于已经Attached Session则不能直接screen -r，需要先screen -d，然后才能screen -r</p><p>用screen -ls可以查看所有的session的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">先 screen -d session_name</span><br><span class="line">再 screen -r session_name</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S session_name -X quit</span><br></pre></td></tr></table></figure><p><strong>重命名怎么删，如下图：</strong></p><p>​    <img src="1.png" alt=""></p><ol><li><p>没有重命名的直接可以screen -S session_name -X quit</p></li><li><p>重命名的，需要带上id删，screen -S id.session_name -X quit                              </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> linux下 bin和 usr bin和 usr local bin的区别</title>
      <link href="/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-linux%E4%B8%8B-bin%E5%92%8C-usr-bin%E5%92%8C-usr-local-bin%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-linux%E4%B8%8B-bin%E5%92%8C-usr-bin%E5%92%8C-usr-local-bin%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/bin 是所有用户都可以访问并执行的可执行程序。包括超级用户及一般用户。</span><br><span class="line">/usr/bin 是系统安装时自带的一些可执行程序。即系统程序，轻易不要去动里面的东西，容易入坑。</span><br><span class="line">/usr/local/bin 是用户自行编译安装时默认的可执行程序的安装位置，这个不小心误删点什么，不会影响大局。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux不同版本的服务管理</title>
      <link href="/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-linux%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-linux%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Rhel6 用 service 和 chkconfig 来管理服务，它是 SystemV 架构下的一个工具。</p><p>Rhel7 是用 systemctl 来管理服务，它融合了之前的 service 和 chkconfig 的功能于一体。可以使用它永久性或只在当前会话中启用/禁用服务。systemctl 是 systemd 架构下的一个工具。</p><div class="table-container"><table><thead><tr><th>动作</th><th>Rhel6 旧指令</th><th>Rhel7新指令</th></tr></thead><tbody><tr><td>启动某服务</td><td>service httpd start</td><td>systemctl start httpd</td></tr><tr><td>停止某服务</td><td>service httpd stop</td><td>systemctl stop httpd</td></tr><tr><td>重启某服务</td><td>service httpd restart</td><td>systemctl restart httpd</td></tr><tr><td>检查服务状态</td><td>service httpd status</td><td>systemctl status httpd</td></tr><tr><td>删除某服务</td><td>chkconfig —del httpd</td><td>停掉应用，删除其配置文件</td></tr><tr><td>使服务开机自启动</td><td>chkconfig —level 5 httpd on</td><td>systemctl enable httpd</td></tr><tr><td>使服务开机不自启动</td><td>chkconfig —level 5 httpd off</td><td>systemctl disable httpd</td></tr><tr><td>显示所有已启动的服务</td><td>chkconfig —list</td><td>systemctl list-unit-files \</td><td>grep enabled</td></tr><tr><td>加入自定义服务</td><td>chkconfig —add test</td><td>systemctl load test</td></tr><tr><td>查询服务是否开机自启</td><td>chkconfig —list \</td><td>grep httpd</td><td>systemctl is-enabled httpd</td></tr><tr><td>查看启动失败的服务</td><td></td><td>systemctl —failed</td></tr></tbody></table></div><p>systemd的一些常用命令：</p><p>列出所有可用单元 ： systemctl list-unit-files</p><p>列出所有运行的单元： systemctl list-unit-files | grep enabled </p><p>列出所有可用服务： systemctl list-unit-files —type=service</p><p>列出所有运行的服务： systemctl list-unit-files —type=service | grep enabled </p><p>屏蔽httpd服务：systemctl mask httpd</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim的查找替换总结</title>
      <link href="/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-vim%E7%9A%84%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-vim%E7%9A%84%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>vim的查找替换操作如果能运用熟练是非常提高效率的，我们来重新梳理一下查找与替换的一些操作，方便更好的记忆 。</p></blockquote><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>在normal模式下按下/即可进入查找模式，输入要查找的字符串并按下回车。 Vim会跳转到第一个匹配。按下n查找下一个，按下N查找上一个。</p><ul><li>Vim查找支持正则表达式 <code>/vim$</code>匹配行尾的”vim”。</li><li>需要查找特殊字符需要转义，例如<code>/vim\$</code>匹配”vim$”。</li></ul><h3 id="大小写敏感查找"><a href="#大小写敏感查找" class="headerlink" title="大小写敏感查找"></a>大小写敏感查找</h3><p>在查找模式中加入\c表示大小写不敏感查找，\C表示大小写敏感查找。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/foo\c</span><br></pre></td></tr></table></figure><h3 id="大小写敏感配置"><a href="#大小写敏感配置" class="headerlink" title="大小写敏感配置"></a>大小写敏感配置</h3><p>Vim 默认采用大小写敏感的查找，为了方便我们常常将其配置为大小写不敏感：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置默认进行大小写不敏感查找 set ignorecase</span><br><span class="line">如果有一个大写字母，则切换到大小写敏感查找 set smartcase</span><br></pre></td></tr></table></figure><blockquote><p>将上述设置粘贴到你的~/.vimrc，重新打开Vim即可生效</p></blockquote><h3 id="查找当前单词"><a href="#查找当前单词" class="headerlink" title="查找当前单词"></a>查找当前单词</h3><p>在normal模式下按下*即可查找光标所在单词（word）， 要求每次出现的前后为空白字符或标点符号。</p><p>例如当前为foo， 可以匹配foo bar中的foo，但不可匹配foobar中的foo。 这在查找函数名、变量名时非常有用。</p><p>按下g*即可查找光标所在单词的字符序列，每次出现前后字符无要求。 即foo bar和foobar中的foo均可被匹配到。</p><h3 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h3><p>:s（substitute）命令用来查找和替换字符串。语法如下：</p><p><code>:{作用范围}s/{目标}/{替换}/{替换标志}</code>          </p><ul><li>%s/foo/bar/g会在全局范围(%)查找foo并替换为bar，所有出现都会被替换（g）</li></ul><h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><p>作用范围分为当前行、全文、选区等等。</p><ol><li>当前行：</li></ol><p>（g 看似为全局 (global) 的含义，容易让人误以为 g 标志位是用于实现在整个文件范围内进行替换操作，但实际上，g 仅表示<strong>当前一整行</strong>范围。由于 Vim 直接继承自 “行编辑器 ed”，对于行编辑器而言，全局的范围就是一行，这就是 g 标志位命令的由来）</p><font color = green>也就是说，不加g，在扫描范围内，只会替换对所有扫描到行的第一个！</font><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/foo/bar/g</span><br></pre></td></tr></table></figure><ol><li>全文：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/foo/bar/g</span><br></pre></td></tr></table></figure><ol><li><p>选区</p><p>选区，在Visual模式下选择区域后输入:，Vim即可自动补全为 :’&lt;,’&gt;。</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:'&lt;,'&gt;s/foo/bar/g</span><br></pre></td></tr></table></figure><ol><li><p>指定行:</p><ol><li>5-12行 </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:5,12s/foo/bar/g</span><br></pre></td></tr></table></figure><ol><li>当前行.与接下来两行+2：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:.,+2s/foo/bar/g</span><br></pre></td></tr></table></figure></li></ol><h3 id="替换标志"><a href="#替换标志" class="headerlink" title="替换标志"></a>替换标志</h3><p>上文中命令结尾的g即是替换标志之一，表示全局global替换（即替换目标的所有出现）。 还有很多其他有用的替换标志：</p><ol><li>空替换标志表示只替换从光标位置开始，目标的第一次出现：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/foo/bar</span><br></pre></td></tr></table></figure><ol><li>i表示大小写不敏感查找，I表示大小写敏感</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/foo/bar/i# 等效于模式中的\c（不敏感）或\C（敏感）:%s/foo\c/bar</span><br></pre></td></tr></table></figure><ol><li>c表示需要确认，例如全局查找”foo”替换为”bar”并且需要确认：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/foo/bar/gc</span><br></pre></td></tr></table></figure><p>回车后Vim会将光标移动到每一次”foo”出现的位置，并提示</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace with bar (y/n/a/q/l/^E/^Y)?</span><br></pre></td></tr></table></figure><p>按下y表示替换，n表示不替换，a表示替换所有，q表示退出查找模式， l表示替换当前位置并退出。<code>^E</code>与<code>^Y</code>是光标移动快捷键.</p><p>参考： <a href="http://harttle.com/2015/11/07/vim-cursor.html" target="_blank" rel="noopener">Vim中如何快速进行光标移</a></p><p>（行首:shfit+4($)、行尾:shfit+6(^)）</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三剑客常用命令-初级</title>
      <link href="/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-%E4%B8%89%E5%89%91%E5%AE%A2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E5%88%9D%E7%BA%A7/"/>
      <url>/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-%E4%B8%89%E5%89%91%E5%AE%A2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E5%88%9D%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>grep、sed、awk号称三剑客，这三条命令对文本处理特别有用，今天来小结一下常用的基础操作，日后再来总结比较难的操作</p></blockquote><h3 id="grep-查找"><a href="#grep-查找" class="headerlink" title="grep-查找"></a><strong>grep-查找</strong></h3><ol><li><p>查询hello.txt中以字母a开头的内容，这样写也是可以的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep ^a hello.txt</span><br></pre></td></tr></table></figure></li><li><p>查看test.log中包含http的所有行(-i忽略大小写）</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i "http" ./test.log</span><br></pre></td></tr></table></figure><ol><li>查询出来对应字符串所在的行号</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i ABC -n hello.txt</span><br></pre></td></tr></table></figure><ol><li>查找进程，去掉错觉</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java | grep -v grep</span><br></pre></td></tr></table></figure><ol><li>查看test.log中包含http的所有行，并显示前后行</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat -n test.log | grep -C 5 "http" (匹配到的前后5行)</span><br><span class="line"></span><br><span class="line">cat -n test.log | grep -B 5 "http"  (前5行)</span><br><span class="line"></span><br><span class="line">cat -n test.log | grep -A 5 "http" (后5行)</span><br></pre></td></tr></table></figure><h3 id="sed-编辑"><a href="#sed-编辑" class="headerlink" title="sed-编辑"></a><strong>sed-编辑</strong></h3><p>都是一个模式类似的，{作用范围}命令[\或者/]操作数</p><ol><li>sed命令向文件中添加一行内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed '2a\haha' hello.txt （append）</span><br><span class="line">sed '1i\haha' hello.txt  (insert)</span><br><span class="line">sed '$a\haha' hello.txt （append）  $代表最后一行</span><br><span class="line">sed '$i\haha' hello.txt  (insert)</span><br></pre></td></tr></table></figure><ol><li>删除最后一行</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '$d' hello.txt</span><br></pre></td></tr></table></figure><ol><li>替换操作：sed后面的参数格式为[address]s/pattern/replacement/ﬂags</li></ol><p>​    和vim的substitute命令一样，再复习一下</p><p>​        这里的address 表示指定要操作的具体行，是一个可选项</p><p>​        s 表示替换操作;</p><p>​        pattern 指的是需要替换的内容;</p><p>​        replacement 指的是要替换的新内;</p><p>​        ﬂags有多种用法，我们挑两种说一下</p><ul><li><p>第一种就是ﬂags可以表示为1~512之间的任意一个数字，表示指定要替换的字符串在这一行中出现第几 次时才进行替换</p></li><li><p>第二种就是ﬂags可以直接表示为g，这样的意思就是对每一行数据中所有匹配到的内容全部进行替换</p></li></ul><p>​    如果ﬂags位置的值为空，则只会在第一次匹配成功时做替换操作</p><p>​    替换源文件修改        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#39;2s&#x2F;l&#x2F;a&#x2F;g&#39; hello.txt</span><br></pre></td></tr></table></figure><ol><li>SED 查看某时间段日志</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n '/2022-06-02 13:10:30/,/2022-06-02 13:10:40/p' test.log</span><br></pre></td></tr></table></figure><p>补充: 命令选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">-e ：直接在命令列模式上进行 sed 的动作编辑；</span><br><span class="line">-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；</span><br><span class="line">-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)</span><br><span class="line">-i ：直接修改读取的文件内容，而不是输出到终端。</span><br></pre></td></tr></table></figure><h3 id="awk-分析"><a href="#awk-分析" class="headerlink" title="awk-分析"></a><strong>awk-分析</strong></h3><p>简单来说awk就是把文件逐行的读入，以空白字符为默认分隔符将每行内容切片，切开的 部分再进行各种分析处理。</p><p>awk的基本格式：awk [option] programe ﬁle</p><p>这里的option是一个可选项，一般在这里来指定文件中数据的字段分隔符</p><p>programe 是具体的处理逻辑;</p><p>ﬁle表示我们要操作的文件;</p><p>在具体使用awk之前我们还需要掌握awk的一个特性，就是awk在处理文本数据的时候，它会自动给每行变量从1开始，</p><p>​    $1表示是文本中的第1个数据字段</p><p>​    $2表示是文本中的第2个数据字段</p><p>以此类推。</p><p>还有一个特殊的 $0 它代表整个文本行的内容</p><p>那下面我们来操作一下hello.txt这个文件</p><p>这个文件的字段中间默认是空格</p><ol><li><p>简单打印</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;print $1&#125;' hello.txt  打印第一列</span><br><span class="line">awk '&#123;print $2&#125;' hello.txt  打印第二列</span><br><span class="line">awk '&#123;print $0&#125;' hello.txt  打印全文</span><br></pre></td></tr></table></figure></li><li><p>在option里面指定字段分隔符，通过-F 参数</p><pre><code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: ‘&#123;print $1&#125;’ /etc/passwd</span><br></pre></td></tr></table></figure></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看磁盘和目录空间df和du</title>
      <link href="/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%92%8C%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4df%E5%92%8Cdu/"/>
      <url>/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%92%8C%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4df%E5%92%8Cdu/</url>
      
        <content type="html"><![CDATA[<h3 id="du和df的区别："><a href="#du和df的区别：" class="headerlink" title="du和df的区别："></a><strong>du和df的区别：</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间(最常见的就是文件已经删除，但是程序并没有释放空间)。</span><br><span class="line">du命令是面向文件的，只会计算文件或目录占用的</span><br></pre></td></tr></table></figure><h3 id="查看磁盘整体情况"><a href="#查看磁盘整体情况" class="headerlink" title="查看磁盘整体情况"></a><strong>查看磁盘整体情况</strong></h3><h4 id="查看整体挂载情况"><a href="#查看整体挂载情况" class="headerlink" title="查看整体挂载情况"></a>查看整体挂载情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="WeChat069a76a447ca86aad5fec1408ef2fbde"></p><h4 id="查看指定目录"><a href="#查看指定目录" class="headerlink" title="查看指定目录"></a>查看指定目录</h4>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h /opt/data/</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="WeChatfddb958643be29daa7380f9e2a7f2ab3"></p><h3 id="查看文件夹的占用情况"><a href="#查看文件夹的占用情况" class="headerlink" title="查看文件夹的占用情况"></a><strong>查看文件夹的占用情况</strong></h3><h4 id="查看当前目录每个文件夹的情况。"><a href="#查看当前目录每个文件夹的情况。" class="headerlink" title="查看当前目录每个文件夹的情况。"></a>查看当前目录每个文件夹的情况。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du --max-depth=1 -h</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="WeChatfddb958643be29daa7380f9e2a7f2ab3"></p><h4 id="指定目录"><a href="#指定目录" class="headerlink" title="指定目录"></a>指定目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du --max-depth=1 -h  /opt/data/</span><br></pre></td></tr></table></figure><p><img src="4.png" alt="WeChat0e80cc2a684da5f972f3d507563465d2"></p><h4 id="计算文件夹大小"><a href="#计算文件夹大小" class="headerlink" title="计算文件夹大小"></a>计算文件夹大小</h4><p>(<strong>为了快算显示，同时也只是想查看目录整体占用大小。可以直接使用du -sh 命令，如果想查看指定目录，直接在命令后根目录即可</strong>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh /usr/</span><br></pre></td></tr></table></figure><p><img src="5.png" alt="WeChat0dadf840b9fa7087478e4c7700ef1761"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其中df -h和du -sh使用的比较多，一个统计整体磁盘情况，一个看单独目录点用情况，而命令du —max-depth=1 -h查看了目录下文件夹占用情况，使用比较少，可以用du -sh代替，而且命令较长，当然并不是说它没用。</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yum换源的详细操作</title>
      <link href="/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-yum%E6%8D%A2%E6%BA%90%E7%9A%84%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-yum%E6%8D%A2%E6%BA%90%E7%9A%84%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure><p><strong>备份原来的源</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bk</span><br></pre></td></tr></table></figure><p><strong>下载阿里源</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.dsudo wget -nc http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><p> <strong>更改阿里yum源为默认源</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv Centos-7.repo CentOS-Base.repo</span><br></pre></td></tr></table></figure><p><strong>更新本地yum缓存</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum clean all # 全部清除</span><br><span class="line">sudo yum list # 更新列表 </span><br><span class="line">sudo yum makecache# 缓存yum包信息到本机，提高搜索速度</span><br></pre></td></tr></table></figure><p><strong>国内yum源</strong></p><p>阿里yum源:<a href="http://mirrors.aliyun.com/repo/" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/</a></p><p>163(网易)yum源: <a href="http://mirrors.163.com/.help/" target="_blank" rel="noopener">http://mirrors.163.com/.help/</a></p><p>中科大的Linux安装镜像源：<a href="http://centos.ustc.edu.cn/" target="_blank" rel="noopener">http://centos.ustc.edu.cn/</a></p><p>搜狐的Linux安装镜像源：<a href="http://mirrors.sohu.com/" target="_blank" rel="noopener">http://mirrors.sohu.com/</a></p><p>北京首都在线科技：<a href="http://mirrors.yun-idc.com/" target="_blank" rel="noopener">http://mirrors.yun-idc.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yum源解释</title>
      <link href="/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-yum%E6%BA%90%E8%A7%A3%E9%87%8A/"/>
      <url>/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-yum%E6%BA%90%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载他人的文章主要说明下如何配置linux上的本地yum源，主要关于一些原理上的说明。</p></blockquote><h3 id="yum是什么，yum源又是什么"><a href="#yum是什么，yum源又是什么" class="headerlink" title="yum是什么，yum源又是什么"></a>yum是什么，yum源又是什么</h3><p>   在windows上安装一个软件，我们可以通过360管家。因为360管家提供了软件的安装，卸载，并且解决了软件之间的依赖等相关问题，使得我们能够一键安装。在linux上有一个提供了和360管家类似功能的工具，叫做yum。使用yum我们就可以做到一个命令安装软件，并且不同的发行linux有不同工具，例如红帽（read hat）linux就使用的rpm全称就是read hat package manager 红帽软件包管理工具。</p><p>   yum源是什么呢？我们安装软件的时候需要下载软件，将很多软件放在一起就是源。软件安装包的来源。所以yum源就是软件安装包来源。如果我们是在线的，他会在网上给你下载安装包，如果是离线的没有网络。那么就只能配置本地的yum源了。</p><h3 id="本地yum源是什么呢？"><a href="#本地yum源是什么呢？" class="headerlink" title="本地yum源是什么呢？"></a>本地yum源是什么呢？</h3><p>   上面说过yum源就是软件安装包的来源，但是这些安装包哪里有呢？其实在linux的安装镜像中就有的，linux已经将常见的安装包放到了linux镜像中。如果你使用压缩文件打开linux的iso镜像文件，你会发现在根目录下有个文件夹：packages</p><p><img src="1.png" alt="WeChat40190bf3ee24416d2daacfa56f1f172d"></p><p>   上图就是使用压缩软件打开的系统盘内部情况，比如我们常用的工具vim，就是在这里面的。所以说： 系统的安装镜像就可以当作yum源。</p><h3 id="与yum源相关的配置文件"><a href="#与yum源相关的配置文件" class="headerlink" title="与yum源相关的配置文件"></a>与yum源相关的配置文件</h3><p> <img src="2.png" alt="WeChat5b86da0c7a3647cb6d31f02d5c5e2cbe"></p><p>   上图就是yun源相关的配置，在路径/etc/yum.repos.d/目录下，一共4个文件，说下两个常用的。</p><p>   CentOS-Base.repo：有网的环境下默认使用这个，这个是第一优先级。因为没网，所以修改文件名，设置成备份文件。这样系统就会使用第二优先级的文件。</p><p>   CentOS-Media.repo：没网的环境下使用这个，在上图中会发现他默认配置了4个路径，第4个yumsource是我自己加的。意思是说，如果系统检测yum使用了离线安装，那么会从上到下从这4个路径中查找安装软件。所以我们只要把光盘挂载在这四个目录下的任意一个目录即可。同时，该配置文件默认是不启用的，如果想使用需要 修改倒数第二行的enabled为1，否则该文件无效。</p><h3 id="media目录与mnt目录"><a href="#media目录与mnt目录" class="headerlink" title="media目录与mnt目录"></a>media目录与mnt目录</h3><p>   挂载光盘或者u盘等使用的mount命令，但是你百度所有会说有挂在media目录下，也有挂载在mnt目录下的。这两个目录区别是什么呢？</p><p>   media：挂载一些移动设备，例如光盘，U盘等。</p><p>   mnt：挂载一些硬盘等设备。所以我们的光盘应该挂载在media目录下，从yum给的默认配置文件也能看出。</p><h3 id="挂载光盘到系统上"><a href="#挂载光盘到系统上" class="headerlink" title="挂载光盘到系统上"></a>挂载光盘到系统上</h3><p>  <img src="3.png" alt="WeChatbc41627d35f3138e31bd97db231c8a8d"></p><p>   如上图，首先执行df -h命令发现当前系统没有光盘信息，然后挂载目录之后，在查看就发现我们把光盘挂载到了系统上，光盘大小4.2G。</p><p>-o loop ：指定挂载文件类型，说简单点就是我要挂载的是光盘这种设备。</p><h3 id="卸载光盘"><a href="#卸载光盘" class="headerlink" title="卸载光盘"></a>卸载光盘</h3><p><img src="4.png" alt="WeChat418e1c2e32e31f4f22bcc4d12f0e5b33"></p><p>   执行df -h发现光盘是挂载的，然后执行umount命令之后，在查看发现设备被卸载了</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>top命令的Load average 含义及性能参考基值</title>
      <link href="/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-top%E5%91%BD%E4%BB%A4%E7%9A%84Load-average-%E5%90%AB%E4%B9%89%E5%8F%8A%E6%80%A7%E8%83%BD%E5%8F%82%E8%80%83%E5%9F%BA%E5%80%BC/"/>
      <url>/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-top%E5%91%BD%E4%BB%A4%E7%9A%84Load-average-%E5%90%AB%E4%B9%89%E5%8F%8A%E6%80%A7%E8%83%BD%E5%8F%82%E8%80%83%E5%9F%BA%E5%80%BC/</url>
      
        <content type="html"><![CDATA[ <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">uptime</span></span><br><span class="line">11:12:26 up3:44,4users,load average:0.38,0.31,0.19</span><br></pre></td></tr></table></figure><p>系统平均负载被定义为在特定时间间隔内运行队列中的平均进程树。如果一个进程满足以下条件则其就会位于运行队列中：</p><ul><li>它没有在等待I/O操作的结果</li><li>它没有主动进入等待状态(也就是没有调用’wait’)</li><li>没有被停止(例如：等待终止)</li></ul><p>上面的输出，load average后面分别是1分钟、5分钟、15分钟的负载情况。数据是每隔5秒钟检查一次活跃的进程数，然后根据这个数值算出来的。如果这个数除以CPU 的数目，结果高于5的时候就表明系统在超负荷运转了。</p><p>Linux系统Load average负载详细解释 　我们知道判断一个系统的负载可以使用top，uptime等命令去查看，它分别记录了一分钟、五分钟、以及十五分钟的系统平均负载</p><p>　　例如我的某台服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> uptime  　09:50:21 up 200 days, 15:07, 1 user, load average: 0.27, 0.33, 0.37</span></span><br></pre></td></tr></table></figure><p>　　大部分的人都认为这个数字越小越好，其实有很多关联的提示信息，今天看到这个好文，应该可以给大家说清楚很多问题，转一下：</p><p>　　原文链接： <a href="http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages" target="_blank" rel="noopener">http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages</a></p><p>　　你可能对于 Linux 的负载均值（load averages）已有了充分的了解。负载均值在 uptime 或者 top 命令中可以看到，它们可能会显示成这个样子：</p><pre><code>         <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load average: 0.09, 0.05, 0.01</span><br></pre></td></tr></table></figure></code></pre><p>　　很多人会这样理解负载均值：三个数分别代表不同时间段的系统平均负载（一分钟、五 分钟、以及十五分钟），它们的数字当然是越小越好。数字越高，说明服务器的负载越 大，这也可能是服务器出现某种问题的信号。</p><p>　　而事实不完全如此，是什么因素构成了负载均值的大小，以及如何区分它们目前的状况是 “好”还是“糟糕”？什么时候应该注意哪些不正常的数值？</p><p>　　回答这些问题之前，首先需要了解下这些数值背后的些知识。我们先用最简单的例子说明， 一台只配备一块单核处理器的服务器。</p><p>　　行车过桥</p><p>　　一只单核的处理器可以形象得比喻成一条单车道。设想下，你现在需要收取这条道路的过桥 费 — 忙于处理那些将要过桥的车辆。你首先当然需要了解些信息，例如车辆的载重、以及 还有多少车辆正在等待过桥。如果前面没有车辆在等待，那么你可以告诉后面的司机通过。 如果车辆众多，那么需要告知他们可能需要稍等一会。</p><p>　　因此，需要些特定的代号表示目前的车流情况，例如：</p><p>　　0.00 表示目前桥面上没有任何的车流。 实际上这种情况与 0.00 和 1.00 之间是相同的，总而言之很通畅，过往的车辆可以丝毫不用等待的通过。</p><p>　　1.00 表示刚好是在这座桥的承受范围内。 这种情况不算糟糕，只是车流会有些堵，不过这种情况可能会造成交通越来越慢。</p><p>　　超过 1.00，那么说明这座桥已经超出负荷，交通严重的拥堵。 那么情况有多糟糕？ 例如 2.00 的情况说明车流已经超出了桥所能承受的一倍，那么将有多余过桥一倍的车辆正在焦急的等待。3.00 的话情况就更不妙了，说明这座桥基本上已经快承受不了，还有超出桥负载两倍多的车辆正在等待。</p><p>　　上面的情况和处理器的负载情况非常相似。一辆汽车的过桥时间就好比是处理器处理某线程 的实际时间。Unix 系统定义的进程运行时长为所有处理器内核的处理时间加上线程 在队列中等待的时间。</p><p>　　和收过桥费的管理员一样，你当然希望你的汽车（操作）不会被焦急的等待。所以，理想状态 下，都希望负载平均值小于 1.00 。当然不排除部分峰值会超过 1.00，但长此以往保持这 个状态，就说明会有问题，这时候你应该会很焦急。</p><p>　　“所以你说的理想负荷为 1.00 ？”</p><p>　　嗯，这种情况其实并不完全正确。负荷 1.00 说明系统已经没有剩余的资源了。在实际情况中 ，有经验的系统管理员都会将这条线划在<font color = red> 0.70</font>：</p><p>　　<font color = green>“需要进行调查法则”</font>： 如果长期你的系统负载在 0.70 上下，那么你需要在事情变得更糟糕之前，花些时间了解其原因。</p><p>　　<font color = green>“现在就要修复法则”</font>：1.00 。 如果你的服务器系统负载长期徘徊于 1.00，那么就应该马上解决这个问题。否则，你将半夜接到你上司的电话，这可不是件令人愉快的事情。</p><p>　　<font color = green>“凌晨三点半锻炼身体法则”</font>：5.00。 如果你的服务器负载超过了 5.00 这个数字，那么你将失去你的睡眠，还得在会议中说明这情况发生的原因，总之千万不要让它发生。</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用docker部署hadoop集群的记录</title>
      <link href="/2022/07/22/docker-2022-07-22-%E5%88%A9%E7%94%A8docker%E9%83%A8%E7%BD%B2hadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/07/22/docker-2022-07-22-%E5%88%A9%E7%94%A8docker%E9%83%A8%E7%BD%B2hadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>计划部署五个docker容器，node1 为主节点，部署hdfs的namenode，yarn的resourcemager，redis的master等节点，目的就是拿docker当虚拟机用。</strong></p><p><strong>理想很丰满，现实很骨干，问题重重,现把遇到的问题记录下，做相应的知识补充，也防止下次再次掉坑。</strong></p><p>启动容器：</p><ol><li><p>启动就退出，需要让容器内启动一个进程，否则没有服务 就退掉了</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>拿docker容器部署多个服务，所以只能用最基础的centos 镜像，docker容器内的内核是受限制的，默认不能使用sytemctl命令，启动时候，要允许使用特权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">报错:</span><br><span class="line">    [root@4decd9c3c3aa /]# systemctl start sshd</span><br><span class="line">    Failed to get D-Bus connection: Operation not permitted</span><br><span class="line">报错： </span><br><span class="line">  System has not been booted with systemd as init system (PID 1). Can't operate.    </span><br><span class="line">  Failed to connect to bus: Host is down</span><br><span class="line">解决：</span><br><span class="line"> docker run -itd   --privileged --name myCentos centos /usr/sbin/init</span><br></pre></td></tr></table></figure></li></ol><p>3.docker 部署的多个容器肯定是要通信的，可以直接建立一个桥接网络，启动容器时候，加入到网络中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --privileged --name t4 --network docker_net hub.c.163.com/library/centos  /usr/sbin/init bash</span><br></pre></td></tr></table></figure><p>4.节点间肯定是要传数据的，可以使用docker cp 实现宿主机和容器的互传，使用scp依赖ssh服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">安装完以后报如下的错:</span><br><span class="line">    The authenticity of host 'oradb24 (192.168.1.24)' can't be established.</span><br><span class="line">RSA key fingerprint is e0:fb:fb:67:a0:fc:cd:a5:dc:c8:bc:68:67:b1:93:3f.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added 'oradb24,192.168.1.24' (RSA) to the list of known hosts.</span><br><span class="line">root@oradb24's password: </span><br><span class="line">bash: scp: command not found</span><br><span class="line">lost connection</span><br><span class="line">注意，拷贝文件的双方服务器都要安装ssh服务，并且服务端和客户端都要安装完整才行</span><br><span class="line">yum install -y openssh-server</span><br><span class="line">yum install -y openssh-clients</span><br><span class="line">systemctl restart sshd #启动ssh服务</span><br></pre></td></tr></table></figure><ol><li><p>一些常用的命令，直接yum安装不行，不是直接的命令，是在一个包下，会提示找不到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat、telnet 命令</span><br><span class="line">    yum install net-tools</span><br><span class="line">pstree 命令</span><br><span class="line">    yum install psmisc -y</span><br><span class="line">    </span><br><span class="line">有时候不一定什么样，学会搜学，学会通用的本领</span><br><span class="line">yum list | grep telnet</span><br></pre></td></tr></table></figure></li><li><p>scp装完之后，想要用的话，是需要登陆账户的，默认root账户密码，你自己是不知道的，修改文件太麻烦，所以，注意启动容器第一件事就是先修改root密码</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@06e23c44de37 /]# passwd root</span><br><span class="line">Changing password for user root.</span><br><span class="line">New password: </span><br><span class="line">BAD PASSWORD: The password is shorter than 8 characters</span><br><span class="line">Retype new password: </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><ol><li>在一台节点上，装好所有的服务，做好一个容器，保存为一个镜像，然后，利用这个镜像启动多个容器，注意启动时候的命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a &quot;zhangxiaodong&quot; -m &quot;bigdata centos7&quot; 5d8e05402c40  mycentos:v1</span><br></pre></td></tr></table></figure><ol><li>防止出现意外，把镜像提交到docker.hub仓库中去</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一：网易镜像仓库，但是现在需要企业认证才让推，坑爹</span><br><span class="line">二：官方的hub.docker</span><br><span class="line">    docker tag masternode:v1  12345678900100/masternode:v1  #这一步是重新标记镜像，得按照 注册用户名/镜像名  这个规范来才能推送上去</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOCKER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器互访三种方式</title>
      <link href="/2022/07/22/docker-2022-07-22-Docker%E5%AE%B9%E5%99%A8%E4%BA%92%E8%AE%BF%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/07/22/docker-2022-07-22-Docker%E5%AE%B9%E5%99%A8%E4%BA%92%E8%AE%BF%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>我们都知道docker容器之间是互相隔离的，不能互相访问，但如果有些依赖关系的服务要怎么办呢。下面介绍三种方法解决容器互访问题。</p><h3 id="方式一、虚拟ip访问"><a href="#方式一、虚拟ip访问" class="headerlink" title="方式一、虚拟ip访问"></a><strong>方式一、虚拟ip访问</strong></h3><p>安装docker时，docker会默认创建一个内部的桥接网络docker0，每创建一个容器分配一个虚拟网卡，容器之间可以根据ip互相访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@33fcf82ab4dd &#x2F;]# [root@CentOS ~]# ifconfig</span><br><span class="line">......</span><br><span class="line">docker0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::42:35ff:feac:66d8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:35:ac:66:d8  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 4018  bytes 266467 (260.2 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 4226  bytes 33935667 (32.3 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>运行一个centos镜像， 查看ip地址得到：172.17.0.7</p><pre><code>          <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS ~]# docker run -it --name centos-1 docker.io/centos:latest</span><br><span class="line">[root@6d214ff8d70a /]# ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.7  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::42:acff:fe11:7  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:ac:11:00:07  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 16  bytes 1296 (1.2 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 8  bytes 648 (648.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></code></pre><p>以同样的命令再起一个容器，查看ip地址得到：172.17.0.8</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS ~]# docker run -it --name centos-2 docker.io/centos:latest</span><br><span class="line">[root@33fcf82ab4dd /]# ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.8  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::42:acff:fe11:8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:ac:11:00:08  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 8  bytes 648 (648.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 8  bytes 648 (648.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>容器内部ping测试结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@33fcf82ab4dd /]# ping 172.17.0.7</span><br><span class="line">PING 172.17.0.7 (172.17.0.7) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.7: icmp_seq=1 ttl=64 time=0.205 ms</span><br><span class="line">64 bytes from 172.17.0.7: icmp_seq=2 ttl=64 time=0.119 ms</span><br><span class="line">64 bytes from 172.17.0.7: icmp_seq=3 ttl=64 time=0.118 ms</span><br><span class="line">64 bytes from 172.17.0.7: icmp_seq=4 ttl=64 time=0.101 ms</span><br></pre></td></tr></table></figure><p>这种方式必须知道每个容器的ip，在实际使用中并不实用。</p><p><strong>方式二、link</strong></p><p>运行容器的时候加上参数link</p><p>运行第一个容器</p><pre><code>      <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS ~]# docker run -it --name centos-1 docker.io/centos:latest</span><br></pre></td></tr></table></figure></code></pre><p>运行第二个容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS ~]# docker run -it --name centos-2--link centos-1:centos-1 docker.io/centos:latest</span><br></pre></td></tr></table></figure><p>—link：参数中第一个centos-1是<strong>容器名</strong>，第二个centos-1是定义的<strong>容器别名</strong>（使用别名访问容器），为了方便使用，一般别名默认容器名。</p><p>测试结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@e0841aa13c5b /]# ping centos-1</span><br><span class="line">PING centos-1 (172.17.0.7) 56(84) bytes of data.</span><br><span class="line">64 bytes from centos-1 (172.17.0.7): icmp_seq=1 ttl=64 time=0.210 ms</span><br><span class="line">64 bytes from centos-1 (172.17.0.7): icmp_seq=2 ttl=64 time=0.116 ms</span><br><span class="line">64 bytes from centos-1 (172.17.0.7): icmp_seq=3 ttl=64 time=0.112 ms</span><br><span class="line">64 bytes from centos-1 (172.17.0.7): icmp_seq=4 ttl=64 time=0.114 ms</span><br></pre></td></tr></table></figure><p> 此方法对容器创建的顺序有要求，如果集群内部多个容器要互访，使用就不太方便。</p><p><strong>方式三、创建bridge网络</strong></p><p>1.安装好docker后，运行如下命令创建bridge网络：docker network create testnet</p><p>查询到新创建的bridge testnet。</p><p>   <img src="1.png" alt="WeChat314744afd88365f3f0d8d8c97c8544e9"></p><p>2.运行容器连接到testnet网络。</p><p>使用方法：docker run -it —name &lt;容器名&gt; —-network —network-alias &lt;网络别名&gt; &lt;镜像名&gt;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS ~]# docker run -it --name centos-1 --network testnet --network-alias centos-1 docker.io/centos:latesta</span><br><span class="line">[root@CentOS ~]# docker run -it --name centos-2 --network testnet --network-alias centos-2 docker.io/centos:latest</span><br></pre></td></tr></table></figure><p>3.从一个容器ping另外一个容器，测试结果如下：</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@fafe2622f2af /]# ping centos-1</span><br><span class="line">PING centos-1 (172.20.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from centos-1.testnet (172.20.0.2): icmp_seq=1 ttl=64 time=0.158 ms</span><br><span class="line">64 bytes from centos-1.testnet (172.20.0.2): icmp_seq=2 ttl=64 time=0.108 ms</span><br><span class="line">64 bytes from centos-1.testnet (172.20.0.2): icmp_seq=3 ttl=64 time=0.112 ms</span><br><span class="line">64 bytes from centos-1.testnet (172.20.0.2): icmp_seq=4 ttl=64 time=0.113 ms</span><br></pre></td></tr></table></figure><p>4.若访问容器中服务，可以使用这用方式访问 &lt;网络别名&gt;：&lt;服务端口号&gt; </p><p>推荐使用这种方法，自定义网络，因为使用的是网络别名，可以不用顾虑ip是否变动，只要连接到docker内部bright网络即可互访。bridge也可以建立多个，隔离在不同的网段。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOCKER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker启动后自动停止的原因及解决</title>
      <link href="/2022/07/22/docker-2022-07-22-docker%E5%90%AF%E5%8A%A8%E5%90%8E%E8%87%AA%E5%8A%A8%E5%81%9C%E6%AD%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
      <url>/2022/07/22/docker-2022-07-22-docker%E5%90%AF%E5%8A%A8%E5%90%8E%E8%87%AA%E5%8A%A8%E5%81%9C%E6%AD%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>centos 启动一个容器添加了-d 参数，但是docker ps 或者docker ps -a查看却已经退出了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centosa44b2b88559b68a2221c9574490a0e708bff49d88ca21f9e59d3eb245c7c0547</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="WeChat497baa8def4c0ee1d65fa1d8a7b1e555"></p><h3 id="退出原因"><a href="#退出原因" class="headerlink" title="退出原因"></a>退出原因</h3><ol><li><p>docker容器运行必须有一个前台进程， 如果没有前台进程执行，容器认为空闲，就会自行退出</p></li><li><p>容器运行的命令如果不是那些一直挂起的命令（ 运行top，tail、循环等），就是会自动退出</p></li><li><p>这个是 docker 的机制问题</p></li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h5 id="方案1："><a href="#方案1：" class="headerlink" title="方案1："></a>方案1：</h5><p>网上有很多介绍，就是起一个死循环进程，让他不停的循环下去，前台永远有进程执行，那么容器就不会退出了,以centos为例</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos /bin/sh -c "while true; do echo hello world; sleep 1; done"</span><br></pre></td></tr></table></figure><p>缺点： 命令太冗长了，还占用一个终端</p><h5 id="方案2："><a href="#方案2：" class="headerlink" title="方案2："></a>方案2：</h5> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit centos /bin/bash</span><br></pre></td></tr></table></figure><p>添加-it 参数交互运行</p><p>添加-d 参数后台运行</p><p>这样就能启动一个一直停留在后台运行的Centos了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>容器运行起来了               <img src="2.png" alt="WeChatf6376383dead7cd5df001a7f289d65d8"></p><p>进入容器的方法：</p><p>使用exec，不要使用attach命令</p><p>attach命令就是使用现有终端，如果你要退出容器操作，那么bash结束，容器也就退出了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it /bin/bash //新建一个bash</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="WeChat7921d95cf39d8ef42a04cf42d1d5d5e3"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOCKER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker tag命令解释</title>
      <link href="/2022/07/22/docker-2022-07-22-docker-tag%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A/"/>
      <url>/2022/07/22/docker-2022-07-22-docker-tag%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br></pre></td></tr></table></figure><h3 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h3><ol><li>比如我现在有一个 centos 镜像：</li></ol><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE </span><br><span class="line">centos              latest              <span class="number">1</span>e1148e4cc2c        <span class="number">2</span> weeks ago         <span class="number">202</span>MB</span><br></pre></td></tr></table></figure><ol><li>我对 centos 进行开发，开发了第一个版本，我就可以对这个版本打标签，打完标签后会生成新的镜像：</li></ol><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ docker tag centos centos:v1</span><br><span class="line">[root@localhost ~]$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE </span><br><span class="line">centos              latest              <span class="number">1</span>e1148e4cc2c        <span class="number">2</span> weeks ago         <span class="number">202</span>MB</span><br><span class="line">centos              v1                  <span class="number">1</span>e1148e4cc2c        <span class="number">2</span> weeks ago         <span class="number">202</span>MB</span><br></pre></td></tr></table></figure><ol><li>我继续对 centos 进行开发，开发了第二个版本，继续打标签：</li></ol><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ docker tag centos centos:v2</span><br><span class="line">[root@localhost ~]$ docker images </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              <span class="number">1</span>e1148e4cc2c        <span class="number">2</span> weeks ago         <span class="number">202</span>MB</span><br><span class="line">centos              v1                  <span class="number">1</span>e1148e4cc2c        <span class="number">2</span> weeks ago         <span class="number">202</span>MB</span><br><span class="line">centos              v2                  <span class="number">1</span>e1148e4cc2c        <span class="number">2</span> weeks ago         <span class="number">202</span>MB</span><br></pre></td></tr></table></figure><ol><li>以此类推，每开发一个版本打一个标签，如果以后我想回滚版本，就可以使用指定标签的镜像来创建容器：</li></ol><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ docker <span class="keyword">run</span><span class="bash"> -itd centos:v1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOCKER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 常用命令记录</title>
      <link href="/2022/07/22/docker-2022-07-22-docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/07/22/docker-2022-07-22-docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<pre><code>### 查看镜像/容器</code></pre> <figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker images 查看镜像信息列表 镜像是静态的</span><br><span class="line">docker ps -a 查看运行中的所有容器</span><br><span class="line">docker pull  [images]:[version]从dockerhub拉取指定镜像</span><br><span class="line">docker rm [containerID] 删除容器</span><br><span class="line">docker rmi [imageID] 删除镜像</span><br><span class="line">docker cp [YourHostFilePath] [containerID]:[DockerPath]  将宿主机内的指定文件传输至容器内部的指定地址。</span><br></pre></td></tr></table></figure><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -p 8000:80 -tdi --privileged [imageID] [<span class="built_in">command</span>]  </span></span><br><span class="line">后台启动docker,并指定宿主机端口和docker映射端口。</span><br><span class="line">    -i:以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">    -d:后台运行容器，并返回容器ID；</span><br><span class="line">    -t:为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br><span class="line">    --privileged 容器将拥有访问主机所有设备的权限</span><br><span class="line">    通常情况下 [command] 填下 /bin/bash 即可。</span><br><span class="line">    特殊情况下，如需要在centos镜像中使用systemctl . 则应添加--privileged 并设置[command ]为 init。</span><br><span class="line">当镜像通过<span class="keyword">run</span><span class="bash"> 启动后，便会载入到一个动态的container(容器)中运行，此时若需要进入终端交互模式：</span></span><br><span class="line">sudo docker exec -it [containerID] /bin/bash</span><br><span class="line">交互模式中，使用ctrl+p+q退出交互 保持运行,使用 exit命令退出并停止容器。</span><br><span class="line">非交互模式中 docker  start/stop 命令启动/停止已部署的容器服务。</span><br></pre></td></tr></table></figure><h3 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker commit [containerID] [ImageName]:[Version] 将修改后的容器重新打包成镜像</span><br><span class="line">docker commit -a <span class="string">"runoob.com"</span> -m <span class="string">"my apache"</span> a404c6c174a2 mymysql:v1 将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</span><br><span class="line">    -a :提交的镜像作者；</span><br><span class="line">    -c :使用Dockerfile指令来创建镜像；</span><br><span class="line">    -m :提交时的说明文字；</span><br><span class="line">    -p :在commit时，将容器暂停。</span><br><span class="line">docker push [ImageID] [repertory_address]提交镜像到云仓库</span><br></pre></td></tr></table></figure><h3 id="修改景象名称"><a href="#修改景象名称" class="headerlink" title="修改景象名称"></a>修改景象名称</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pujh/centos         tomcat-centos       <span class="number">70</span>ff7873d7cd        About an hour ago   <span class="number">612</span> MB</span><br><span class="line">docker.io/centos    latest              <span class="number">9</span>f38484d220f        <span class="number">11</span> days ago         <span class="number">202</span> MB</span><br><span class="line">[root@localhost ~]<span class="comment"># docker tag 70ff7873d7cd my_centos:tomcat-centos</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOCKER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet过滤器与SpringMVC拦截器</title>
      <link href="/2022/07/22/Java-2022-07-22-Servlet%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8ESpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
      <url>/2022/07/22/Java-2022-07-22-Servlet%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8ESpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架中的三种配置方式</title>
      <link href="/2022/07/22/Java-2022-07-22-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/07/22/Java-2022-07-22-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>前言:</strong></p><blockquote><p>java中对配置的方式有三种，配置文件（xml、properties、yml等）、注解式配置、代码配置类，配置文件配置不用修改源码，并且适合模块的划分管理，一般适合大型项目，不好处就是配置文件太多，尤其像ssm的xml整合配置等，冗杂繁琐，对程序员极其不友好，于是有了注解式配置，注解配置对开发人员友好，但是不好处就是改注解相当于改代码，改代码就得重新编译、部署，但对于程序员来说，可能更注重体验感，现在注解用的更多些，至于代码类配置，在spring-boot程序中用分较多一些。**</p></blockquote><p><strong>下面以Filter为例，详细解释三种配置的注意点</strong></p><ul><li><strong>注解式配置</strong></li></ul><p>​    <strong>注意</strong>使用内嵌容器时，可以使用 @ServletComponentScan 启用带 @WebServlet、@WebFilter 和 @WebListener 注解的类自动注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"myfilter"</span>,urlPatterns = <span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myfilter</span> <span class="keyword">extends</span> <span class="title">HttpFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"过滤器进入"</span>);</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        System.out.println(<span class="string">"过滤器离开"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置类配置</li></ul><p>​    使用代码配置类配置的时候，要把配置类对象注入容器，使用@Bean注解，注意参数Filter对象，既然使用容器，就都是容器内的对象，要保证在容器内有这个AdminFilter对象，可以使用@Bean像如下方法一样，注入容器，或者在AdminFilter类上使用@Component注解，在容器中初始化对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public AdminFilter adminFilter() &#123;</span></span><br><span class="line"><span class="comment">//        return new AdminFilter();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"loginFilterConf"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">loginFilterConfig</span><span class="params">(AdminFilter filter)</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        filterRegistrationBean.setFilter(filter);</span><br><span class="line"><span class="comment">//        filterRegistrationBean.setEnabled(false);</span></span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">"/admin/category/*"</span>);</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">"/admin/product/*"</span>);</span><br><span class="line">        filterRegistrationBean.setName(<span class="string">"loginFilterConf"</span>);</span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置文件配置</li></ul><p>​    以前的单体项目，传统的web开发，使用web.xml配置时候经常用这种配置，现在的ssm的spring mvc 也还用得到。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingfilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.my.app.EncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingfilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视图解析与模版引擎</title>
      <link href="/2022/07/21/Java-2022-07-21-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/"/>
      <url>/2022/07/21/Java-2022-07-21-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p><strong>ModelAndView</strong></p><ul><li><p>ModelAndView对象是指”模型(数据)与视图(界面)”对象</p></li><li><p>通过ModelAndView可将包含数据对象与模板引擎进行绑定</p></li><li><p>SpringMVC中默认的View是JSP,也可以配置其他模板引擎</p></li></ul><p><strong>视图解析器作用</strong></p><p>一般地视图解析器配置如下：      </p><p>假如Controller类中返回值为hello，那么根据视图解析器可得将要跳转的页面路径为：/WebContent/jsp/hello.jsp</p><p><strong>注意：</strong></p><p>视图解析器的作用是只对Controller类中每个函数返回值那里的String类型前后加路径，而不对@RequestMapping处加路径，对@RequestMapping处无影响！</p><p><strong>模版引擎</strong></p><ul><li><p>模板引擎的目标是”数据+模板=结果”</p></li><li><p>模板引擎将数据与展现有效”解耦”</p></li></ul><p>​    <img src="1.png" alt="0"></p><p>  常见的模版引擎像jsp、freemarker、Thymeleaf等。</p><p>  <strong>小结：</strong></p><ul><li>​    SpringMVC的MAV，实际就是把数据和视图绑定在一起，程序员写逻辑出数据，前端写对应的视图页面，</li></ul><p>用MAV绑定在一起，跳到模版引擎，比如jsp，它能调用java代码，就可以拿到后端写的数据进行展示，这样就可以进行数据的渲染</p><ul><li>视图解析器和模版引擎是配合使用的，默认的InternalResourceViewResolver只解析成jsp页面，Freemarker和Velocity的视频解析器：FreemarkerViewResolver和VelocityViewResolver</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC用Map接收请求参数分析</title>
      <link href="/2022/07/21/Java-2022-07-21-SpringMVC%E7%94%A8Map%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/"/>
      <url>/2022/07/21/Java-2022-07-21-SpringMVC%E7%94%A8Map%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="第一种情况，什么也不设置，无参数传递"><a href="#第一种情况，什么也不设置，无参数传递" class="headerlink" title="第一种情况，什么也不设置，无参数传递"></a><strong>第一种情况</strong>，什么也不设置，无参数传递</h3><p>注解为 @Controller @RequestMapping</p><p><img src="1.png" alt="img"></p><p>可以看到传递的为SpringMVC的BindingAwareModelMap类型，SpringMVC中的隐含模型就是这个类型，其作用域等价于 request 域，当添加Model、ModelMap参数时，SpringMVC实际传入的就是这个隐含模型；向这个隐含模型种设置值后，在返回的页面中就能通过request域取值。</p><h3 id="第二种情况，加个参数试试-gt-…-testmap-test1-2342"><a href="#第二种情况，加个参数试试-gt-…-testmap-test1-2342" class="headerlink" title="第二种情况，加个参数试试 =&gt; …/testmap?test1=2342"></a><strong>第二种情况</strong>，加个参数试试 =&gt; …/testmap?test1=2342</h3><p>结果类型还是一样，且参数不会被传入，当然使用request肯定能取出来。</p><p><img src="2.png" alt="img"> </p><h3 id="第三种情况，给Map参数添加-RequestParam注解"><a href="#第三种情况，给Map参数添加-RequestParam注解" class="headerlink" title="第三种情况，给Map参数添加@RequestParam注解"></a><strong>第三种情况</strong>，给Map参数添加@RequestParam注解</h3><p>　　1、Get请求 =&gt; <a href="http://localhost:8080/ssm/v2/testmap?test1=234234" target="_blank" rel="noopener">http://localhost:8080/ssm/v2/testmap?test1=234234</a></p><p>　　成功传入了参数，注意这个Map类型为LinkedHashMap，而不是隐含模型了</p><p><img src="3.png" alt="img"></p><p>　　再添加个Model参数看看，隐含模型中依然没有值</p><p>　　所以添加@RequestParam注解后，SpringMVC会将 Get 请求中封装进对应的参数中，如果参数是Map就封装称LinkedHashMap而不再传入隐含模型</p><p><img src="4.png" alt="img"></p><p>　　2、Post请求， 再测试测试Post请求</p><p>　　与Get的结果一致：参数无@RequestParam注解时，Map接收隐含模型；添加@RequestParam注解时，Map接收LinkedHashMap；隐含模型中无值。</p><p><img src="5.png" alt="img"></p><h3 id="第四种情况，给Map参数添加-RequestBody注解，且请求方式为Post"><a href="#第四种情况，给Map参数添加-RequestBody注解，且请求方式为Post" class="headerlink" title="第四种情况，给Map参数添加@RequestBody注解，且请求方式为Post"></a><strong>第四种情况</strong>，给Map参数添加@RequestBody注解，且请求方式为Post</h3><p>出乎意料的也成功传入了，与@RequestParam注解结果类似，也是LinkedHashMap</p><p><img src="6.png" alt="img"></p><p><img src="7.png" alt="img"></p><p>复杂点的Json数据也能解析接收成功</p><p><img src="8.png" alt="img"> <img src="9.png" alt="img"> </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><p>SpringMVC处理请求用Map类型接收参数时，如果参数无注解，则会传入BindingAwareModelMap类型，等价于Model、ModelMap参数；</p></li><li><p>参数添加@RequestParam注解时，会将参数包装称LinkedHashMap对象，参数的key为Map的key，参数值为Map的key，支持Get、Post方法（应该支持Put、Delete，没有测，俩方法与Post类似）；</p></li><li><p>添加@RequestBody注解时，接收Json类型数据，也会包装成LinkedHashMap对象，该注解不支持Get请求，Get请求没有请求体不能传Json。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> @requestParam与@Param</title>
      <link href="/2022/07/21/Java-2022-07-21-requestParam%E4%B8%8E-Param/"/>
      <url>/2022/07/21/Java-2022-07-21-requestParam%E4%B8%8E-Param/</url>
      
        <content type="html"><![CDATA[<p><strong>@RequestParam</strong> 用于controller层，是Spring的注解</p><p>解决前台参数名称与后台接收参数变量名称不一致的问题，等价于request.getParam</p><ul><li>value：参数名字，即入参的请求参数名字，如username表示请求的参数区中的name为username的参数的值将传入；</li><li>required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；</li><li>defaultValue：默认值，表示如果请求中没有同名参数时的默认值，默认值可以是SpEL表达式，如<code>“#{systemProperties[&#39;java.vm.version&#39;]}”</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(@RequestParam(value = <span class="string">"username"</span>)</span> <span class="keyword">final</span> String username,</span></span><br><span class="line"><span class="function">                        @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"password"</span>,required = <span class="keyword">false</span>)</span> <span class="keyword">final</span> String password,</span></span><br><span class="line"><span class="function">                        @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"valcode"</span>,required = <span class="keyword">false</span>)</span> <span class="keyword">final</span> String valcode) </span>&#123;</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure><p><strong>@Param</strong> 用于dao层，是mybatis中的注解</p><p>使得mapper.xml中的参数与后台的参数对应上，也增强了可读性</p><p>如果两者参数名一致得话，spring会自动进行封装，不一致的时候就需要手动去使其对应上。</p><p>即：用注解来简化xml配置的时候,@Param注解的作用是给参数命名,参数命名后就能根据名字得到参数值,正确的将参数传入sql语句中 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span> </span>&#123; </span><br><span class="line">   </span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select s_id id,s_name name,class_id classid"</span>+ </span><br><span class="line">        <span class="string">"from student where  s_name= #&#123;aaaa&#125; and class_id = #&#123;bbbb&#125;"</span>) </span><br><span class="line"> <span class="function"><span class="keyword">public</span> Student <span class="title">select</span><span class="params">(@Param(<span class="string">"aaaa"</span>)</span> String name,@<span class="title">Param</span><span class="params">(<span class="string">"bbbb"</span>)</span><span class="keyword">int</span> class_id)</span>;  </span><br><span class="line">   </span><br><span class="line"><span class="meta">@Delete</span>...... </span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert</span>...... </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在dao层，用来给参数命名，在Mybatis的mapper中加上该注解，传递的参数与Sql中的字段名一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt;getAllEmployeeByPage(<span class="meta">@Param</span>(<span class="string">"page"</span>) Integer page,</span><br><span class="line"> <span class="meta">@Param</span>(<span class="string">"size"</span>) Integer size);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springmvc Controller 页面跳转</title>
      <link href="/2022/07/21/Java-2022-07-21-springmvc-Controller-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/"/>
      <url>/2022/07/21/Java-2022-07-21-springmvc-Controller-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>如果返回值为</strong>ModelAndView<strong>，在处理方法中，返回</strong>null<strong>时，默认跳转的视图名称为请求名。跳转结果会根据视图解析器来跳转。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello================"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> <strong>结果：</strong> <img src="1.png" alt="0"></p><ul><li><strong>如果返回值为</strong>ModelAndView,<strong>在处理方法中，指定视图名称，那么将跳转到指定的视图名。跳转结果会根据视图解析器来跳转。</strong>——-<font face = "黑体" color = green><strong>使用最多</strong></font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello================"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"index"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong><img src="2.png" alt="0"></p><ul><li><strong>返回值为</strong>void<strong>，在处理方法中，默认跳转的视图名称为请求名。跳转结果会根据视图解析器来跳转。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello================"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong> <img src="3.png" alt=""></p><ul><li><strong>返回值为</strong>void,<strong>在处理方法中通过</strong>ServletAPI<strong>来进行跳转：</strong>—-<strong><font color=green>不用视图解析器</font></strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(HttpServletRequest req,HttpServletResponse resp)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello================"</span>);</span><br><span class="line">        req.getRequestDispatcher(<span class="string">"hello.jsp"</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong> <img src="4.png" alt="0"></p><ul><li><p><strong>返回值为</strong>String,默认情况下，将会以返回值为视图名通过视图解析器来找到跳转的页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello================"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>结果：</strong> <img src="5.png" alt="0">)</p><ul><li>返回值为<strong>String</strong>，在处理方法中，返回<strong>null</strong>时，默认跳转的视图名称为请求名。跳转结果会根据视图解析器来跳转。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello================"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong>： <img src="6.png" alt="0"></p><ul><li>返回值为<strong>String,</strong>为返回值加上前缀<strong>”redirect:”或者”forward:”那么将会根据返回值去进行转发或重定向，</strong><font color = green>不使用视图解析器：</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello================"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"forward:/index.jsp"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果：<img src="7.png" alt="0"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvcc原理解释</title>
      <link href="/2022/07/21/mysql-2022-07-21-mvcc%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A/"/>
      <url>/2022/07/21/mysql-2022-07-21-mvcc%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p><img src="1.png" alt="img"></p><p>MVCC实现原理也是一道非常高频的面试题,自己在整理这篇文章的时候,感觉到网上的资料在讲这块知识点上写的五花八门,好像大家的理解并没有一致。</p><p>这里将自己所理解的做一个总结,个人会觉得这是一篇含金量挺高的一篇文章(哈哈),<strong>所以请你坚持认真的看下去</strong>,一定会对你有收获。</p><p>如果文章中哪里没有理解,或者认为我讲的不对的地方，都欢迎留言一起交流哈。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一些基本概念我这里不在做阐述了。好比什么是事务? 事务的ACID? 四大隔离级别?</p><p>有关事务并发存在的问题之前有写过一篇文章:<a href="https://mp.weixin.qq.com/s/LcdorR-oldsm3FEYAAnisQ" target="_blank" rel="noopener">一文详解脏读、不可重复读、幻读</a></p><p>如果你还不清楚不可重复读和幻读的区别，非常建议看完上面这篇文章。因为好多人会把不可重复读和幻读搞在一起。</p><p>所以会认为MVCC能解决幻读，其实MVCC解决的不是幻读，而是不可重复读,下面会用实际例子来证明这一点。</p><h2 id="一、什么是MVCC"><a href="#一、什么是MVCC" class="headerlink" title="一、什么是MVCC"></a>一、什么是MVCC</h2><p><strong>多版本控制</strong>: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，<strong>只有写写之间相互阻塞</strong>，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。</p><p>在内部实现中，InnoDB通过undo log保存每条数据的多个版本，并且能够找回数据历史版本提供给用户读，每个事务读到的数据版本可能是不一样的。在同一个事务中，用户只能看到该事务创建快照之前已经提交的修改和该事务本身做的修改。</p><p>MVCC只在<code>已提交读</code>（Read Committed）和<code>可重复读</code>（Repeatable Read）两个隔离级别下工作，其他两个隔离级别和MVCC是不兼容的。因为未提交读，总数读取最新的数据行，而不是读取符合当前事务版本的数据行。而串行化（Serializable）则会对读的所有数据多加锁。</p><p>MVCC的实现原理主要是依赖<strong>每一行记录中两个隐藏字段，undo log，ReadView</strong></p><h2 id="二、MVCC相关的一些概念"><a href="#二、MVCC相关的一些概念" class="headerlink" title="二、MVCC相关的一些概念"></a>二、MVCC相关的一些概念</h2><p>这里我们先来理解下有关MVCC相关的一些概念，这些概念都理解后，我们会通过实际例子来演示MVCC的具体工作流程是怎么样的。</p><h4 id="1、事务版本号"><a href="#1、事务版本号" class="headerlink" title="1、事务版本号"></a>1、事务版本号</h4><blockquote><p>事务每次开启时，都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。这就是事务版本号。</p></blockquote><p>也就是每当begin的时候,首选要做的就是从数据库获得一个自增长的事务ID,它也就是当前事务的事务ID。</p><h4 id="2、隐藏字段"><a href="#2、隐藏字段" class="headerlink" title="2、隐藏字段"></a>2、隐藏字段</h4><p>对于InnoDB存储引擎，每一行记录都有两个隐藏列<strong>trx_id</strong>、<strong>roll_pointer</strong>,如果数据表中存在主键或者非NULL的UNIQUE键时不会创建row_id,否则InnoDB会自动生成单调递增的隐藏主键row_id。</p><div class="table-container"><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">是否必须</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">row_id</td><td style="text-align:left">否</td><td style="text-align:left">单调递增的行ID，不是必需的，占用6个字节。 这个跟MVCC关系不大</td></tr><tr><td style="text-align:left">trx_id</td><td style="text-align:left">是</td><td style="text-align:left">记录操作该行数据事务的事务ID</td></tr><tr><td style="text-align:left">roll_pointer</td><td style="text-align:left">是</td><td style="text-align:left">回滚指针，指向当前记录行的undo log信息</td></tr></tbody></table></div><p>这里的记录操作，指的是insert|update|delete。对于delete操作而已，InnoDB认为是一个update操作，不过会更新一个另外的删除位，将行表示为deleted,并非真正删除。</p><h4 id="3、undo-log"><a href="#3、undo-log" class="headerlink" title="3、undo log"></a>3、undo log</h4><p><strong>undo log可以理解成回滚日志,它存储的是老版本数据</strong>。在表记录修改之前，会先把原始数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据。或者如果当前记录行不可见，可以顺着undo log链找到满足其可见性条件的记录行版本。</p><p>在insert/update/delete(本质也是做更新，只是更新一个特殊的删除位字段)操作时，都会产生undo log。</p><p>在InnoDB里，undo log分为如下两类：</p><p>1）<strong>insert undo log</strong> : 事务对insert新记录时产生的undo log, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</p><p>2）<strong>update undo log</strong> : 事务对记录进行delete和update操作时产生的undo log，不仅在事务回滚时需要，快照读也需要，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被删除。</p><p>undo log有什么用途呢？</p><blockquote><p>1、事务回滚时，保证原子性和一致性。<br>2、如果当前记录行不可见，可以顺着undo log链找到满足其可见性条件的记录行版本(用于MVCC快照读)。</p></blockquote><h4 id="4、版本链"><a href="#4、版本链" class="headerlink" title="4、版本链"></a>4、版本链</h4><p>多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为<strong>版本链</strong>。如下：</p><p><img src="2.png" alt="img"></p><h4 id="5、快照读和当前读"><a href="#5、快照读和当前读" class="headerlink" title="5、快照读和当前读"></a>5、快照读和当前读</h4><p><strong>快照读</strong>： 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的select语句都是快照读,如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>当前读</strong>：读取的是记录数据的最新版本，显式加锁的都是当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br></pre></td></tr></table></figure><h4 id="6、ReadView"><a href="#6、ReadView" class="headerlink" title="6、ReadView"></a>6、ReadView</h4><blockquote><p>ReadView是事务在进行快照读的时候生成的记录快照, 可以帮助我们解决可见性问题的</p></blockquote><p>如果一个事务要查询行记录，需要读取哪个版本的行记录呢？ ReadView 就是来解决这个问题的。 ReadView 保存了<strong>当前事务开启时所有活跃的事务列表</strong>。换个角度，可以理解为: <strong>ReadView 保存了不应该让这个事务看到的其他事务 ID 列表。</strong></p><p>ReadView是如何保证可见性判断的呢？我们先看看 ReadView 的几个重要属性</p><ul><li><strong>trx_ids</strong>: 当前系统中那些活跃(未提交)的读写事务ID, 它数据结构为一个List。(<code>重点注意</code>:这里的trx_ids中的活跃事务，<strong>不包括当前事务自己</strong>和已提交的事务，这点非常重要)</li><li><strong>low_limit_id</strong>: 目前出现过的最大的事务ID+1，即下一个将被分配的事务ID。</li><li><strong>up_limit_id</strong>: 活跃事务列表trx_ids中最小的事务ID，如果trx_ids为空，则up_limit_id 为 low_limit_id。</li><li><strong>creator_trx_id</strong>: 表示生成该 ReadView 的事务的 事务id</li></ul><p>访问某条记录的时候如何判断该记录是否可见,具体规则如下：</p><ul><li>如果被访问版本的 <code>事务ID = creator_trx_id</code>，那么表示当前事务访问的是自己修改过的记录，那么该版本对当前事务可见；</li><li>如果被访问版本的 <code>事务ID &lt; up_limit_id</code>，那么表示生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 <code>事务ID &gt; low_limit_id</code> 值，那么表示生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的 <code>事务ID在 up_limit_id和m_low_limit_id</code> 之间，那就需要判断一下版本的事务ID是不是在 trx_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；<br>如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p>画张图来理解下</p><p><img src="3.png" alt="img"></p><p>这里需要思考的一个问题就是 <code>何时创建ReadView？</code></p><p>上面说过,ReadView是来解决一个事务需要读取哪个版本的行记录的问题的。那么说明什么？只有在select的时候才会创建ReadView。但在不同的隔离级别是有区别的:</p><blockquote><p>在RC隔离级别下，是每个select都会创建最新的ReadView；而在RR隔离级别下，则是当事务中的第一个select请求才创建ReadView(下面会详细举例说明)。</p></blockquote><p>那insert/update/delete操作呢？</p><p>这样操作不会创建ReadView。但是这些操作在事务开启(begin)且其未提交的时候，那么它的事务ID,会存在在其它存在查询事务的ReadView记录中，也就是trx_ids中。</p><h2 id="三、MVCC实现原理分析"><a href="#三、MVCC实现原理分析" class="headerlink" title="三、MVCC实现原理分析"></a>三、MVCC实现原理分析</h2><h4 id="1、如何查询一条记录"><a href="#1、如何查询一条记录" class="headerlink" title="1、如何查询一条记录"></a>1、如何查询一条记录</h4><ol><li>获取事务自己事务ID,即trx_id。(这个也不是select的时候获取的，而是这个事务开启的时候获取的 也就是begin的时候)</li><li>获取ReadView(这个才是select的时候才会生成的)</li><li>数据库表中如果查询到数据，那就到ReadView中的事务版本号进行比较。</li><li>如果不符合ReadView的可见性规则， 即就需要Undo log中历史快照,直到返回符合规则的数据;</li></ol><p>InnoDB 实现MVCC，是通过<code>ReadView+ Undo Log</code> 实现的，Undo Log 保存了历史快照，ReadView可见性规则帮助判断当前版本的数据是否可见。</p><h4 id="2、MVCC是如何实现读已提交和可重复读的呢？"><a href="#2、MVCC是如何实现读已提交和可重复读的呢？" class="headerlink" title="2、MVCC是如何实现读已提交和可重复读的呢？"></a>2、MVCC是如何实现读已提交和可重复读的呢？</h4><p>其实其它流程都是一样的，读已提交和可重复读唯一的区别在于：在RC隔离级别下，是每个select都会创建最新的ReadView；而在RR隔离级别下，则是当事务中的第一个select请求才创建ReadView。</p><p>看完下面这个例子你应该就明白了。</p><p><img src="4.png" alt="img"></p><h2 id="四、经典面试题-MVCC能否解决了幻读问题呢？"><a href="#四、经典面试题-MVCC能否解决了幻读问题呢？" class="headerlink" title="四、经典面试题:MVCC能否解决了幻读问题呢？"></a>四、经典面试题:MVCC能否解决了幻读问题呢？</h2><p>有关这个问题查了很多资料,有的说能解决，有的说不能解决，也有人说能解决部分幻读场景。这里部分解决指的是能解决快照读的幻读问题，不能解决当前读的幻读问题。</p><p>具体可以看下面这篇文章</p><p>面试题之：MVCC能否解决幻读？<a href="https://blog.csdn.net/qq_35590091/article/details/107734005" target="_blank" rel="noopener">https://blog.csdn.net/qq_35590091/article/details/107734005</a></p><p>先说我的结论:</p><blockquote><p>MVCC能解决不可重复读问题,但是不能解决幻读问题，不论是快照读和当前读都不能解决。RR级别解决幻读靠的是锁机制,而不是MVCC机制。</p></blockquote><p>既然网上那么多人说，MVCC解决能解决快照读下的幻读问题， 那这里通过举示例来说明,MVCC解决不了快照读的幻读问题。</p><p>假设有张用户表,这张表的 id 是主键。表中一开始有4条数据。</p><p><img src="5.png" alt="img"></p><p>这里是在RR级别下研究(可重复读)。</p><p><img src="6.png" alt="img"></p><p>1、事务A,查询是否存在 id=5 的记录，没有则插入，这是我们期望的正常业务逻辑。</p><p>2、这个时候 事务B 新增的一条 id=5 的记录，并提交事务。</p><p>3、事务A,再去查询 id=5 的时候,发现还是没有记录。</p><p>上面的文章是这样来举例说明,事务A第一次和第二次读到的是一样的，所以认为解决了幻读。我不认为这个是解决了幻读，而是解决了不可能重复读。它保证了第一次和第二次所读到的结果是一样的。</p><p>解决幻读了吗？显然没有，因为这个时候如果事务A执行一条插入操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`pwd`</span>) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">'田七'</span>, <span class="string">'fff'</span>);</span><br></pre></td></tr></table></figure><p><img src="7.png" alt="img"></p><p>最终 事务A 提交事务，发现报错了。这就很奇怪，查的时候明明没有这条记录，但插入的时候 却告诉我 主键冲突，这就好像幻觉一样。这才是幻读问题。</p><p>所以说MVCC是不能解决的，要想解决还是需要锁。</p><p>这里事务A能正常的插入的前提就是其它事务不能插入id=5并提交成功。要解决这个问题也很简单，就是事务A先获得id=5这个排它锁。</p><p>我们可以在事务A第一次查询的时候加一个排他锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span> <span class="string">`user`</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>那么事务B的插入动作永远属于堵塞状态，直到事务A插入成功，并提交。那么最终是事务B报主键冲突而回滚。但事务A不会因为查询的时候没有这条记录，插入失败。也就解决了幻读问题。</p><p>所以说 RR级别下解决幻读问题靠的是锁机制，而不是MVCC机制。</p><blockquote><p>转载公众号：后端元宇宙</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解脏读、不可重复读、幻读</title>
      <link href="/2022/07/21/mysql-2022-07-21-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB/"/>
      <url>/2022/07/21/mysql-2022-07-21-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在MySQL的众多存储引擎中，只有InnoDB支持事务，所有这里说的事务隔离级别指的是InnoDB下的事务隔离级别。</p></blockquote><p>MySQL 是支持多事务并发执行的。否则来一个事务处理一个请求，处理一个人请求的时候，其它事务都等着，那估计都没人敢用MySQL作为数据库,因为用户体验太差，估计都要砸键盘了。</p><p>既然事务可以并发操作,这里就有一些问题：一个事务在写数据的时候，另一个事务要读这行数据，该怎么处理？一个事务在写数据，另一个数据也要写这行数据，又该怎么处理这个冲突？</p><p>这就是并发事务所产生的一些问题。具体来说就是：<code>脏读</code>、<code>不可重复读</code>和<code>幻读</code>。</p><h2 id="一、概念说明"><a href="#一、概念说明" class="headerlink" title="一、概念说明"></a>一、概念说明</h2><p>以下几个概念是事务隔离级别要实际解决的问题，所以需要搞清楚都是什么意思。</p><h4 id="1、脏读"><a href="#1、脏读" class="headerlink" title="1、脏读"></a>1、脏读</h4><p>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</p><p><img src="1.png" alt="img"></p><p>脏读最大的问题就是可能会读到不存在的数据。比如在上图中，事务B的更新数据被事务A读取，但是事务B回滚了，更新数据全部还原，也就是说事务A刚刚读到的数据并没有存在于数据库中。</p><p><strong>从宏观来看，就是事务A读出了一条不存在的数据，这个问题是很严重的。</strong></p><h4 id="2、不可重复读"><a href="#2、不可重复读" class="headerlink" title="2、不可重复读"></a>2、不可重复读</h4><p>不可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据出现不一致的情况。</p><p><img src="2.png" alt="img"></p><p><strong>事务 A 多次读取同一数据，但事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</strong></p><h4 id="3、幻读"><a href="#3、幻读" class="headerlink" title="3、幻读"></a>3、幻读</h4><p>脏读、不可重复读上面的图文都很好的理解，对于幻读网上有很多文章都是这么解释的</p><p><strong>幻读错误的理解</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">说幻读是 事务A 执行两次 <span class="keyword">select</span> 操作得到不同的数据集，即 <span class="keyword">select</span> <span class="number">1</span> 得到 <span class="number">10</span> 条记录，<span class="keyword">select</span> <span class="number">2</span> 得到 <span class="number">15</span> 条记录。</span><br><span class="line">这其实并不是幻读，既然第一次和第二次读取的不一致，那不还是不可重复读吗，所以这是不可重复读的一种。</span><br></pre></td></tr></table></figure><p><strong>正确的理解应该是</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 <span class="built_in">select</span> 操作得到的结果所表征的数据状态无法支撑后续的业务操作。</span><br><span class="line">更为具体一些：<span class="built_in">select</span> 某记录是否存在，不存在，准备插入此记录，但执行 <span class="built_in">insert</span> 时发现此记录已存在，无法插入，此时就发生了幻读。</span><br><span class="line">举例</span><br></pre></td></tr></table></figure><p>假设有张用户表,这张表的 id 是主键。表中一开始有4条数据。</p><p><img src="3.png" alt="img"></p><p>我们再来看下出现 幻读 的场景</p><p><img src="4.png" alt="img"></p><p>这里是在RR级别下研究(可重复读),因为 RU / RC 下还会存在脏读、不可重复读，故我们就以 RR 级别来研究 幻读，排除其他干扰。</p><p>1、事务A,查询是否存在 id=5 的记录，没有则插入，这是我们期望的正常业务逻辑。</p><p>2、这个时候 事务B 新增的一条 id=5 的记录，并提交事务。</p><p>3、事务A,再去查询 id=5 的时候,发现还是没有记录（因为这里是在RR级别下研究(可重复读)，所以读到依然没有数据）</p><p>4、事务A,插入一条 id=5 的数据。</p><p>最终 事务A 提交事务，发现报错了。这就很奇怪，查的时候明明没有这条记录，但插入的时候 却告诉我 主键冲突，这就好像幻觉一样。这才是所有的幻读。</p><p><strong>不可重复读侧重表达 读-读，幻读则是说 读-写，用写来证实读的是鬼影</strong>。</p><h2 id="二、事务的隔离级别"><a href="#二、事务的隔离级别" class="headerlink" title="二、事务的隔离级别"></a>二、事务的隔离级别</h2><p>上述所说的”脏读”，”不可重复读”，”幻读”这些问题，其实就是数据库读一致性问题，必须由数据库提供的事务隔离机制来进行解决。</p><p><img src="5.png" alt="img"></p><p>首先说读未提交，它是性能最好，也可以说它是最野蛮的方式，因为它压根儿就不加锁，所以根本谈不上什么隔离效果，可以理解为没有隔离。</p><p>再来说串行化。串行化就相当于上面所说的，处理一个人请求的时候，别的人都等着。读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读。</p><p>最后说读提交和可重复读。这两种隔离级别是比较复杂的，既要允许一定的并发，又想要兼顾的解决问题。MySQL默认事务隔离级别为可重复读(RR),oracle默认事务隔离级别为读已提交(RC),</p><p>数据库的事务隔离越严格，并发副作用越小，但付出的代价越大；因为事务隔离本质就是使事务在一定程度上处于串行状态，这本身就是和并发相矛盾的。</p><p>同时，不同的应用对读一致性和事务隔离级别是不一样的，比如许多应用对数据的一致性没那么个高要求，相反，对并发有一定要求。</p><blockquote><p>公众号：后端的名字一文，解释的不错，特地转载。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的操作规范</title>
      <link href="/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E6%93%8D%E4%BD%9C%E8%A7%84%E8%8C%83/"/>
      <url>/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E6%93%8D%E4%BD%9C%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天来看一下，比较通用的规范操作。</p><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>1.1、表名建议使用有业务意义的英文词汇，必要时可加数字和下划线，并以英文字母开头；</p><p>1.2、库、表、字段全部采用小写；</p><p>MySQL 在 Linux 下默认是区分大小写的，而在 Windows 下不区分大小写。因此，防止出现问题，建议都设置为小写。</p><p>1.3、避免用 MySQL 的保留字， MySQL 保留字请参考<a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html" target="_blank" rel="noopener">官方手册：9.3 Keywords and Reserved Words</a>；</p><p>1.4、命名（包括表名、列名）禁止超过 30 个字符；</p><p>1.5、临时库、表名必须以 tmp 为前缀，并以日期为后缀，如：tmp_shop_info_20190404；</p><p>1.6、备份库、表必须以 bak 为前缀，并以日期为后缀，如：bak_shop_info_20190404；</p><p>1.7、索引命名：</p><ul><li>非唯一索引必须按照“idx_字段名称”进行命名；</li><li>唯一索引必须按照“uniq_字段名称”进行命名。</li></ul><h2 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h2><ol><li>主键：</li></ol><ul><li>表必须有主键；</li><li>不使用更新频繁的列做主键；</li><li>尽量不选择字符串列做主键；</li><li>不使用 UUID MD5 HASH 做主键；</li><li>默认使用非空的唯一键。</li></ul><ol><li><p>如无特殊要求，建议都使用 InnoDB 引擎；</p></li><li><p>默认使用 utf8mb4 字符集，数据排序规则使用 utf8mb4_general_ci；</p></li></ol><p>原因：utf8mb4 为万国码，无乱码风险；与 utf8 编码相比，utf8mb4 能支持 Emoji 表情。</p><ol><li>所有表、字段都需要增加 comment 来描述此表、字段所表示的含义；</li></ol><p>比如：data_status TINYINT NOT NULL DEFAULT ‘1’ COMMENT ‘1代表记录有效，0代表记录无效’。</p><ol><li><p>、如无说明，表必须包含 create_time 和 update_time 字段，即表必须包含记录创建时间和修改时间的字段；</p></li><li><p>用尽量少的存储空间来存数一个字段的数据：</p></li></ol><ul><li>能用 int 的就不用 char 或者 varchar；</li><li>能用 tinyint 的就不用 int；</li><li>使用 UNSIGNED 存储非负数值；</li><li>只存储年使用 YEAR 类型；</li><li>只存储日期使用 DATE 类型。</li></ul><ol><li>存储精确浮点数必须使用 DECIMAL 替代 FLOAT 和 DOUBLE；</li></ol><p>原因：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。</p><ol><li>尽可能不使用 TEXT、BLOB 类型；</li></ol><p>原因：会浪费更多的磁盘和内存空间，非必要的大量大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能。如果实在有某个字段过长需要使用 TEXT、BLOB 类型，则建议独立出来一张表，用主键来对应，避免影响原表的查询效率。</p><ol><li><p>禁止在数据库中存储明文密码；</p></li><li><p>索引设计规范：</p></li></ol><ul><li><p>需要添加索引的字段</p><ul><li><p>UPDATE、DELETE 语句的 WHERE 条件列；</p></li><li><p>ORDER BY、GROUP BY、DISTINCT 的字段（原因可复习<a href="https://www.imooc.com/read/43/article/686" target="_blank" rel="noopener">第 6 节</a>）；</p></li><li><p>多表 JOIN 的字段（原因可复习<a href="https://www.imooc.com/read/43/article/688" target="_blank" rel="noopener">第 8 节</a>）。</p></li></ul></li><li><p>单表索引建议控制在 5 个以内；</p></li><li><p>适当配置联合索引；</p></li></ul><p>比如方便查询能走覆盖索引，或者几个字段同时作为条件的概率很高时，当然还有其他很多种情况可以设置联合索引.</p><ul><li>业务上具有唯一性的字段，添加成唯一索引；</li></ul><p>遇到过几次字段在业务场景上要求唯一，但是该字段在数据库里的数据却出现了重复。因此在代码层考虑外，还需要在 MySQL 上的对应字段添加唯一索引。</p><ul><li>在 varchar 字段上建立索引时，建议根据实际文本区分度指定索引长度；</li></ul><p>原因：可以降低索引所占用的空间，并且很多时候，比如字符串基本是长度大于 20，但是只要建立长度为 20 的索引，就已经有很高的区分度了。可以使用 count(distinct left(列名, 索引长度))/count(*) 的区分度来确定。</p><ul><li><p>索引禁忌：</p><ul><li><p>不在低基数列上建立索引，例如：性别字段。</p></li><li><p>不在索引列进行数学运算和函数运算（原因，做函数操作可能会导致使用不了索引）</p></li></ul></li></ul><ol><li>不建议使用外键；</li></ol><p>原因：外键会导致表与表之间耦合，update 与 delete 操作都会涉及相关联的表，十分影响 sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能。</p><ol><li>禁止使用存储过程、视图、触发器、Event ；</li></ol><p>原因：高并发的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性。</p><ol><li><p>单表列数目建议小于 30；</p></li><li><p>表示例：</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_info (</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line"> stu_name <span class="built_in">VARCHAR</span> (<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line"> stu_class <span class="built_in">VARCHAR</span> (<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'班级'</span>,</span><br><span class="line"> stu_num <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'学号'</span>,</span><br><span class="line"> stu_score <span class="built_in">SMALLINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'总分'</span>,</span><br><span class="line"> tuition <span class="built_in">DECIMAL</span> (<span class="number">5</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'学费'</span>,</span><br><span class="line"> phone_number <span class="built_in">VARCHAR</span> (<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'电话号码'</span>,</span><br><span class="line"> create_time datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'记录创建时间'</span>,</span><br><span class="line"> update_time datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'记录更新时间'</span>,</span><br><span class="line"> <span class="keyword">status</span> <span class="built_in">TINYINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'1代表记录有效，0代表记录无效'</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line"> <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> uniq_stu_num (stu_num),</span><br><span class="line"> <span class="keyword">KEY</span> idx_stu_score (stu_score),</span><br><span class="line"> <span class="keyword">KEY</span> idx_update_time_tuition (update_time, tuition)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">charset</span> = utf8mb4 <span class="keyword">COMMENT</span> <span class="string">'学生信息表'</span>;</span><br></pre></td></tr></table></figure><h2 id="SQL语句规范"><a href="#SQL语句规范" class="headerlink" title="SQL语句规范"></a>SQL语句规范</h2><ol><li>避免隐式转换；</li></ol><p>具体原因可以看一下前文。</p><ol><li>尽量不使用select *,只 select 需要的字段 ；</li></ol><p>原因：读取不需要的列会增加 CPU、IO、NET 消耗，并且不能有效的利用覆盖索引。使用 SELECT * 容易在增加或者删除字段后导致程序报错。</p><ol><li>禁止使用 INSERT INTO t_xxx VALUES (xxx)，必须显示指定插入的列属性 ；</li></ol><p>原因：容易在增加或者删除字段后导致程序报错。</p><ol><li>尽量不使用负向查询；</li></ol><p>比如 not in/like。</p><ol><li>禁止以 % 开头的模糊查询。</li></ol><p>原因：使用不了索引</p><ol><li><p>禁止单条 SQL 语句同时更新多个表；</p></li><li><p>统计记录数使用 select count(*)，而不是 select count(primary_key)或者 select count(普通字段名)；</p></li></ol><p>原因：可能会导致走的索引不是最优的或者导致统计数字不准确。</p><ol><li><p>建议将子查询转换为关联查询；</p></li><li><p>建议应用程序捕获 SQL 异常，并有相应处理；</p></li><li><p>SQL 中不建议使用 sleep()，如特殊需求需要用到 sleep()，请提前告知 DBA；</p></li><li><p>避免大表的 join。</p></li></ol><h2 id="行为规范"><a href="#行为规范" class="headerlink" title="行为规范"></a>行为规范</h2><ol><li><p>批量导入、导出数据必须提前通知 DBA 协助观察；</p></li><li><p>有可能导致 MySQL QPS 上升的活动，提前告知DBA；</p></li><li><p>同一张表的多个 alter 合成一次操作；</p></li><li><p>不在业务高峰期批量更新、查询数据库；</p></li><li><p>删除表或者库要求尽量先 rename，观察几天，确定对业务没影响，再 drop。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了 MySQL 的一些操作规范，主要讲解了下面这些场景的规范：</p><ol><li>命名规范；</li><li>设计规范；</li><li>SQL 语句规范；</li><li>行为规范。</li></ol><p>当然，各个公司可能都有自己独有的 MySQL 使用规范，因此这篇文章仅供参考。</p><p>当制定出合理的 MySQL 使用规范，并严格按照规范操作，很多问题都可以在源头上避免掉。</p><blockquote><p>参考资料</p><p>《MySQL 工作笔记》第 4 章：SQL 开发规范和基础</p><p>《阿里巴巴Java开发手册》第五章：MySQL 数据库</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层的优化点总结</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E4%BC%98%E5%8C%96%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E4%BC%98%E5%8C%96%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    对于数据库的使用，我们不仅仅要考虑 MySQL 本身的优化，还需要考虑应用层的优化。因为有些线上问题，就是由于应用层设置不合理导致的。下面看一下常见的优化点。</p><h2 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h2><p>MySQL 如果频繁创建和断开连接，那 MySQL 的开销会比较大，可能会占用过多的服务器内存资源，甚至导致响应时间变慢。此时就可以考虑使用连接池来改进性能。</p><p>连接池可以理解为：创建一些持久连接的“池”，新的请求可以使用这些连接池，减少创建和断开连接的次数。</p><p>其大致原理是：</p><ol><li>当进程启动时，创建相应的数据库连接池对象；</li><li>如果程序需要请求数据库，则直接从连接池获取到一个连接；</li><li>数据库请求完成后，释放数据库连接池。</li></ol><p><strong>那么连接池会不会导致服务器连接过多呢？</strong></p><p>通常情况下，连接池不会导致服务器连接过多，因为它们会在进程间排队和共享连接。</p><blockquote><p>在《高性能 MySQL》第 14 章：应用层优化中就提到：当遇到连接池完全占满时，应该将连接请求进行排队，而不是扩展连接池。这样可以避免将压力都转到 MySQL 上而导致 MySQL 连接数过多。</p></blockquote><h2 id="减少对-MySQL-的访问"><a href="#减少对-MySQL-的访问" class="headerlink" title="减少对 MySQL 的访问"></a>减少对 MySQL 的访问</h2><p>避免对同一行数据做重复检索，比如查询某个用户信息。</p><p>首先查出这个用户的联系方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> phone <span class="keyword">from</span> user_info <span class="keyword">where</span> user_id=<span class="number">111</span>;</span><br></pre></td></tr></table></figure><p>然后再查出这个用户的姓名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> user_info <span class="keyword">where</span> user_id=<span class="number">111</span>;</span><br></pre></td></tr></table></figure><p>显然上面的方式并不是最优的，可以将两条 SQL 合并成一条：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> phone,<span class="keyword">name</span>  <span class="keyword">from</span> user_info <span class="keyword">where</span> user_id=<span class="number">111</span>;</span><br></pre></td></tr></table></figure><p>然后返回给客户端。这样跟数据库建立连接的次数从 2 次降低到 1 次，从而节省了部分建立连接所花费的内存和时间。</p><h2 id="增加-Redis-缓存层"><a href="#增加-Redis-缓存层" class="headerlink" title="增加 Redis 缓存层"></a>增加 Redis 缓存层</h2><p>在很多业务场景，Redis 充当着不可或缺的角色。这里介绍几种通过 Redis 环境 MySQL 压力的场景：</p><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>当统计数增加，则在 Redis 中执行下面的命令让计数器加 1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR t1_count</span><br></pre></td></tr></table></figure><p>通过这种方式缓解在 MySQL 中执行 update 的压力。</p><h3 id="K-V-数据缓存"><a href="#K-V-数据缓存" class="headerlink" title="K-V 数据缓存"></a>K-V 数据缓存</h3><p>在 MySQL 中，如果某个字段会被频繁查询，而该字段内容变化的概率又不是很大，就可以考虑使用 Redis 缓存。比如电商业务，查看上个季度某类型商品的销量排行，如果这一个功能放在主页，点击量可能会非常高，因此可以考虑放在 Redis 中。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Redis 中可以非常方便的使用消息队列。</p><p>生产者通过 lpush 将消息放在 list 中，消费者通过 rpop 取出该消息。</p><p>比如使用 Redis 实现短信消息队列。如果用户在 APP 上点击注册用户名密码，需要填下手机号验证，程序会将该用户的手机号放在 Redis 的 list 中，然后另外一个程序一直去消费 list 中的手机号，取出手机后，则调用第三方短信接口，发送手机短信息给到用户。</p><h2 id="单表过大及时归档"><a href="#单表过大及时归档" class="headerlink" title="单表过大及时归档"></a>单表过大及时归档</h2><p>比如单张表过大，可能有下面这些影响：</p><ol><li>在修改表结构时导致长时间主从延迟；</li><li>备份时间过久；</li><li>查询速度可能也会变慢。</li></ol><p>因此，可以考虑对历史数据归档（比如日志数据），控制单表的数据量。</p><h2 id="代码层读写分离"><a href="#代码层读写分离" class="headerlink" title="代码层读写分离"></a>代码层读写分离</h2><p>在配置了 MySQL 主从环境的情况下，可以考虑使用读写分离，通过程序配置的这种方式，在专栏<a href="https://www.imooc.com/read/43/article/707" target="_blank" rel="noopener">第 27 节</a>有提到过。更新走主库，查询走从库。</p><p>当然，主从同步可能因为大事务或者网络等原因导致同步延迟，在使用读写分离是也需要考虑到延迟这一点。</p><h2 id="表的索引提前规划"><a href="#表的索引提前规划" class="headerlink" title="表的索引提前规划"></a>表的索引提前规划</h2><p>当开发或者 DBA 在创建新表时，就应该考虑在表的条件字段添加合适索引。这样可以避免业务上线后，数据量一上来就出现大量慢查询而导致 MySQL 服务器高负载。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了使用 MySQL 时，应用层的一些优化。</p><p>提到了以下几点优化方案：</p><p>1、使用连接池；</p><p>2、减少对 MySQL 的访问；</p><p>3、增加 Redis 缓存层；</p><p>4、单表过大及时归档；</p><p>5、代码层读写分离；</p><p>6、表的索引提前规划；</p><p>······</p><p>实际工作中也是，不单单 DBA 要去优化 MySQL，开发也应该考虑在应用层去做一些优化，以保证业务稳定高效。</p><blockquote><p>参考资料</p><p>《深入浅出 MySQL》第 23 章：应用优化</p><p>《高性能 MySQL》第 14 章：应用层优化</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除大量数据的经验</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E5%88%A0%E9%99%A4%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E5%88%A0%E9%99%A4%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了防止单张表过大，很多情况下，我们需要对历史数据做归档或者删除操作。那么如何高效删除大量无用数据呢？今天就来总结一下。</p><p>在聊数据删除前，我们先来看看 MySQL 的共享表空间和独立表空间。</p><h2 id="共享表空间和独立表空间"><a href="#共享表空间和独立表空间" class="headerlink" title="共享表空间和独立表空间"></a>共享表空间和独立表空间</h2><p>InnoDB 数据是按照表空间进行存放的，其表空间分为共享表空间和独立表空间。</p><h3 id="共享表空间"><a href="#共享表空间" class="headerlink" title="共享表空间"></a>共享表空间</h3><p>共享表空间：表的数据放在系统共享表空间，也就是跟数据字典放一起。文件名为 ibdata1。可以通过参数 innodb_data_file_path 进行设置。在 my.cnf 中配置，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path = ibdata1:1G;ibdata2:1G:autoextend</span><br></pre></td></tr></table></figure><p>表示用两个文件（ibdata1 和 ibdata2）组成表空间，文件 ibdata1 的大小为 1G，文件 ibdata2 的大小为 1G，autoextend 表示用完 1G 可以自动增长。</p><h3 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h3><p>独立表空间：每个 InnoDB 表数据存储在一个以 .idb 为后缀的文件中。</p><p>由参数 innodb_file_per_table 控制。</p><p>设置为 on 表示使用独立表空间；</p><p>设置为 off 表示使用共享表空间。</p><blockquote><p><strong>经验分享</strong></p><p>一般情况下建议设置为独立表空间，原因是：如果某张表被 drop 掉，会直接删除该表对应的文件，如果放在共享表空间中，即使执行了 drop table 操作，空间还是不能回收。</p></blockquote><p>基于上面的经验分享，因此建议使用独立表空间，而本节后面提到的几种删除数据的情况，都是基于独立表空间的情况。</p><h2 id="几种数据删除形式"><a href="#几种数据删除形式" class="headerlink" title="几种数据删除形式"></a>几种数据删除形式</h2><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>如果是某张表（假如表名为 t29）的数据和表结构都不需要使用了，那么可以考虑 drop 掉。出于安全考虑，建议的步骤如下：</p><ul><li>1、首先将表名改为 t29_bak_20191011：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t29 <span class="keyword">rename</span> t29_bak_20191011;</span><br></pre></td></tr></table></figure><ul><li>2、然后等待半个月，观察是否有程序因为找不到表 t29 而报错；</li><li>3、如果没有跟表 t29 相关的报错，则半个月后直接 drop 掉 t29_bak_20191011：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t29_bak_20191011;</span><br></pre></td></tr></table></figure><h3 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h3><p>如果是某张表（假如表名为 t29）的历史数据不需要使用了，要做一次清空，则可以考虑使用 truncate。</p><p>建议的步骤如下：</p><p>1、创建一张与 t29 表结构相同的临时表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t29_bak_20191011 <span class="keyword">like</span> t29;</span><br></pre></td></tr></table></figure><p>2、并将数据拷贝到临时表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_bak_20191011  <span class="keyword">select</span> * <span class="keyword">from</span> t29;</span><br></pre></td></tr></table></figure><p>3、再清空该表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> t29;</span><br></pre></td></tr></table></figure><p>4、如果空间不够，观察半个月后，考虑转移 t29_bak_20191011 的数据到备份机器上。然后删除表 t29_bak_20191011：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t29_bak_20191011;</span><br></pre></td></tr></table></figure><blockquote><p><strong>经验分享</strong></p><p>我不止一次遇到类似的情况：需要清空表而使用 delete from table_name，导致主从延迟和磁盘 IO 跑满的情况。 原因是 binlog 为行模式的情况下，执行全表 delete 会生成每一行对应的删除操作，因此可能导致单个删除事务非常大。而 truncate 可以理解为 drop + create，在 binlog 为 row 模式的情况下，也只会产生一行 truncate 操作。所以，建议清空表时使用 truncate 而不使用 delete。</p></blockquote><h3 id="非分区表删除部分记录"><a href="#非分区表删除部分记录" class="headerlink" title="非分区表删除部分记录"></a>非分区表删除部分记录</h3><p>实际更多的情况，我们是需要删除表中一部分数据，在没有配置分区表的情况下，就只能用 delete 了。也许我们有时会发现，在 delete 很多数据后，实际表文件大小没变化。这是什么原因呢？</p><p>原因是，如果通过 delete 删除某条记录，InnoDB 引擎会把这条记录标记为删除，但是磁盘文件的大小并不会缩小。如果之后要在这中间插入一条数据，则可以复用这个位置，如果一直没有数据插入，就会形成一个 “空洞”。因此 delete 命令是不能回收空间的，这也是 delete 后表文件大小没变化的原因。</p><p>对于非分区表删除部分记录（比如删除 2017 年之前的数据，语句为：delete from table_name where date&lt;‘2017-01-01’;），建议的步骤是：</p><ul><li>1、首先备份全表；</li><li>2、确保 date 字段有索引，如果没有索引，则需要添加索引（目的是避免执行删除命令时，全表扫描）；</li><li>3、如果要删除的数据比较多，建议写一个循环，每次删除满足条件记录的 1000 条（目的是避免大事务），删完为止：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="built_in">date</span>&lt;<span class="string">'2017-01-01'</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><ul><li>4、最后重建表（目的是释放表空间，但是会锁表，建议在业务低峰执行）：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optimize</span> <span class="keyword">table</span> student;</span><br></pre></td></tr></table></figure><h3 id="分区表删除部分分区"><a href="#分区表删除部分分区" class="headerlink" title="分区表删除部分分区"></a>分区表删除部分分区</h3><p>从 MySQL 5.1 开始，支持分区。MySQL 分区是指将一张表按照某种规则（比如时间范围或者哈希等），划分为多个区块，各个区块所属的数据文件是相互独立的。</p><p>比如对于一些日志表，我们可以创建成分区表，建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t29_log ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t29_log (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">log_info <span class="built_in">VARCHAR</span> (<span class="number">100</span>),</span><br><span class="line"><span class="built_in">date</span> datetime</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(<span class="built_in">date</span>))(</span><br><span class="line"><span class="keyword">PARTITION</span> p2016</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line"><span class="keyword">less</span> <span class="keyword">THAN</span> (<span class="number">2017</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p2017</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line"><span class="keyword">less</span> <span class="keyword">THAN</span> (<span class="number">2018</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p2018</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line"><span class="keyword">less</span> <span class="keyword">THAN</span> (<span class="number">2019</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在上表的分区表中，表示：</p><ul><li>当日期的年份小于 2017 时，则数据存放在 p2016 分区；</li><li>当日期的年份大于等于 2017 小于 2018 时，则数据存放在 p2017 分区；</li><li>当日期的年份大于等于 2018 小于 2019 时，则数据存放在 p2018 分区。</li></ul><p>对于分区表，其物理文件是由建立分区时的各个分区 idb 文件组成，如下：</p><p><img src="1.png" alt="图片描述"></p><p>这里写入几条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_log <span class="keyword">select</span> <span class="number">1</span>,<span class="string">'aaa'</span>,<span class="string">'2016-01-01'</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_log <span class="keyword">select</span> <span class="number">2</span>,<span class="string">'bbb'</span>,<span class="string">'2016-06-01'</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_log <span class="keyword">select</span> <span class="number">3</span>,<span class="string">'ccc'</span>,<span class="string">'2017-01-01'</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_log <span class="keyword">select</span> <span class="number">4</span>,<span class="string">'ddd'</span>,<span class="string">'2018-01-01'</span>;</span><br></pre></td></tr></table></figure><p>因为表 t29_log 是根据 date 来分区的，因此数据是根据 date 值的范围存放在不同的物理文件中，可以通过 information_schema 库下的 partitions 表来查看各个分区的具体信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> TABLE_SCHEMA,TABLE_NAME,PARTITION_NAME,TABLE_ROWS <span class="keyword">from</span> information_schema.partitions <span class="keyword">where</span> table_schema=<span class="string">'muke'</span> <span class="keyword">and</span> table_name=<span class="string">'t29_log'</span>;</span><br></pre></td></tr></table></figure><p><img src="/2.png" alt="图片描述"><br>TABLE_ROWS 表示每个分区中的记录数。</p><p>我们查询下 t29_log 全表的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t29_log;</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="图片描述"><br>比如上面例子中 t29_log 需要删除 2016 年全年的数据，那么可以直接把 p2016 分区 drop 掉：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t29_log <span class="keyword">drop</span> <span class="keyword">partition</span> p2016;</span><br></pre></td></tr></table></figure><p><img src="4.png" alt="图片描述"></p><p>相对慢慢 delete，这种方式删除历史数据效率高很多。</p><p>因此，对于要经常删除历史数据的表，建议配置成分区表。以方便后续历史数据删除。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节首先提到了共享表空间和独立表空间，考虑到独立表空间的情况下，如果 drop 一张表，空间可以回收。因此一般建议设置为独立表空间。</p><p>如果要清空表，建议使用 truncate，而不使用 delete。</p><p>原因是 binlog 为行模式的情况下，执行全表 delete 会生成每一行对应的删除操作，因此可能导致单个删除事务非常大。而 truncate 可以理解为 drop + create，在 binlog 为 row 模式的情况下，也只会产生一行 truncate 操作。所以，建议清空表时使用 truncate 而不使用 delete。</p><p>本节提到了几种常见删除数据的情况，并提供了一些方法，其核心是删除前，需要备份数据。以防万一，另外就是尽可能的去避免删除数据时产生大事务。</p><p>考虑到非分区表删除部分记录会比较麻烦，因此如果知道某张表（比如日志类表）会进程删除几年前的数据，那么建议设置成分区表，删除历史数据将非常方便高效。</p><blockquote><p>参考资料</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-tablespaces.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-tablespaces.html</a></p><p>《MySQL 技术内幕：InnoDB 存储引擎》3.6.1 表空间文件、4.8 分区表</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的分库分表</title>
      <link href="/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>使用数据库时，我们经常会聊到分库分表，那么分库分表有哪些方式？什么情况应该考虑分库分表呢？这次我们来看下这些问题。</p><p>MySQL 分库分表是指：把 MySQL 数据库物理地拆分到多个实例或者机器上去。从而降低单台 MySQL 实例的负载。那么这里讲的拆分究竟以什么方式实现的呢？这里就先来看看 MySQL 分库分表的拆分方法：</p><h2 id="MySQL-分库分表拆分方法"><a href="#MySQL-分库分表拆分方法" class="headerlink" title="MySQL 分库分表拆分方法"></a>MySQL 分库分表拆分方法</h2><p>MySQL 分库分表拆分方法分为：垂直拆分和水平拆分。</p><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><p>垂直拆分一般是指下面几种情况：</p><ul><li>有多个业务，每个业务单独分到一个实例里面。</li><li>在一个实例中有多个库，把这些库分别放到单独的实例中。</li><li>在一个库中存在过多的表，把这些表拆分到多个库中。</li><li>把字段过多的表拆分成多个表，每张表包含一部分字段。</li></ul><p>比如一个电商网站，他的用户信息（userinfo）、商品信息（productinfo）、订单信息（orderinfo) 垂直拆分在三个实例中，如下图所示：</p><p><img src="1.png" alt="图片描述"></p><h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><p>如果通过垂直拆分，表数据量仍然很大，那就可以考虑使用水平拆分了。</p><p>所谓水平拆分，就是把同一张表分为多张表结构相同的表，每张表里存储一部分数据。而拆分的算法也比较多，常见的就是取模、范围、和全局表等。</p><p>还是拿上面电商网站的例子，比如业务会考虑做一次活动，预计注册用户会暴涨。那么就应该考虑对用户表进行水平拆分了，如下图：</p><p><img src="2.png" alt="图片描述"></p><p>这里使用的是取模分片，用户 ID 对 3 取模，如果余数是 0，则数据存放在 userinfo01 库的 user 表中；如果余数是 1，则数据存放在 userinfo02 库的 user 表中；如果余数是 2，则数据存放在 userinfo03 库的 user 表中。</p><h2 id="哪些情况需要考虑分库分表？"><a href="#哪些情况需要考虑分库分表？" class="headerlink" title="哪些情况需要考虑分库分表？"></a>哪些情况需要考虑分库分表？</h2><p>都在提分库分表，那么哪些情况应该考虑分库分表呢？这里总结了几个需要考虑分库分表的场景：</p><h3 id="数据量过大，影响了运维操作"><a href="#数据量过大，影响了运维操作" class="headerlink" title="数据量过大，影响了运维操作"></a>数据量过大，影响了运维操作</h3><p>如果数据量比较大，其对数据库影响也会比较大，最常见的比如：影响备份、大表 DDL 导致主从长时间延迟等。下面仔细讲讲这两种情况：</p><p>备份：如果单张表或者单个实例数据量太大，那备份可能需要占用大量的 IO 和磁盘空间，并且持续时间还会比较久。曾经听说过有公司的单个实例的备份从凌晨持续到当天下午的情况，这种场景下，尽管在从库备份，如果开启了读写分离，对业务的影响也是比较大的。</p><p>DDL 导致主从长时间延迟：大表执行 DDL 不但会产生 MDL 写锁（MDL 的风险可以看前文），并且还会导致主从延迟。</p><blockquote><p><strong>直接执行大表 DDL，为什么会导致主从延迟？</strong></p><p>原因是主库执行完 DDL 后，才会写入到 binlog 里，然后传输到从库执行，而又因为从库 SQL 线程是单线程的，因此，需要等到这条 DDL 在从库执行完成，其他事务才能继续执行，而从库执行 DDL 这段时间，主从都是延迟的。</p></blockquote><h3 id="把修改频繁的字段拆分出来"><a href="#把修改频繁的字段拆分出来" class="headerlink" title="把修改频繁的字段拆分出来"></a>把修改频繁的字段拆分出来</h3><p>比如电商业务场景的用户表，这张表可能包含了用户唯一标识 ID，用户名，昵称，联系方式，性别，出生日期，注册时间，积分等等。这些字段中，其实也只有积分会变更的比较频繁，因此可以把积分字段独立出来，然后加上用户唯一标识 ID。这样，用户表的更新次数就大大降低了。</p><h3 id="把大字段拆分出去"><a href="#把大字段拆分出去" class="headerlink" title="把大字段拆分出去"></a>把大字段拆分出去</h3><p>比如电商业务的商品表，表里可能包含了商品的价格，生产日期，产地，供应商，商品详情和使用说明等。我们会发现商品详情和使用说明的字段特别大，可能字段类型需要配置成 text 或 blob，类似的字段占用的磁盘空间也是比较大。维护起来会比较麻烦，因此这种情况下，建议把这类大字段水平拆分出来。</p><h3 id="增长比较快的"><a href="#增长比较快的" class="headerlink" title="增长比较快的"></a>增长比较快的</h3><p>还是拿电商业务举例，比如订单表，如果预估未来增长速度会比较快，那么可以考虑提前对订单表进行分库分表。防止单表增长过快。</p><h3 id="降低不同库或者表的相互影响"><a href="#降低不同库或者表的相互影响" class="headerlink" title="降低不同库或者表的相互影响"></a>降低不同库或者表的相互影响</h3><p>电商业务会涉及多个模块，比如会员，订单，库存等。比如搞了一个活动，扫码送会员积分，如果会员相关的表和订单相关的表在一个库中，那么很可能会员的活动会影响到订单业务。因此可以考虑将这些模块对应的表拆分到不同的库中。避免不同业务表或者库的相互影响。</p><h2 id="分库分表的实现"><a href="#分库分表的实现" class="headerlink" title="分库分表的实现"></a>分库分表的实现</h2><h3 id="通过程序"><a href="#通过程序" class="headerlink" title="通过程序"></a>通过程序</h3><p>如我已经通过垂直拆分，将不同业务表放在不同的业务库中。这种情况，程序只要每个业务配置不同的 database 即可。</p><p>如果是水平拆分，业务可以通过程序实现，比如按照用户名首字母分，讲不同首字母的名字过来的请求放在不同的库中。</p><h3 id="通过数据库中间件"><a href="#通过数据库中间件" class="headerlink" title="通过数据库中间件"></a>通过数据库中间件</h3><p>目前比较常见的就是通过数据库中间件，比如 MyCAT。这种对业务程序来说就比较友好了，某个业务库，程序端只要连逻辑库，而后端是通过 MyCAT，将这一个逻辑库指向多个物理库。然后通过分片字段，决定数据应该放在哪个分片里。如本节 1.2 所讲的水平分割的示意图。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了 MySQL 分库分表。</p><p>一般情况下，MySQL 分库分表可以分为：</p><ul><li>垂直拆分。</li><li>水平拆分。</li></ul><p>在本节总结了需要考虑分库分表的场景：</p><ul><li>数据量过大。</li><li>某个字段更新过于频繁。</li><li>存在大字段。</li><li>表数据增长比较快。</li><li>不同库表之间性能相互影响了。</li></ul><p>最后介绍了两种分库分表的实现方式：</p><ul><li>通过程序。</li><li>通过数据库。</li></ul><blockquote><p>参考资料</p><p>《MySQL 运维内参》第 24 节：MySQL 分库分表</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读写分离注意问题</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于高访问量的业务场景，MySQL 读写分离显得格外重要。</p><p>通常我们说的 MySQL 读写分离是指：对于修改操作在主库上执行，而对于查询操作，在从库上执行。主要目的是分担主库的压力。</p><p>但是读写分离有时也会存在问题，比如：主从延迟时，读取的从库数据不是最新的，对应的业务场景比如：</p><p>你网购的一个商品，付完款之后，因为主从延迟，第一时间还查询不到订单（查询的从库），即使等一段时间能看到订单，但是相信这种情况很多用户是不能接受的。</p><p>接下里就一起来讨论一下：读写分离需要注意哪些问题。</p><p>通常情况下，读写分离都是依赖主从复制，因此，我们先来看看主从复制的原理，也能方便我们理解为什么会出现主从延迟的现象。</p><h2 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h2><h3 id="MySQL-异步复制"><a href="#MySQL-异步复制" class="headerlink" title="MySQL 异步复制"></a>MySQL 异步复制</h3><p>传统的 MySQL 主从复制是异步的，因此也称为异步复制，MySQL 异步复制的原理如下：</p><ul><li>在主库开启 binlog 的情况下</li><li>如果主库有增删改的语句，会记录到 binlog 中</li><li>主库通过 IO 线程把 binlog 里面的内容传给从库的中继日志（relay log）中</li><li>主库给客户端返回 commit 成功（这里不会管从库是否已经收到了事务的 binlog）</li><li>从库的 SQL 线程负责读取它的 relay log 里的信息并应用到从库数据库中</li></ul><p>实现原理如下图：<br><img src="1.png" alt="图片描述"><br>在上图中，有一个地方不能忽视：</p><p><strong>在主库上并行运行的更新 SQL，由于从库只有单个 SQL 线程去消化 relay log，因此更新的 SQL 在从库只能串行执行。这也是很多情况下，会出现主从延迟的原因。</strong></p><p>当然，从 5.6 开始，MySQL 支持了每个库可以配置单独的 SQL 线程来消化 relay log，在 5.7 又增加了基于组提交的并行复制，大大改善了主从延迟的问题。</p><h3 id="MySQL-半同步复制"><a href="#MySQL-半同步复制" class="headerlink" title="MySQL 半同步复制"></a>MySQL 半同步复制</h3><p>在 MySQL 异步复制的基础上，又出现了一种改进的复制方式，称为：半同步复制。其原理如下：</p><ul><li>在主库开启 binlog 的情况下</li><li>如果主库有增删改的语句，会记录到 binlog 中</li><li>主库通过 IO 线程把 binlog 里面的内容传给从库的中继日志（relay log）中</li><li><strong>从库收到 binlog 后，发送给主库一个 ACK，表示收到了</strong></li><li><strong>主库收到这个 ACK 以后，才能给客户端返回 commit 成功</strong></li><li>从库的 SQL 线程负责读取它的 relay log 里的信息并应用到从库数据库中</li></ul><p>实现原理如下图：<br><img src="2.png" alt="图片描述">跟传统的异步复制相比，半同步复制保证了所有给客户端发送过确认提交的事务，从库都已经收到这个日志了。</p><h2 id="常见的读写分离方式"><a href="#常见的读写分离方式" class="headerlink" title="常见的读写分离方式"></a>常见的读写分离方式</h2><h3 id="通过程序"><a href="#通过程序" class="headerlink" title="通过程序"></a>通过程序</h3><p>开发通过配置程序来决定修改操作走主库，查询操作走从库。这种方式直连数据库，优点是性能会好点，缺点是配置麻烦。</p><p>但是需要注意的是：从库需要设置为 read_only，防止配置错误在从库写入了数据。</p><blockquote><p>这里提醒一点：</p><p>程序连接的用户建议不要给 super 权限，因为 super 权限的用户，即使整个库设置了 read_only ，也能写入数据。</p></blockquote><h3 id="2-2、通过中间件"><a href="#2-2、通过中间件" class="headerlink" title="2.2、通过中间件"></a>2.2、通过中间件</h3><p>通过中间件实现读写分离，目前算是一种主流的方式。拿 MyCAT 举例：</p><p>在 schema.xml 文件中，dataHost 标签 balance 属性的值，决定了是否启用读写分离。</p><p>balance 各个值及对应的读写方法如下：</p><ul><li>0：不开启读写分离，读操作发送到 writehost</li><li>1：全部的 readhost 与 stand by writehost 参与 select 语句的负载均衡</li><li>2：所有读操作都随机在 writehost、readhost上分发</li><li>3：所有读请求随机分发到 writerhost 对应的 readhost 执行，writehost 不负担读压力</li></ul><p>因此可以根据实际情况选择上面合适的读写分离策略。</p><h2 id="什么情况下会出现主从延迟"><a href="#什么情况下会出现主从延迟" class="headerlink" title="什么情况下会出现主从延迟"></a>什么情况下会出现主从延迟</h2><p>我们说到，对于读写分离场景，最大的问题就是：主从延迟。那么在哪些情况下会出现主从延迟呢？这里大致总结一下可能导致主从延迟的场景：</p><ul><li>大表 DDL</li><li>大事务</li><li>主库 DML 并发大</li><li>从库配置差</li><li>表上无主键</li><li>等等</li></ul><p>因此，如果存在读写分离的情况，应尽量避免上诉情况在业务高峰出现。</p><p>当然，我们不能完全杜绝主从延迟。因此再介绍几种读写分离场景下应对延迟的方法。</p><h2 id="读写分离怎样应对主从延迟"><a href="#读写分离怎样应对主从延迟" class="headerlink" title="读写分离怎样应对主从延迟"></a>读写分离怎样应对主从延迟</h2><p>读写分离场景应该怎样应对主从延迟呢？这里来讨论一下几种常见的应对主从延迟的方法：</p><h3 id="判断主从是否延迟"><a href="#判断主从是否延迟" class="headerlink" title="判断主从是否延迟"></a>判断主从是否延迟</h3><p>有些业务场景，如果所有请求都落在主库，主库压力会很大，但是在读写分离的情况，又不希望主从存在延迟的时候去读取从库。这种情况，就可以考虑查询时，先判断主从是否存在延迟，如果存在延迟，则查询落在主库，如果没延迟，则查询语句落在从库。</p><p>这里介绍几种判断主从延迟的方法：</p><p>第一种方法：判断 Seconds_Behind_Master 是否等于 0。</p><p>如果 Seconds_Behind_Master =0，则查询从库，如果大于 0，则查询主库。</p><blockquote><p>这里补充一下 Seconds_Behind_Master。</p><p>Seconds_Behind_Master 是在从库上执行 show slave status 时返回的其中一项，表示从库延迟的秒数。</p><p>其计算方法是：</p><p>从库服务器当前的时间戳与二进制日志中的事件的时间戳（在主库上的写入时间）相对比得到的。</p></blockquote><p>但是某些情况下，Seconds_Behind_Master 并不一定准确。比如网络中断时，Seconds_Behind_Master = 0 ，并不能代表主从无延迟。因此，有比这个更准确的一种方法：对比位点或 GTID。</p><p>第二种方法：对比位点或 GTID</p><p>如果 Master_Log_File 跟 Relay_Master_Log_File 相等，</p><p>并且 Read_Master_Log_Pos 跟 Exec_Master_Log_Pos 相等，</p><p>则可以把读请求放到从库，否则读请求放到主库。</p><blockquote><p><strong>补充一下上面几个参数的意义：</strong></p><p>几个参数均是通过 show slave status 返回的参数，用来查询主从复制的状态。</p><p>Master_Log_File：IO 线程正在读取的主库 binlog 文件名</p><p>Relay_Master_Log_File：SQL 线程最近执行的事务对应的主库 binlog 文件名</p><p>Read_Master_Log_Pos ：IO 线程正在读取的主库 binlog 文件中的位点</p><p>Exec_Master_Log_Pos ：SQL 线程最近读取和执行的事务对应的主库 binlog 文件中的位点</p></blockquote><p>如果开启了 GTID 复制，则可以对比 Retrieved_Gtid_Set 和 Executed_Gtid_Set 是否相等，相等则把读请求放到从库，有差异则读请求放到主库。</p><blockquote><p><strong>同样补充下两个参数的意义：</strong></p><p>前提是需要开启 GTID 两个参数才会有值，解释如下：</p><p>Retrieved_Gtid_Set：从库收到的所有日志的 GTID 集合</p><p>Executed_Gtid_Set：从库已经执行完的 GTID 集合</p></blockquote><h3 id="采用半同步复制"><a href="#采用半同步复制" class="headerlink" title="采用半同步复制"></a>采用半同步复制</h3><p>在本节的前面，我们讲解了半同步复制的原理，跟传统的异步复制相比，半同步复制保证了所有给客户端发送过确认提交的事务，从库都已经收到这个日志了。因此出现延迟的概率会小很多，当然实际生产应用时，建议结合上面讲的位点或 GTID 判断。</p><h3 id="等待同步完成"><a href="#等待同步完成" class="headerlink" title="等待同步完成"></a>等待同步完成</h3><p>依然采用 4.1 中介绍的几种判断是否有延迟的方法，只是应对方式不一样，比如存在延迟，则将情况反馈给程序，在前端页面提醒用户数据未完全同步，如果没有延迟，则查询从库。</p><p>有人可能会觉得：这种方式谁会用啊？实际可以应用在内部人员看的报表业务上。因为报表可能涉及的 SQL 都比较复杂，存在延迟就考虑去查询主库，可能会对其它线上业务有影响，因此可以等待从库同步完成，再查询从库。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲了读写分离，由于能分担主库的压力，很多情况会考虑读写分离。但是在使用时，就应该考虑到一些问题，其中最主要的就是主从延迟。</p><p>这个就看业务是否能接受延迟了。</p><p>如果不能接受延迟，建议采用半同步复制并且加上延迟判断。存在延迟则把读请求放到主库，没延迟就读从库。</p><p>如果业务能接受延迟，可以等数据同步完成，再去从库进行查询。</p><blockquote><p>参考资料</p><p>《MyCAT 权威指南》第 1 版：6.6.4 balance 属性</p><p>《MySQL 5.7 官方手册》 14.7.5.34 SHOW SLAVE STATUS Syntax</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的QC</title>
      <link href="/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84QC/"/>
      <url>/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84QC/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从 MySQL 4.1 开始，增加了查询缓存（Query Cache，简称 QC）的功能，它会存储 select 语句的文本以及发送到客户端的结果。如果下一次收到一个相同的查询，就会从查询缓存中获得查询结果。</p><blockquote><p>关于 QC 的详细定义，可以查询 <a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="noopener">MySQL 5.7 官方手册</a></p></blockquote><p>那么是不是只要开启查询缓存就能提升查询速度呢？今天就一起探讨这一话题。</p><h2 id="认识-QC"><a href="#认识-QC" class="headerlink" title="认识 QC"></a>认识 QC</h2><p>QC 需要缓存最新数据结果，因此表数据发生任何变化（insert、update、delete 等操作时），都会导致 QC 被刷新。</p><p>查询缓存相关的参数主要有：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">"%query_cache%"</span>;</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="图片描述"></p><blockquote><p><strong>这里解释一下上面几个参数</strong></p><p>have_query_cache：服务器在安装时是否已经配置了高速缓存<br>query_cache_limit：单条查询能够使用的缓存区大小<br>query_cache_min_res_unit：查询缓存分配内存块的最小单位<br>query_cache_size：缓存区的大小，单位为 MB<br>query_cache_type：缓存类型，有三个值可选：</p><ul><li>0 或者 off：关闭缓存</li><li>1 或者 on：打开缓存</li><li>2 或者 demand：只缓存带有 sql_cache 的 select 语句。</li></ul><p>query_cache_wlock_invalidate：如果某个数据表被其它的连接锁住，是否仍然从查询缓存中返回结果</p></blockquote><p>通过下面命令，可以监视查询缓存的使用情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">"qcache%"</span>;</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="图片描述"></p><blockquote><p><strong>这里解释一下各个参数的意义</strong></p><p>Qcache_free_blocks：查询缓存中的空闲内存块的数目</p><p>Qcache_free_memory：查询缓存的空闲内存总数</p><p>Qcache_hits：缓存命中次数</p><p>Qcache_inserts：被加入到缓存中的查询数目</p><p>Qcache_lowmem_prunes：因为缺少内存而从缓存中删除的查询数目</p><p>Qcache_not_cached：没有被缓存的查询数目</p><p>Qcache_queries_in_cache：在缓存中已注册的查询数目</p><p>Qcache_total_blocks：查询缓存中的块的总数目</p></blockquote><h2 id="QC-的优劣"><a href="#QC-的优劣" class="headerlink" title="QC 的优劣"></a>QC 的优劣</h2><p>在讲到底要不要开启 QC 之前，我们先聊聊 QC 的优劣。</p><p>QC 优势：</p><ul><li>提高查询速度：使用查询缓存在单行数据的表中搜索要比不使用查询缓存快 238%（数据来源：<a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="noopener">MySQL 5.7 官方手册</a>）。</li></ul><p>劣势：</p><ul><li>比如执行的 SQL 都很简单（比如从只有一行的表中查询数据），但每次查询都不一样的话，打开 QC 后，额外的开销为 13% 左右；</li><li>如果表数据发生了修改，使用该表的所有缓存查询都将实效，并且从缓存中删除；</li><li>QC 要求前后两次请求的 SQL 完全一样，不同数据库、不同协议版本或不同默认字符集的查询，都会被认为是不同的查询。甚至包括大小写，比如下面两条 SQL ，查询缓存就会认为是两个不同的查询：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> tbl_name</span><br></pre></td></tr></table></figure><ul><li>每次更新 QC 的内存块都需要进行锁定；</li><li>可能会导致 SQL 查询时间不稳定，比如<a href="https://www.percona.com/blog/2012/09/05/write-contentions-on-the-query-cache/" target="_blank" rel="noopener">这个例子</a>。</li></ul><h2 id="是否需要开启-QC"><a href="#是否需要开启-QC" class="headerlink" title="是否需要开启 QC"></a>是否需要开启 QC</h2><p>通过上面讲解的 QC 优劣，对于是否需要开启 QC 这个问题，我们大概能总结出：</p><p>如果线上环境中 99% 以上都是只读，很少更新，可以考虑全局开启 QC，也就是设置 query_cache_type 为 1。</p><p>很多时候，我们希望缓存的是几张更新频率很低的表，其它表不考虑使用查询缓存，就可以考虑将 query_cache_type 设置成 2 或者 DEMAND，这样就只缓存下面这类 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sql_cache</span> ......;</span><br></pre></td></tr></table></figure><p>结合前面讲的 QC 的劣势，其它情况就不建议开启 QC 了。</p><h2 id="4-怎样开启和关闭-QC"><a href="#4-怎样开启和关闭-QC" class="headerlink" title="4 怎样开启和关闭 QC"></a>4 怎样开启和关闭 QC</h2><p>全局开启 QC：</p><p>在配置文件 my.cnf 中设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type = 1</span><br><span class="line">query_cache_size = 50M</span><br></pre></td></tr></table></figure><p>只开启部分表的 QC：</p><p>在配置文件 my.cnf 中设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type = 2</span><br><span class="line">query_cache_size = 50M</span><br></pre></td></tr></table></figure><p>前面也提到了，这种情况，如果要使用 QC，查询语句需要加上 select sql_cache。</p><p>关闭 QC：</p><p>在配置文件 my.cnf 中设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type = 0</span><br><span class="line">query_cache_size = 0</span><br></pre></td></tr></table></figure><p>或者源码编译安装 MySQL 的话，编译时增加参数 —without-query-cache 即可。</p><h2 id="开启-QC-的注意事项"><a href="#开启-QC-的注意事项" class="headerlink" title="开启 QC 的注意事项"></a>开启 QC 的注意事项</h2><p>如果要开启 QC，建议不要设置过大，通常几十兆就好。如果设置过大，会增加维护缓存所需要的开销。</p><p>另外要注意一些即使开启 QC 也不能使用 QC 的场景（这里参考的是 MySQL 5.7 官方手册第 8.10.3.1 节： <a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-operation.html" target="_blank" rel="noopener">How the Query Cache Operates</a> ）：</p><ul><li>分区表不支持，如果涉及分区表的查询，将自动禁用查询缓存</li><li>子查询或者外层查询</li><li>存储过程、触发器中使用的 SQL</li><li>读取系统库时</li><li>类似下面 SQL 时：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><ul><li>用到临时表</li><li>产生了 warning 的查询</li><li>显示增加了 SQL_NO_CACHE 关键字的</li><li>如果没有全部库、表的 select 权限，则也不会使用 QC</li><li>使用了一些函数：比如 now ()，user ()，password () 等</li></ul><p>了解上面的场景，我们就能知道：开了查询缓存，前后 SQL 一模一样，为什么后面这一次执行也使用不了缓存的原因了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查询环境会存储 select 语句的文本以及发送到客户端的结果。</p><p>如果使用查询缓存在单行数据的表中搜索要比不使用查询缓存快 238%。</p><p>如果线上环境中 99% 以上都是只读，很少更新，可以考虑全局开启 QC。如果希望缓存的是几张更新频率很低的表，其它表不考虑使用查询缓存，就可以考虑将 query_cache_type 设置成 2，这些需要使用查询缓存的表，使用时加上 select sql_cache 即可。</p><p>但是考虑到 QC 存在下面这些缺点，因此，其它情况就不建议开启 QC 了。</p><ul><li>每次查询不一样，会额外增加开销</li><li>需要前后两条 SQL 完全一样才能使用</li><li>只要存在更新，就会清空这张表的查询缓存</li><li>等等</li></ul><p>当然开启 QC 的情况下，部分查询是无法走 QC 的，需要留意到这些场景。</p><blockquote><p>参考资料</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/query-cache.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-operation.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/query-cache-operation.html</a></p><p><a href="https://www.percona.com/blog/2012/09/05/write-contentions-on-the-query-cache/" target="_blank" rel="noopener">https://www.percona.com/blog/2012/09/05/write-contentions-on-the-query-cache/</a></p><p>《深入浅出 MySQL》第 2 版：23.2.2 使用查询缓存}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置自增主键的好处</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%A5%BD%E5%A4%84/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>mysql默认都带有一个id的自增主键，这么做的原因是神马，今天研究一下。</p><h2 id="关于自增主键"><a href="#关于自增主键" class="headerlink" title="关于自增主键"></a>关于自增主键</h2><p>当我们创建表时，可以定义主键为自增的，具体方法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t25`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`b`</span> <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>空表情况下，我们不指定 id 字段写入数据时，id 字段会自动获取到值 1，如下：</p><p>首先写入一条数据，没指定 id 的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t25(a,b) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'hi'</span>);</span><br></pre></td></tr></table></figure><p>再进行查询时，发现 id 字段自动获取到值 1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t25;</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="图片描述"><br>这里我们查询一下表 t25 的表结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t25;</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="图片描述"><br>发现表结构中包含 AUTO_INCREMENT=2，在下一次执行未指定 id 字段的 insert 语句时， 主键 id 会自动获取到这个值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t25(a,b) <span class="keyword">values</span> (<span class="number">2</span>,<span class="string">'ha'</span>);</span><br></pre></td></tr></table></figure><p>select * from t25;<br><img src="3.png" alt="图片描述"><br>发现新写入的数据 id 自动获取到 2 这个值。也就是，如果不指定，则会写入当前最大 ID 加 1 的值。</p><h2 id="主键和聚集索引的关系"><a href="#主键和聚集索引的关系" class="headerlink" title="主键和聚集索引的关系"></a>主键和聚集索引的关系</h2><p>很多同学会把主键和聚集索引弄混，这里先简单聊聊它们的区别：</p><ul><li>在 InnoDB 中，聚集索引不一定是主键，但是主键一定是聚集索引：原因是如果没有定义主键，聚集索引可能是第一个不允许为 null 的唯一索引，如果也没有这样的唯一索引，InnoDB 会选择内置 6 字节长的 ROWID 作为隐含的聚集索引。</li><li>我们知道 InnoDB 的数据是按照主键顺序存放的，而聚集索引就是按照每张表的主键构造一颗 B+ 树，它的叶子节点存放的是整行数据。</li><li>每张 InnoDB 表都有一个聚集索引，但是不一定有主键。</li></ul><h2 id="主键是否需要设置为自增"><a href="#主键是否需要设置为自增" class="headerlink" title="主键是否需要设置为自增"></a>主键是否需要设置为自增</h2><p>现在来讨论本节的重点：主键是否需要设置为自增？</p><p>通过上面的学习，我们知道了聚集索引是按照每张表的主键构造一颗 B+ 树的，而 B+ 树中，所有记录节点都是按键值的大小顺序存放在同一层叶子节点上。</p><p>如果每次插入的数据都是在聚集索引树的后面，聚集索引不需要分裂就可以存入数据。</p><p>但是如果插入的数据值在聚集索引树的中间部分，由于要保证插入后叶子节点中的记录依然排序，就可能需要聚集索引树分裂来保证键值的有序性。如下（这里省略了叶子节点之间的指针）：<br><img src="4.png" alt="图片描述"><br>如上图，Leaf Page（叶子节点数据页)已经满的情况下，如果写入的值是聚集索引树的中间部分，则会进行一次页分裂，以保证叶子节点上的记录有序和 B+ 树的平衡。并且分裂后，有些数据页没被用满，导致页空间浪费。</p><p><strong>因此如果业务输入的主键都是随机数字，那么写入数据时很可能会导致数据页频繁分裂，从而影响写入效率。</strong></p><p><strong>而如果设置主键是自增，那么每一次都是在聚集索引的最后增加，当一页写满，就会自动开辟一个新页，不会有聚集索引树分裂这一步，效率会比随机主键高很多。这也是很多建表规范要求主键自增的原因。</strong></p><blockquote><p>经验分享：</p><p>除了要求主键自增外，最好主键也要无业务意义，原因是防止主键更新而导致页分裂的情况。</p></blockquote><p>当然也不是所有的情况主键都需要设置为自增，比如可以用程序写入增长的主键值，保证了新写入数据的主键值比之前大，也可以避免聚集索引树频繁分裂。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讨论了自增主键的使用方式，并讲解了主键与聚集索引的关系。</p><p>通过本节学习，<strong>如果主键是随机的，那么写入数据时很可能会导致数据页频繁分裂，从而导致写入效率低和页空间浪费。</strong></p><p><strong>而如果设置主键是自增，那么每一次都是在聚集索引的最后增加，当一页写满，就会自动开辟一个新页，不会有聚集索引树分裂这一步，效率会比随机主键高很多。</strong></p><p>当然也不是所有的表都需要设置为自增，如果通过业务逻辑给到表主键的值是增长的（不一定连续），保证了新写入数据的主键值比之前大，也可以避免聚集索引树频繁分裂。这种方式也是可以选择的。</p><blockquote><p>参考资料</p><p>《MySQL 技术内幕：InnoDB 存储引擎》第 2 版 5.3.1 B+ 树的插入操作 和 5.4.3 B+ 树索引的分裂</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入攻击和预防</title>
      <link href="/2022/07/19/mysql-2022-07-19-sql%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%92%8C%E9%A2%84%E9%98%B2/"/>
      <url>/2022/07/19/mysql-2022-07-19-sql%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%92%8C%E9%A2%84%E9%98%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多时候，我们关心的是程序是否能实现我们的预期功能，而忽视了 SQL 安全，这就存在 SQL 注入的风险，本节就一起来聊聊 SQL 注入及防御。</p><h2 id="认识-SQL-注入"><a href="#认识-SQL-注入" class="headerlink" title="认识 SQL 注入"></a>认识 SQL 注入</h2><p>SQL 注入是利用某些数据库的外部接口将用户数据插入到实际的数据库操作语句中，从而达到入侵数据库乃至操作系统的目的。</p><p>SQL 注入产生的主要原因是：程序对用户输入的数据没有进行严格的过滤，导致非法数据库查询语句的执行。</p><p>SQL 注入具有很大的危害，可能会导致攻击者非法入侵系统，或者盗取数据，甚至清空数据等。</p><h2 id="如何进行-SQL-注入攻击"><a href="#如何进行-SQL-注入攻击" class="headerlink" title="如何进行 SQL 注入攻击"></a>如何进行 SQL 注入攻击</h2><p>为了方便理解 SQL 注入，我们来用实验模拟一下 SQL 注入攻击。</p><p>我们模拟一个用户登录验证的场景，首先创建用户表，并录入几个用户，语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists t24;</span><br><span class="line">CREATE TABLE &#96;t24&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;username&#96; varchar(20) DEFAULT NULL,</span><br><span class="line">  &#96;password&#96; varchar(20) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB CHARSET&#x3D;utf8mb4;</span><br><span class="line"></span><br><span class="line">insert into t24(username,password) values (&#39;mt&#39;,&#39;aaa&#39;),(&#39;gg&#39;,&#39;bbb&#39;),(&#39;mm&#39;,&#39;ccc&#39;);</span><br></pre></td></tr></table></figure><p>验证用户登录的 PHP 代码（PHP 版本：7.0.33）：</p><p>文件名：index.php</p><p>内容如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername=<span class="string">"127.0.0.1"</span>;</span><br><span class="line">$dbuser=<span class="string">"muke_user"</span>;</span><br><span class="line">$dbpassword=<span class="string">"9Gcag71Gaa"</span>;</span><br><span class="line">$dbname=<span class="string">"muke"</span>;</span><br><span class="line"></span><br><span class="line">$mysqli = <span class="keyword">new</span> mysqli($servername,$dbuser,$dbpassword,$dbname); <span class="comment">//配置MySQL连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($mysqli-&gt;connect_error)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'connect error:'</span>.$mysqli-&gt;connect_errno);</span><br><span class="line">&#125;</span><br><span class="line">$mysqli-&gt;set_charset(<span class="string">'UTF-8'</span>); <span class="comment">// 设置数据库字符集</span></span><br><span class="line">$username = <span class="keyword">isset</span>($_GET[<span class="string">'username'</span>]) ? $_GET[<span class="string">'username'</span>] : <span class="string">''</span>;</span><br><span class="line">$password = <span class="keyword">isset</span>($_GET[<span class="string">'password'</span>]) ? $_GET[<span class="string">'password'</span>] : <span class="string">''</span>;</span><br><span class="line">$sql = <span class="string">"select * from t24 where username='$username' and password= '$password'"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$sql&lt;br/&gt;"</span>;</span><br><span class="line">$result = $mysqli-&gt;query(<span class="string">"$sql"</span>);</span><br><span class="line"></span><br><span class="line">$data = $result-&gt;fetch_all(); <span class="comment">// 从结果集中获取所有数据</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($data))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"登录失败"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"登录成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">print_r($data);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>正常情况下，我们提交如下 URL，如果用户名密码正确的话，就可以使用 mt 这个用户登录系统了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=aaa</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887cb0001b39908610178.png" alt="图片描述"></p><p>如果不知道密码情况下乱输入一个密码，将无法登录通过验证：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=abc</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887be00014eb008600184.png" alt="图片描述"></p><p>但是可以通过 SQL 注入的方式，让攻击者不知道密码的情况也可以通过验证，如下：</p><p>把 URL 改成：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt' or '1=1</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887af0001c0c709390182.png" alt="图片描述"><br>显然我们不希望能通过这种方式登录系统，这就是一个 SQL 注入的例子。</p><p>这个例子中，甚至可以通过 SQL 注入捞取到所有用户信息，如下 URL：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=aaa' or username&lt;&gt;'mt</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d88879c0001313a17420198.png" alt="图片描述"><br>从上面截图中可以看到，URL 获取到表里所有用户的信息了。如果是生产环境，用户表有这种漏洞，可想而知他的危害有多大。</p><h2 id="如何预防-SQL-注入"><a href="#如何预防-SQL-注入" class="headerlink" title="如何预防 SQL 注入"></a>如何预防 SQL 注入</h2><h3 id="控制输入变量的格式"><a href="#控制输入变量的格式" class="headerlink" title="控制输入变量的格式"></a>控制输入变量的格式</h3><p>如上面例子中的 PHP 代码，可以优化成如下效果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername=<span class="string">"127.0.0.1"</span>;</span><br><span class="line">$dbuser=<span class="string">"muke_user"</span>;</span><br><span class="line">$dbpassword=<span class="string">"9Gcag71Gaa"</span>;</span><br><span class="line">$dbname=<span class="string">"muke"</span>;</span><br><span class="line"></span><br><span class="line">$mysqli = <span class="keyword">new</span> mysqli($servername,$dbuser,$dbpassword,$dbname); <span class="comment">//配置MySQL连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($mysqli-&gt;connect_error)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'connect error:'</span>.$mysqli-&gt;connect_errno);</span><br><span class="line">&#125;</span><br><span class="line">$mysqli-&gt;set_charset(<span class="string">'UTF-8'</span>); <span class="comment">// 设置数据库字符集</span></span><br><span class="line">$username = <span class="keyword">isset</span>($_GET[<span class="string">'username'</span>]) ? $_GET[<span class="string">'username'</span>] : <span class="string">''</span>;</span><br><span class="line">$password = <span class="keyword">isset</span>($_GET[<span class="string">'password'</span>]) ? $_GET[<span class="string">'password'</span>] : <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加对输入用户名密码的判断，如果不是字母或者数字，就直接提示格式错误而退出。</span></span><br><span class="line"><span class="keyword">if</span>( !preg_match(<span class="string">"/^[a-zA-Z0-9]&#123;1,&#125;$/"</span>,$username) || !preg_match(<span class="string">"/^[a-zA-Z0-9]&#123;1,&#125;$/"</span>,$password) ) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">"You input username and password  format error "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"select * from t24 where username='$username' and password= '$password'"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$sql&lt;br/&gt;"</span>;</span><br><span class="line">$result = $mysqli-&gt;query(<span class="string">"$sql"</span>);</span><br><span class="line"></span><br><span class="line">$data = $result-&gt;fetch_all(); <span class="comment">// 从结果集中获取所有数据</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($data))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"登录失败"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"登录成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">print_r($data);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>增加了对输入信息的判断，过滤掉一些带特殊字符的输入，我们再验证一下是否还会出现上面我们测试的 SQL 注入情况：</p><p>首先看这个 URL：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt' or '1=1</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d88876a0001d7f309240113.png" alt="图片描述"><br>发现会提示输入格式有问题，无法登录系统。</p><p>在看下上面能获取整张用户表数据的 SQL 注入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=aaa' or username&lt;&gt;'mt</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887590001e63712140133.png" alt="图片描述"></p><p>发现同样提示输入格式有问题，无法查询到任何数据。</p><h3 id="转义特殊字符"><a href="#转义特殊字符" class="headerlink" title="转义特殊字符"></a>转义特殊字符</h3><p>有时，我们程序是允许输入信息带特殊字符的，这种情况就可以使用转义的方式，防止 SQL 注入。</p><p>我们来实验下，在原始代码中，修改定义 sql 这一行为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql = <span class="string">"select * from t24 where username='"</span> . addslashes($username) . <span class="string">"' and password= '"</span> . addslashes($password) . <span class="string">"'"</span>;</span><br></pre></td></tr></table></figure><p>我们再输入前面会导致 SQL 注入的 URL：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt' or '1=1</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887420001ee7f09300195.png" alt="图片描述"></p><p>将传输的变量转义后，避免了 SQL 注入，发现登录失败。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=aaa' or username&lt;&gt;'mt</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d88872d0001a28912040188.png" alt="图片描述"><br>转义后，无法查询到整张用户表的信息了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了 SQL 注入。</p><p>产生的原因：程序对用户输入的数据没有进行严格的过滤，导致攻击者增加一些特殊字符，从而改变传输到 MySQL 中的 SQL。</p><p>SQL 注入危害：会导致攻击者非法入侵系统，或者盗取数据，甚至清空数据等。</p><p>本节讲解了 SQL 注入攻击的方法，目的是让我们能认识到会导致 SQL 注入的一些漏洞，从而优化我们的代码，比如控制输入变量的格式或者转义特殊字符，从而避免程序被 SQL 注入。</p><blockquote><p>参考资料</p><p>《深入浅出 MySQL》第 2 版 第 15 章 SQL 中的安全问题</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的分布式事务</title>
      <link href="/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天我们看一下mysql提供的分布式事务，有关分布式事务的更多详细解释以及更多的解决方案，可以看博客的其它文章。</p><h2 id="认识分布式事务"><a href="#认识分布式事务" class="headerlink" title="认识分布式事务"></a>认识分布式事务</h2><p>分布式事务是指一个大的事务由很多小操作组成，小操作分布在不同的服务器上或者不同的应用程序上。分布式事务需要保证这些小操作要么全部成功，要么全部失败。MySQL 从 5.0.3 开始支持分布式事务。</p><p>分布式事务使用两阶段提交协议：</p><ul><li>第一阶段：所有分支事务都开始准备，告诉事务管理器自己已经准备好了；</li><li>第二阶段：确定是 rollback 还是 commit，如果有一个节点不能提交，则所有节点都要回滚。</li></ul><p>与本地事务不同点在于：分布式事务需要多一次 prepare 操作，等收到所有节点的确定信息后，再进行 commit 或者 rollback。</p><p>上面买书的例子，就可以放到一个分布式事务里，保证增加订单和减库存操作有原子性，要么全部成功，要么全部失败。</p><p>MySQL 中分布式事务按实现方式可以分为两种：MySQL 自带的分布式事务和结合中间件实现分布式事务。下面来详细介绍一下这两种分布式事务。</p><h2 id="MySQL-自带的分布式事务"><a href="#MySQL-自带的分布式事务" class="headerlink" title="MySQL 自带的分布式事务"></a>MySQL 自带的分布式事务</h2><p>MySQL 有自带的分布式事务实现方法，具体语法如下：</p><p>启动分支事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">start</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>‘a’,‘a_1’ 表示 xid，</p><p>a 表示 gtrid，为分布式事务标识符，相同的分布式事务使用相同的 gtrid。</p><p>a_1 表示 bqual，为分支限定符，分布式事务中的每一个分支事务的 bqual 必须不同。</p></blockquote><p>结束分支事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">end</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><p>进入准备状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">prepare</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><p>提交分支事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">commit</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><p>回滚分支事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">rollback</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><p>返回当前数据库中处于 prepare 状态的分支事务的详细信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa recover;</span><br></pre></td></tr></table></figure><p>我们来看一个具体例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">use muke1;</td><td style="text-align:left">use muke2;</td></tr><tr><td style="text-align:left">create table t23_1(id int);</td><td style="text-align:left">create table t23_2(id int);</td></tr><tr><td style="text-align:left">xa start ‘test’,‘muke1’;</td><td style="text-align:left">xa start ‘test’,‘muke2’;</td></tr><tr><td style="text-align:left">insert into t23_1 select 1;</td><td style="text-align:left">insert into t23_2 select 1;</td></tr><tr><td style="text-align:left">xa end ‘test’,‘muke1’;</td><td style="text-align:left">xa end ‘test’,‘muke2’;</td></tr><tr><td style="text-align:left">xa prepare ‘test’,‘muke1’;</td><td style="text-align:left">xa prepare ‘test’,‘muke2’;</td></tr><tr><td style="text-align:left">xa recover \G</td><td style="text-align:left">xa recover \G</td></tr><tr><td style="text-align:left">xa commit ‘test’,‘muke1’;</td><td style="text-align:left">xa commit ‘test’,‘muke2’;</td></tr></tbody></table></div><p>上面的例子就演示了一个分布式事务，事务在 muke1 库中的 t23_1 表中插入一条记录，同时在 muke2 库中的 t23_2 表中插入一条记录，两个操作作为同一个事务提交。在进入准备状态之前，如果 session2 中某一步没执行成功而回滚了，则 session1 和 session2 整个分布式事务的操作都会回滚。</p><p>但是 MySQL 5.7 之前的版本，自带的分布式事务存在以下问题：</p><p>比如某个分支事务到达 prepare 状态时，此时数据库断电，重启后，可以继续对分支事务进行提交或者回滚，但是提交的事务不会写 binlog，如果有从库，会导致主从数据不一致的情况。</p><p>如果分支事务的客户端连接异常中止，那么数据库会自动回滚当前分支未完成的事务，如果此时分支事务已经到 prepare 状态，那么这个分布式事务的其他分支可能已经成功提交，如果这个分支回滚，可能导致分布式事务的不完整，丢失部分分支事务的内容。</p><p>还有一种情况，如果分支事务在执行到 prepare 状态时，数据库出现故障，并且无法启动，需要使用全备和 binlog 来恢复数据，那么这些在 prepare 状态的分支事务因为没有记录到 binlog，所以也不能通过binlog 进行恢复，在数据库恢复后，将丢失这部分数据。</p><p>所以，MySQL 5.7 之前的版本自带的分布式事务还存在比较严重的缺陷，在有些场景下，会导致数据丢失。如果业务对数据完整性要求不改，可以考虑使用，如果对数据完整性要求比较高，需要考虑先升级到 5.7 版本。</p><h2 id="结合中间件实现分布式"><a href="#结合中间件实现分布式" class="headerlink" title="结合中间件实现分布式"></a>结合中间件实现分布式</h2><p>上面说了 MySQL 自带的分布式事务，这里再介绍一下借助中间件实现分布式的情况。</p><p>具体实现方式可以拿上面网上购书的例子来说：</p><p>订单业务程序处理完增加订单的操作后，将减库存操作发送到消息队列中间件中（比如：Rocketmq），订单业务程序完成提交。然后库存业务程序检查到消息队列有减对应商品库存的信息，就开始执行减库存操作。库存业务执行完减库存操作，再发送一条消息给消息队列中间件：内容是已经减掉库存。具体步骤如下：<br><img src="/Users/james/blogs/blog/source/_posts/2022-07-19-mysql的分布式事务/1.png" alt="图片描述"><br>当然，为了确定最终已经完成减库存操作，还可以加一步对数据库中该商品库存的判断。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了分布式事务，所谓分布式事务，是指一个大的事务由很多小操作组成，小操作分布在不同的服务器上或者不同的应用程序上。分布式事务需要保证这些小操作要么全部成功，要么全部失败。</p><p>本节讲解了两种分布式方式：</p><ul><li>MySQL 自带的分布式事务</li><li>结合中间件实现分布式</li></ul><p>当然，目前主流的分布式实现还是结合中间件实现分布式处理的，本节也举例说明了使用 MQ 实现分布式的例子。</p><blockquote><p>参考资料</p><p>《高性能 MySQL》第 3 版 7.11 分布式（XA）事务</p><p>《深入浅出 MySQL》第 2 版 14.3 分布式事务的使用</p><p>《MySQL 技术内幕：InnoDB存储引擎》第 2 版 7.7 分布式事务)</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>有关事务的使用习惯</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E6%9C%89%E5%85%B3%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%A0%E6%83%AF/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E6%9C%89%E5%85%B3%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%A0%E6%83%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时好的事务习惯也影响着业务访问速度。接下来我们看一下事务的使用习惯。</p><p>我们先来看看一些不好的事务习惯：</p><h2 id="不好的事务习惯"><a href="#不好的事务习惯" class="headerlink" title="不好的事务习惯"></a>不好的事务习惯</h2><h3 id="在循环中提交"><a href="#在循环中提交" class="headerlink" title="在循环中提交"></a>在循环中提交</h3><p>在大多数情况下，MySQL 都是开启自动提交的，如果遇到循环执行 SQL，则相当于每个循环中都会进行一次提交，实际这算一个不好的事务习惯了。下面我创建一张测试表，并定义两个循环写入数据的存储过程：一个是自动提交，另一个是在循环前开启一个事务，在循环后一次性提交。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke; <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t22; <span class="comment">/* 如果表t22存在则删除表t22 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t22`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_a`</span> (<span class="string">`a`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_b`</span> (<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> <span class="keyword">if</span> <span class="keyword">exists</span> insert_t22_1; <span class="comment">/* 如果存在存储过程insert_t22_1，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t22_1() <span class="comment">/* 创建存储过程insert_t22_1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="built_in">int</span>; <span class="comment">/* 声明变量i */</span></span><br><span class="line"><span class="keyword">set</span> i=<span class="number">1</span>; <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">while(i&lt;=10000)do /* 对满足i&lt;=10000的值进行while循环 */</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t22(a,b,c,d) <span class="keyword">values</span>(i,i,i,i); <span class="comment">/* 写入表t22中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line"><span class="keyword">set</span> i=i+<span class="number">1</span>; <span class="comment">/* 将i加1 */</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ; <span class="comment">/* 创建批量写入10000条数据到表t22的存储过程insert_t22_1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> <span class="keyword">if</span> <span class="keyword">exists</span> insert_t22_2; <span class="comment">/* 如果存在存储过程insert_t22_2，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t22_2() <span class="comment">/* 创建存储过程insert_t22_2 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="built_in">int</span>; <span class="comment">/* 声明变量i */</span></span><br><span class="line"><span class="keyword">set</span> i=<span class="number">1</span>; <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">while(i&lt;=10000)do /* 对满足i&lt;=10000的值进行while循环 */</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t22(a,b,c,d) <span class="keyword">values</span>(i,i,i,i); <span class="comment">/* 写入表t22中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line"><span class="keyword">set</span> i=i+<span class="number">1</span>; <span class="comment">/* 将i加1 */</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ; <span class="comment">/* 创建批量写入10000条数据到表t22的存储过程insert_t22_2 */</span></span><br></pre></td></tr></table></figure><p>我们来对比两个存储过程的速度：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> insert_t22_1(); <span class="comment">/* 运行存储过程insert_t22_1 */</span></span><br></pre></td></tr></table></figure><p><img src="/Users/james/blogs/blog/source/_posts/2022-07-19-有关事务的使用习惯/1.png" alt="图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> insert_t22_2(); <span class="comment">/* 运行存储过程insert_t22_2 */</span></span><br></pre></td></tr></table></figure><p><img src="/Users/james/blogs/blog/source/_posts/2022-07-19-有关事务的使用习惯/2.png" alt="图片描述">明显第二种方式快的多。因为 insert_t22_1 每一次提交都要写一次重做日志，实际写了 10000 次重做日志，而存储过程 insert_t22_2 只写了 1 次重做日志。</p><p>因此，在类似这种循环写入的情况，如果循环次数不是太多，建议在循环前开启一个事务，循环结束后统一提交。</p><h3 id="不关注同一个事务里语句顺序"><a href="#不关注同一个事务里语句顺序" class="headerlink" title="不关注同一个事务里语句顺序"></a>不关注同一个事务里语句顺序</h3><p>比如 A 在超市购买 100 元的商品，付款操作可以简化为：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">操作</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">A 的账户中扣除 100</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">超市的账户增加 100</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">在超市系统中记录一条日志</td></tr></tbody></table></div><p>很多时候我们会按上面的 SQL 步骤放入一个事务里执行，不关注里面语句的顺序。实际可以优化的。</p><p>根据两阶段锁，整个事务里面涉及的锁，需要等到事务提交时才会释放。因此我们在<strong>同一个事务中，可以把没锁或者锁范围小的语句放在事务前面执行，而锁定范围大的语句放在后面执行。</strong></p><blockquote><p>这里来回顾一下第 16 节中提到的两阶段锁：锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。在执行语句的时候加上锁，但并不是语句执行完就立刻释放锁，而是要等到事务结束时才释放。</p></blockquote><p>因此上面 A 购买商品的例子中，可能很多人同时在超市付款，那么存在锁竞争的最可能是超市账户增加 100 元的操作。</p><p>那么付款操作可以这么优化：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">操作</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">在超市系统中记录一条日志</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">A 的账户中扣除 100</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">超市的账户增加 100</td></tr></tbody></table></div><p>把可能存在锁竞争的操作放在最后执行，从而优化整个事务。</p><p>因此在写程序时，应该去关注事务里的语句顺序。</p><h3 id="不关注不同事务访问资源的顺序"><a href="#不关注不同事务访问资源的顺序" class="headerlink" title="不关注不同事务访问资源的顺序"></a>不关注不同事务访问资源的顺序</h3><p>不同事务访问资源顺序也会导致产生死锁，我们来回顾一下：</p><ul><li>不同线程并发访问同一张表的多行数据，未按顺序访问导致死锁。</li><li>不同线程并发访问多个表时，未按顺序访问导致死锁。</li></ul><p>如果不关注并发访问的不同事务中访问资源的顺序，就会增大出现死锁的概率。</p><p>因此，为了降低死锁，我们需要去关注不同事务访问资源的顺序。</p><h3 id="不关注事务隔离级别"><a href="#不关注事务隔离级别" class="headerlink" title="不关注事务隔离级别"></a>不关注事务隔离级别</h3><p>不同事务隔离级别加锁的情况也是不同的。</p><p>如果完全不关注自己业务使用的 MySQL 是什么隔离级别，可能会降低程序的并发能力或者导致死锁。</p><p>比如业务场景完全能接受幻读，如果要求更高的 QPS，使用 RR 隔离级别显然不是最好的选择，因此可以改为 RC 隔离级别。</p><p>而如果业务使用的是 RR 隔离级别，可能由于间隙锁导致死锁，因此也应该在程序编写时关注 RR 隔离级别下是否会有间隙锁。</p><p>因此，为了更高的并发和降低死锁概率，在创建事务前，也应该去关注自己业务的数据库是什么事务隔离级别。</p><h3 id="在事务中混合使用存储引擎"><a href="#在事务中混合使用存储引擎" class="headerlink" title="在事务中混合使用存储引擎"></a>在事务中混合使用存储引擎</h3><p>在事务中混合使用事务型（比如 InnoDB）和非事务型（比如 MyISAM）表，如果是正常提交，到没什么问题。</p><p>但是，如果该事务回滚了，事务型的表可以正常回滚，而非事务型的表的变更就无法回滚了。这种情况就会导致数据不正常，并且事务最终的结果也难以确定。</p><p>因此，在事务中混合使用存储引擎也是一个不好的事务习惯。</p><blockquote><p>值得一提的是：如果开启 GTID，那么当同一个事务中使用不同存储引擎的表时，会出现如下报错：</p><p>ERROR 1785 (HY000): Statement violates GTID consistency: Updates to non-transactional tables can only be done in either autocommitted statements or single-statement transactions, and never in the same statement as updates to transactional tables.</p><p>因此，开启 GTID 的情况，可以避免同一个事务中混合使用存储引擎的情况。</p></blockquote><h2 id="总结一下好的事务习惯"><a href="#总结一下好的事务习惯" class="headerlink" title="总结一下好的事务习惯"></a>总结一下好的事务习惯</h2><p>在本节中，我们列举了几种不好的事务习惯，这里总结一下好的事务习惯：</p><ul><li>循环写入的情况，如果循环次数不是太多，建议在循环前开启一个事务，循环结束后统一提交。</li><li>优化事务里的语句顺序，减少锁时间。</li><li>关注不同事务访问资源的顺序。</li><li>创建事务之前，关注事务隔离级别。</li><li>在事务中不要混合使用存储引擎。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《MySQL 技术内幕》第 2 版 7.8 不好的事务习惯</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvcc实现</title>
      <link href="/2022/07/18/mysql-2022-07-18-mvcc%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/07/18/mysql-2022-07-18-mvcc%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    本节跟大家一起聊聊 MVCC。</p><h2 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a>什么是 MVCC？</h2><p>在说 MVCC 之前，大家先看看下面这个例子。</p><p>首先创建表并写入测试数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t20;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t20`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t20(a,b) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>进行实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">select * from t20; <img src="/Users/james/blogs/blog/source/_posts/mysql/2022-07-18-mvcc实现/1.png" alt="图片描述"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">begin;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">update t20 set b=666 where a=1;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"></td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"></td><td style="text-align:left">select * from t20; <img src="/Users/james/blogs/blog/source/_posts/mysql/2022-07-18-mvcc实现/2.png" alt="图片描述"></td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">commit;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"></td><td style="text-align:left">select * from t20; <img src="/Users/james/blogs/blog/source/_posts/mysql/2022-07-18-mvcc实现/3.png" alt="图片描述"></td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"></td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>在 session1 更新了 a=1 这行记录，但还没提交的情况下，在 session2 中，满足 a=1 这条记录，b 的值还是原始值 1，而不是 session 1 更新之后的 666，那么在数据库层面，这是怎么实现的呢？</p><p>其实 InnoDB 就是通过 MVCC 和 UNDO LOG 来实现的。</p><p>什么是 MVCC 呢？</p><p>MVCC， 即多版本并发控制。MVCC 的实现，是通过保存数据在某个时间点的快照来实现的，也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><p>也就是上面实验第 6 步中，为什么 session2 查询的结果还是 session1 修改之前的记录。</p><p>MCCC 只在 RC 和 RR 两个隔离级别下工作。因此在上面的实验中，改成 RR 隔离级别，第 6 步中，得到的结果还是 session1 修改之前的记录（但是在第 8 步，结果不一样哦，感兴趣的可以把上面操作放在 RR 隔离级别下实验一下）</p><p>上面提到了 undo log，那么什么是 undo log 呢？</p><h2 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h2><p>上节我们讲到了 redo log，它记录了事务操作变化。但是事务有时是需要回滚的，这时，undo log 就发挥了作用。undo log 是逻辑日志，将数据库逻辑地恢复到原来的样子，所有修改都被逻辑地取消了。</p><p>也就是如果是 insert 操作，其对应的回滚操作就是 delete；</p><p>如果是 delete，则对应的回滚操作是 insert；</p><p>如果是 update，则对应的回滚操作是一个反向的 update 操作。</p><p>除了回滚操作，undo log 的另一个作用是 MVCC，InnoDB 存储引擎中 MVCC 的实现是通过 undo 来完成的。当用户读取一行记录时，若该记录已经被其它事务占用，当前事务可以通过 undo log 读取之前的行版本信息，以此实现非锁定读取。</p><h2 id="MVCC-的实现原理"><a href="#MVCC-的实现原理" class="headerlink" title="MVCC 的实现原理"></a>MVCC 的实现原理</h2><p>InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本（存放在 UNDO LOG 中）。</p><p><img src="/Users/james/blogs/blog/source/_posts/mysql/2022-07-18-mvcc实现/4.png" alt="图片描述"><br>如图，执行 update t20 set b=666 where a=1; 时，会将原记录放到 undo 表空间中，并通过隐藏的回滚指针指向该记录。在本节开始的实验中的第 6 步中，session2 查询的结果是 session1 修改之前的记录，这个记录就是来自 undo log 中。</p><h2 id="MVCC-的优势"><a href="#MVCC-的优势" class="headerlink" title="MVCC 的优势"></a>MVCC 的优势</h2><p>MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。</p><p>通过 MVCC，保证了事务 ACID 中的 （隔离性）特性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 RC 和 RR 隔离级别下，如果需要查询一些被其它事务正在更新的行，看到的是这些记录被更新之前的值。而这就是用 MVCC 实现的。</p><p>MVCC 实现的原理大致是：</p><p><strong>InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。</strong></p><p>MVCC 最大的好处是读不加锁，读写不冲突，极大的增加了 MySQL 的并发性，通过 MVCC，也保证了事务 ACID 中的 (隔离性)特性。</p><blockquote><p>参考</p><p>《MySQL 技术内幕》第 2 版：7.2.2 undo</p><p>《高性能 MySQL》第 3 版：1.4 多版本并发控制</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务与事务持久化</title>
      <link href="/2022/07/18/mysql-2022-07-18-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2022/07/18/mysql-2022-07-18-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 思考两个问题，数据库突然断电会丢失数据吗？数据库中的事务是如何记录的？带着两个疑问，我们继续往下看。</p><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>根据《高性能 MySQL》第 3 版 1.3 事务一节中定义：</p><blockquote><p>事务就是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。</p></blockquote><p>看上面的文字可以稍微抽象了一点，可以结合生活中的一个例子：</p><p>比如你给朋友转账 100 元，其大致过程是：从你的账户扣除 100 元，然后再到你朋友的账户中增加 100 元，试想，如果在这中间，因为网络问题或者程序问题，导致在你的账户中扣除了，但是没有在你朋友的账户中增加，那岂不是乱套了。</p><p>所以，类似这种情况，就可以把这两个步骤放到一个事务里面。要么全部成功，也就是从你的账户扣除之后，然后在你朋友账户中新增；要么全部失败，比如在中间出现问题，会回滚这中间所有的变更。大致操作步骤如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">步骤</th><th style="text-align:left">对应的语句</th></tr></thead><tbody><tr><td style="text-align:left">开始一个事务</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">从你的账户扣除 100 元</td><td style="text-align:left">update money_info set balance = balance - 100 where user_id=1;</td></tr><tr><td style="text-align:left">在你朋友的账户中增加 100 元</td><td style="text-align:left">update money_info set balance = balance + 100 where user_id=2;</td></tr><tr><td style="text-align:left">事务结束</td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>一个良好的事务处理系统，必须具备 ACID 特性：</p><ul><li>atomicity（原子性） ：要么全执行，要么全都不执行；</li><li>consistency（一致性）：在事务开始和完成时，数据都必须保持一致状态；</li><li>isolation（隔离性） ：事务处理过程中的中间状态对外部是不可见的；</li><li>durability（持久性） ：事务完成之后，它对于数据的修改是永久性的。</li></ul><p>InnoDB 采用 redo log 机制来保证事务更新的一致性和持久性。什么是 redo log？下面来一起看下：</p><h2 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h2><p>Redo log 称为重做日志，用于记录事务操作变化，记录的是数据被修改之后的值。</p><p>Redo log 由两部分组成：</p><ul><li>内存中的重做日志缓冲（redo log buffer）</li><li>重做日志文件（redo log file）</li></ul><p>每次数据更新会先更新 redo log buffer，然后根据 innodb_flush_log_at_trx_commit 来控制 redo log buffer 更新到 redo log file 的时机。innodb_flush_log_at_trx_commit 有三个值可选：</p><ul><li><p>0：事务提交时，在事务提交时，每秒触发一次 redo log buffer 写磁盘操作，并调用操作系统 fsync 刷新 IO 缓存。</p></li><li><p>1：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，并调用操作系统 fsync 刷新 IO 缓存；</p></li><li><p>2：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，但不是马上调用 fsync 刷新 IO 缓存，而是每秒只做一次磁盘 IO 缓存刷新操作。</p></li></ul><p>innodb_flush_log_at_trx_commit 参数的默认值是 1，也就是每个事务提交的时候都会从 log buffer 写更新记录到日志文件，而且会刷新磁盘缓存，这完全满足事务持久化的要求，是最安全的，但是这样会有比较大的性能损失。</p><p>将参数设置为 0 时，如果数据库崩溃，最后 1秒钟的 redo log 可能会由于未及时写入磁盘文件而丢失，这种方式尽管效率最高，但是最不安全。</p><p>将参数设置为 2 时，如果数据库崩溃，由于已经执行了重做日志写入磁盘的操作，只是没有做磁盘 IO 刷新操作，因此，只要不发生操作系统奔溃，数据就不会丢失，这种方式是对性能和安全的一种折中处理。</p><h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><p>二进制日志（binlog）记录了所有的 DDL（数据定义语句）和 DML（数据操纵语句），但是不包括 select 和 show 这类操作。Binlog 有以下几个作用：</p><ul><li>恢复：数据恢复时可以使用二进制日志</li><li>复制：通过传输二进制日志到从库，然后进行恢复，以实现主从同步</li><li>审计：可以通过二进制日志进行审计数据的变更操作</li></ul><p>可以通过参数 sync_binlog 来控制累积多少个事务后才将二进制日志 fsync 到磁盘。</p><ul><li>sync_binlog=0，表示每次提交事务都只write，不fsync</li><li>sync_binlog=1，表示每次提交事务都会执行fsync</li><li>sync_binlog=N(N&gt;1)，表示每次提交事务都write，累积N个事务后才fsync</li></ul><p>比如要加快写入数据的速度或者机器磁盘 IO 瓶颈时，可以将 sync_binlog 设置成大于 1 的值，<strong>但是如果设置为 N(N&gt;1)时，如果数据库崩溃，可能会丢失最近 N 个事务的 binlog。</strong></p><h2 id="怎样确保数据库突然断电不丢数据？"><a href="#怎样确保数据库突然断电不丢数据？" class="headerlink" title="怎样确保数据库突然断电不丢数据？"></a>怎样确保数据库突然断电不丢数据？</h2><p>通过上面的讲解，只要 innodb_flush_log_at_trx_commit 和 sync_binlog 都为 1（通常称为：双一），就能确保 MySQL 机器断电重启后，数据不丢失。</p><p>因此建议在比较重要的库，比如涉及到钱的库，设置为双一，而你的测试环境或者正式业务不那么重要的库（比如日志库）可以将 innodb_flush_log_at_trx_commit 设置为0，sync_binlog 设置成大于100 的数值，提高更新效率。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了什么是事务？</p><p>所谓事务：是指一组原子性的 SQL 查询，事务里的 SQL 要么全部执行成功，要么全部执行失败。</p><p>一个良好的事务处理系统，必须具备 ACID 特性： atomicity（原子性）、consistency（一致性）、 isolation（隔离性）、 durability（持久性）。</p><p>另外讲解了 Redo log 和 Binlog：</p><ul><li>Redo log：称为重做日志，用于记录事务操作变化，记录的是数据被修改之后的值</li><li>Binlog：记录了所有变更操作，其作用有：恢复、复制、审计等</li></ul><p>如果想要数据库达到最安全的状态，可以将 innodb_flush_log_at_trx_commit 和 sync_binlog 都设置为 1。</p><blockquote><p>参考资料</p><p>《高性能 MySQL》第 3 版：1.3 事务</p><p>《MySQL 技术内幕》第 2 版：7.2 事务的实现</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql死锁的发生与解决</title>
      <link href="/2022/07/18/mysql-2022-07-18-mysql%E6%AD%BB%E9%94%81%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
      <url>/2022/07/18/mysql-2022-07-18-mysql%E6%AD%BB%E9%94%81%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有了锁的基础之后，我们来了解一下死锁的产生和解决。</p><h2 id="认识死锁"><a href="#认识死锁" class="headerlink" title="认识死锁"></a>认识死锁</h2><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</p><p>InnoDB 中解决死锁问题有两种方式：</p><ol><li>检测到死锁的循环依赖，立即返回一个错误（这个报错内容请看下面的实验），将参数 innodb_deadlock_detect 设置为 on 表示开启这个逻辑；</li><li>等查询的时间达到锁等待超时的设定后放弃锁请求。这个超时时间由 innodb_lock_wait_timeout 来控制。默认是 50 秒。</li></ol><blockquote><p>一般线上业务都建议使用的第 1 种策略，因为第 2 种策略锁等待时间是 50 秒，对于高并发的线上业务是不能接受的。</p><p>但是第 1 种策略，也会有死锁检测时的额外 CPU 开销的，比如电商中的秒杀场景。这种情况就可以根据业务开发商量优化程序，如果可以确保业务一定不会出现死锁，可以临时把死锁检测关掉，以提高并发效率。</p></blockquote><h2 id="为什么会产生死锁"><a href="#为什么会产生死锁" class="headerlink" title="为什么会产生死锁"></a>为什么会产生死锁</h2><p>我们通过几个实验来构造几种产生死锁的情况，首先创建测试表并写入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t18;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t18`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t18(a,b,c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t18_1;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t18_1  <span class="keyword">like</span> t18;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t18_1 <span class="keyword">select</span> * <span class="keyword">from</span> t18;</span><br></pre></td></tr></table></figure><h3 id="同一张表中"><a href="#同一张表中" class="headerlink" title="同一张表中"></a>同一张表中</h3><p>不同线程并发访问同一张表的多行数据，未按顺序访问导致死锁。</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">select * from t18 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left">select * from t18 where a=2 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left">select * from t18 where a=2 for update;/* SQL1 */ （等待）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>（session2 提示死锁回滚后，SQL1 成功返回结构）</strong></td><td style="text-align:left">select * from t18 where a=1 for update; <strong>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>session1 在等待 session2 释放 a=2 的行锁，而 session2 在等待 session1 释放 a=1 的行锁。两个 session 互相等待对方释放资源，就进入了死锁状态。</p><p>因此，在上面的例子中，如果 session1 中的事务提交之后，再执行 session2 中的事务，就可以避免这次死锁的发生了。</p><p><strong>所以对于程序多个并发访问同一张表时，如果事先确保每个线程按固定顺序来处理记录，可以降低死锁的概率。</strong></p><h3 id="不同表之间"><a href="#不同表之间" class="headerlink" title="不同表之间"></a>不同表之间</h3><p>不同线程并发访问多个表时，未按顺序访问导致死锁：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">select * from t18 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left">select * from t18_1 where a=1 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left">select * from t18_1 where a=1 for update;/* SQL2 */ 等待</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>（session2 提示死锁回滚后，SQL1 成功返回结构）</strong></td><td style="text-align:left">select * from t18 where a=1 for update; <strong>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>与 同一张表类似，但是这个例子涉及到两张表，如果上例中，之前就约定好 session1 中的事务执行完毕后，再执行 session2 的事务，则可以避免死锁的产生。</p><p>因此，<strong>不同程序并发访问多个表时，应尽量约定以相同的顺序来访问表，可大大降低并发操作不同表时死锁发生的概率</strong>。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>RR 隔离级别下，由于间隙锁导致死锁：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’; /* 设置会话隔离级别为 RR */</td><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’; /* 设置会话隔离级别为 RR */</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">select * from t18 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left">select * from t18 where a=2 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left">insert into t18(a,b,c) values (2,3,3);/* SQL3 */ 等待</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>（session2 提示死锁回滚后，SQL1 成功返回结构）</strong></td><td style="text-align:left">insert into t18(a,b,c) values (1,4,4);/* SQL4 */ ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>有之前的索引知识可以知道 SQL3 需要等待 a=2 获得的间隙锁，而 SQL4 需要等待 a=1 获得的间隙锁，两个 session 互相等待对方释放资源，就进入了死锁状态。</p><p>类似这种情况，可以考虑将隔离级别改成 RC（这里各位读者可以尝试在 RC 隔离级别下，做上面的实验），降低死锁的概率（当然RC 隔离级别可能会导致幻读，因此需要确定是否可以改成 RC。）</p><h2 id="如何降低死锁概率"><a href="#如何降低死锁概率" class="headerlink" title="如何降低死锁概率"></a>如何降低死锁概率</h2><p>那么应该怎样降低出现死锁的概率呢？这里总结了如下一些经验：</p><ol><li>更新 SQL 的 where 条件尽量用索引；</li><li>基于 primary 或 unique key 更新数据；</li><li>减少范围更新，尤其非主键、非唯一索引上的范围更新；</li><li>加锁顺序一致，尽可能一次性锁定所有需要行；</li><li>将 RR 隔离级别调整为 RC 隔离级别。</li></ol><h2 id="分析死锁的方法"><a href="#分析死锁的方法" class="headerlink" title="分析死锁的方法"></a>分析死锁的方法</h2><p>尽管在上面介绍了降低死锁概率的方法，但是在实际工作中，死锁很难完全避免。因此，捕获并处理死锁也是一个好的编程习惯。</p><p>InnoDB 中，可以使用 SHOW INNODB STATUS 命令来查看最后一个死锁的信息。我们可以尝试用下这个命令获取一些死锁信息，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span>\G</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="图片描述">如上面的图片，就是事务隔离级别例子中的死锁情况，在最后显示回滚了事务 2，也就是对应实验中的 session2。</p><p>另外设置 innodb_print_all_deadlocks = on 可以在 err log 中记录全部死锁信息。</p><p>因此我们可以通过上面两种方式捕获死锁信息，从而进行优化。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节聊了死锁相关的内容。通过具体实验列举了几种出现死锁的情况：</p><ul><li>不同线程并发访问同一张表的多行数据，未按顺序访问导致死锁；</li><li>不同线程并发访问多个表时，未按顺序访问导致死锁；</li><li>RR 隔离级别下，由于间隙锁导致死锁。</li></ul><p>后面提供了几种降低死锁概率的方法。</p><p>由于死锁不能完全杜绝，因此，在最后提供了捕获死锁信息的方法，在工作中我们可以把死锁信息记录下来，如果出现频率过高，就应该考虑去优化程序了。</p><blockquote><p>参考资料</p><p>《深入浅出 MySQL》第 2 版：20.3.9 关于死锁</p><p>《高性能 MySQL》第 3 版：1.3.2 死锁</p><p>《MySQL 技术内幕》第 2 版：6.7 死锁</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql锁机制-间隙锁</title>
      <link href="/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E9%97%B4%E9%9A%99%E9%94%81/"/>
      <url>/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E9%97%B4%E9%9A%99%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    上节我们聊到了 RC 隔离级别的各种情况的锁，这节我们就来一起看看 RR 隔离级别各种情况下的锁，同时揭晓间隙锁的意义。</p><h2 id="RC下的幻读"><a href="#RC下的幻读" class="headerlink" title="RC下的幻读"></a>RC下的幻读</h2><p>下面我们来做一个实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t16 where c=3 for update; <img src="6.png" alt="图片描述"></td></tr><tr><td style="text-align:left">use muke; insert into t16(a,b,c) values (5,5,3); Query OK, 1 row affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select * from t16 where c=3 for update; <img src="7.png" alt="图片描述"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>我们看一下上面的实验结果，在 session2 中，同一个事务中，按相同的查询条件重新读取以前检索过的数据，却发现了 session1 插入的满足查询条件的新数据，这也就是上一节讲到的幻读情况。</p><p>为什么上面的实验中会出现幻读呢？</p><p>我们来看看下面这张图：<br><img src="1.png" alt="图片描述">从图中可以看出，RC 隔离级别下，只锁住了满足 c=3 的当前行，而不会对后面的位置（或者说间隙)加锁，因此导致 session1 的写入语句能正常执行并提交。</p><p>那么应该怎样避免幻读呢？</p><p>从上面的分析我们可以知道，产生幻读的原因是：行锁只能锁住当前行，但是新插入的记录，是在被锁住记录之前的间隙。因此，为了解决幻读问题，InnoDB 在 RR 隔离级别下配置了间隙锁（Gap Lock）。</p><h2 id="RR-隔离级别下的非唯一索引查询"><a href="#RR-隔离级别下的非唯一索引查询" class="headerlink" title="RR 隔离级别下的非唯一索引查询"></a>RR 隔离级别下的非唯一索引查询</h2><p>我们继续看上面的实验，这里不同点是我们把隔离级别设置成 RR。</p><p>我们再单独建一张表，表结构与上节的表结构一致，为了方便后面分析，数据稍微有改动，语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t17;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t17`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uniq_a`</span> (<span class="string">`a`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t17(<span class="keyword">id</span>,a,b,c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>开始 RR 隔离级别下的实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t17 where c=4 for update; <img src="2.png" alt="图片描述"></td></tr><tr><td style="text-align:left">use muke; insert into t17(a,b,c) values (7,7,4); /* SQL1 */ <strong>（等待）</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select *\ from t17 where c=4 for update; <img src="3.png" alt="图片描述"></td></tr><tr><td style="text-align:left">insert into t17(a,b,c) values (7,7,4); /* SQL1 */ Query OK, 1 row affected (20.73 sec) <strong>（等 session2 执行 commit; 后，SQL1 马上返回结果）</strong></td><td style="text-align:left">commit;</td></tr><tr><td style="text-align:left">commit;</td></tr></tbody></table></div><p>根据实验情况，我们在 session2 中，对满足条件 c=4 的数据加上了排他锁，然后在 session1 写入一条 c=4 的记录，此时会出现等待，直到 session2 对事务进行提交后，session1 才会执行成功。这是为什么呢？我们来看下图：<br><img src="4.png" alt="图片描述">与 RC 隔离级别下的图相似，但是有个比较大的区别是：RR 隔离级别多了 GAP 锁。</p><p>如上图，首先需要考虑哪些位置可以插入新的满足条件 c=4 的项：</p><ul><li>由于 B+ 树索引是有序的，因此 [2,2]（代表 c 和 id 的值，后面就不一一说明了）前面的记录，不可能插入 c=4 的记录了；</li><li>[2,2] 与 [4,4] 之间可以插入 [4,3]；</li><li>[4,4] 与 [4,6] 之间可以插入 [4,5]；</li><li>[4,6] 之后，可以插入的值就很多了：<a href="其中 n&gt;6">4,n</a> ；</li></ul><p>为了保证这几个区间不会插入新的满足条件 c=4 的记录，MySQL RR 隔离级别选择了 GAP 锁，将这几个区间锁起来。</p><p>而上面实验中，语句 insert into t17 (a,b,c) values (7,7,4) 其对应插入 c 和 id 的值为 [4,7]，是在最后这个被 GAP Lock 锁住的区间，因此如上面实验，insert 操作会等待。</p><h2 id="RR-隔离级别下的非索引字段查询"><a href="#RR-隔离级别下的非索引字段查询" class="headerlink" title="RR 隔离级别下的非索引字段查询"></a>RR 隔离级别下的非索引字段查询</h2><p>上一节中，我们测试了 RC 隔离级别下，非索引字段做条件的当前读会对所有记录都加锁。</p><p>这一节，我们测试一下 RR 隔离级别下，非索引字段做条件的当前读加锁情况。</p><p>首先对 t17 表中的数据做初始化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t17;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t17`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uniq_a`</span> (<span class="string">`a`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t17(<span class="keyword">id</span>,a,b,c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; select * from t17 where b=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t17 where b=2 for update; <strong>（等待）</strong></td><td style="text-align:left">insert into t17(a,b,c) values (10,10,10); <strong>（等待）</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select * from t17 where b=2 for update; … 1 row in set (31.51 sec) <strong>（session1 提交后，马上返回结果）</strong></td><td style="text-align:left">insert into t17(a,b,c) values (10,10,10); Query OK, 1 row affected (8.08 sec) <strong>（session1 提交后，马上写入）</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></div><p>可能你会问？为什么 session3 的 insert 会出现等待？</p><p>我们看看下图：<br><img src="5.png" alt="图片描述"><br>如图，所有记录都有 X 锁，除此之外，每个 GAP 也被加上了 GAP 锁。因此这张表在执行完 select * from t17 where b=1 for update; 到 commit 之前，除了不加锁的快照读，其它任何加锁的 SQL，都会等待，如果这是线上业务表，那就是件非常恐怖的事情了。</p><p>总结：<strong>RR 隔离级别下，非索引字段做条件的当前读不但会把每条记录都加上 X 锁，还会把每个 GAP 加上 GAP 锁。再次说明，条件字段加索引的重要性。</strong></p><h2 id="RR-隔离级别下的唯一索引当前读是否会用到-GAP-锁"><a href="#RR-隔离级别下的唯一索引当前读是否会用到-GAP-锁" class="headerlink" title="RR 隔离级别下的唯一索引当前读是否会用到 GAP 锁"></a>RR 隔离级别下的唯一索引当前读是否会用到 GAP 锁</h2><p>GAP 锁的目的是：为了防止同一事务两次当前读，出现幻读的情况。如果能确保索引字段唯一，那其实一个等值查询，最多就返回一条记录，而且相同索引记录的值，一定不会再新增，因此不会出现 GAP 锁。</p><p>因此以唯一索引为条件的当前读，不会有 GAP 锁。所以 RR 隔离级别下的唯一索引当前读加锁情况与 RC 隔离级别下的唯一索引当前读加锁情况一致。这里就不再实验了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了 RC 隔离级别出现幻读的情况，而 RR 通过 GAP 锁解决了幻读，但是 RR 隔离级别相对于 RC，锁的范围可能更大了，特别是对没有索引的字段进行当前读（比如增、删、改或者 select … for update）时，会阻塞除快照读以外所有的并发 SQL。</p><p>而后面我们又聊了以唯一索引做为条件的当前读不会用到 GAP 锁，因为根据唯一索引查询最多就一条记录，而且相同索引记录的值，一定不会再新增。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql锁机制-行锁</title>
      <link href="/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E8%A1%8C%E9%94%81/"/>
      <url>/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E8%A1%8C%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>MySQL 5.5 之前的默认存储引擎是 MyISAM，5.5 之后改成了 InnoDB。InnoDB 后来居上最主要的原因就是：</p><ul><li>InnoDB 支持事务：适合在并发条件下要求数据一致的场景。</li><li>InnoDB 支持行锁：有效降低由于删除或者更新导致的锁定。</li></ul><p>本节就一起来探讨 InnoDB 的行锁。</p><p>在讲解行锁之前，我们首先来看一下两阶段锁协议。</p><h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><p>传统的关系型数据库加锁的一个原则是：两阶段锁原则。</p><p>两阶段锁：锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。</p><p>我们可以通过下面这张表理解两阶段锁：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">MySQL 操作</th><th style="text-align:left">解释</th><th style="text-align:left">锁阶段</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">begin;</td><td style="text-align:left">事务开始</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">insert into …;</td><td style="text-align:left">加 insert 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">update table …;</td><td style="text-align:left">加 update 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">delete from …;</td><td style="text-align:left">加 delete 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">commit;</td><td style="text-align:left">事务结束，同时释放 2、3、4 步骤中加的锁</td><td style="text-align:left">解锁阶段</td></tr></tbody></table></div><h2 id="InnoDB-行锁模式"><a href="#InnoDB-行锁模式" class="headerlink" title="InnoDB 行锁模式"></a>InnoDB 行锁模式</h2><p>InnoDB 实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁；</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>对于普通 select 语句，InnoDB 不会加任何锁，事务可以通过以下语句显式给记录集加共享锁或排他锁：</p><ul><li>共享锁（S）：select * from table_name where … lock in share mode;</li><li>排他锁（X）：select * from table_name where … for update。</li></ul><h2 id="InnoDB-行锁算法"><a href="#InnoDB-行锁算法" class="headerlink" title="InnoDB 行锁算法"></a>InnoDB 行锁算法</h2><p>InnoDB 行锁的三种算法：</p><ul><li>Record Lock：单个记录上的索引加锁。</li><li>Gap Lock：间隙锁，对索引项之间的间隙加锁，但不包括记录本身。</li><li>Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。</li></ul><p>InnoDB 行锁实现特点意味着：如果不通过索引条件检索数据，那么 InnoDB 将对表中所有记录加锁，实际效果跟表锁一样。</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>不同事务隔离级别对应的行锁也是不一样的，因此在讲解行锁的锁定范围之前，先简单聊聊事务隔离级别。事务隔离级别的详细介绍放在下一章。</p><p>MySQL 的 4 种隔离级别：</p><ul><li>Read uncommitted（读未提交）: 在该隔离级别，所有事务都可以看到其它未提交事务的执行结果。可能会出现脏读。</li><li>Read Committed（读已提交，简称： RC）：一个事务只能看见已经提交事务所做的改变。因为同一事务的其它实例在该实例处理期间可能会有新的 commit，所以可能出现幻读。</li><li>Repeatable Read（可重复读，简称：RR）：这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。消除了脏读、不可重复读，默认也不会出现幻读。</li><li>Serializable（串行）：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。</li></ul><blockquote><p>这里解释一下脏读和幻读：</p><ul><li>脏读：读取未提交的事务。</li><li>幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。</li></ul></blockquote><h2 id="RC-隔离级别下的行锁实验"><a href="#RC-隔离级别下的行锁实验" class="headerlink" title="RC 隔离级别下的行锁实验"></a>RC 隔离级别下的行锁实验</h2><p>有时我们可能会思考，某条语句（类似 select * from table_name where a=… for update;）是怎么加锁的？</p><p>要想分析某条 SQL 是怎么加锁的，如果其他信息都不知道，那就得分几种情况了，不同情况加锁的方式也各不一样，比较常见的一些情况如下：</p><ul><li>RC 隔离级别，a 字段没索引。</li><li>RC 隔离级别，a 字段有唯一索引。</li><li>RC 隔离级别，a 字段有非唯一索引。</li><li>RR 隔离级别，a 字段没索引。</li><li>RR 隔离级别，a 字段有唯一索引。</li><li>RR 隔离级别，a 字段有非唯一索引。</li><li>…</li></ul><blockquote><p>Read uncommitted 和 Serializable 这两种隔离级别在生产环境基本不用，就不做分析了。</p></blockquote><p>我们先验证 RC 隔离级别下的几种情况，RR 隔离级别的实验放在下节：</p><p>首先创建测试表及写入数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t16`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uniq_a`</span> (<span class="string">`a`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t16(a,b,c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>让我们开始实验吧！</p><h3 id="通过非索引字段查询"><a href="#通过非索引字段查询" class="headerlink" title="通过非索引字段查询"></a>通过非索引字段查询</h3><p>我们首先来看一下条件字段不使用索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/<em> 设置会话隔离级别为 RC\</em>/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; select * from t16 where b=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select <em> from t16 where b=2 for update; <em>*（等待）</em></em></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select * from t16 where b=2 for update; … 1 row in set (6.81 sec) <strong>（session1 执行 commit 后立马返回结果）</strong></td></tr></tbody></table></div><blockquote><p><strong>这里解释一下为什么要用 for update？</strong></p><p>我们常使用的查询语句，比如 select * from t16 where b=1 属于快照读，是不会看到别的事务插入的数据的。</p><p>而在查询语句后面加了 for update 显式给记录集加了排他锁，也就让查询变成了当前读。插入、更新、删除操作，都属于当前读。其实也就可以理解 select … for update 是为了让普通查询获得插入、更新、删除操作时所获得的锁。</p></blockquote><p>表面看起来 session1 只给了 b=1 这一行加了排他锁，但 session2 在请求其它行的排他锁时，却出现了锁等待。看下图：<br><img src="1.png" alt="图片描述">由于 b 字段没有索引，因此只能走聚簇索引，进行全表扫描。从上图中可以看到，满足条件的记录有一条，但是聚簇索引上的所有记录，都被加上了 X 锁。</p><p>为什么不是只在满足条件的记录上加锁呢？</p><p>这是因为在 MySQL 中，如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由 server 层进行过滤。因此也就把所有记录都锁上了。</p><blockquote><p>当然 MySQL 在这里有一些改进的，在 server 层过滤掉不满足条件的数据后，会把不满足条件的记录放锁。保证了最后只会持有满足条件的锁，但是每条记录的加锁操作还是不会省略。</p></blockquote><p>总结：<strong>没有索引的情况下，InnoDB 的当前读会对所有记录都加锁。所以在工作中应该特别注意 InnoDB 这一特性，否则可能会产生大量的锁冲突。</strong></p><h3 id="通过唯一索引查询"><a href="#通过唯一索引查询" class="headerlink" title="通过唯一索引查询"></a>通过唯一索引查询</h3><p>我们再来看一下条件字段有唯一索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td></tr><tr><td style="text-align:left">begin; use muke; select * from t16 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t16 where a=2 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select * from t16 where a=1 for update; <strong>（等待）</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select * from t16 where a=1 for update; … 1 row in set (4.70 sec) <strong>（session1 提交后，马上返回结果）</strong></td></tr></tbody></table></div><p>session1 给了 a=1 这一行加了排他锁，在 session2 中请求其他行的排他锁时，不会发生等待；但是在 session2 中请求 a=1 这一行的排他锁时，会发生等待。看下图：<br><img src="2.png" alt="图片描述"></p><p>由于 a 是唯一索引，因此 select * from t16 where a=1 for update；(后面称为 SQL2) 语句会选择走 a 列的索引进行条件过滤，在找到 a=1 的记录后，会将唯一索引上 a=1 索引记录上加 X 锁，同时，会根据读取到的 id 列，回到聚簇索引，然后将 id=1 对应的聚簇索引项加 X 锁。</p><p>为什么聚簇索引上的记录也要加锁呢？</p><p>比如，并发的一条 SQL，是通过主键索引来更新：update t16 set b=10 where id =1; 如果 SQL2 没有将主键索引上的记录加锁，那么并发的 update 并不知道 SQL2 在执行，所以如果 update 执行了，就违背了同一记录上的更新或者删除需要串行执行的约束。</p><p>总结：<strong>如果查询的条件是唯一索引，那么 SQL 需要在满足条件的唯一索引上加锁，并且会在对应的聚簇索引上加锁。</strong></p><h3 id="通过非唯一索引查询"><a href="#通过非唯一索引查询" class="headerlink" title="通过非唯一索引查询"></a>通过非唯一索引查询</h3><p>我们再来看一下条件字段有非唯一索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; select * from t16 where c=3 for update; … 2 rows in set (0.00 sec)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t16 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left">use muke; select * from t16 where a=2 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select * from t16 where a=3 for update; <strong>(等待)</strong></td><td style="text-align:left">select * from t16 where a=4 for update; <strong>(等待)</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select * from t16 where a=3 for update; … <strong>(session1 提交后，马上返回结果)</strong></td><td style="text-align:left">select * from t16 where a=4 for update; … <strong>(session1 提交后，马上返回结果)</strong></td></tr></tbody></table></div><p>我们在满足条件 c=3 的数据上加了排他锁，如上面结果，就是第 3、4 行。因此第 1、2 行的数据没被锁，而 3、4 行的数据被锁了。如下图：<br><img src="3.png" alt="图片描述">通过上图可以看到，在 a 字段的非唯一索引上，满足 c=3 的所有记录，都被加了锁。同时，对应的主键索引上的记录也都加上了锁。与通过唯一索引查询的情况相比，唯一索引查询最多有一行记录被锁，而非唯一索引将会把满足条件的所有记录都加上锁。</p><p>总结：<strong>如果查询的条件是非唯一索引，那么 SQL 需要在满足条件的非唯一索引上都加上锁，并且会在它们对应的聚簇索引上加锁。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们聊了一下 InnoDB 行锁，这是 InnoDB 替代 MyISAM（只支持表锁）的一个比较重要的原因。</p><p>在文稿的开始，跟大家讲解了两阶段锁、行锁模式、行锁算法以及事务隔离级别等。</p><p>我们做了 RC 隔离级别下不同场景的行锁实验，比较重要的一点是：在更新数据时，如果条件字段没索引，则表中所有记录都会被加上 X 锁。所以在工作中应该尽可能的让查询走索引。</p><blockquote><p>参考资料</p><p>何登成的 github：<a href="https://github.com/hedengcheng/tech/tree/master/database/MySQL。" target="_blank" rel="noopener">https://github.com/hedengcheng/tech/tree/master/database/MySQL。</a></p><p>《深入浅出 MySQL》（第 2 版）：20.3.4 InnoDB 行锁实现方式。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql锁机制-全局锁与表锁</title>
      <link href="/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E5%85%A8%E5%B1%80%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81/"/>
      <url>/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E5%85%A8%E5%B1%80%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>mysql有两大类内存一块是索引，主要是提高检索查询能力，另一大块就是锁，MySQL 中，锁就是协调多个用户或者客户端并发访问某一资源的机制，保证数据并发访问时的一致性和有效性。</p><p>本章就来介绍一下不同场景下的锁机制。</p><p>根据加锁的范围，MySQL 中的锁可分为三类：</p><ul><li>全局锁</li><li>表级锁</li><li>行锁</li></ul><p>本节来重点讲解一下全局锁和表锁。</p><h2 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1 全局锁"></a><strong>1 全局锁</strong></h2><p>MySQL 全局锁会关闭所有打开的表，并使用全局读锁锁定所有表。其命令为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">TABLES</span> <span class="keyword">WITH</span> <span class="keyword">READ</span> <span class="keyword">LOCK</span>;</span><br></pre></td></tr></table></figure><p>简称：FTWRL，可以使用下面命令解锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure><p>我们来通过实验理解一下全局锁：</p><p>首先创建测试表，并写入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t14;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t14`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t14(a,b) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>进行 FTWRL 实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">FLUSH TABLES WITH READ LOCK; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select * from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td><td style="text-align:left">select * from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td></tr><tr><td style="text-align:left">insert into t14(a,b) values(2,2); ERROR 1223 (HY000): Can’t execute the query because you have a conflicting read lock <strong>（报错）</strong></td><td style="text-align:left">insert into t14(a,b) values(2,2);/*sql1*/ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">UNLOCK TABLES;</td><td style="text-align:left">insert into t14(a,b) values(2,2);/* sql1 */ Query OK, 1 row affected (5.73 sec) <strong>（session1 解锁后，在等待的 sql1 马上执行成功）</strong></td></tr></tbody></table></div><p>上面的实验中，当 session1 执行 FTWRL 后，本线程 session1 和其它线程 session2 都可以查询，本线程和其它线程都不能更新。</p><p>原因是：<strong>当执行 FTWRL 后，所有的表都变成只读状态，数据更新或者字段更新将会被阻塞。</strong></p><p>那么全局锁一般什么时候会用到呢？</p><p>全局锁一般用在整个库（包含非事务引擎表）做备份（mysqldump 或者 xtrabackup）时。也就是说，在整个备份过程中，整个库都是只读的，其实这样风险挺大的。如果是在主库备份，会导致业务不能修改数据；而如果是在从库备份，就会导致主从延迟。</p><p>好在 mysqldump 包含一个参数 —single-transaction，可以在一个事务中创建一致性快照，然后进行所有表的备份。因此增加这个参数的情况下，备份期间可以进行数据修改。但是需要所有表都是事务引擎表。所以这也是建议使用 InnoDB 存储引擎的原因之一。</p><p>而对于 xtrabackup，可以分开备份 InnoDB 和 MyISAM，或者不执行 —master-data，可以避免使用全局锁。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁有两种：表锁和元数据锁。</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表锁使用场景：</p><ol><li>事务需要更新某张大表的大部分或全部数据。如果使用默认的行锁，不仅事务执行效率低，而且可能造成其它事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高事务执行速度；</li><li>事务涉及多个表，比较复杂，可能会引起死锁，导致大量事务回滚，可以考虑表锁避免死锁。</li></ol><p>其中表锁又分为表读锁和表写锁，命令分别是：</p><p>表读锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> t14 <span class="keyword">read</span>;</span><br></pre></td></tr></table></figure><p>表写锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> t14  write;</span><br></pre></td></tr></table></figure><p>下面我们分别用实验验证表读锁和表写锁。</p><p>表读锁实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">lock tables t14 read; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select id,a,b from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td></tr><tr><td style="text-align:left">insert into t14(a,b) values(3,3); ERROR 1099 (HY000): Table ‘t14’ was locked with a READ lock and can’t be updated <strong>（报错）</strong></td><td style="text-align:left">insert into t14(a,b) values(3,3);/* sql2 */ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left">insert into t14(a,b) values(3,3);/* sql2 */ Query OK, 1 row affected (10.97 sec) <strong>（session1 解锁后，sql2 立马写入成功）</strong></td></tr></tbody></table></div><p>从上面的实验我们可以看出，在 session1 中对表 t14 加表读锁，session1 和 session2 都可以查询表 t14 的数据；而 session1 执行更新会报错，session2 执行更新会等待（直到 session1 解锁后才更新成功）。</p><p>总结：<strong>对表执行 lock tables xxx read （表读锁）时，本线程和其它线程可以读，本线程写会报错，其它线程写会等待。</strong></p><p>我们再来看一下表写锁实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">lock tables t14 write; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select id,a,b from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/* sql3 */ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; Query OK, 0 rows affected (0.01 sec)</td><td style="text-align:left">select id,a,b from t14 limit 1;/* sql3 */ … 1 row in set (7.16 sec) <strong>（session1 解锁后，sql3 马上返回查询结果）</strong></td></tr><tr><td style="text-align:left">lock tables t14 write; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">delete from t14 limit 1; Query OK, 1 row affected, 1 warning (0.00 sec) <strong>（能正常执行删除语句）</strong></td><td style="text-align:left">delete from t14 limit 1;/<em> sql4 </em>/ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left">delete from t14 limit 1;/* sql4 */ Query OK, 1 row affected, 1 warning (14.94 sec) <strong>（session1 解锁后，sql4 立马执行成功）</strong></td></tr></tbody></table></div><p>总结：<strong>对表执行 lock tables xxx write （表写锁）时，本线程可以读写，其它线程读写都会阻塞。</strong></p><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>在 MySQL 中，DDL 是不属于事务范畴的。如果事务和 DDL 并行执行同一张表时，可能会出现事务特性被破坏、binlog 顺序错乱等 bug（比如 <a href="https://bugs.mysql.com/bug.php?id=989" target="_blank" rel="noopener">bug#989</a>）。为了解决这类问题，从 MySQL 5.5.3 开始，引入了元数据锁（Metadata Locking，简称：MDL 锁）（这段内容参考《淘宝数据库内核月报》<a href="http://mysql.taobao.org/monthly/2015/11/04/" target="_blank" rel="noopener">MySQL · 特性分析 · MDL 实现分析</a>）。</p><p>从上面我们知道，MDL 锁的出现解决了同一张表上事务和 DDL 并行执行时可能导致数据不一致的问题。</p><p>但是，我们在工作中，很多情况需要考虑 MDL 的存在，否则可能导致长时间锁等待甚至连接被打满的情况。如下例：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">select id,a,b,sleep(100) from t14 limit 1;/<em> sql5 </em>/</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">alter table t14 add column c int;/* sql6 */ <strong>（等待）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/* sql7 */ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">select id,a,b,sleep(100) from t14 limit 1;/* sql5 */ … 1 row in set (1 min 40.00 sec) <strong>（100秒后 sql5 返回结果）</strong></td><td style="text-align:left">alter table t14 add column c int;/* sql6 */ Query OK, 0 rows affected (1 min 33.98 sec) Records: 0 Duplicates: 0 Warnings: 0 <strong>（session1 的查询语句执行完成后，sql6 立马执行完毕）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/* sql7 */ … 1 row in set (1 min 26.65 sec) <strong>（session1 的查询语句执行完成后，sql7 立马执行完毕）</strong></td></tr></tbody></table></div><p>上面的实验中，我们在 session1 查询了表 t14 的数据，其中使用了 sleep(100) ，表示在 100 秒后才会返回结果；然后在 session2 执行 DDL 操作时会等待（原因是 session1 执行期间会对表 t14 加一个 MDL，而 session2 又会跟 session1 争抢 MDL）；而 session3 执行查询时也会继续等待。因此如果 session1 的语句一直没结束，其它所有的查询都会等待。这种情况下，如果这张表查询比较频繁，很可能短时间把数据库的连接数打满，导致新的连接无法建立而报错，如果是正式业务，影响是非常恐怖的。</p><p>当然如果出现这种情况，假如你还有 session 连着数据库，可以 kill 掉 session1 中的语句或者终止 session2 中的 DDL 操作，可以让业务恢复。但是出现这种情况的根源其实是：session1 中有长时间未提交的事务。<strong>因此对于开发来说，在工作中应该尽量避免慢查询、尽量保证事务及时提交、避免大事务等，当然对于 DBA 来说，也应该尽量避免在业务高峰执行 DDL 操作。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了全局锁和表锁。</p><p>其中<strong>全局锁会让所有的表变成只读状态，所有更新操作都会被阻塞。</strong></p><p>而表级锁分为表锁和元数据锁。</p><p>表锁又提到了表读锁和表写锁，并都进行了实验。两者的区别是：</p><p><strong>表读锁：本线程和其它线程可以读，本线程写会报错，其它线程写会等待。</strong></p><p><strong>表写锁：本线程可以读写，其它线程读写都会阻塞。</strong></p><p>为了保证事务和 DDl 并行执行数据一致，在 MySQL 5.5.3 引入了 MDL 锁。通过本节讲解的 MDL 锁机制，应该注意的几个点是：</p><ul><li>尽量避免慢查询</li><li>事务要及时提交</li><li>避免大事务</li><li>避免在业务高峰执行 DDL 操作</li></ul><blockquote><p>参考资料</p><p>《深入浅出 MySQL》第二版：20.3.8 什么时候使用表锁</p><p>《MySQL 5.7 参考手册》：<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables-with-read-lock" target="_blank" rel="noopener">13.7.6.3 FLUSH Syntax</a></p><p>《淘宝数据库内核月报》：<a href="http://mysql.taobao.org/monthly/2015/11/04/" target="_blank" rel="noopener">MySQL · 特性分析 · MDL 实现分析</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解红黑树性质与实现</title>
      <link href="/2022/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-16-%E8%AF%A6%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%A7%E8%B4%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-16-%E8%AF%A6%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%A7%E8%B4%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文将从2-3树与红黑树的联系入手，详细解释红黑树的性质与代码实现，让各位清楚红黑树为何如此定义以及性质是如何推导出来的。本文需要前章2-3树的知识</p><p>[红黑树等价树2-3树]: <a href="http://www.icanfly.tech/2022/07/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AD%89%E4%BB%B7%E6%A0%912-3%E6%A0%91/" target="_blank" rel="noopener">http://www.icanfly.tech/2022/07/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AD%89%E4%BB%B7%E6%A0%912-3%E6%A0%91/</a></p></blockquote><h3 id="初见红黑树"><a href="#初见红黑树" class="headerlink" title="初见红黑树"></a>初见红黑树</h3><p>引用&lt;&lt;算法导论&gt;&gt;一书，原文如下:</p><p>A red-black tree is a binary tree that satisfies the following red-black properties:</p><ol><li><strong>Every node is either red or black.</strong></li><li><strong>The root is black.</strong></li><li><strong>Every leaf (NIL) is black.</strong></li><li><strong>If a node is red, then both its children are black.</strong></li><li><strong>For each node, all simple paths from the node to descendant leaves contain the<br>same number of black nodes.</strong></li></ol><p>红黑树的性质网上一搜一堆，包括操作也是，但关键是 这性质是怎么推得呢？为什么有这样的性质呢？我可以先记下这些性质，耐心往下看。</p><h3 id="红黑树与2-3树的联系"><a href="#红黑树与2-3树的联系" class="headerlink" title="红黑树与2-3树的联系"></a>红黑树与2-3树的联系</h3><p>让我们先回顾一下 2-3树 添加新元素时要注意的地方:<br>    <strong>或者添加进2-节点，形成一个3-节点</strong><br>    <strong>或者添加进3-节点，暂时形成一个4-节点</strong>    </p><p>我们可以看到，插入的新元素一定要先插入到叶子节点上，如果超过了3节点，再去调整，红黑树也是一颗树，它本质上上实在模仿2-3树，因为2-3这种插入及调整能保证绝对的平衡，红黑树也想实现这种类似的平衡，我们假设红黑树插入的元素，每次也是要插入到一个元素身上，再去考虑调整。</p><p>​    我们将2-3树与红黑树做一下类比:</p><p>​    <img src="1.png" alt=""></p><p>​    我们观察此图，当在2-3树中插入第一个元素时，对应红黑树，也是插入一个元素，此元素默认颜色为黑色。当我们插入第二个元素时，我们说2-3树中，每插入一个元素，都是要插在一个元素身上的，对应红黑树，红黑树也想表达这种3节点的，但红黑树是用在内存的结构，也是基于BST的，一个节点只能有一个元素，那它怎么办，它只能拆分，并且这个地方定义，小的元素在下，拆在我的左孩子(这是定义，你要是不喜欢，可以定义一个红黑树2，让大的元素在小元素的右孩子身上)拆分之后，为了能表示 他们是处于在2-3树中同一个3节点的身份，可以让树枝是红色的来特殊标识一下，表示此节点与父亲节共同组成3节点，但实际上我们写过BST代码就知道了，其实树枝在代码里面就是那个next指针代替了，是没有具体实现类的，所以从实现的角度讲，从节点标识更容易实现，所以我们不妨将小元素节点来标识成红色，至此，一个简单的对应关系就出来了，我们看一下完整的一棵树</p><p><img src="2.png" alt=""></p><p>看完上图，是不是有一恍然大悟的感觉？我们再回过头来，看一下算法导论中提到的性质 ：</p><pre><code>1. 每个节点要么黑，要么红，显然，对应2-3树中的2节点以及3节点中的右面那个元素是黑，3节点中小的那个是红的。1. 跟元素是黑的，这个也简单，因为红元素的节点一定是有一个黑色节点的父亲，那根节点自然是父亲了。1. 叶节点是黑的，这个地方是定义的关系，它把null定义为叶节点，这个不影响理解。1. 如果一个节点是红色，则它的两个孩子是黑的。so easy，因为在2-3树中，一个3节点的孩子要么是2节点（一个元素，黑色代表）要么是3节点（父亲是黑，左孩子是红）。1. 其实说的是，从根节点到任意一个叶节点(我们还是习惯的将最后一个非空节点视为叶节点 )路径上黑色节点的个数是固定的。我们对比2-3树就知道了，把红黑树看成一颗假象的2-3树，2-3树绝对平衡的，层数是固定的，而黑色节点恰巧代表了层数，所以这个路径上黑色节点树固定也不难理解哦。</code></pre><h3 id="插入调整"><a href="#插入调整" class="headerlink" title="插入调整"></a>插入调整</h3><p>接下来我们考虑如何进行调整?，首先我们知道，插入的一个新元素，一定要先附着于一个叶子节点元素上，然后再去调整，因为相当于每个元素都要经过调整，我们可以先假设插入的新元素都是红色的节点，去调整。类似AVL的旋转操作，我们看一下红黑树的基本旋转操作，这些操作是红黑树的数据结构的基本操作。</p><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li><p>左旋转</p><p>左旋转要做的事情如下 ：</p></li></ul><p>​            <img src="3.png" alt="">    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node.right = x.left</span><br><span class="line">x.left = node</span><br><span class="line">x.color = node.color</span><br><span class="line">node.color = RED</span><br></pre></td></tr></table></figure><p><img src="4.png" alt=""></p><p>了解过AVL旋转实现的话，这个代码就很简单了。    </p><ul><li>颜色翻转</li></ul><p>左旋转实际是插入到一个2节点身上，下面我们重点看插入到3节点身上的形态及调整。</p><p>​    <img src="5.png" alt=""></p><p>在42、37插入完成之后，我们又插入了66，对应如图，插入的元素因为要和叶节点绑定，所以默认插入为红色。红色代表与父亲元素是同一个节点，但此时在2-3树中是一个临时的4节点的状态，2-3树中要分裂调整如图示的结构，同理红黑树，我们也对应的表示成2-3树分裂后的结构即可,也就是3个2节点。</p><p><img src="6.png" alt=""></p><p>但要注意一点，虽然都是2节点，但是分裂出来之后父亲是划到上层去了，也是一个结合的节点，所以要标识为红色。红色就代表要调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node.color = RED</span><br><span class="line">node.left.color = BLACK</span><br><span class="line">node.right.color = BLACK</span><br></pre></td></tr></table></figure><ul><li>右旋转</li></ul><p>右旋转也是插入到3节点中出现某种状态时需要调整的操作.</p><p>假设在插入42、37之后再插入一个12元素，显然这是一种临时的4节点状态，需要调整，目标是如图中的3节点状态，我们可先做一个右旋转操作（AVL中常规操作）</p><p><img src="7.png" alt=""></p><p>此时只是简单的右旋，还没到目标结构，但是注意看，这不正是颜色翻转要调整的状态吗？所以此时再调一次颜色翻转的操作即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node.left = x.right</span><br><span class="line">x.right = node</span><br><span class="line">x.color = node.color</span><br><span class="line">node.color = RED</span><br></pre></td></tr></table></figure><h4 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h4><p>我们取一种最麻烦的状态做示例，来回顾整个调整过程，假设向一个3节点中插入一个中间大小的元素</p><p><img src="8.png" alt=""></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            color = RED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点node的颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> BLACK;</span><br><span class="line">        <span class="keyword">return</span> node.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node x = node.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左旋转</span></span><br><span class="line">        node.right = x.left;</span><br><span class="line">        x.left = node;</span><br><span class="line"></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node x = node.left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右旋转</span></span><br><span class="line">        node.left = x.right;</span><br><span class="line">        x.right = node;</span><br><span class="line"></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 颜色翻转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        node.color = RED;</span><br><span class="line">        node.left.color = BLACK;</span><br><span class="line">        node.right.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向红黑树中添加新的元素(key, value)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">        root = add(root, key, value);</span><br><span class="line">        root.color = BLACK; <span class="comment">// 最终根节点为黑色节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向以node为根的红黑树中插入元素(key, value)，递归算法</span></span><br><span class="line">    <span class="comment">// 返回插入新节点后红黑树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            size ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value); <span class="comment">// 默认插入红色节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">            node.left = add(node.left, key, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span>)</span><br><span class="line">            node.right = add(node.right, key, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line">            node.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left))</span><br><span class="line">            node = leftRotate(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left))</span><br><span class="line">            node = rightRotate(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right))</span><br><span class="line">            flipColors(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根节点的二分搜索树中，key所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.equals(node.key))</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> getNode(node.left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// if(key.compareTo(node.key) &gt; 0)</span></span><br><span class="line">            <span class="keyword">return</span> getNode(node.right, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(root, key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span></span>&#123;</span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key + <span class="string">" doesn't exist!"</span>);</span><br><span class="line"></span><br><span class="line">        node.value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉以node为根的二分搜索树中的最小节点</span></span><br><span class="line">    <span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size --;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.left = removeMin(node.left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除键为key的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = remove(root, key);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">            node.left = remove(node.left , key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            node.right = remove(node.right, key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;   <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Node rightNode = node.right;</span><br><span class="line">                node.right = <span class="keyword">null</span>;</span><br><span class="line">                size --;</span><br><span class="line">                <span class="keyword">return</span> rightNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Node leftNode = node.left;</span><br><span class="line">                node.left = <span class="keyword">null</span>;</span><br><span class="line">                size --;</span><br><span class="line">                <span class="keyword">return</span> leftNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">            <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">            Node successor = minimum(node.right);</span><br><span class="line">            successor.right = removeMin(node.right);</span><br><span class="line">            successor.left = node.left;</span><br><span class="line"></span><br><span class="line">            node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树性质解释"><a href="#红黑树性质解释" class="headerlink" title="红黑树性质解释"></a>红黑树性质解释</h3><p> 前面已经解释性质来，这就不重复了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    我们通过插入操作讲解了红黑树的调整及性质的推导，删除操作其实也是在BST操作之上添加调整，可能要更复杂一些但大致原理类似，调整的基础操作也是上面讲到的，相信仔细读完本篇之后对红黑树有一定的感觉了，接下来我们将红黑树、BST、AVL综合对比一下：</p><ol><li>对于完全随机的数据，普通的二分搜索树很好用! 缺点:极端情况退化成链表(或者高度不平衡)</li><li>对于查询较多的使用情况，AVL树很好用!</li><li>红黑树牺牲了平衡性(21ogn的高度) 但是 统计性能更优(综合增删改查所有的操作)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 - 经典数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的回退操作</title>
      <link href="/2022/07/15/Java-2022-07-14-git%E7%9A%84%E5%9B%9E%E9%80%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/07/15/Java-2022-07-14-git%E7%9A%84%E5%9B%9E%E9%80%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="查看提交的log日志"><a href="#查看提交的log日志" class="headerlink" title="查看提交的log日志"></a>查看提交的log日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><h3 id="回退提交点"><a href="#回退提交点" class="headerlink" title="回退提交点"></a>回退提交点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commidId</span><br></pre></td></tr></table></figure><h3 id="显示所有提交点"><a href="#显示所有提交点" class="headerlink" title="显示所有提交点"></a>显示所有提交点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><blockquote><p>有时候回退回去，还想回退回来，这时候 git log 就已经删除了所有commit id了，只能用这个命令，这个日志 包括所有的 分之合并等提交点都会显示，但是注意，只是显示本地进行的操作，如果从git拉取下来后，不是在本地进行的提交，直接回退后，可能 git reflog 也不显示提交点，这时候直接用 git pull 拉取下来就行了，然后到你指定的位移.</p></blockquote><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自建项目上传github常用操作</title>
      <link href="/2022/07/15/Java-2022-07-14-%E8%87%AA%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0github%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/07/15/Java-2022-07-14-%E8%87%AA%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0github%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>在idea 初始化本地项目后</strong></p><ol><li><p>在github创建仓库</p></li><li><p>添加git远程仓库绑定:git remote add origin <a href="https://github.com/zzzzxd/xxxx" target="_blank" rel="noopener">https://github.com/zzzzxd/xxxx</a> 当前没有追踪远程分支,拉取时候绑定远程分支:git pull origin master </p></li></ol><p><strong>常见的其他操作</strong></p><ul><li><ul><li>删除项目当前分支对远程分支的关联</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></li><li><ul><li>项目以http方式重新关联</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin http://gitlab.xxxxxxxx.cn:xxxx/xxxxxx/mall.git</span><br></pre></td></tr></table></figure><ul><li><ul><li>项目中本地分支和远程分支关联</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull git branch --set-upstream-to=origin/de</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase 数据倾斜原因及解决方案</title>
      <link href="/2022/07/15/%E5%A4%A7%E6%95%B0%E6%8D%AE-2022-07-15-Hbase-%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/07/15/%E5%A4%A7%E6%95%B0%E6%8D%AE-2022-07-15-Hbase-%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近公司在做ip维度表，数据量比较大，上亿条数据了，拿hbase存储，进行实时关联。发现ip存到region上倾斜的比较严重，考虑到基数比较大，后期增量相对比较少，可以做一个预分区，使数据分布均衡，借此机会，从网上搜集了一下资料，总结一下常见的解决方案。</p></blockquote><h3 id="热点与数据倾斜"><a href="#热点与数据倾斜" class="headerlink" title="热点与数据倾斜"></a><strong>热点与数据倾斜</strong></h3><p><strong>热点：</strong></p><p>​    热点发生在大量的client直接访问集群的一个或极少数个节点（访问可能是读，写或者其他操作。</p><p>​    大量访问会使热点region所在的单个机器超出自身承受能力，引起性能下降甚至region不可用，这也会影响同一个RegionServer上的其他region，由于主机无法服务其他region的请求，造成资源浪费。设计良好的数据访问模式以使集群被充分，均衡的利用。</p><p><strong>数据倾斜：         </strong></p><p>​    Hbase可以被划分为多个Region，但是默认创建时只有一个Region分布在集群的一个节点上，数据一开始时都集中在这个Region，也就是集中在这一个节点上，就算region存储达到临界值时被划分，数据也是存储在少数节点上。这就是数据倾斜。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ul><li>HBase中的行是按照rowkey的字典顺序排序的，这种设计优化了scan操作，可以将相关的行以及会被一起读取的行存取在临近位置，便于scan。</li><li><strong>rowkey设计是热点的源头</strong>。</li><li><p>HBase中，表会被划分为1…n个Region，被托管在RegionServer中。Region有二个重要的属性: StartKey与EndKey</p><p>表示这个Region维护的rowKey范围，当我们要读/写数据时，如果rowKey落在某个start-end key范围内，那么就会定位到目标        region并且读/写到相关的数据。</p></li><li><p>默认的情况下，创建一张表是，只有1个region，</p><pre><code>    start-end key没有边界，所有数据都在这个region里装，然而，当数据越来越多，region的size越来越大时，大到一定的阀值，hbase认为再往这个region里塞数据已经不合适了，就会找到一个midKey将region一分为二，成为2个region,这个过程称为分裂(region-split)。而midKey则为这二个region的临界（这个中间值这里不作讨论是如何被选取的）。 此时，我们假设假设rowkey小于midKey则为阴被塞到1区，大于等于midKey则会被塞到2区，如果 rowkey还是顺序增大的，那数据就总会往2区里面写数据，而1区现在处于一个被冷落的状态，而且是半满的。2区的数据满了 会被再次分裂成2个区，如此不断产生被冷落而且不满的Region，当然，这些region有提供数据查询的功能。</code></pre><p>这种设计是分布式系统一个很大的弊端，而且这样导致数据倾斜和热点问题，从而导致集群的资源得不到很好的利用。</p></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="预分区"><a href="#预分区" class="headerlink" title="预分区"></a><strong>预分区</strong></h4><h5 id="预分区的必要性"><a href="#预分区的必要性" class="headerlink" title="预分区的必要性"></a><strong>预分区的必要性</strong></h5><p>HBase默认建表时有一个region，这个region的rowkey是没有边界的，即没有startkey和endkey，在数据写入时，所有数据都会写入这个默认的region，当一个region中数据超过阈值时（默认10G），此region已经不能承受不断增长的数据量，会进行split，分成2个region。在此过程中，会产生两个问题：</p><ul><li><ul><li><ol><li>我们的数据会不断的往一个region上写,会有写热点问题。</li></ol></li><li><ol><li>region split会消耗宝贵的集群I/O资源。如果在任务执行时region分裂，会导致任务失败</li></ol></li></ul></li></ul><p>基于此我们可以控制在建表的时候，创建多个空region，并确定每个region的起始和终止rowky，这样只要我们的rowkey设计能均匀的命中各个region，就不会存在写热点问题。自然split的几率也会大大降低。当然随着数据量的不断增长，该split的还是要进行split。像这样预先创建hbase表分区的方式，称之为预分区</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h5><p>首先看没有预分区的：</p><p>一个region里面就保存了7000w（虽然7000w对hbase来说是小case）的数据，读写压力全在这一个region上，会很容易造成热点问题</p><p>​    <img src="1.png" alt="0"></p><h5 id="使用Hbase-shell进行预分区"><a href="#使用Hbase-shell进行预分区" class="headerlink" title="使用Hbase shell进行预分区"></a><strong>使用Hbase shell进行预分区</strong></h5><p>前面说到了rowkey的排列是根据字典排序，所以rowkey寻址的时候是和startkey、endkey进行比较，在字典排序在哪个region的startkey、endkey之间，就落在哪个region</p><p>​                create ‘t1’,’f1’,SPLITS =&gt; [‘10’,’20’,’30’]              </p><p>​    <img src="2.png" alt="0"></p><p>四个分区，rowkey如果是‘0232534’，就落在第一个分区，‘13003424’落在第二个分区</p><p>​                 hbase&gt;create ‘t14’,’f’,SPLITS_FILE=&gt;’splits.txt’              </p><p>​    <img src="3.png" alt="0"></p><p>​    <img src="4.png" alt="0"></p><h4 id="rowkey设计避免热点"><a href="#rowkey设计避免热点" class="headerlink" title="rowkey设计避免热点"></a><strong>rowkey设计避免热点</strong></h4><h5 id="常用手段"><a href="#常用手段" class="headerlink" title="常用手段"></a><strong>常用手段</strong></h5><ul><li>⽣成随机数、hash、散列值</li></ul><p>​                ⽐如: 原本rowKey为1001的，SHA1后变成：dd01903921ea24941c26a48f2cec24e0bb0e8cc7       原本rowKey为3001的，SHA1后变成：49042c54de64a1e9bf0b33e00245660ef92dc7bd      原本rowKey为5001的，SHA1后变成：7b61dec07e02c188790670af43e717f0f46e8913      在做此操作之前，⼀般我们会选择从数据集中抽取样本，来决定什么样的rowKey来Hash后作为每个分区的临 界值。              </p><ul><li>字符串反转</li></ul><p>​                以手机号为rowkey，可以将手机号反转后的字符串作为rowkey，这样的就避免了以手机号那样比较固定开头导致热点问题    例如：20191124000001转成10000042119102           20191124000002转成20000042119102              </p><ul><li>加盐</li></ul><p>​                这里所说的加盐不是密码学中的加盐，而是在rowkey的前面增加随机数，具体就是给rowkey分配一个随机前缀以使得它和之前的rowkey的开头不同。 分配的前缀种类数量应该和你想使用数据分散到不同的region的数量一致。 加盐之后的rowkey就会根据随机生成的前缀分散到各个region上，以避免热点              </p><p>还有其他方案、具体情况具体分析。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式AKF拆分原则</title>
      <link href="/2022/07/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-07-15-%E5%88%86%E5%B8%83%E5%BC%8FAKF%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99/"/>
      <url>/2022/07/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-07-15-%E5%88%86%E5%B8%83%E5%BC%8FAKF%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载 :<a href="https://blog.csdn.net/tomcosin/article/details/119332084" target="_blank" rel="noopener">https://blog.csdn.net/tomcosin/article/details/119332084</a></p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    当我们需要分布式系统提供更强的性能时，该怎样扩展系统呢？什么时候该加机器？什么时候该重构代码？扩容时，究竟该选择哈希算法还是最小连接数算法，才能有效提升性能？</p><p>在面对 Scalability 可伸缩性问题时，我们必须有一个系统的方法论，才能应对日益复杂的分布式系统。这一讲我将介绍 AKF 立方体理论，它定义了扩展系统的 3 个维度，我们可以综合使用它们来优化性能。</p><h3 id="什么是AKF"><a href="#什么是AKF" class="headerlink" title="什么是AKF"></a>什么是AKF</h3><p>AKF 立方体也叫做scala cube，它在《The Art of Scalability》一书中被首次提出，旨在提供一个系统化的扩展思路。AKF 把系统扩展分为以下三个维度：</p><ul><li>X 轴：直接水平复制应用进程来扩展系统。</li><li>Y 轴：将功能拆分出来扩展系统。</li><li>Z 轴：基于用户信息扩展系统。</li></ul><p>如下图所示：</p><p>​    <img src="1.png" alt="0"></p><h3 id="如何基于-AKF-X-轴扩展系统？"><a href="#如何基于-AKF-X-轴扩展系统？" class="headerlink" title="如何基于 AKF X 轴扩展系统？"></a><strong>如何基于 AKF X 轴扩展系统？</strong></h3><p>我们日常见到的各种系统扩展方案，都可以归结到 AKF 立方体的这三个维度上。而且，我们可以同时组合这 3 个方向上的扩展动作，使得系统可以近乎无限地提升性能。为了避免对 AKF 的介绍过于抽象，下面我用一个实际的例子，带你看看这 3 个方向的扩展到底该如何应用。</p><p>假定我们开发一个博客平台，用户可以申请自己的博客帐号，并在其上发布文章。最初的系统考虑了 MVC 架构，将数据状态及关系模型交给数据库实现，应用进程通过 SQL 语言操作数据模型，经由 HTTP 协议对浏览器客户端提供服务，如下图所示：</p><p>​    <img src="2.png" alt="0"></p><p>在这个架构中，处理业务的应用进程属于无状态服务，用户数据全部放在了关系数据库中。因此，当我们在应用进程前加 1 个负载均衡服务后，就可以通过部署更多的应用进程，提供更大的吞吐量。而且，初期增加应用进程，RPS 可以获得线性增长，很实用，如下图：</p><p>​    <img src="3.png" alt="0"></p><p>这就叫做沿 AKF X 轴扩展系统。这种扩展方式最大的优点，就是开发成本近乎为零，而且实施起来速度快！在搭建好负载均衡后，只需要在新的物理机、虚拟机或者微服务上复制程序，就可以让新进程分担请求流量，而且不会影响事务 Transaction 的处理。</p><p>当然，AKF X 轴扩展最大的问题是只能扩展无状态服务，当有状态的数据库出现性能瓶颈时，X 轴是无能为力的。例如，当用户数据量持续增长，关系数据库中的表就会达到百万、千万行数据，SQL 语句会越来越慢，这时可以沿着 AKF Z 轴去分库分表提升性能。又比如，当请求用户频率越来越高，那么可以把单实例数据库扩展为主备多实例，沿 Y 轴把读写功能分离提升性能。下面我们先来看 AKF Y 轴如何扩展系统。</p><h3 id="如何基于-AKF-Y-轴扩展系统？"><a href="#如何基于-AKF-Y-轴扩展系统？" class="headerlink" title="如何基于 AKF Y 轴扩展系统？"></a><strong>如何基于 AKF Y 轴扩展系统？</strong></h3><p>当数据库的 CPU、网络带宽、内存、磁盘 IO 等某个指标率先达到上限后，系统的吞吐量就达到了瓶颈，此时沿着 AKF X 轴扩展系统，是没有办法提升性能的。</p><p>在现代经济中，更细分、更专业的产业化、供应链分工，可以给社会带来更高的效率，而 AKF Y 轴与之相似，当遇到上述性能瓶颈后，拆分系统功能，使得各组件的职责、分工更细，也可以提升系统的效率。比如，当我们将应用进程对数据库的读写操作拆分后，就可以扩展单机数据库为主备分布式系统，使得主库支持读写两种 SQL，而备库只支持读 SQL。这样，主库可以轻松地支持事务操作，且它将数据同步到备库中也并不复杂，如下图所示：</p><p>​    <img src="4.png" alt="0"></p><p>当然，上图中如果读性能达到了瓶颈，我们可以继续沿着 AKF X 轴，用复制的方式扩展多个备库，提升读 SQL 的性能，可见，AKF 多个轴完全可以搭配着协同使用。</p><p>拆分功能是需要重构代码的，它的实施成本比沿 X 轴简单复制扩展要高得多。在上图中，通常关系数据库的客户端 SDK 已经支持读写分离，所以实施成本由中间件承担了，这对我们理解 Y 轴的实施代价意义不大，所以我们再来看从业务上拆分功能的例子。</p><p>当这个博客平台访问量越来越大时，一台主库是无法扛住所有写流量的。因此，基于业务特性拆分功能，就是必须要做的工作。比如，把用户的个人信息、身份验证等功能拆分出一个子系统，再把文章、留言发布等功能拆分到另一个子系统，由无状态的业务层代码分开调用，并通过事务组合在一起，如下图所示：</p><p>​    <img src="5.png" alt="0"></p><p>这样，每个后端的子应用更加聚焦于细分的功能，它的数据库规模会变小，也更容易优化性能。比如，针对用户登录功能，你可以再次基于 Y 轴将身份验证功能拆分，用 Redis 等服务搭建一个基于 LRU 算法淘汰的缓存系统，快速验证用户身份。</p><p>然而，沿 Y 轴做功能拆分，实施成本非常高，需要重构代码并做大量测试工作，上线部署也很复杂。比如上例中要对数据模型做拆分（如同一个库中的表拆分到多个库中，或者表中的字段拆到多张表中），设计组件之间的 API 交互协议，重构无状态应用进程中的代码，为了完成升级还要做数据迁移，等等。</p><p>解决数据增长引发的性能下降问题，除了成本较高的 AKF Y 轴扩展方式外，沿 Z 轴扩展系统也很有效，它的实施成本更低一些，下面我们具体看一下。</p><p><strong>如何基于 AKF Z 轴扩展系统？</strong></p><p>不同于站在服务角度扩展系统的 X 轴和 Y 轴，AKF Z 轴则从用户维度拆分系统，它不仅可以提升数据持续增长降低的性能，还能基于用户的地理位置获得额外收益。</p><p>仍然以上面虚拟的博客平台为例，当注册用户数量上亿后，无论你如何基于 Y 轴的功能去拆分表（即“垂直”地拆分表中的字段），都无法使得关系数据库单个表的行数在千万级以下，这样表字段的 B 树索引非常庞大，难以完全放在内存中，最后大量的磁盘 IO 操作会拖慢 SQL 语句的执行。</p><p>这个时候，关系数据库最常用的分库分表操作就登场了，它正是 AKF 沿 Z 轴拆分系统的实践。比如已经含有上亿行数据的 User 用户信息表，可以分成 10 个库，每个库再分成 10 张表，利用固定的哈希函数，就可以把每个用户的数据映射到某个库的某张表中。这样，单张表的数据量就可以降低到 1 百万行左右，如果每个库部署在不同的服务器上（具体的部署方式视访问吞吐量以及服务器的配置而定），它们处理的数据量减少了很多，却可以独占服务器的硬件资源，性能自然就有了提升。如下图所示：</p><p>​    <img src="6.png" alt="0"></p><p>分库分表是关系数据库中解决数据增长压力的最有效办法，但分库分表同时也导致跨表的查询语句复杂许多，而跨库的事务几乎难以实现，因此这种扩展的代价非常高。当然，如果你使用的是类似 MySQL 这些成熟的关系数据库，整个生态中会有厂商提供相应的中间件层，使用它们可以降低 Z 轴扩展的代价。</p><p>再比如，最开始我们采用 X 轴复制扩展的服务，它们的负载均衡策略很简单，只需要选择负载最小的上游服务器即可，比如 RoundRobin 或者最小连接算法都可以达到目的。但若上游服务器通过 Y 轴扩展，开启了缓存功能，那么考虑到缓存的命中率，就必须改用 Z 轴扩展的方式，基于用户信息做哈希规则下的新路由，尽量将同一个用户的请求命中相同的上游服务器，才能充分提高缓存命中率。</p><p>Z 轴扩展还有一个好处，就是可以充分利用 IDC 与用户间的网速差，选择更快的 IDC 为用户提供高性能服务。网络是基于光速传播的，当 IDC 跨城市、国家甚至大洲时，用户访问不同 IDC 的网速就会有很大差异。当然，同一地域内不同的网络运营商之间，也会有很大的网速差。</p><p>例如你在全球都有 IDC 或者公有云服务器时，就可以通过域名为当地用户就近提供服务，这样性能会高很多。事实上，CDN 技术就基于 IP 地址的位置信息，就近为用户提供静态资源的高速访问。</p><p>下图中，我使用了 2 种 Z 轴扩展系统的方式。首先是基于客户端的地理位置，选择不同的 IDC 就近提供服务。其次是将不同的用户分组，比如免费用户组与付费用户组，这样在业务上分离用户群体后，还可以有针对性地提供不同水准的服务。</p><p>​    <img src="7.png" alt="0"></p><p>沿 AKF Z 轴扩展系统可以解决数据增长带来的性能瓶颈，也可以基于数据的空间位置提升系统性能，然而它的实施成本比较高，尤其是在系统宕机、扩容时，一旦路由规则发生变化，会带来很大的数据迁移成本，[第 24 讲] 我将要介绍的一致性哈希算法，其实就是用来解决这一问题的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>这一讲我们介绍了如何基于 AKF 立方体的 X、Y、Z 三个轴扩展系统提升性能。</p><ul><li><p>X 轴扩展系统时实施成本最低，只需要将程序复制到不同的服务器上运行，再用下游的负载均衡分配流量即可。X 轴只能应用在无状态进程上，故无法解决数据增长引入的性能瓶颈。</p></li><li><p>Y 轴扩展系统时实施成本最高，通常涉及到部分代码的重构，但它通过拆分功能，使系统中的组件分工更细，因此可以解决数据增长带来的性能压力，也可以提升系统的总体效率。比如关系数据库的读写分离、表字段的垂直拆分，或者引入缓存，都属于沿 Y 轴扩展系统。</p></li><li><p>Z 轴扩展系统时实施成本也比较高，但它基于用户信息拆分数据后，可以在解决数据增长问题的同时，基于地理位置就近提供服务，进而大幅度降低请求的时延，比如常见的 CDN 就是这么提升用户体验的。但 Z 轴扩展系统后，一旦发生路由规则的变动导致数据迁移时，运维成本就会比较高。</p></li></ul><p>​    当然，X、Y、Z 轴的扩展并不是孤立的，我们可以同时应用这 3 个维度扩展系统。分布式系统非常复杂，AKF 给我们提供了一种自上而下的方法论，让我们能够针对不同场景下的性能瓶颈，以最低的成本提升性能。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解一致性哈希算法</title>
      <link href="/2022/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-2022-07-15-%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2022/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-2022-07-15-%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载:<a href="https://segmentfault.com/a/1190000021199728" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021199728</a></p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>要了解一致性哈希，首先我们必须了解传统的哈希及其在大规模分布式系统中的局限性。简单地说，哈希就是一个键值对存储，在给定键的情况下，可以非常高效地找到所关联的值。假设我们要根据其邮政编码查找城市中的街道名称。一种最简单的实现方式是将此信息以哈希字典的形式进行存储 <code>&lt;Zip Code，Street Name&gt;</code>。</p><p>当数据太大而无法存储在一个节点或机器上时，问题变得更加有趣，系统中需要多个这样的节点或机器来存储它。比如，使用多个 Web 缓存中间件的系统。<strong>那如何确定哪个 key 存储在哪个节点上？针对该问题，最简单的解决方案是使用哈希取模来确定。</strong> 给定一个 key，先对 key 进行哈希运算，将其除以系统中的节点数，然后将该 key 放入该节点。同样，在获取 key 时，对 key 进行哈希运算，再除以节点数，然后转到该节点并获取值。上述过程对应的哈希算法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_number &#x3D; hash(key) % N # 其中 N 为节点数。</span><br></pre></td></tr></table></figure><p>下图描绘了多节点系统中的传统的哈希取模算法，基于该算法可以实现简单的负载均衡。</p><p><img src="traditional-hashing.png" alt="traditional-hashing"></p><h3 id="一、传统哈希取模算法的局限性"><a href="#一、传统哈希取模算法的局限性" class="headerlink" title="一、传统哈希取模算法的局限性"></a>一、传统哈希取模算法的局限性</h3><p>下面我们来分析一下传统的哈希及其在大规模分布式系统中的局限性。这里我们直接使用我之前所写文章 <a href="https://segmentfault.com/a/1190000021136424" target="_blank" rel="noopener">布隆过滤器你值得拥有的开发利器</a> 中定义的 SimpleHash 类，然后分别对 <strong>semlinker、kakuqo 和 test</strong> 3 个键进行哈希运算并取余，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleHash &#123;</span><br><span class="line">    private int cap;</span><br><span class="line">    private int seed;</span><br><span class="line"></span><br><span class="line">    public SimpleHash(int cap, int seed) &#123;</span><br><span class="line">        this.cap &#x3D; cap;</span><br><span class="line">        this.seed &#x3D; seed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int hash(String value) &#123;</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        int len &#x3D; value.length();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            result &#x3D; seed * result + value.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return (cap - 1) &amp; result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SimpleHash simpleHash &#x3D; new SimpleHash(2 &lt;&lt; 12, 8);</span><br><span class="line">        System.out.println(&quot;node_number&#x3D;hash(\&quot;semlinker\&quot;) % 3 -&gt; &quot; + </span><br><span class="line">          simpleHash.hash(&quot;semlinker&quot;) % 3);</span><br><span class="line">        System.out.println(&quot;node_number&#x3D;hash(\&quot;kakuqo\&quot;) % 3 -&gt; &quot; + </span><br><span class="line">          simpleHash.hash(&quot;kakuqo&quot;) % 3);</span><br><span class="line">        System.out.println(&quot;node_number&#x3D;hash(\&quot;test\&quot;) % 3 -&gt; &quot; + </span><br><span class="line">          simpleHash.hash(&quot;test&quot;) % 3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码成功运行后，在控制台会输出以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node_number&#x3D;hash(&quot;semlinker&quot;) % 3 -&gt; 1</span><br><span class="line">node_number&#x3D;hash(&quot;kakuqo&quot;) % 3 -&gt; 2</span><br><span class="line">node_number&#x3D;hash(&quot;test&quot;) % 3 -&gt; 0</span><br></pre></td></tr></table></figure><p>基于以上的输出结果，我们可以创建以下表格：</p><p><img src="ch-three-nodes-hash.png" alt="ch-three-nodes-hash"></p><h4 id="1-1-节点减少的场景"><a href="#1-1-节点减少的场景" class="headerlink" title="1.1 节点减少的场景"></a>1.1 节点减少的场景</h4><p><strong>在分布式多节点系统中，出现故障很常见。任何节点都可能在没有任何事先通知的情况下挂掉，针对这种情况我们期望系统只是出现性能降低，正常的功能不会受到影响。</strong> 对于原始示例，当节点出现故障时会发生什么？原始示例中有的 3 个节点，假设其中 1 个节点出现故障，这时节点数发生了变化，节点个数从 3 减少为 2，此时表格的状态发生了变化：</p><p><img src="ch-two-nodes-hash.png" alt="ch-two-nodes-hash"></p><p>很明显节点的减少会导致键与节点的映射关系发生变化，这个变化对于新的键来说并不会产生任何影响，但对于已有的键来说，将导致节点映射错误，以 “semlinker” 为例，变化前系统有 3 个节点，该键对应的节点编号为 1，当出现故障时，节点数减少为 2 个，此时该键对应的节点编号为 0。</p><h4 id="1-2-节点增加的场景"><a href="#1-2-节点增加的场景" class="headerlink" title="1.2 节点增加的场景"></a>1.2 节点增加的场景</h4><p><strong>在分布式多节点系统中，对于某些场景比如节日大促，就需要对服务节点进行扩容，以应对突发的流量。</strong> 对于原始示例，当增加节点会发生什么？原始示例中有的 3 个节点，假设进行扩容临时增加了 1 个节点，这时节点数发生了变化，节点个数从 3 增加为 4 个，此时表格的状态发生了变化：</p><p><img src="ch-four-nodes-hash.png" alt="ch-four-nodes-hash"></p><p>很明显节点的增加也会导致键与节点的映射关系发生变化，这个变化对于新的键来说并不会产生任何影响，但对于已有的键来说，将导致节点映射错误，同样以 “semlinker” 为例，变化前系统有 3 个节点，该键对应的节点编号为 1，当增加节点时，节点数增加为 4 个，此时该键对应的节点编号为 2。</p><p>当集群中节点的数量发生变化时，之前的映射规则就可能发生变化。如果集群中每个机器提供的服务没有差别，这不会有什么影响。<strong>但对于分布式缓存这种的系统而言，映射规则失效就意味着之前缓存的失效，若同一时刻出现大量的缓存失效，则可能会出现 “缓存雪崩”，这将会造成灾难性的后果。</strong></p><p><strong>要解决此问题，我们必须在其余节点上重新分配所有现有键，这可能是非常昂贵的操作，并且可能对正在运行的系统产生不利影响。当然除了重新分配所有现有键的方案之外，还有另一种更好的方案即使用一致性哈希算法。</strong></p><h3 id="二、一致性哈希算法"><a href="#二、一致性哈希算法" class="headerlink" title="二、一致性哈希算法"></a>二、一致性哈希算法</h3><p>一致性哈希算法在 1997 年由麻省理工学院提出，是一种特殊的哈希算法，在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式<a href="https://baike.baidu.com/item/哈希表/5981869" target="_blank" rel="noopener">哈希表</a>（Distributed Hash Table，DHT）中存在的动态伸缩等问题 。</p><h4 id="2-1-一致性哈希算法优点"><a href="#2-1-一致性哈希算法优点" class="headerlink" title="2.1 一致性哈希算法优点"></a>2.1 一致性哈希算法优点</h4><ul><li><p>可扩展性。一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少，相比传统哈希算法大大节省了数据移动的开销 。</p></li><li><p>更好地适应数据的快速增长。采用一致性哈希算法分布数据，当数据不断增长时，部分虚拟节点中可能包含很多数据、造成数据在虚拟节点上分布不均衡，此时可以将包含数据多的虚拟节点分裂，这种分裂仅仅是将原有的虚拟节点一分为二、不需要对全部的数据进行重新哈希和划分。</p><p>虚拟节点分裂后，如果物理服务器的负载仍然不均衡，只需在服务器之间调整部分虚拟节点的存储分布。这样可以随数据的增长而动态的扩展物理服务器的数量，且代价远比传统哈希算法重新分布所有数据要小很多。</p></li></ul><h4 id="2-2-一致性哈希算法与哈希算法的关系"><a href="#2-2-一致性哈希算法与哈希算法的关系" class="headerlink" title="2.2 一致性哈希算法与哈希算法的关系"></a>2.2 一致性哈希算法与哈希算法的关系</h4><p>一致性哈希算法是在哈希算法基础上提出的，在动态变化的分布式环境中，哈希算法应该满足的几个条件：平衡性、单调性和分散性。</p><ul><li>平衡性：是指 hash 的结果应该平均分配到各个节点，这样从算法上解决了负载均衡问题。</li><li>单调性：是指在新增或者删减节点时，不影响系统正常运行。</li><li>分散性：是指数据应该分散地存放在分布式集群中的各个节点（节点自己可以有备份），不必每个节点都存储所有的数据。</li></ul><h3 id="三、一致性哈希算法原理"><a href="#三、一致性哈希算法原理" class="headerlink" title="三、一致性哈希算法原理"></a>三、一致性哈希算法原理</h3><p>一致性哈希算法通过一个叫作一致性哈希环的数据结构实现。这个环的起点是 0，终点是 2^32 - 1，并且起点与终点连接，故这个环的整数分布范围是 [0, 2^32-1]，如下图所示：</p><p><img src="hash-ring.png" alt="hash-ring"></p><h4 id="3-1-将对象放置到哈希环"><a href="#3-1-将对象放置到哈希环" class="headerlink" title="3.1 将对象放置到哈希环"></a>3.1 将对象放置到哈希环</h4><p>假设我们有 “semlinker”、”kakuqo”、”lolo”、”fer” 四个对象，分别简写为 o1、o2、o3 和 o4，然后使用哈希函数计算这个对象的 hash 值，值的范围是 [0, 2^32-1]：</p><p><img src="hash-ring-hash-objects.png" alt="hash-ring-hash-objects"></p><p>图中对象的映射关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash(o1) &#x3D; k1; hash(o2) &#x3D; k2;</span><br><span class="line">hash(o3) &#x3D; k3; hash(o4) &#x3D; k4;</span><br></pre></td></tr></table></figure><h4 id="3-2-将服务器放置到哈希环"><a href="#3-2-将服务器放置到哈希环" class="headerlink" title="3.2 将服务器放置到哈希环"></a>3.2 将服务器放置到哈希环</h4><p>接着使用同样的哈希函数，我们将服务器也放置到哈希环上，可以选择服务器的 IP 或主机名作为键进行哈希，这样每台服务器就能确定其在哈希环上的位置。这里假设我们有 3 台缓存服务器，分别为 cs1、cs2 和 cs3：</p><p><img src="/hash-ring-hash-servers.png" alt="hash-ring-hash-servers"></p><p>图中服务器的映射关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(cs1) &#x3D; t1; hash(cs2) &#x3D; t2; hash(cs3) &#x3D; t3; # Cache Server</span><br></pre></td></tr></table></figure><h4 id="3-3-为对象选择服务器"><a href="#3-3-为对象选择服务器" class="headerlink" title="3.3 为对象选择服务器"></a>3.3 为对象选择服务器</h4><p>将对象和服务器都放置到同一个哈希环后，在哈希环上顺时针查找距离这个对象的 hash 值最近的机器，即是这个对象所属的机器。以 o2 对象为例，顺序针找到最近的机器是 cs2，故服务器 cs2 会缓存 o2 对象。而服务器 cs1 则缓存 o1，o3 对象，服务器 cs3 则缓存 o4 对象。</p><p><img src="hash-ring-objects-servers.png" alt="hash-ring-objects-servers"></p><h4 id="3-4-服务器增加的情况"><a href="#3-4-服务器增加的情况" class="headerlink" title="3.4 服务器增加的情况"></a>3.4 服务器增加的情况</h4><p>假设由于业务需要，我们需要增加一台服务器 cs4，经过同样的 hash 运算，该服务器最终落于 t1 和 t2 服务器之间，具体如下图所示：</p><p><img src="http://cdn.semlinker.com/hash-ring-add-server.jpg" alt="hash-ring-add-server"></p><p>对于上述的情况，只有 t1 和 t2 服务器之间的对象需要重新分配。在以上示例中只有 o3 对象需要重新分配，即它被重新到 cs4 服务器。在前面我们已经分析过，如果使用简单的取模方法，当新添加服务器时可能会导致大部分缓存失效，而使用一致性哈希算法后，这种情况得到了较大的改善，因为只有少部分对象需要重新分配。</p><h4 id="3-5-服务器减少的情况"><a href="#3-5-服务器减少的情况" class="headerlink" title="3.5 服务器减少的情况"></a>3.5 服务器减少的情况</h4><p>假设 cs3 服务器出现故障导致服务下线，这时原本存储于 cs3 服务器的对象 o4，需要被重新分配至 cs2 服务器，其它对象仍存储在原有的机器上。</p><p><img src="hash-ring-remove-server.png" alt="hash-ring-remove-server"></p><h4 id="3-6-虚拟节点"><a href="#3-6-虚拟节点" class="headerlink" title="3.6 虚拟节点"></a>3.6 虚拟节点</h4><p>到这里一致性哈希的基本原理已经介绍完了，但对于新增服务器的情况还存在一些问题。新增的服务器 cs4 只分担了 cs1 服务器的负载，服务器 cs2 和 cs3 并没有因为 cs4 服务器的加入而减少负载压力。如果 cs4 服务器的性能与原有服务器的性能一致甚至可能更高，那么这种结果并不是我们所期望的。</p><p><strong>针对这个问题，我们可以通过引入虚拟节点来解决负载不均衡的问题。即将每台物理服务器虚拟为一组虚拟服务器，将虚拟服务器放置到哈希环上，如果要确定对象的服务器，需先确定对象的虚拟服务器，再由虚拟服务器确定物理服务器。</strong></p><p><img src="ch-virtual-nodes.png" alt="ch-virtual-nodes"></p><p>图中 o1 和 o2 表示对象，v1 ~ v6 表示虚拟服务器，s1 ~ s3 表示物理服务器。</p><h3 id="四、一致性哈希算法实现"><a href="#四、一致性哈希算法实现" class="headerlink" title="四、一致性哈希算法实现"></a>四、一致性哈希算法实现</h3><p>这里我们只介绍不带虚拟节点的一致性哈希算法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import java.util.SortedMap;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class ConsistentHashingWithoutVirtualNode &#123;</span><br><span class="line">    &#x2F;&#x2F;待添加入Hash环的服务器列表</span><br><span class="line">    private static String[] servers &#x3D; &#123;&quot;192.168.0.1:8888&quot;, &quot;192.168.0.2:8888&quot;, </span><br><span class="line">      &quot;192.168.0.3:8888&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;key表示服务器的hash值，value表示服务器</span><br><span class="line">    private static SortedMap&lt;Integer, String&gt; sortedMap &#x3D; new TreeMap&lt;Integer, String&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;程序初始化，将所有的服务器放入sortedMap中</span><br><span class="line">    static &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; servers.length; i++) &#123;</span><br><span class="line">            int hash &#x3D; getHash(servers[i]);</span><br><span class="line">            System.out.println(&quot;[&quot; + servers[i] + &quot;]加入集合中, 其Hash值为&quot; + hash);</span><br><span class="line">            sortedMap.put(hash, servers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;得到应当路由到的结点</span><br><span class="line">    private static String getServer(String key) &#123;</span><br><span class="line">        &#x2F;&#x2F;得到该key的hash值</span><br><span class="line">        int hash &#x3D; getHash(key);</span><br><span class="line">        &#x2F;&#x2F;得到大于该Hash值的所有Map</span><br><span class="line">        SortedMap&lt;Integer, String&gt; subMap &#x3D; sortedMap.tailMap(hash);</span><br><span class="line">        if (subMap.isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果没有比该key的hash值大的，则从第一个node开始</span><br><span class="line">            Integer i &#x3D; sortedMap.firstKey();</span><br><span class="line">            &#x2F;&#x2F;返回对应的服务器</span><br><span class="line">            return sortedMap.get(i);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;第一个Key就是顺时针过去离node最近的那个结点</span><br><span class="line">            Integer i &#x3D; subMap.firstKey();</span><br><span class="line">            &#x2F;&#x2F;返回对应的服务器</span><br><span class="line">            return subMap.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用FNV1_32_HASH算法计算服务器的Hash值</span><br><span class="line">    private static int getHash(String str) &#123;</span><br><span class="line">        final int p &#x3D; 16777619;</span><br><span class="line">        int hash &#x3D; (int) 2166136261L;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length(); i++)</span><br><span class="line">            hash &#x3D; (hash ^ str.charAt(i)) * p;</span><br><span class="line">        hash +&#x3D; hash &lt;&lt; 13;</span><br><span class="line">        hash ^&#x3D; hash &gt;&gt; 7;</span><br><span class="line">        hash +&#x3D; hash &lt;&lt; 3;</span><br><span class="line">        hash ^&#x3D; hash &gt;&gt; 17;</span><br><span class="line">        hash +&#x3D; hash &lt;&lt; 5;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果算出来的值为负数则取其绝对值</span><br><span class="line">        if (hash &lt; 0)</span><br><span class="line">            hash &#x3D; Math.abs(hash);</span><br><span class="line">        return hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] keys &#x3D; &#123;&quot;semlinker&quot;, &quot;kakuqo&quot;, &quot;fer&quot;&#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; keys.length; i++)</span><br><span class="line">            System.out.println(&quot;[&quot; + keys[i] + &quot;]的hash值为&quot; + getHash(keys[i])</span><br><span class="line">                    + &quot;, 被路由到结点[&quot; + getServer(keys[i]) + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码成功运行后，在控制台会输出以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[192.168.0.1:8888]加入集合中, 其Hash值为1326271016</span><br><span class="line">[192.168.0.2:8888]加入集合中, 其Hash值为1132535844</span><br><span class="line">[192.168.0.3:8888]加入集合中, 其Hash值为115798597</span><br><span class="line"></span><br><span class="line">[semlinker]的hash值为1549041406, 被路由到结点[192.168.0.3:8888]</span><br><span class="line">[kakuqo]的hash值为463104755, 被路由到结点[192.168.0.2:8888]</span><br><span class="line">[fer]的hash值为1677150790, 被路由到结点[192.168.0.3:8888]</span><br></pre></td></tr></table></figure><p>上面我们只介绍了不带虚拟节点的一致性哈希算法实现，如果有的小伙伴对带虚拟节点的一致性哈希算法感兴趣，可以参考 <a href="https://blog.csdn.net/suifeng629/article/details/81567777" target="_blank" rel="noopener">一致性Hash(Consistent Hashing)原理剖析及Java实现</a> 这篇文章。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>​    本文通过示例介绍了传统的哈希取模算法在分布式系统中的局限性，进而在针对该问题的解决方案中引出了一致性哈希算法。一致性哈希算法在 1997 年由麻省理工学院提出，是一种特殊的哈希算法，在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。在介绍完一致性哈希算法的作用和优点等相关知识后，我们以图解的形式生动介绍了一致性哈希算法的原理，最后给出了不带虚拟节点的一致性哈希算法的 Java 实现。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一 致性Hash </tag>
            
            <tag> 分布式算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树等价树2-3树</title>
      <link href="/2022/07/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-14-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AD%89%E4%BB%B7%E6%A0%912-3%E6%A0%91/"/>
      <url>/2022/07/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-14-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AD%89%E4%BB%B7%E6%A0%912-3%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote><p>一提到红黑树大家应该都不陌生，jdk集合容器底层大量应用红黑树来实现，是一种高性能应用广泛的数据结构。可是，对于它的性质原理很多人理解起来都比较困难，在&lt;&lt;算法&gt;&gt;本书中，作者也是红黑树的作者，采用2-3树来引入的方式介绍红黑树的原理，所以我们接下来要聊的2-3树是理解红黑树很重要的数据结构，可以这么说，看懂了本篇，再了解红黑树和2-3树的等价关系，就很容易理解红黑树的性质了。</p></blockquote><h3 id="2-3树基本性质"><a href="#2-3树基本性质" class="headerlink" title="2-3树基本性质"></a>2-3树基本性质</h3><ul><li>2-3树是一种绝对平衡的树 即平衡因子为0；</li><li>2-3树也是一种BST，满足二分搜索树的基本性质</li><li>2-3树，只有两种节点，2节点（节点有两个孩子）和3节点（节点有3个孩子）</li><li>2-3树 每插入一个元素，一定是插在叶子节点上，再去进行调整。</li></ul><h3 id="2-3树插入过程"><a href="#2-3树插入过程" class="headerlink" title="2-3树插入过程"></a>2-3树插入过程</h3><p>​    假设你已经具备BST、AVL平衡树的基础，那么基本性质了解以后，我们再看一下插入过程，基本上就搞定2-3树了</p><p>​    以 42、37、12、18、6、11、5 元素插入为例，详细的插入过程如下图:    <img src="1.png" alt=""></p><p>  详细解释一下:</p><pre><code>1. 第一次插入元素42时，整树为空，形成根节点1. 接着插入37，要和根节点先合并，检查是不是形成4节点，没有则无需调整。1. 插入12，此时只有根节点这个叶节点，先合并，检查形成4节点，需要拆分，37成根1. 插入18，和BST一样的插入顺序，来到12点叶节点位置，合并，检查无需拆分。1. 插入6，又来到12点叶节点，形成4节点，拆分。1. 插入11，来到6节点的位置，无需拆分。1. 插入5，此时引起了连锁的拆分反应，最终12成根。</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>可以发现，2-3 树由于这种插入调整的规则，使得它在任何时刻都是绝对平衡，2-3树可能是我们见到的唯一绝对平衡的数据结构。</li><li>2-3树 每次插入一定是插入在叶节点上，再去考虑调整。</li><li>2-3树不难，它的绝对平衡的特性，使得它查找迅速，并且插入速度并不是特别慢</li><li>先牢记插入合并以及拆分的过程，等理解红黑树性质时会有大用。</li></ol><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 算法 - 经典数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化Mysql数据导入的几种方法</title>
      <link href="/2022/07/14/mysql-2022-07-14-%E4%BC%98%E5%8C%96Mysql%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/14/mysql-2022-07-14-%E4%BC%98%E5%8C%96Mysql%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析sql执行效率的方法</title>
      <link href="/2022/07/14/mysql-2022-07-14-%E5%88%86%E6%9E%90sql%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/14/mysql-2022-07-14-%E5%88%86%E6%9E%90sql%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql ONLY_FULL_BY_GROUP_MODE模式</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql-ONLY-FULL-BY-GROUP-MODE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql-ONLY-FULL-BY-GROUP-MODE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>ONLY_FULL_BY_GROUP_MODE</strong></p><p>​    如果此模式不开启，则对mysql的扩展生效 此时与标准sql 有两个明显的区别：</p><p>​    <strong>允许在select list，having condition 和 order by 中使用没有出现在group by 中的字段，此时mysql会随机选择没有出现在group by字段中的值，其效果和使用ANY—VALUE效果是一样的</strong></p><p><strong>允许在having condition 中使用select list 中的alias</strong></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql DateTime与Timestamp区别</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql-DateTime%E4%B8%8ETimestamp%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql-DateTime%E4%B8%8ETimestamp%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 创建用户相关操作常用命令</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>创建用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#39;username&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39;;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#39;dog&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;192.168.1.101_&#39; IDENDIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;&#39;;CREATE USER &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure><p><strong>赋予权限</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON test.user TO &#39;pig&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON *.* TO &#39;pig&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON maindataplus.* TO &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure><p><strong>刷新权限</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><strong>删除用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql dump 命令</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql-dump-%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql-dump-%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="命令及解释"><a href="#命令及解释" class="headerlink" title="命令及解释"></a>命令及解释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -ubackup -p123456 -h 192.168.1.2 backup_test &gt; D:\bak\bakcup.sql </span><br><span class="line">在这段命令中：mysqldump 是myqldump的程序名了；</span><br><span class="line">  -u 是数据库的用户名，后面紧跟着用户名backup；</span><br><span class="line">  -p 是数据库的密码，后面同样紧跟着密码，注意是-p和密码之间不能有空格；</span><br><span class="line">  -h 是数据库的地址，如果没有此项表明是备份本地的数据库；</span><br><span class="line">(对我们用的阿里云，就是rds暴露在外的公网地址  xxxx.mysql.rds.aliyuncs.com)</span><br><span class="line">backup_test 要备份的数据库名称；</span><br><span class="line">表明该数据库备份到后面的文件，紧跟当然是备份文件的地址了，注意要用绝对文件路径，文件的后缀也可以用.txt。</span><br><span class="line">一旦执行该命令后，mysqldump立即执行备份操作。远程备份数据库要似乎网络的情况，一般远程备份需要一定的时间的。</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>实际mysql dump记住两条命令就够了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">导入：</span><br><span class="line">mysql -u root -p database &lt; data.sql</span><br><span class="line">导出：</span><br><span class="line">（整个数据库）</span><br><span class="line">mysqldump -u 账户 -p密码 数据库名字 &gt; data.sql</span><br><span class="line">（单个表）</span><br><span class="line">mysqldump  -u 账户 -p密码 数据库名字 表名字 &gt; data.sql</span><br></pre></td></tr></table></figure><blockquote><p>补充：</p><p>导出一个表，只有表结构</p><p>mysqldump -u用户名 -p 密码 -d数据库名 表名&gt; 导出的文件名</p><p>C:\Users\jack&gt; mysqldump -uroot -pmysql -d sva_rec date_rec_drv&gt; e:\date_rec_drv.sql</p><p>导出一个数据库结构</p><p>C:\Users\jack&gt; mysqldump -uroot -pmysql -d sva_rec &gt; e:\sva_rec.sql</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 停止启动mysql常用命令</title>
      <link href="/2022/07/14/mysql-2022-07-14-linux-%E5%81%9C%E6%AD%A2%E5%90%AF%E5%8A%A8mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/14/mysql-2022-07-14-linux-%E5%81%9C%E6%AD%A2%E5%90%AF%E5%8A%A8mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="查看mysql版本"><a href="#查看mysql版本" class="headerlink" title="查看mysql版本"></a>查看mysql版本</h3><p>方法一：status;</p><p>方法二：select version();</p><h3 id="Mysql启动、停止、重启常用命令"><a href="#Mysql启动、停止、重启常用命令" class="headerlink" title="Mysql启动、停止、重启常用命令"></a>Mysql启动、停止、重启常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a、启动方式</span><br><span class="line">1、使用 service 启动：</span><br><span class="line">    [root@localhost &#x2F;]# service mysqld start (5.0版本是mysqld)</span><br><span class="line">    [root@szxdb etc]# service mysql start (5.5.7版本是mysql)</span><br><span class="line">2、使用 mysqld 脚本启动：</span><br><span class="line">    &#x2F;etc&#x2F;inint.d&#x2F;mysqld start</span><br><span class="line">3、使用 safe_mysqld 启动：</span><br><span class="line">    safe_mysqld&amp;</span><br><span class="line">b、停止</span><br><span class="line">    1、使用 service 启动：</span><br><span class="line">    service mysqld stop</span><br><span class="line">    2、使用 mysqld 脚本启动：</span><br><span class="line">    &#x2F;etc&#x2F;inint.d&#x2F;mysqld stop</span><br><span class="line">    3、mysqladmin shutdown</span><br><span class="line">c、重启</span><br><span class="line">    1、使用 service 启动：</span><br><span class="line">    service mysqld restart</span><br><span class="line">    service mysql restart (5.5.7版本命令)</span><br><span class="line">    2、使用 mysqld 脚本启动：</span><br><span class="line">    &#x2F;etc&#x2F;init.d&#x2F;mysqld restart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql中Binlog常用命令</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql%E4%B8%ADBinlog%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql%E4%B8%ADBinlog%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Binlog使用场景"><a href="#Binlog使用场景" class="headerlink" title="Binlog使用场景"></a>Binlog使用场景</h3><ul><li>主从数据库复制： Mysql Replication在Master端开启Binlog，Master把日志传递给Slavers，以达到    Master-slavers主从数据同步。</li><li>数据恢复： 使用mysqlbinlog工具来恢复数据</li></ul><h3 id="Binlog常用命令"><a href="#Binlog常用命令" class="headerlink" title="Binlog常用命令"></a>Binlog常用命令</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 查看是否启用Binlog日志</span><br><span class="line">show variables like &#39;log_bin&#39;;</span><br><span class="line"></span><br><span class="line"># 查看详细的日志配置信息</span><br><span class="line">show global variables like &#39;%log%&#39;;</span><br><span class="line"></span><br><span class="line"># Mysql数据存储目录</span><br><span class="line">show variables like &#39;%dir%&#39;;</span><br><span class="line"></span><br><span class="line"># 查看binlog数据目录</span><br><span class="line">show global variables like &#39;%log_bin%&#39;;</span><br><span class="line"></span><br><span class="line">##以下命令需要super权限</span><br><span class="line"># 查看当前服务器binlog文件及大小</span><br><span class="line">show binary logs;</span><br><span class="line"></span><br><span class="line"># 查看 binlog 内容</span><br><span class="line">show binlog events;</span><br><span class="line"></span><br><span class="line"># 查看具体一个binlog文件的内容 （in 后面为binlog的文件名）</span><br><span class="line">show binlog events in &#39;master.000003&#39;;</span><br><span class="line"></span><br><span class="line"># 设置binlog文件保存事件，过期删除，单位天</span><br><span class="line">set global expire_log_days&#x3D;3; </span><br><span class="line"></span><br><span class="line"># 删除当前的binlog文件</span><br><span class="line">reset master; </span><br><span class="line"></span><br><span class="line"># 删除slave的中继日志</span><br><span class="line">reset slave;</span><br><span class="line"></span><br><span class="line"># 删除指定日期前的日志索引中binlog日志文件</span><br><span class="line">purge master logs before &#39;2019-03-12 21:54:00&#39;;</span><br><span class="line"></span><br><span class="line"># 删除指定日志文件</span><br><span class="line">purge master logs to &#39;master.000001&#39;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda、pip、virtualenv的几点区别</title>
      <link href="/2022/07/14/python-2022-07-14-conda%E3%80%81pip%E3%80%81virtualenv%E7%9A%84%E5%87%A0%E7%82%B9%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/07/14/python-2022-07-14-conda%E3%80%81pip%E3%80%81virtualenv%E7%9A%84%E5%87%A0%E7%82%B9%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="conda"><a href="#conda" class="headerlink" title="conda"></a><strong>conda</strong></h3><p>首先，<strong>conda是一个通用的包管理器</strong>，意思是什么语言的包都可以用其进行管理，自然也就包括Python了。在安装Anaconda或者Miniconda时，会对conda进行一同安装。其中Anaconda作为Python的发行版，相当于在Python的基础上自带了常用第三方库，而Miniconda则相当于是一个conda环境的安装程序，只包含了conda及其依赖项，这样就可以减少一些不需要的第三方库的安装，所以Miniconda所占用的空间很小。</p><h3 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h3><p>Pip同conda一样，也是一个包管理器，并且是Python官方认可的包管理器。其中pip的含义是Pip Installs Packages。最常用于安装在Python包索引（PyPI, Python Package Index <a href="https://pypi.python.org/pypi）上发布的包。因此，在通过conda" target="_blank" rel="noopener">https://pypi.python.org/pypi）上发布的包。因此，在通过conda</a> list命令查看当前环境下已安装的包时，通过pip的源是pypi。</p><p>​    <img src="1.png" alt="在这里插入图片描述"></p><h3 id="conda和pip安装库的区别"><a href="#conda和pip安装库的区别" class="headerlink" title="conda和pip安装库的区别"></a>conda和pip安装库的区别</h3><p>在Anaconda中，<strong>无论在哪个环境下</strong>，只要通过conda install xxx的方式安装的库都会放在Anaconda的pkgs目录下，如:E:\python\anaconda\pkgs\numpy-1.18.1-py36h48dd78f_1。这样的好处就是，当在某个环境下已经下载好了某个库，再在另一个环境中还需要这个库时，就可以直接从pkgs目录下将该库复制至新环境（将这个库的Lib\site-packages中的文件复制到当前新环境下Lib中的第三方库中，也即Lib\site-packages中，这个过程相当于通过pip install xxx进行了安装）而不用重复下载。</p><h3 id="conda和pip卸载库的区别"><a href="#conda和pip卸载库的区别" class="headerlink" title="conda和pip卸载库的区别"></a>conda和pip卸载库的区别</h3><p>pip是在<strong>特定的环境</strong>中进行库的安装，所以卸载库也是一样的道理，通过pip uninstall xxx就可以将该环境下Lib\site-packages中对应的库进行卸载了。</p><p>如果通过conda uninstall xxx删除当前环境下某个库时，删除的只是当前环境下site-packages目录中该库的内容，它的效果和通过pip uninstall xxx是一样的。如果再到另一个环境中通过conda install xxx下载这个库，则还是通过将pkgs目录下的库复制到当前环境。若要清空这个pkgs下的已下载库，可以通过命令conda clean -h进行实现。</p><h3 id="conda和virtualenv的区别"><a href="#conda和virtualenv的区别" class="headerlink" title="conda和virtualenv的区别"></a>conda和virtualenv的区别</h3><p>virtualenv和conda都可以做包隔离，类似java中的maven管理，实现一个项目一个独立的环境，简单的包隔离，用virtualenv就可以实现，它本质就是创建一个文件夹，作为一个独立的环境，运行文件夹bin下的激活脚本就进入这个独立的环境，在这个环境中，所有运行的python命令，安装的脚本都是在这个目录下的，是独立全局的python环境的。但有一个缺点就是virtualenv使用哪个版本的pip命令就会安装到当前目录的bin下，那么用virtualenv创建的虚拟环境就是这个版本的环境，是不能实现版本切换的，换句话说创建出的所有环境都是同一个python版本，要想实现多版本的环境就得用conda，很好的工具，可以详细学习一下。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH协议原理及最佳实践</title>
      <link href="/2022/07/07/network-2022-07-07-SSH%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2022/07/07/network-2022-07-07-SSH%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="初识SSH"><a href="#初识SSH" class="headerlink" title="初识SSH"></a>初识SSH</h3><p>​    维基百科是这样描述ssh协议的 ：</p><blockquote><p><strong>Secure Shell</strong>（安全外壳协议，简称<strong>SSH</strong>）是一种加密的<a href="https://zh.m.wikipedia.org/wiki/网络传输协议" target="_blank" rel="noopener">网络传输协议</a>，可在不安全的网络中为网络服务提供安全的传输环境<a href="https://zh.m.wikipedia.org/zh-cn/Secure_Shell#cite_note-rfc4251-1" target="_blank" rel="noopener">[1]</a>。SSH通过在网络中创建<a href="https://zh.m.wikipedia.org/w/index.php?title=安全隧道&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">安全隧道</a>（英语：<a href="https://en.wikipedia.org/wiki/secure_channel" target="_blank" rel="noopener">secure channel</a>）来实现SSH客户端与服务器之间的连接<a href="https://zh.m.wikipedia.org/zh-cn/Secure_Shell#cite_note-rfc4252-2" target="_blank" rel="noopener">[2]</a>。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输<a href="https://zh.m.wikipedia.org/wiki/命令行界面" target="_blank" rel="noopener">命令行界面</a>和远程执行命令。</p></blockquote><p>通常是用来建立一条相对安全的连接，而不是明文传输。</p><h3 id="SSH原理"><a href="#SSH原理" class="headerlink" title="SSH原理"></a>SSH原理</h3><p>同样，SSH协议也要解决三个问题，即</p><ul><li>如何保证信息的保密性？</li><li>如和保证信息的完整性？</li><li>如何识别对方身份？</li></ul><p>其中前两个问题，通过使用对称加密与非对称加密、数字签名可以解决，在之前的HTTPS相关的文章中都有详细的解释，现在我们重点讨论第三个问题，如何识别对方身份？我们知道HTTPS是通过CA机构颁发证书的方式来确认对方的身份，而SSH的公钥和私钥是客户端自己生成，所以没有CA机构认证。SSH协议有两种识别对方身份的方式</p><ul><li>基于口令的认证</li><li>基于公钥认证</li></ul><h4 id="口令认证"><a href="#口令认证" class="headerlink" title="口令认证"></a>口令认证</h4><p>基于口令的认证，我个人认为，实际上基于口令的认证是第一次的时候需要与 “正确的对方”建立连接,次此连接之后给主机生成一个唯一的host_key，相当于”认识“了这台主机，下次建立链接时，如果与一台错误的主机建立链接时，通过host_key便可以识别出来！</p><p> 如下图，第一登陆的时候:</p><p><img src="1.png" alt=""></p><p>图中显是的是，先通过RSA算法对域名+ip这个key结合公钥对应的唯一信息生成加密串,然后做一个hash提取一个比较短的摘要作为指纹（实际上这只是通俗的解释，指纹的生成用到ECDSA算法，这个算法比较复杂，本人也没详细了解就不做过多的介绍了）,询问你是否继续连接</p><p><img src="2.png" alt=""></p><p>其中know hosts用来存放已经接受识别的身份。</p><p>再下一步就是输入密码进行登录了，其实验证是双向的，指纹验证是验证服务器，用户密码就是服务器再验证客户端了。</p><h4 id="公钥认证"><a href="#公钥认证" class="headerlink" title="公钥认证"></a>公钥认证</h4><p>第一种验证方式，再服务器验证客户端的时候，每次都得使用密码来进行验证，所以通过有了第二种方式来进行免密登录。</p><p>具体流程如下:</p><ol><li>Client将自己的公钥存放在Server上，追加在文件authorized_keys中。</li><li>Server端接收到Client的连接请求后，会在authorized_keys中匹配到Client的公钥pubKey，并生成随机数R，用Client的公钥对该随机数进行加密得到pubKey(R)<br> ，然后将加密后信息发送给Client。</li><li>Client端通过私钥进行解密得到随机数R，然后对随机数R和本次会话的SessionKey利用MD5生成摘要Digest1，发送给Server端。</li><li>Server端会也会对R和SessionKey利用同样摘要算法生成Digest2。</li><li>Server端会最后比较Digest1和Digest2是否相同，完成认证过程。</li></ol><p><img src="3.png" alt="img"></p><blockquote><p>在步骤1中，Client将自己的公钥存放在Server上。需要用户手动将公钥copy到server上。这就是在配置ssh的时候进程进行的操作。下图是GitHub上SSH keys设置视图：</p></blockquote><p><img src="4.png" alt=""></p><h3 id="SSH的最佳实践"><a href="#SSH的最佳实践" class="headerlink" title="SSH的最佳实践"></a>SSH的最佳实践</h3><h4 id="SSH生成的文件"><a href="#SSH生成的文件" class="headerlink" title="SSH生成的文件"></a>SSH生成的文件</h4><p><img src="5.png" alt=""></p><ol><li>d_rsa：保存私钥</li><li>id_rsa.pub：保存公钥</li><li>authorized_keys：保存已授权的客户端公钥</li><li>known_hosts：保存已认证的远程主机ID</li></ol><p><img src="6.png" alt=""></p><blockquote><p>需要注意的是：一台主机可能既是Client，也是Server。所以会同时拥有authorized_keys和known_hosts。</p></blockquote><h4 id="有关文件的常见疑问"><a href="#有关文件的常见疑问" class="headerlink" title="有关文件的常见疑问"></a>有关文件的常见疑问</h4><ol><li>known_hosts中存储的内容是什么？</li></ol><p>​    known_hosts中存储是已认证的远程主机host key，每个SSH Server都有一个<strong>secret, unique ID, called a host key</strong>。    </p><ol><li>host key何时加入known_hosts的？</li></ol><p>​    当我们第一次通过SSH登录远程主机的时候</p><ol><li>为什么需要known_hosts？</li></ol><p>​    最后探讨下为什么需要known_hosts，这个文件主要是通过Client和Server的双向认证，从而避免中间人（<strong>man-in-the-middle attack</strong>）攻击，每次Client向Server发起连接的时候，不仅仅Server要验证Client的合法性，Client同样也需要验证Server的身份，SSH client就是通过known_hosts中的host key来验证Server的身份的。</p><blockquote><p>这中方案足够安全吗？当然不，比如第一次连接一个未知Server的时候，known_hosts还没有该Server的host key，这不也可能遭到<strong>中间人</strong>攻击吗？这可能只是安全性和可操作性之间的折中吧。</p></blockquote><h4 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h4><p>记住三步走:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.客户端生成公钥私钥 </span><br><span class="line">ssh-keygen</span><br><span class="line">2.上传公钥到服务器</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.100</span><br><span class="line">3.免密登录</span><br><span class="line">ssh root@192.168.1.100</span><br></pre></td></tr></table></figure><blockquote><p>参考:<a href="https://www.jianshu.com/p/33461b619d53" target="_blank" rel="noopener">https://www.jianshu.com/p/33461b619d53</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> ssh </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS与&quot;中间人攻击&quot;</title>
      <link href="/2022/07/07/network-2022-07-07-HTTPS%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
      <url>/2022/07/07/network-2022-07-07-HTTPS%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="引导问题"><a href="#引导问题" class="headerlink" title="引导问题"></a>引导问题</h3><ol><li><p>为什么使用Https是安全的？</p></li><li><p>Https的底层原理如何实现？</p></li><li><p>使用Https是绝对安全的吗？</p></li></ol><h3 id="Https实现原理"><a href="#Https实现原理" class="headerlink" title="Https实现原理"></a>Https实现原理</h3><p>Https协议在内容传输上使用的加密是“对称加密”，而“非对称加密”只作用于证书验证阶段。Https的整体实现过程分为“证书验证”和“数据传输”两个阶段，过程如下所示：</p><ul><li>Https协议在内容传输上使用的加密是“对称加密”，而“非对称加密”只作用于证书验证阶段。</li><li>Https的整体实现过程分为“证书验证”和“数据传输”两个阶段，过程如下所示：</li></ul><p>​    <img src="1.png" alt="0"></p><p><strong>证书验证阶段</strong></p><ol><li><p>浏览器发起Https请求；</p></li><li><p>服务器端返回Https证书；</p></li><li><p>浏览器客户端验证证书是否合法，若不合法则提示警告</p></li></ol><p><strong>数据传输阶段</strong></p><ol><li><p>当证书验证合法后，在客户端本地生成随机数；</p></li><li><p>通过公钥加密随机数，并将加密后的随机数传输到服务端；</p></li><li><p>服务端通过私钥对接收到的加密随机数进行解密操作；</p></li><li><p>服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密操作后再进行内容传输。</p></li></ol><h3 id="为什么数据传输是用对称加密？"><a href="#为什么数据传输是用对称加密？" class="headerlink" title="为什么数据传输是用对称加密？"></a>为什么数据传输是用对称加密？</h3><p>首先，非对称加密的加密效率是非常低的，而http的应用场景通常存在着端与端之间的大量数据交互，从效率来说是无法接受的；</p><p>其次，在Https场景中只有服务端保存了私钥，而一对公私钥只能实现单向的加解密（即服务端无法使用私钥对传回浏览器客户端的数据进行加密，只能用于解密），所以Https中内容传输加密采取的是对称加密，而不是非对称加密（此处随机数则是对称加密的介体，即客户端和服务器端所拥有的随机数都是一致的，能够进行双向加解密）。</p><h3 id="为什么需要CA认证机构颁发证书？"><a href="#为什么需要CA认证机构颁发证书？" class="headerlink" title="为什么需要CA认证机构颁发证书？"></a>为什么需要CA认证机构颁发证书？</h3><p>Http协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而Https协议主要就是解决网络传输的安全性问题。</p><p>首先，我们假设不存在认证机构，任何人都可以制作证书，这存在的风险便是经典的“中间人攻击”问题。具体过程如下：</p><p>​    <img src="2.png" alt="0"></p><h3 id="“中间人攻击”原理"><a href="#“中间人攻击”原理" class="headerlink" title="“中间人攻击”原理"></a>“中间人攻击”原理</h3><ol><li><p>客户端请求被劫持（如DNS劫持等），所有的客户端请求均被转发至中间人的服务器；</p></li><li><p>中间人服务器返回中间人伪造的“伪证书”（包含伪公钥）；</p></li><li><p>客户端创建随机数，通过中间人证书的伪公钥对随机数进行加密后传输给中间人，然后凭随机数构造对称加密算法对要进行传输的数据内容进行对称加密后传输；</p></li><li><p>中间人因为拥有客户端生成的随机数，从而能够通过对称加密算法进行数据内容解密；</p></li><li><p>中间人再以“伪客户端”的身份向正规的服务端发起请求；</p></li><li><p>因为中间人与服务器之间的通信过程是合法的，正规服务端通过建立的安全通道返回加密后的数据内容；</p></li><li><p>中间人凭借与正规服务器建立的对称加密算法进行数据内容解密；</p></li><li><p>中间人再通过与客户端建立的对称加密算法对正规服务器返回的数据内容进行加密传输；</p></li><li><p>客户端通过中间人建立的对称加密算法对返回的数据内容进行解密；</p></li></ol><p>由于缺少对证书的真伪性验证，所有客户端即使发起了Https请求，但客户端完全不知道自己发送的请求已经被第三方拦截，导致其中传输的数据内容被中间人窃取。</p><h3 id="浏览器如何确保CA证书的合法性？"><a href="#浏览器如何确保CA证书的合法性？" class="headerlink" title="浏览器如何确保CA证书的合法性？"></a>浏览器如何确保CA证书的合法性？</h3><ol><li>证书包含的主要信息：</li></ol><ul><li>颁发机构信息</li><li>公钥</li><li>公司信息</li><li>域名</li><li>有效期</li><li>指纹</li><li>等等</li></ul><ol><li>证书的合法性依据</li></ol><p>首先，权威机构是需要通过认证的。其次证书的可信性基于信任制，CA认证机构需要对其颁发的证书进行信用担保，只要是CA认证机构颁发的证书，我们就认为是合法的。CA认证机构会对证书申请人的信息进行审核的。</p><ol><li><p>浏览器如何验证证书的合法性？</p><p>浏览器发起https请求时，服务器会返回网站的SSL证书，浏览器需要对证书做以下验证：</p></li></ol><ul><li>验证域名、有效期等信息是否正确；</li><li>判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发的证书进行来源验证；</li><li>判断证书是否被篡改。需要与CA服务器进行对比校验；</li><li>判断证书是否已被吊销。通过CRL(Certificate Revocation List 证书注销列表) 和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中OCSP可用于第3步中以减少与CA服务器的交互，提高验证效率。</li></ul><p>以上任意一步都同时满足的情况下，浏览器才认为证书是合法的。</p><h3 id="只有认证机构可以生产证书吗？"><a href="#只有认证机构可以生产证书吗？" class="headerlink" title="只有认证机构可以生产证书吗？"></a>只有认证机构可以生产证书吗？</h3><p>如果需要浏览器不提示安全风险，那只能通过认证机构签发的证书。但浏览器通常只是会提示安全风险，并不会限制网站的访问，所有从技术上来说，谁都可以生产证书，只要有证书就能够完成网站的https传输。</p><h3 id="客户端的本地随机数被窃取了怎么办？"><a href="#客户端的本地随机数被窃取了怎么办？" class="headerlink" title="客户端的本地随机数被窃取了怎么办？"></a>客户端的本地随机数被窃取了怎么办？</h3><p>其实https并不包含对随机数的安全保证，https保证的只是数据传输过程安全，而随机数存储于本地，本地的安全属于另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。（这也反映了Https协议并不是绝对的安全的）</p><h3 id="使用Https被抓包了会怎样？"><a href="#使用Https被抓包了会怎样？" class="headerlink" title="使用Https被抓包了会怎样？"></a>使用Https被抓包了会怎样？</h3><p>由于Https的数据是加密，常规下抓包工具代理请求后抓到的包内容是加密状态的，无法直接查看。</p><p>但是，浏览器只会提示安全风险，如果用户授权仍然继续访问网站，完成请求。那么，只有客户端是我们自己的终端，我们授权的情况下，便能够建立中间人网络，而抓包工具作为中间人的代理。</p><p>通常， HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。</p><p>即是，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。</p><blockquote><p>引用:<a href="https://blog.csdn.net/Jop_qq/article/details/104362064" target="_blank" rel="noopener">https://blog.csdn.net/Jop_qq/article/details/104362064</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashSet与TreeSet源码解析</title>
      <link href="/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-HashSet%E4%B8%8ETreeSet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-HashSet%E4%B8%8ETreeSet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TreeMap源码解析</title>
      <link href="/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-TreeMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-TreeMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>TreeMap是一种常用的key有序的数据结构,底层原理主要是用到动态平衡树，之前研究过了HashMap，解决冲突时链表会转化红黑树，同样这里平衡树依然是红黑树,可见这个数据结构的重要性了。如果红黑树原理不熟悉，那么涉及到具体的操作源码 可先跳过，有关红黑树只需要记住一点，红黑树和AVL都是动态平衡树的一种，都是在BST的基础上改进而来，基础的查询操作和BST一模一样，插入元素与删除元素，都是在元素插入或删除之后根据自己的特性取调整节点-“打补丁”以维持平衡。</p></blockquote><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li>结构图</li><li><p>类注释信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较器，如果外部有传进来 Comparator 比较器，首先用外部的</span></span><br><span class="line"><span class="comment">//如果外部比较器为空，则使用 key 自己的 Comparable 的 compareTo 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"><span class="comment">//红黑树的根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">//树节点的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//树的版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ol><p>看一下这棵红黑树的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> keyHash = (key==<span class="keyword">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> valueHash = (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">"="</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><ol><li>常用属性</li></ol><h3 id="常用操作源码解析"><a href="#常用操作源码解析" class="headerlink" title="常用操作源码解析"></a>常用操作源码解析</h3><ol><li>添加元素</li><li>查找</li><li>删除</li><li>迭代</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList源码解析</title>
      <link href="/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-LinkList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-LinkList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li><p>整体结构</p><p>LinkedList也是常用的一种数据结构,它和ArrayList在逻辑上都是线性结构，而在物理存储上ArrayList是连续存储，LinkedList是非连续存储。LinkedList实现是一个双向链表。Node节点源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     E item;</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line">   </span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">         <span class="keyword">this</span>.item = element;</span><br><span class="line">         <span class="keyword">this</span>.next = next;</span><br><span class="line">         <span class="keyword">this</span>.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>只要稍微熟悉点数据结构对这种实现就不陌生，典型的链表结构，整体的图示如下:</p></li></ol><ol><li><p>类注释信息</p><pre><code>    1. 没有实现线程同步，多线程的时候需要外部来做同步。</code></pre><ol><li>ListIterator也是有“fail-fast”机制的。</li></ol></li><li><p>常见属性</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">transient int size &#x3D; 0;</span><br><span class="line">&#x2F;**</span><br><span class="line">     * Pointer to first node.</span><br><span class="line">     * Invariant: (first &#x3D;&#x3D; null &amp;&amp; last &#x3D;&#x3D; null) ||</span><br><span class="line">     *            (first.prev &#x3D;&#x3D; null &amp;&amp; first.item !&#x3D; null)</span><br><span class="line">     *&#x2F;</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">     * Pointer to last node.</span><br><span class="line">     * Invariant: (first &#x3D;&#x3D; null &amp;&amp; last &#x3D;&#x3D; null) ||</span><br><span class="line">     *            (last.next &#x3D;&#x3D; null &amp;&amp; last.item !&#x3D; null)</span><br><span class="line">     *&#x2F;</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h3 id="常用操作解析"><a href="#常用操作解析" class="headerlink" title="常用操作解析"></a>常用操作解析</h3><ol><li><p>添加</p><ol><li><p>从头插入</p><p>因为比较简单，都是最基础的数据结构，就不过多解释了，源码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从头部追加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//头节点赋值给临时变量</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="comment">//新建节点，前一个节点指向null，e是新建节点的值，f 是新建节点的下一个节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">        <span class="comment">//新建节点成为头节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="comment">//头节点为空，就是链表唯恐，头尾节点是一个节点。</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="comment">//上一个头节点的前一个节点就是当前节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>从尾巴插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从尾部开始追加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把尾节点数据暂存</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="comment">//新建新的节点，l 是前一个节点，e 是当前节点的值，后一个节点是 null</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//新建的节点放在尾部</span></span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="comment">//如果链表为空，头部和尾部是同一个节点，都是新建的节点</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="comment">//否则把前尾节点的下一个节点，指向当前尾节点。</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        <span class="comment">//大小和版本更改</span></span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>删除</p><ol><li>从头删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从头删除节点 f 是链表头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拿出头节点的值，作为方法的返回值</span></span><br><span class="line">        <span class="keyword">final</span> E element = f.item;</span><br><span class="line">        <span class="comment">// 拿出头节点的下一个节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        <span class="comment">//帮助 GC 回收头节点</span></span><br><span class="line">        f.item = <span class="keyword">null</span>;</span><br><span class="line">        f.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 头节点的下一个节点成为头节点</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="comment">//如果 next 为空，表明链表为空</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//链表不为空，头节点的前一个节点指向 null</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//修改链表大小和版本</span></span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>从尾巴删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> l == last &amp;&amp; l != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> E element = l.item;</span><br><span class="line">        <span class="comment">//删除之前先保留前一个节点，last前移做准备</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = <span class="keyword">null</span>;</span><br><span class="line">        l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">            first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//修改版本</span></span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代</p><p>有关迭代器相关的知识，在ArrayList文章中已经解释的比较详细了，这里就重点看下源码好了，比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>LinkedList是双向链表，所以实现的接口也是双向迭代器,继承关系如下:</p><p><img src="2.png" alt=""></p><p>接下来我们看下，它的向前，向后的迭代方法</p><ol><li>　向后迭代</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断还有没有下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextIndex &lt; size;<span class="comment">//下一个节点的索引小于链表的大小，就有</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//检查期望版本号有无发生变化</span></span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="keyword">if</span> (!hasNext())<span class="comment">//再次检查</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="comment">// next 是当前节点</span></span><br><span class="line">  lastReturned = next;</span><br><span class="line">  <span class="comment">// next 是下一个节点了，为下次迭代做准备</span></span><br><span class="line">  next = next.next;</span><br><span class="line">  nextIndex++;</span><br><span class="line">  <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>向前</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果上次节点索引位置大于 0，就还有节点可以迭代</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取前一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="comment">// next 为空场景：说明是第一次迭代，取尾节点(last)</span></span><br><span class="line">  <span class="comment">// next 不为空场景：说明已经发生过迭代了，直接取前一个节点即可(next.prev)</span></span><br><span class="line">  lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">  <span class="comment">// 索引位置变化</span></span><br><span class="line">  nextIndex--;</span><br><span class="line">  <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>迭代器删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="comment">// lastReturned 为空，说明没有执行 next 或者 previos，直接报错</span></span><br><span class="line">  <span class="comment">// lastReturned = next() 方法执行的结果</span></span><br><span class="line">  <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">  <span class="comment">//删除当前节点</span></span><br><span class="line">  unlink(lastReturned);</span><br><span class="line">  <span class="comment">// 从尾到头递归顺序，并且是第一次迭代，并且要删除最后一个元素的情况下</span></span><br><span class="line">  <span class="comment">// 这种情况下，previous 方法里面设置了 lastReturned = next = last。</span></span><br><span class="line">  <span class="comment">// 我们必须把 next 设置成 null，这样在下次递归时，previous 方法才会让队尾最后一个节点赋值给 next</span></span><br><span class="line">  <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">    next = lastNext;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    nextIndex--;</span><br><span class="line">  lastReturned = <span class="keyword">null</span>;</span><br><span class="line">  expectedModCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    LinkedList无非是链表的封装，使用起来也很简单，它的插入与删除都是O(1) 的复杂度，虽然ArrayList也是O(1)的，但那是在均摊分析下的，LinkedList是真正的O (1)操作，主要是它不需要考虑动态的扩容缩容操作。</p><p>此外，LinkedList也常用来作为DeQueue的实现。Queue接口，我觉得它主要就是拿来做并发用的，有关它的知识点，有机会来介绍一下。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList源码解析</title>
      <link href="/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ArrayList几乎是最常用的一种数据结构,本篇就研究一下ArrayList的常用操作的底层实现。通过学习底层实现的细节，帮助自己写出更优秀的代码 。</p></blockquote><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li>结构图</li></ol><p>​    ArrayList实际上就是封装了一个数组 ,代码体现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装的数组</span></span><br><span class="line"><span class="keyword">transient</span>  Object[] elementData;</span><br></pre></td></tr></table></figure><p><img src="1.jpg" alt=""></p><ol><li>类注释信息        </li></ol><ul><li>允许 put null 值，会自动扩容；</li><li>size、isEmpty、get、set、add 等方法时间复杂度都是 O (1)；</li></ul><ol><li>常见属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认数组大小10</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"> <span class="comment">//数组使用的大小</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">transient</span>  Object[] elementData;</span><br></pre></td></tr></table></figure><ul><li>DEFAULT_CAPACITY 表示数组的初始大小，默认是 10，这个数字要记住；</li><li>size 表示当前数组的大小，类型 int，没有使用 volatile 修饰，非线程安全的；</li><li>还有一个特别重要的变量,继承自AbstractList </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>​        这个变量与ArrayList源码注释中提到的”fail-fast”有关，这个变量源码中有详细的解释，翻译过来大致如下 ：</p><blockquote><p>此列表在结构上被修改的次数。结构修改是指改变列表的大小，或以某种方式干扰列表，使正在进行的迭代可能产生不正确的结果。</p><p>该字段由迭代器和列表迭代器方法返回的迭代器和列表迭代器实现使用。如果此字段的值意外更改，迭代器（或列表迭代器）将抛出ConcurrentModificationException，以响应下一个、删除、上一个、设置或添加操作。这提供了快速失效行为，而不是在迭代过程中面对并发修改时的不确定性行为。</p><p>子类使用此字段是可选的。如果子类希望提供故障快速迭代器（和列表迭代器），那么它只需在其add（int，E）和remove（int）方法（以及它覆盖的任何其他导致列表结构修改的方法）中增加该字段。对add（int，E）或remove（int）的单个调用只能向该字段添加一个，否则迭代器（和列表迭代器）将抛出虚假的ConcurrentModificationException。如果实现不希望提供故障快速迭代器，则可以忽略此字段。</p></blockquote><p>什么意思呢，所谓的”fail-fast”就是指如果在迭代时，容器发生结构性的改变，元素减少或者增多（注意更新不算）,那么遍历时会立刻抛出异常结束迭代，而这个”fail-fast”机制就是通过检查modCount变量来实现的，下文在源码中我会再详细解释。 算法导论中 也曾提过 “循环不变性”,是指如果在循环的某一次迭代开始之前是正确的，那么在下一次迭代开始之前，也是正确的，感觉是有一丢丢的联系。在很多框架的实现中也见过类似的操作，对List中的元素，会先copy一份出来，再去迭代，目的就是避免迭代过程中容器发生变更而必须加锁的操作。</p><h3 id="常用操作的源码解析"><a href="#常用操作的源码解析" class="headerlink" title="常用操作的源码解析"></a>常用操作的源码解析</h3><ol><li>初始化</li></ol><p>​        初始化代码有3种:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                         initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  无参数构造器，默认是空数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//指定初始数据初始化</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//elementData 是保存数组的容器，默认为 null</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">//如果给定的集合（c）数据有值，则进行拷贝赋值操作</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">      <span class="comment">//如果集合元素类型不是 Object 类型，才开始拷贝，否则不执行</span></span><br><span class="line">      <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 给定集合（c）无值，则默认空数组</span></span><br><span class="line">      <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意: ArrayList 无参构造器初始化时，默认大小是空数组，并不是10，10 是在第一次 add 的时候扩容的数组值。</p><ol><li>新增与扩容</li></ol><p>​    添加元素的逻辑很简单，首先判断是不是需要扩容，保证容量够用，然后添加元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确保数组大小足够，不够需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//直接赋值，线程不安全的</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>继续看 ensureCapacityInternal()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是空数组，就从最小容量和默认容量10之间取最大值</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">      minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保容积足够</span></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录数组被修改</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果我们希望的最小容量大于目前数组的长度，那么就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">      grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最终实际是在grow方法中进行了扩容，并且做了旧值的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老的数组大小2倍，最后把现有数据拷贝到新的数组里面去</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// oldCapacity &gt;&gt; 1 是把 oldCapacity / 2 的意思</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就去 Integer 的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// 通过复制进行扩容</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>添加以及扩容操作也比较简单，有两个细节，需要注意一下</p><ul><li><p>扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是 原来容量的 1.5 倍；</p></li><li><p>ArrayList 中的数组的最大值是 Integer.MAX_VALUE，超过这个值， JVM 就不会给数组 分配内存空间了。</p></li></ul><ol><li>扩容的具体实现</li></ol><p>​    实际上，我们看到最终调用的扩容，不过是用工具类新生成了一个数组，而这个工具类的底层实际调用的也是系统类，进行数组的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Params:</span><br><span class="line">  src – the source array.</span><br><span class="line">  srcPos – starting position in the source array.</span><br><span class="line">  dest – the destination array.</span><br><span class="line">  destPos – starting position in the destination data.</span><br><span class="line">  length – the number of array elements to be copied</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>删除</li></ol><p>​    删除元素有两种，一种是根据下标删除，一种是根据值删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据数组下标去删除</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">      System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                       numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据值去删除</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果值是空的，找到第一个值是空的删除</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">        <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">          fastRemove(index);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 值不为空，找到第一个和入参相等的删除</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">        <span class="comment">// 这里是根据  equals 来判断值相等的</span></span><br><span class="line">        <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">          fastRemove(index);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>迭代器遍历</li></ol><p>​    Iterator我们来详细解释一下，这种遍历的思想在国外的很多企业算法面试题中都有涉及，并且它还是一种设计模式，同时我们再看下上文中提到的modCount是如何来实现“fail-fast”机制的。</p><p>首先看一下ArrayList的iterator方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//源码带注释 * &lt;p&gt;The returned iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际就是返回来一个Iterator接口的实现<code>private class Itr implements Iterator&lt;E&gt;</code></p><p>我们先看一下Iterator接口，再看一下在ArrayList中的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中就这几个方法，其中<code>hasNext()</code>、<code>next()</code>、<code>remove()</code>方法通常是迭代器重点使用的方法,而<code>forEachRemaining()</code>方法我们也看到实际调用的也是迭代器，它是传入的是一个函数式接口, 接下来我们重点关注前三种方法的实现，先看下Iterator在ArrayList中的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 迭代过程中，下一个元素的位置，从 0 开始，用来控制拿下一个元素</span></span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="comment">// 新增时表示上一次迭代过程中，索引的位置，删除成功时为 -1</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="comment">// 迭代过程中期望数组修改版本号</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasNext()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> cursor != size;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>next()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span></span><br><span class="line">      checkForComodification();</span><br><span class="line">      <span class="comment">//本次迭代过程中，元素的索引位置</span></span><br><span class="line">      <span class="keyword">int</span> i = cursor;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      <span class="comment">// 下一次迭代时，元素的位置</span></span><br><span class="line">      cursor = i + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 返回元素值</span></span><br><span class="line">      <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有关这个”fail-fast”,我们看下checkForComodification()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>迭代器一创建出来，就会赋值expectedModCount，然后每次操作前会比较modCount与它的值，用来做检查，而迭代器删除的时候，会重新赋值<code>expectedModCount = modCount</code>,保证可以通过检查，下面我们也会看到。</p><p>remove()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果上一次操作时，数组的位置已经小于 0 了，说明数组已经被删除完了</span></span><br><span class="line">      <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">      <span class="comment">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span></span><br><span class="line">      checkForComodification();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        <span class="comment">// -1 表示元素已经被删除，这里也防止重复删除</span></span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 删除元素时 modCount 的值已经发生变化，再此赋值给 expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>​    ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多 个线程对这些变量进行操作时，可能会有值被覆盖的情况。</p><p>类注释中推荐我们使用 Collections#synchronizedList 来保证线程安全，SynchronizedList 是 通过在每个方法上面加上锁来实现，虽然实现了线程安全，但是性能大大降低，具体实现源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">synchronized</span> (mutex) &#123;<span class="comment">// synchronized 是一种 重量级锁，但具有锁升级的概念，mutex 表示一把互斥锁 </span></span><br><span class="line">    <span class="keyword">return</span> c.add(e); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    本文从 ArrayList 整体架构出发，落地到初始化、新增、扩容、删除、迭代等核心源码实现，我 们发现 ArrayList 其实就是围绕底层数组结构，各个 API 都是对数组的操作进行封装，让使用者 无需感知底层实现，只需关注如何使用即可。</p>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS对称与非对称加密协议</title>
      <link href="/2022/07/06/network-2022-07-06-Httptps%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/07/06/network-2022-07-06-Httptps%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>众所周知，WEB服务存在http和https两种通信方式，http默认采用80作为通讯端口，对于传输采用不加密的方式，https默认采用443，对于传输的数据进行加密传输。本文重点介绍https涉及到的对称加密和非对称加密协议原理。</p></blockquote><p>首先我们先不谈https，先从一个简单的通讯原理图讲起：</p><p>​    <img src="1.png" alt="0"></p><h4 id="http通信原理"><a href="#http通信原理" class="headerlink" title="http通信原理"></a>http通信原理</h4><p>客户端发送一句client hello给服务器端，服务器端返回一句serverhello给客户端，鉴于本文讨论是https的加密主题，我们只讨论信息传输的加密问题实现客户端和服务端发送的信息client hello 和server hello，即使中间的包被窃取了，也无法解密传输的内容</p><p>http：client hello和server hello在通讯的过程中，以明文的形式进行传输，采用wireshark抓包的效果如下图：</p><p>​    <img src="2.png" alt="0"></p><p>有没有感觉这个的信息传输是完全暴露在互联网上面，你请求的所有信息都可以被窥测到，是不是感觉心一凉，不过不用担心，我们的安全信息现在都是采用https的传输，后面讲到https的时候大家心里会顿时轻松。但这不是最关键的，http的传输最大的隐患是信息劫持和篡改，如下图：</p><p>​    <img src="3.png" alt="0"></p><p>可以看到，http的信息传输中，信息很容易被×××给劫持，更有甚者，×××可以伪装服务器将篡改后的信息返回给用户，试想一下，如果×××劫持的是你的银行信息，是不是很可怕。所以对于http传出存在的问题可以总结如下：</p><p>（1）信息篡改：修改通信的内容</p><p>（2）信息劫持：拦截到信息通信的内容</p><p>这些是http不安全的体现，说完http，我们回到本文的主题https，看下人家是怎么保护信息的，所有的请求信息都采用了TLS加密，如果没有秘钥是无法解析传输的是什么信息</p><p>​    <img src="4.png" alt="0"></p><h4 id="对于加密传输存在对称加密和非对称加密"><a href="#对于加密传输存在对称加密和非对称加密" class="headerlink" title="对于加密传输存在对称加密和非对称加密"></a>对于加密传输存在对称加密和非对称加密</h4><h5 id="对称加密-——对称加密传输"><a href="#对称加密-——对称加密传输" class="headerlink" title="对称加密 ——对称加密传输"></a>对称加密 ——对称加密传输</h5><p>​    <img src="5.png" alt="0"></p><p>当客户端发送Hello字符串的时候，在进行信息传输前，采用加密算法（上图中的秘钥S）将hello加密程JDuEW8&amp;*21!@#进行传输，即使中间被×××劫持了，如果没有对应的秘钥S也无法知道传出的信息为何物，在上图中信息的加密和解密都是通过同一个秘钥进行的，对于这种加密我们称之为对称加密，只要A和B之间知道加解密的秘钥，任何第三方都无法获取秘钥S，则在一定条件下，基本上解决了信息通信的安全问题。但在现实的情况下（www），实际的通讯模型远比上图复杂，下图为实际的通信模型</p><p>​    <img src="6.png" alt="0"></p><p>server和所有的client都采用同一个秘钥S进行加解密，但大家思考下，如果这样的话，无异于没有加密，请做下思考</p><p>由于server和所有的client都采用同一个秘钥S，则×××们作为一个client也可以获取到秘钥S，此地无银三百两。所以在实际的通讯中，一般不会采用同一个秘钥，而是采用不同的秘钥加解密，如下图——通过协商的方式获取不同的秘钥</p><p>​    <img src="7.png" alt="0"></p><p>如上图，A和server通信采用对称加密A算法，B和server通信采用对称秘钥B算法，因此可以很好的解决了不同的客户端采用相同的秘钥进行通讯的问题</p><p>那现在又存在问题了，A通过明文传输和server协商采用了加密算法A，但这条信息本身是没有加密的，因此×××们还是可以窃取到秘钥的，整个的通讯仍然存在风险。那该如何处理呢？有人说，把这条信息（协调秘钥的过程）再次加密，那是不是还要协商加密秘钥，如此反复，永无止境。从根本上无法解决信息通讯的安全问题</p><h5 id="如何对协商过程进行加密-（-非对称加密原理图）"><a href="#如何对协商过程进行加密-（-非对称加密原理图）" class="headerlink" title="如何对协商过程进行加密 （ 非对称加密原理图）"></a>如何对协商过程进行加密 （ 非对称加密原理图）</h5><p>​    <img src="8.png" alt="0"></p><p>在密码学跟对称加密一起出现的，应用最广的加密机制“非对称加密”，如上图，特点是私钥加密后的密文，只要是公钥，都可以解密，但是反过来公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。</p><p>基于上述的特点，我们可以得出如下结论：</p><p>（1）公钥是开放给所有人的，但私钥是需要保密的，存在于服务端</p><p>（2）服务器端server向client端（A、B…）的信息传输是不安全的：因为所有人都可以获取公钥</p><p>（3）但client端（A、B…）向server端的信息传输确实安全的：因为私钥只有server端存在</p><p>因此，如何协商加密算法的问题，我们解决了，非对称加密算法进行对称加密算法协商过程。</p><p>​    <img src="9.png" alt="0"></p><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>信息通信采用http是不安全的，存在信息劫持、篡改的风险，https是加密传输，是安全的通信，对于https加密的过程，我们首先介绍的对称加密，采用对称加密进行通信存在秘钥协商过程的不安全性，因此我们采用了非对称加密算法解决了对协商过程的加密，因此https是集对称加密和非对称加密为一体的加密过程</p><p><strong>安全的获取公钥</strong></p><p>细心的人可能已经注意到了如果使用非对称加密算法，我们的客户端A，B需要一开始就持有公钥，要不没法开展加密行为啊。</p><p>这下，我们又遇到新问题了，如何让A、B客户端安全地得到公钥？</p><p>​    <img src="10.png" alt="0"></p><p>client获取公钥最最直接的方法是服务器端server将公钥发送给每一个client用户，但这个时候就出现了公钥被劫持的问题，如上图，client请求公钥，在请求返回的过程中被×××劫持，那么我们将采用劫持后的假秘钥进行通信，则后续的通讯过程都是采用假秘钥进行，数据库的风险仍然存在。在获取公钥的过程中，我们又引出了一个新的话题：如何安全的获取公钥，并确保公钥的获取是安全的， 那就需要用到终极武器了：SSL 证书（需要购买）和CA机构</p><p>​    <img src="11.png" alt="0"></p><p>如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有证书的颁发机构、有效期、公钥、证书持有者、签名，通过第三方的校验保证了身份的合法，解决了公钥获取的安全性</p><p>以浏览器为例说明如下整个的校验过程：</p><p>（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验</p><p>（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发</p><p>（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。</p><p>（4）如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密</p><p>（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比</p><p>（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充</p><p>（7）此时浏览器就可以读取证书中的公钥，用于后续加密了</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​        HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。</p><blockquote><p>引用：<a href="https://blog.csdn.net/weixin_42504145/article/details/85207103/" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42504145/article/details/85207103/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> 加密算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS、证书机构（CA）、证书、数字签名、私钥、公钥</title>
      <link href="/2022/07/06/network-2022-07-06-HTTPS%E3%80%81%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84%EF%BC%88CA%EF%BC%89%E3%80%81%E8%AF%81%E4%B9%A6%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E3%80%81%E7%A7%81%E9%92%A5%E3%80%81%E5%85%AC%E9%92%A5/"/>
      <url>/2022/07/06/network-2022-07-06-HTTPS%E3%80%81%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84%EF%BC%88CA%EF%BC%89%E3%80%81%E8%AF%81%E4%B9%A6%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E3%80%81%E7%A7%81%E9%92%A5%E3%80%81%E5%85%AC%E9%92%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文内容主要来自简书博主olaH的文章，作者对概念之间的联系解释的非常清楚，熟悉这些概念可以对理解SSH协议、Https协议以及证书颁发等打下基础</p><p>原文链接:<a href="https://www.jianshu.com/u/ab311efd67d7" target="_blank" rel="noopener">olaH</a></p></blockquote><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密是指双方持有相同的密钥进行通信，加密速度快，但是有一个安全问题，双方怎样获得相同的密钥？你总不能总是拿着U盘把密钥拷贝给对方吧。</p><p>常见的对称加密算法有DES、3DES、AES等</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密，又称为公开密钥加密，是为了解决对称加密中的安全问题而诞生，一个称为公开密钥(public key)，即公钥，另一个称为私钥(private key)，即私钥。但是它的加密速度相对于对称加密来说很慢。</p><ul><li>公钥(public key)是对外开放的，私钥(private key)是自己拥有的。</li><li>公钥(public key)加密的数据，只能用私钥(private key)解密。</li><li>私钥(private key)加密的数据，只能用公钥(public key)解密。</li></ul><h3 id="信息安全问题"><a href="#信息安全问题" class="headerlink" title="信息安全问题"></a>信息安全问题</h3><p>在信息安全性问题中，我们常常要做到三点才能保证信息的安全：</p><ol><li>信息的保密性</li><li>信息的完整性</li><li>身份识别</li></ol><h4 id="信息的保密性（加密算法）"><a href="#信息的保密性（加密算法）" class="headerlink" title="信息的保密性（加密算法）"></a>信息的保密性（加密算法）</h4><p>信息的保密性我们可以使用对称加密和非对称加密来完成，使用对称加密来完成，速度相对非对称加密很快，但是存在一个安全问题，密钥如何传递？由此通用的方法是使用非对称加密+对称加密来完成。客户端使用公钥对对称加密的密钥进行加密，然后传递给服务端，服务端使用私钥进行解密确认密钥，开始传输数据。</p><p>​    <img src="1.png" alt="0"></p><h4 id="信息的完整性（数字签名）"><a href="#信息的完整性（数字签名）" class="headerlink" title="信息的完整性（数字签名）"></a>信息的完整性（数字签名）</h4><p>信息传输的途中，我们的信息很有可能被第三方劫持篡改，所以我们需要保证信息的完整性，通用方法是使用散列算法如SHA1，MD5将传输内容hash一次获得hash值，即摘要。客户端使用服务端的公钥对摘要和信息内容进行加密，然后传输给服务端，服务端使用私钥进行解密获得原始内容和摘要值，这时服务端使用相同的hash算法对原始内容进行hash，然后与摘要值比对，如果一致，说明信息是完整的。</p><p>​    <img src="2.png" alt="0"></p><p>image.png</p><h4 id="身份识别（数字证书）"><a href="#身份识别（数字证书）" class="headerlink" title="身份识别（数字证书）"></a>身份识别（数字证书）</h4><p>在信息传输的过程中，我们通常需要验证信息的发送方的身份，这时我们转化一下思路就可以完成，把发送端的公钥发送给接收端，发送端通过把自己的内容使用私钥加密然后发送给接收端，接收端只能用发送端的公钥解密，自然就验证了发送端的身份。</p><p>​    <img src="3.png" alt="0"></p><p>image.png</p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>在传输的过程中，客户端如何获得服务器端的公钥呢？当时是服务器分发给客户端，如果一开始服务端发送的公钥到客户端的过程中有可能被第三方劫持，然后第三方自己伪造一对密钥，将公钥发送给客户端，当服务器发送数据给客户端的时候，中间人将信息进行劫持，用一开始劫持的公钥进行解密后，然后使用自己的私钥将数据加密发送给客户端，而客户端收到后使用公钥解密，反过来亦是如此，整个过程中间人是透明的，但信息泄露却不得而知。</p><p>​    <img src="4.png" alt="0"></p><p>image.png</p><p>为了防止这种情况，数字证书就出现了，它其实就是基于上上面所说的私钥加密数据，公钥解密来验证其身份。</p><p>数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，最重要的是公钥在数字证书中。</p><p>数字证书是如何保证公钥来自请求的服务器呢？数字证书上由持有人的相关信息，通过这点可以确定其不是一个中间人；但是证书也是可以伪造的，如何保证证书为真呢？</p><p>一个证书中含有三个部分:”证书内容，散列算法，加密密文”，证书内容会被散列算法hash计算出hash值，然后使用CA机构提供的私钥进行RSA加密。</p><p>​    <img src="5.png" alt="0"></p><p>image.png</p><p>当客户端发起请求时，服务器将该数字证书发送给客户端，客户端通过CA机构提供的公钥对加密密文进行解密获得散列值（数字签名），同时将证书内容使用相同的散列算法进行Hash得到另一个散列值，比对两个散列值，如果两者相等则说明证书没问题。</p><p>​    <img src="6.png" alt="0"></p><p>image.png</p><p>一些常见的证书文件类型如下：</p><p>X.509#DER 二进制格式证书，常用后缀.cer .crt</p><p>X.509#PEM 文本格式证书，常用后缀.pem</p><p>有的证书内容是只包含公钥（服务器的公钥），如.crt、.cer、.pem</p><p>有的证书既包含公钥又包含私钥（服务器的私钥），如.pfx、.p12</p><h3 id="HTTPS，TLS-SSL"><a href="#HTTPS，TLS-SSL" class="headerlink" title="HTTPS，TLS/SSL"></a>HTTPS，TLS/SSL</h3><p>Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。</p><p>使用TCP端口默认为443</p><p>TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。</p><p>SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。</p><p>SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。</p><h4 id="对称加密-1"><a href="#对称加密-1" class="headerlink" title="对称加密"></a>对称加密</h4><p>速度高，可加密内容较大，用来加密会话过程中的消息</p><h4 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h4><p>加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</p><p>​    <img src="7.png" alt="0"></p><p>image.png</p><h4 id="HTTPS单向认证"><a href="#HTTPS单向认证" class="headerlink" title="HTTPS单向认证"></a>HTTPS单向认证</h4><p>Https在建立Socket连接之前，需要进行握手，具体过程如下：</p><p>​    <img src="8.png" alt="0"></p><p>image.png</p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息;</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书;</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：</li></ol><ul><li><ul><li>证书是否过期;</li><li>发行服务器证书的CA是否可靠;(通过查询浏览器或本机内的CA证书)</li><li>返回的公钥是否能正确解开返回证书中的数字签名;（通过使用本机或浏览器内置的CA公钥进行解密）</li><li>服务器证书上的域名是否和服务器的实际域名相匹配;</li><li>验证通过后，将继续进行通信，否则，终止通信;</li></ul></li></ul><ol><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择;</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式;</li><li>服务器将选择好的加密方案通过明文方式返回给客户端;</li><li>客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器;</li><li>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥;</li></ol><p>在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全;</p><h4 id="HTTPS双向认证"><a href="#HTTPS双向认证" class="headerlink" title="HTTPS双向认证"></a>HTTPS双向认证</h4><p>双向认证和单向认证类似，它额外增加了服务端对客户端的认证：</p><p>​    <img src="9.png" alt="0"></p><p>image.png</p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息;</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书;</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：</li></ol><ul><li><ul><li>证书是否过期;</li><li>发行服务器证书的CA是否可靠;(通过查询浏览器或本机内的CA证书)</li><li>返回的公钥是否能正确解开返回证书中的数字签名;（通过使用本机或浏览器内置的CA公钥进行解密）</li><li>服务器证书上的域名是否和服务器的实际域名相匹配;</li><li>验证通过后，将继续进行通信，否则，终止通信;</li></ul></li></ul><ol><li>服务端要求客户端发送客户端的证书即客户端证书公钥，客户端会将自己的证书发送至服务端；</li><li>验证客户端的证书，通过验证后，会获得客户端的公钥；</li><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式;</li><li>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</li><li>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端；</li><li>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全；</li></ol>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 128 整数翻转</title>
      <link href="/2021/03/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-03-01-Problem-128-%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC/"/>
      <url>/2021/03/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-03-01-Problem-128-%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个32位的有符号整数x<br>返回将x中的数字部分反转后的结果<br>反转后整数超过 32 位的有符号整数的范围就返回0<br>假设环境不允许存储 64 位整数（有符号或无符号）<br>Leetcode题目：<a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-integer/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>注意，给的就是整数,可以进行翻转溢出的提前判断</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> neg = x &lt; <span class="number">0</span>;</span><br><span class="line">        x = neg ? x : -x;   <span class="comment">//溢出是两个方向的，统一变负数处理，可以换成一个方向上 </span></span><br><span class="line">        <span class="keyword">int</span> m = Integer.MIN_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> o = Integer.MIN_VALUE % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res &lt; m || res==m &amp;&amp; x%<span class="number">10</span> &lt; o)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neg ? res : Math.abs(res);  <span class="comment">//理论会有 负数没溢出，转绝对值溢出的情况，所以应该特殊处理，但这个题输入是一个整数，不会出现反转是-2147483647</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 127 两数之和</title>
      <link href="/2021/03/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-03-01-Problem-127-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2021/03/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-03-01-Problem-127-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 nums 和一个整数目标值 target<br>请你在该数组中找出 和为目标值 target  的那两个整数<br>并返回它们的数组下标<br>你可以假设每种输入只会对应一个答案<br>但是数组中同一个元素在答案里不能重复出现<br>你可以按任意顺序返回答案<br>Leetcode题目：<a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>两数之和，题目简单，写出好的代码也不好想,能不能熟练的运用数据机构来优化代码 ？</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="comment">// key 某个之前的数   value 这个数出现的位置</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(target - nums[i]), i &#125;;</span><br><span class="line">&#125;</span><br><span class="line">map.put(nums[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 126 企鹅文化衫问题</title>
      <link href="/2021/02/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-26-Problem-126-%E4%BC%81%E9%B9%85%E6%96%87%E5%8C%96%E8%A1%AB%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-26-Problem-126-%E4%BC%81%E9%B9%85%E6%96%87%E5%8C%96%E8%A1%AB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>企鹅厂活动发文化衫，文化衫有很多种，企鹅们都穿文化衫<br>采访中，企鹅会说还有多少企鹅跟他穿一种文化衫<br>有些企鹅没被采访到<br>将这些回答放在answers数组里，返回活动中企鹅的最少数量<br>Leetcode题目：<a href="https://leetcode.com/problems/rabbits-in-forest/" target="_blank" rel="noopener">https://leetcode.com/problems/rabbits-in-forest/</a></p><p>27</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 125 乐队演出问题</title>
      <link href="/2021/02/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-24-Problem-125-%E4%B9%90%E9%98%9F%E6%BC%94%E5%87%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-24-Problem-125-%E4%B9%90%E9%98%9F%E6%BC%94%E5%87%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>每一个项目都有三个数，[a,b,c]表示这个项目a和b乐队参演，花费为c<br>每一个乐队可能在多个项目里都出现了，但是只能被挑一次<br>nums是可以挑选的项目数量，所以一定会有nums<em>2只乐队被挑选出来<br>返回一共挑nums轮(也就意味着一定请到所有的乐队)，最少花费是多少<br>如果怎么都无法在nums轮请到nums</em>2只乐队且每只乐队只能被挑一次<br>返回-1<br>nums&lt;9，programs长度小于500<br>每组测试乐队的全部数量一定是nums<em>2，且标号一定是0 ~ nums</em>2-1</p><p>27</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 124 表达式添加运算符</title>
      <link href="/2021/02/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-21-Problem-124-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2021/02/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-21-Problem-124-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 : </p><p><a href="https://leetcode.com/problems/expression-add-operators/" target="_blank" rel="noopener">https://leetcode.com/problems/expression-add-operators/</a></p><p>自己可以试试普通递归，优化了计算表达式的过程</p><p>26节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 123 单词搜索II</title>
      <link href="/2021/02/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-20-Problem-123-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II/"/>
      <url>/2021/02/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-20-Problem-123-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 :<br><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/word-search-ii/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>BFS + Prefix Tree</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        Node root;</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            Node[] nodes;</span><br><span class="line">            <span class="keyword">boolean</span> isWord;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = chars[i]-<span class="string">'a'</span>;</span><br><span class="line">                cur.nodes[index] = cur.nodes[index] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node():cur.nodes[index];</span><br><span class="line">                cur = cur.nodes[index];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] path = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            prefixTree.insert(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                process(res,path,<span class="number">0</span>,i,j,prefixTree.root,board);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; res,<span class="keyword">char</span>[] path,<span class="keyword">int</span> k,<span class="keyword">int</span> i,<span class="keyword">int</span> j,PrefixTree.Node cur,<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index = board[i][j] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.nodes[index] == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">         path[k] = board[i][j];</span><br><span class="line">         board[i][j] = <span class="string">'-'</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur.nodes[index].isWord) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(path,<span class="number">0</span>,k+<span class="number">1</span>));</span><br><span class="line">            cur.nodes[index].isWord = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续以感染的方式 继续检测单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">4</span>;d++)&#123;</span><br><span class="line">            process(res,path,k+<span class="number">1</span>,i+dir_x[d],j+dir_y[d],cur.nodes[index],board);</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = path[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 122 最窄区间变形题</title>
      <link href="/2021/02/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-20-Problem-122-%E6%9C%80%E7%AA%84%E5%8C%BA%E9%97%B4%E5%8F%98%E5%BD%A2%E9%A2%98/"/>
      <url>/2021/02/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-20-Problem-122-%E6%9C%80%E7%AA%84%E5%8C%BA%E9%97%B4%E5%8F%98%E5%BD%A2%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 :<br><a href="https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/</a><br>—最窄区间变形<br>有三个有序数组，分别在三个数组中挑出3个数，x、y、z<br>返回 |x-y| + |y-z| + |z-x|最小是多少？</p><p>26</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 121 单词梯子II</title>
      <link href="/2021/02/19/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-19-Problem-121-%E5%8D%95%E8%AF%8D%E6%A2%AF%E5%AD%90II/"/>
      <url>/2021/02/19/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-19-Problem-121-%E5%8D%95%E8%AF%8D%E6%A2%AF%E5%AD%90II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 :<br><a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">https://leetcode.com/problems/gas-station/</a></p><p>26</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>同单词梯子一</li><li></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 120 单词梯子</title>
      <link href="/2021/02/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-16-Problem-120-%E5%8D%95%E8%AF%8D%E6%A2%AF%E5%AD%90/"/>
      <url>/2021/02/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-16-Problem-120-%E5%8D%95%E8%AF%8D%E6%A2%AF%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 : </p><p><a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">https://leetcode.com/problems/word-ladder/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>只要能反应过来使用图的模型，就能做，只不过要麻烦些而已。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] vToStr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String,Integer&gt; strToMap;</span><br><span class="line">    <span class="comment">//图论的好多东西还是的捡一捡的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = wordList.size()+<span class="number">1</span>;</span><br><span class="line">        vToStr = <span class="keyword">new</span> String[N];</span><br><span class="line">        strToMap =  <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        wordList.add(beginWord);</span><br><span class="line">        <span class="comment">// 处理映射</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            vToStr[i] = wordList.get(i);</span><br><span class="line">            strToMap.put(vToStr[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Integer end = strToMap.get(endWord);</span><br><span class="line">        <span class="keyword">if</span>(end == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; adjectTb = getAdjectTb();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bfs = bfs(adjectTb,N,strToMap.get(beginWord),end);</span><br><span class="line">        <span class="keyword">return</span> bfs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; getAdjectTb()&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vToStr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> String str = vToStr[i];</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; chars.length; i1++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">'a'</span>;k &lt;= <span class="string">'z'</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(chars[i1] == k)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">char</span> tmp = chars[i1];</span><br><span class="line">                    chars[i1] = k;</span><br><span class="line">                    <span class="keyword">final</span> String s = <span class="keyword">new</span> String(chars);</span><br><span class="line">                    <span class="keyword">final</span> Integer con = strToMap.get(s);</span><br><span class="line">                    <span class="keyword">if</span>(con != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        list.add(con);</span><br><span class="line">                    &#125;</span><br><span class="line">                    chars[i1] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; adjectTb ,<span class="keyword">int</span> N,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] queue = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>,rear = <span class="number">0</span>;</span><br><span class="line">        queue[rear++] = begin;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        visited[begin] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (front != rear)&#123;</span><br><span class="line">            <span class="keyword">int</span> next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; batchSize;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = queue[front++];</span><br><span class="line">                <span class="keyword">if</span>(tmp == end)</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">final</span> List&lt;Integer&gt; adjents = adjectTb.get(tmp);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adjents.size(); j++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Integer t = adjents.get(j);</span><br><span class="line">                    <span class="keyword">if</span>(!visited[t])&#123;</span><br><span class="line">                        queue[rear++] = t;</span><br><span class="line">                        visited[t] = <span class="keyword">true</span>;</span><br><span class="line">                        next_batch++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">            batchSize = next_batch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Trie </tag>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 119 加油站问题</title>
      <link href="/2021/02/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-12-Problem-119-%E5%8A%A0%E6%B2%B9%E7%AB%99%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-12-Problem-119-%E5%8A%A0%E6%B2%B9%E7%AB%99%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 : </p><p><a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">https://leetcode.com/problems/gas-station/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>加油站问题比较经典，这里还是介绍比较通俗的做法</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = cost.length;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> gas[<span class="number">0</span>]-cost[<span class="number">0</span>] &gt;= <span class="number">0</span>?<span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            cost[i] = gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; N)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; N &amp;&amp;cost[p1] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p1 &lt; N)&#123;</span><br><span class="line">                <span class="keyword">int</span> p2 = p1,preSum = cost[p1];</span><br><span class="line">                <span class="comment">//窗口增长</span></span><br><span class="line">                <span class="keyword">while</span> ((p2-p1+N)%N+<span class="number">1</span>&lt;N &amp;&amp; preSum &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    p2 = (p2+<span class="number">1</span>)%N;</span><br><span class="line">                    preSum += cost[p2];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(preSum &gt;= <span class="number">0</span> ) <span class="keyword">return</span> p1;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p2 &gt; p1) p1 = p2;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 118 最多的共线点数</title>
      <link href="/2021/02/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-10-Problem-118-%E6%9C%80%E5%A4%9A%E7%9A%84%E5%85%B1%E7%BA%BF%E7%82%B9%E6%95%B0/"/>
      <url>/2021/02/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-10-Problem-118-%E6%9C%80%E5%A4%9A%E7%9A%84%E5%85%B1%E7%BA%BF%E7%82%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 : </p><p><a href="https://leetcode.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">https://leetcode.com/problems/max-points-on-a-line/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>普通计算题，两个点计算出斜率和表达式，验证在直线上的点数，注意精度问题</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line">        <span class="keyword">int</span> N = points.length;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p1 = <span class="number">0</span>; p1 &lt; N - <span class="number">1</span>; p1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = p1 + <span class="number">1</span>; t &lt; N; t++) &#123;</span><br><span class="line">                <span class="comment">//计算斜率及直线表达式</span></span><br><span class="line">                <span class="keyword">double</span> k = points[t][<span class="number">0</span>] - points[p1][<span class="number">0</span>] == <span class="number">0</span> ? Integer.MAX_VALUE : (<span class="keyword">double</span>)(points[t][<span class="number">1</span>] - points[p1][<span class="number">1</span>]) / (points[t][<span class="number">0</span>] - points[p1][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">double</span> b = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (k != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    b = points[p1][<span class="number">1</span>] - k * points[p1][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> tmp_max = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> p2 = t + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 扫描共线点</span></span><br><span class="line">                <span class="keyword">if</span> (k == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (p2 &lt; N) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (points[p2][<span class="number">0</span>] == points[p1][<span class="number">0</span>]) &#123;</span><br><span class="line">                            tmp_max++;</span><br><span class="line">                            res = Math.max(tmp_max, res);</span><br><span class="line">                        &#125;</span><br><span class="line">                        p2++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (p2 &lt; N) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (Math.abs(points[p2][<span class="number">1</span>]-(k * points[p2][<span class="number">0</span>] + b)) &lt; eps) &#123;</span><br><span class="line">                            tmp_max++;</span><br><span class="line">                            res = Math.max(tmp_max, res);</span><br><span class="line">                        &#125;</span><br><span class="line">                        p2++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 117 三数之和问题</title>
      <link href="/2021/02/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-10-Problem-117-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-10-Problem-117-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 : </p><p><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目不难，但可以提示一个小技巧，3个数的和为0 ，如果只是直接找前两个数的组合，然后再去找第三个数，直接查找，可能会出现重复，这时候需要利用set之类数据结构对重复的额外处理，但我们可以事先排序一下，按住三数之中小的去遍历，这样相同的小的数 就可以跳过，直接去重了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> p1 = i+<span class="number">1</span>,p2 = nums.length-<span class="number">1</span>,target = <span class="number">0</span>-nums[i];</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; p2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[p1]+nums[p2] == target)&#123;</span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    tmp.add(nums[i]);</span><br><span class="line">                    tmp.add(nums[p1++]);</span><br><span class="line">                    tmp.add(nums[p2--]);</span><br><span class="line">                    list.add(tmp);</span><br><span class="line">                    <span class="keyword">while</span> (p2 &gt; p1 &amp;&amp; nums[p2] == nums[p2+<span class="number">1</span>]) p2--;</span><br><span class="line">                    <span class="keyword">while</span> (p1 &lt; p2 &amp;&amp; nums[p1] == nums[p1-<span class="number">1</span>]) p1++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[p1]+nums[p2] &lt; target)&#123;</span><br><span class="line">                    p1++;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 116 ip-to-cidr问题</title>
      <link href="/2021/02/09/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-09-Problem-116-ip-to-cidr%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/09/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-09-Problem-116-ip-to-cidr%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 : </p><p><a href="https://leetcode.com/problems/ip-to-cidr/" target="_blank" rel="noopener">https://leetcode.com/problems/ip-to-cidr/</a></p><p>26jie</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 115 移除重复字母</title>
      <link href="/2021/02/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-05-Problem-115-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/"/>
      <url>/2021/02/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-05-Problem-115-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode题目链接：</p><p><a href="https://leetcode.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicate-letters/</a></p><p>24节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 114 字符串包含问题</title>
      <link href="/2021/02/04/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-04-Problem-114-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/04/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-04-Problem-114-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个字符串str1和str2<br>在str1中寻找一个最短子串，能包含str2的所有字符<br>字符顺序无所谓，str1的这个最短子串也可以包含多余的字符<br>返回这个最短包含子串</p><p>Leetcode:  <a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-window-substring/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>滑动窗口+欠债表思想</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] tb = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>]; <span class="comment">//欠债表</span></span><br><span class="line">        <span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] p_str = t.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p_str.length; i++) &#123;</span><br><span class="line">            tb[p_str[i]]++;</span><br><span class="line">            in++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_n = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sloc = <span class="number">0</span>,eloc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;p1 &lt; str.length;p1++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p2 &lt; str.length &amp;&amp; in &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (--tb[str[p2++]] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    in--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(in == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p2 - p1 &lt; min_n)&#123;</span><br><span class="line">                    min_n = p2-p1;</span><br><span class="line">                    sloc = p1;</span><br><span class="line">                    eloc = p2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++tb[str[p1]] &gt; <span class="number">0</span>)&#123; in++; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(sloc,eloc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 113 格子染色问题</title>
      <link href="/2021/02/02/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-02-Problem-113-%E6%A0%BC%E5%AD%90%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/02/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-02-Problem-113-%E6%A0%BC%E5%AD%90%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>N * M的棋盘（N和M是输入参数）<br>每种颜色的格子数必须相同的<br>上下左右的格子算相邻<br>相邻格子染的颜色必须不同<br>所有格子必须染色<br>返回至少多少种颜色可以完成任务</p><p>24节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 112 吉祥里程码问题</title>
      <link href="/2021/02/02/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-02-Problem-112-%E5%90%89%E7%A5%A5%E9%87%8C%E7%A8%8B%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/02/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-02-Problem-112-%E5%90%89%E7%A5%A5%E9%87%8C%E7%A8%8B%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>正常的里程表会依次显示自然数表示里程<br>吉祥的里程表会忽略含有4的数字而跳到下一个完全不含有4的数<br>正常：1 2 3 4 5 6 7 8   9 10 11 12 13 14 15    X<br>吉祥：1 2 3 5 6 7 8 9 10 11 12 13 15 16 17 … 38 39 50 51 52 53 55<br>给定一个吉祥里程表的数字num(当然这个数字中不含有4)<br>返回这个数字代表的真实里程</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><code>java</code></p>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 111 第k小的数值对</title>
      <link href="/2021/01/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-31-Problem-111-%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%E5%80%BC%E5%AF%B9/"/>
      <url>/2021/01/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-31-Problem-111-%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%E5%80%BC%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>长度为N的数组arr，一定可以组成N^2个数字对<br>例如arr = [3,1,2]，数字对有(3,3) (3,1) (3,2) (1,3) (1,1) (1,2) (2,3) (2,1) (2,2)<br>也就是任意两个数都可以，而且自己和自己也算数字对<br>数字对怎么排序？<br>第一维数据从小到大；第一维数据一样的，第二维数组也从小到大<br>所以上面的数值对排序的结果为：(1,1)(1,2)(1,3)(2,1)(2,2)(2,3)(3,1)(3,2)(3,3)<br>给定一个数组arr，和整数k，返回第k小的数值对</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题挺不错。学会数数，注意有重复数数字的情况。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>方法一：O(N*log(N))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getKmin(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k)&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> N = arr.length;</span><br><span class="line"><span class="comment">//      int d = k/N,f = k % N;</span></span><br><span class="line"><span class="comment">//      int pre = f == 0 ? arr[d - 1] : (d == 0 ? arr[0] : arr[d]);</span></span><br><span class="line">        <span class="keyword">int</span> pre = arr[(k-<span class="number">1</span>)/N];</span><br><span class="line">        <span class="keyword">int</span> preNumSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lessPreNumSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N &amp;&amp; arr[i] &lt;= pre;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; pre)&#123;</span><br><span class="line">                lessPreNumSize++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                preNumSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k -= lessPreNumSize * N;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;pre, arr[(k-<span class="number">1</span>)/preNumSize]&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法二: O(N)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 110 数组切分相等部分</title>
      <link href="/2021/01/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-29-Problem-110-%E6%95%B0%E7%BB%84%E5%88%87%E5%88%86%E7%9B%B8%E7%AD%89%E9%83%A8%E5%88%86/"/>
      <url>/2021/01/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-29-Problem-110-%E6%95%B0%E7%BB%84%E5%88%87%E5%88%86%E7%9B%B8%E7%AD%89%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个正数数组arr，长度一定大于6（&gt;=7）<br>一定要选3个数字做分割点，从而分出4个部分，并且每部分都有数<br>分割点的数字直接删除，不属于任何4个部分中的任何一个。<br>返回有没有可能分出的4个部分累加和一样大<br>如：{3,2,3,7,4,4,3,1,1,6,7,1,5,2}<br>可以分成{3,2,3}、{4,4}、{1,1,6}、{1,5,2}。分割点是不算的！</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>一定从最基础的思路开始。寻找可能性的题目都离不开枚举，关键看如何去枚举。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canSplit</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sum+= arr[i];</span><br><span class="line">            map.put(sum,i);</span><br><span class="line">            set.add(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> part = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length-<span class="number">5</span>;i++)&#123;  <span class="comment">//枚举第一刀的位置 ,至少留5个元素 保证4部分</span></span><br><span class="line">            part += arr[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> cut2Sum = sum - (arr[i] + part * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(set.contains(cut2Sum))&#123;</span><br><span class="line">                <span class="keyword">int</span> cut3Sum = cut2Sum - arr[map.get(cut2Sum)] -  part;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(cut3Sum))&#123;</span><br><span class="line">                    <span class="keyword">int</span> lastPartSum = cut3Sum - arr[map.get(cut3Sum)];</span><br><span class="line">                    <span class="keyword">if</span>(lastPartSum == part)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 109 石头合并的最小代价</title>
      <link href="/2021/01/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-28-Problem-109-%E7%9F%B3%E5%A4%B4%E5%90%88%E5%B9%B6%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/"/>
      <url>/2021/01/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-28-Problem-109-%E7%9F%B3%E5%A4%B4%E5%90%88%E5%B9%B6%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/minimum-cost-to-merge-stones/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-cost-to-merge-stones/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目容易理解。比较难，枚举要求比较高。</li><li>两个优化细节<ul><li>if ((n - 1) % (K - 1) &gt; 0) { return -1; }  通过打表观察可以得出这个规律，其实比较难找，靠程序去猜规律。可以提前过滤</li><li>递归中的mid++ 可以替换成 mid+=K-1 其实就是跳过了无效解。</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeStones</span><span class="params">(<span class="keyword">int</span>[] stones, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[stones.length];</span><br><span class="line">        preSum[<span class="number">0</span>] = stones[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line">            preSum[i] = preSum[i-<span class="number">1</span>] + stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> N = stones.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][N][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process(stones,<span class="number">0</span>,stones.length-<span class="number">1</span>,<span class="number">1</span>,k,preSum,dp);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] stones,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> P,<span class="keyword">int</span> k,<span class="keyword">int</span>[] preSum,<span class="keyword">int</span>[][][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r][P] !=<span class="number">0</span> )&#123; <span class="comment">//0相当于不缓存了</span></span><br><span class="line">            <span class="keyword">return</span> dp[l][r][P];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123; <span class="comment">// arr[L..R]</span></span><br><span class="line">            <span class="keyword">return</span> P == <span class="number">1</span> ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// L ... R 不只一个数</span></span><br><span class="line">        <span class="keyword">if</span> (P == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = process(stones,l, r, k, k, preSum,dp);</span><br><span class="line">            <span class="keyword">if</span> (next == -<span class="number">1</span>) &#123;</span><br><span class="line">                dp[l][r][P] = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[l][r][P] = next + (l==<span class="number">0</span>?preSum[r]:preSum[r] - preSum[l-<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> dp[l][r][P];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> minCost = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid=l;mid &lt; r;mid++)&#123; <span class="comment">// </span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> costl = process(stones, l, mid, <span class="number">1</span>, k, preSum,dp);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> costr = process(stones, mid + <span class="number">1</span>, r, P - <span class="number">1</span>, k, preSum,dp);</span><br><span class="line">                <span class="keyword">if</span>(costl==-<span class="number">1</span> || costr==-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                minCost = Math.min(costl+costr,minCost);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[l][r][P] = minCost==Integer.MAX_VALUE?-<span class="number">1</span>:minCost;</span><br><span class="line">            <span class="keyword">return</span> dp[l][r][P];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 108 超级水王问题</title>
      <link href="/2021/01/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-24-Problem-108-%E8%B6%85%E7%BA%A7%E6%B0%B4%E7%8E%8B%E9%97%AE%E9%A2%98/"/>
      <url>/2021/01/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-24-Problem-108-%E8%B6%85%E7%BA%A7%E6%B0%B4%E7%8E%8B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>超级水王问题</p><p>扩展1：摩尔投票</p><p>扩展2：给定一个正数K，返回所有出现次数&gt;N/K的数</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>水王题目算是比较经典的题目了，题目一和题目二实际上思路是一样的</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMoreKNum</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(arr[i]) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (map.size() &lt; k-<span class="number">1</span>)&#123;</span><br><span class="line">                    map.put(arr[i],<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> Set&lt;Integer&gt; integers = map.keySet();</span><br><span class="line">                    <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(map.get(integer)==<span class="number">1</span>)&#123;</span><br><span class="line">                            map.remove(integer);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            map.put(integer,map.get(integer)-<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(map.size() &lt; k-<span class="number">1</span>)&#123;</span><br><span class="line">                        map.put(arr[i],<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Set&lt;Integer&gt; integers = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] == integer) count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!(count &gt; arr.length/k)) map.remove(integer);</span><br><span class="line">            <span class="keyword">else</span> System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        getMoreKNum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> &#125;,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 107 可整合数组</title>
      <link href="/2021/01/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-24-Problem-107-%E5%8F%AF%E6%95%B4%E5%90%88%E6%95%B0%E7%BB%84/"/>
      <url>/2021/01/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-24-Problem-107-%E5%8F%AF%E6%95%B4%E5%90%88%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>定义什么是可整合数组：<br>一个数组排完序之后，除了最左侧的数外，有arr[i] = arr[i-1]+1<br>则称这个数组为可整合数组<br>比如{5,1,2,4,3}、{6,2,3,1,5,4}都是可整合数组<br>返回arr中最长可整合子数组的长度</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><p>没有思路时，要从最暴力的办法下手 先有路走，再讨论路的好坏。</p></li><li><p>两重循环枚举子数组，判断子数组是不是满足条件的。枚举子数组，枚举开始，结尾 。再做操作。这是三重循环。但实际 O(N^2)即可。</p></li><li><p>学会重新定义题目条件。</p><ul><li><p>可整合数组 判断是不是等差数列，但是不是简单求和就可以判断的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((maxn + minn)*(R-L+<span class="number">1</span>) == sum*<span class="number">2</span>)</span><br><span class="line">    ans = Math.max(ans,R-L+<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>正确的定义确实是，1.无重复 2.最大值与最小值差值等于个数减一</p></li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLIL</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>;L &lt; arr.length;L++)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxn = arr[L];</span><br><span class="line">            <span class="keyword">int</span> minn = arr[L];</span><br><span class="line">            set.clear();</span><br><span class="line">            set.add(arr[L]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> R=L+<span class="number">1</span>;R &lt; arr.length;R++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(R))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                maxn = Math.max(maxn,arr[R]);</span><br><span class="line">                minn = Math.min(minn,arr[R]);</span><br><span class="line">                <span class="keyword">if</span>(maxn - minn == R-L)</span><br><span class="line">                    ans = Math.max(ans,R-L+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 106 数组切分的最大差值</title>
      <link href="/2021/01/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-20-Problem-106-%E6%95%B0%E7%BB%84%E5%88%87%E5%88%86%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/"/>
      <url>/2021/01/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-20-Problem-106-%E6%95%B0%E7%BB%84%E5%88%87%E5%88%86%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组arr，长度为N &gt; 1<br>从中间切一刀，保证左部分和右部分都有数字，一共有N-1种切法<br>如此多的切法中，每一种都有:<br>绝对值(左部分最大值 – 右部分最大值)<br>返回最大的绝对值是多少</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>重点还是在做辅助数组。</li><li>事先准备好右区间的最大值数组，再次遍历时，一边求出左侧的最大值，一边更新答案即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxABS</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] lArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"><span class="keyword">int</span>[] rArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">lArr[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">rArr[arr.length - <span class="number">1</span>] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">lArr[i] = Math.max(lArr[i - <span class="number">1</span>], arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">2</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">rArr[i] = Math.max(rArr[i + <span class="number">1</span>], arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">max = Math.max(max, Math.abs(lArr[i] - rArr[i + <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 105 最近公共祖先的n次查询</title>
      <link href="/2021/01/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-16-Problem-105-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E7%9A%84n%E6%AC%A1%E6%9F%A5%E8%AF%A2/"/>
      <url>/2021/01/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-16-Problem-105-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E7%9A%84n%E6%AC%A1%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定数组father大小为N，表示一共有N个节点<br>father[i] = j 表示点i的父亲是点j， father表示的树一定是一棵树而不是森林<br>queries是二维数组，大小为M*2，每一个长度为2的数组都表示一条查询<br>[4,9], 表示想查询4和9之间的最低公共祖先…<br>[3,7], 表示想查询3和7之间的最低公共祖先…<br>tree和queries里面的所有值，都一定在0~N-1之间<br>返回一个数组ans，大小为M，ans[i]表示第i条查询的答案</p><p>23节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 104 最高广告牌问题</title>
      <link href="/2021/01/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-16-Problem-104-%E6%9C%80%E9%AB%98%E5%B9%BF%E5%91%8A%E7%89%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2021/01/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-16-Problem-104-%E6%9C%80%E9%AB%98%E5%B9%BF%E5%91%8A%E7%89%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/tallest-billboard/" target="_blank" rel="noopener">https://leetcode.com/problems/tallest-billboard/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><p>题意就是挑选两个不同的子集，使得大小相同，求最大值。</p></li><li><p>难点在于，一个元素是如何确定出放进哪个集合的？当然不确定，所以要记录下所有可构成的两个集合，并且不断的缩小其差值并找到最大的那个。</p></li><li><p>代码一的这个bug 可让自己吃了一顿苦头。给自己提醒写代码时脑子要清醒。不然很容易想漏，代码一就是没有判断在构造新集合时 取较大的。再者。也可以直接使用一个map将旧值完全copy过来再操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; cur 内部数据完全和之前map一样</span><br><span class="line">cur &#x3D; new HashMap&lt;&gt;(dp); &#x2F;&#x2F; 先进行拷贝 再枚举</span><br></pre></td></tr></table></figure></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码一（bug）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tallestBillboard</span><span class="params">(<span class="keyword">int</span>[] rods)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rod : rods) &#123;</span><br><span class="line">            <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; new_map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">//map 迭代过程中不能用put方法新增 必须用迭代器</span></span><br><span class="line">            <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">                <span class="keyword">final</span> Integer minValue = map.get(key);</span><br><span class="line">                <span class="keyword">int</span> maxValue = minValue + key;</span><br><span class="line">                <span class="keyword">int</span> new_key = Math.abs((minValue + rod)-maxValue);</span><br><span class="line">                new_map.put(new_key,Math.min(minValue + rod,maxValue));</span><br><span class="line">                new_key = Math.abs((maxValue + rod)-minValue);</span><br><span class="line">                new_map.put(new_key,Math.min(maxValue + rod,minValue));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Integer key: map.keySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(new_map.get(key) == <span class="keyword">null</span> || (map.get(key) != <span class="keyword">null</span> &amp;&amp; map.get(key) &gt; new_map.get(key)))&#123;</span><br><span class="line">                    new_map.put(key,map.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map = new_map;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(<span class="number">0</span>)==<span class="keyword">null</span> ? -<span class="number">1</span> : map.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>纠正:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tallestBillboard</span><span class="params">(<span class="keyword">int</span>[] rods)</span> </span>&#123;</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> rod : rods) &#123;</span><br><span class="line">           <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; new_map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           <span class="comment">//map 迭代过程中不能用put方法新增 必须用迭代器</span></span><br><span class="line">           <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">               Integer minValue = map.get(key);</span><br><span class="line">               <span class="keyword">int</span> maxValue = minValue + key;</span><br><span class="line">               <span class="keyword">int</span> new_key = Math.abs((minValue + rod)-maxValue);</span><br><span class="line">               new_map.put(new_key,Math.max(new_map.getOrDefault(new_key,<span class="number">0</span>),Math.min(minValue + rod,maxValue)));</span><br><span class="line">               new_key = Math.abs((maxValue + rod)-minValue);</span><br><span class="line">               new_map.put(new_key,Math.max(new_map.getOrDefault(new_key,<span class="number">0</span>),Math.min(maxValue + rod,minValue)));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (Integer key: map.keySet()) &#123;</span><br><span class="line">               <span class="keyword">if</span>(new_map.get(key) == <span class="keyword">null</span> || (map.get(key) != <span class="keyword">null</span> &amp;&amp; map.get(key) &gt; new_map.get(key)))&#123;</span><br><span class="line">                   new_map.put(key,map.get(key));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           map = new_map;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> map.get(<span class="number">0</span>)==<span class="keyword">null</span> ? -<span class="number">1</span> : map.get(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 103 山峰对问题</title>
      <link href="/2021/01/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-13-Problem-103-%E5%B1%B1%E5%B3%B0%E5%AF%B9%E9%97%AE%E9%A2%98/"/>
      <url>/2021/01/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-13-Problem-103-%E5%B1%B1%E5%B3%B0%E5%AF%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度<br>比如， {3,1,2,4,5}、{4,5,3,1,2}或{1,2,4,5,3}都代表同样结构的环形山<br>山峰A和山峰B能够相互看见的条件为:<br>1.如果A和B是同一座山，认为不能相互看见<br>2.如果A和B是不同的山，并且在环中相邻，认为可以相互看见<br>3.如果A和B是不同的山，并且在环中不相邻，假设两座山高度的最小值为min。<br>       1)如果A通过顺时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互看见<br>       2)如果A通过逆时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互看见<br>两个方向只要有一个能看见，就算A和B可以相互看见<br>给定一个不含有负数且没有重复值的数组 arr，请返回有多少对山峰能够相互看见。</p><p>进阶问题<br>给定一个不含有负数但可能含有重复值的数组arr，返回有多少对山峰能够相互看见。</p><p>22节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 102 接雨水问题II</title>
      <link href="/2021/01/11/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-11-Problem-102-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98II/"/>
      <url>/2021/01/11/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-11-Problem-102-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/trapping-rain-water-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/trapping-rain-water-ii/</a></p><p>22节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 101 接雨水问题</title>
      <link href="/2021/01/07/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-07-Problem-101-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/"/>
      <url>/2021/01/07/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-07-Problem-101-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">https://leetcode.com/problems/trapping-rain-water/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>接雨水问题，这道题提醒我们可以从单个元素入手，不要急于求整体接的水量，挨个遍历看看每个柱子能接多少，求和则是整体！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        <span class="keyword">int</span> max_n = height[height.length-<span class="number">1</span>];</span><br><span class="line">        right[height.length-<span class="number">1</span>] = max_n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = height.length-<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            max_n = Math.max(height[i],max_n);</span><br><span class="line">            right[i] = max_n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        max_n = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; height.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> expect = Math.min(max_n,right[i+<span class="number">1</span>]);</span><br><span class="line">            res += expect &lt; height[i] ? <span class="number">0</span> : expect-height[i];</span><br><span class="line">            max_n = Math.max(max_n,height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 100 3个不交叉子数组最大和</title>
      <link href="/2021/01/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-05-Problem-100-3%E4%B8%AA%E4%B8%8D%E4%BA%A4%E5%8F%89%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2021/01/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-05-Problem-100-3%E4%B8%AA%E4%B8%8D%E4%BA%A4%E5%8F%89%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目难在能不能想到构造辅助数组。</li><li>看看两个代码 。代码二要更简洁，思路更清晰。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] maxSumOfThreeSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] leftEnum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">//以i开头的K个和</span></span><br><span class="line">        <span class="comment">//left[i],从0~i上,长度为k的,最大子数组,right是从i~N-1上长度为k的最大子数组</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] lrange = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] rrange = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sumK = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; k-<span class="number">1</span>) sumK += nums[i]; <span class="comment">//长度增长</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sumK += nums[i];</span><br><span class="line">                <span class="keyword">if</span>(i-<span class="number">1</span> &lt; <span class="number">0</span> || sumK &gt; left[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    left[i] = sumK;</span><br><span class="line">                    lrange[i] = i-k+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left[i] = left[i-<span class="number">1</span>];</span><br><span class="line">                    lrange[i] = lrange[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                sumK -= nums[i-k+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sumK = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; nums.length-<span class="number">1</span> -k+<span class="number">1</span>)</span><br><span class="line">                sumK += nums[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sumK +=nums[i];</span><br><span class="line">                leftEnum[i] = sumK;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span> &gt; nums.length-<span class="number">1</span> || sumK &gt;= right[i+<span class="number">1</span>])&#123;</span><br><span class="line">                   right[i] = sumK;</span><br><span class="line">                   rrange[i] = i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right[i] = right[i+<span class="number">1</span>];</span><br><span class="line">                    rrange[i] = rrange[i+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                sumK -= nums[i+k-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MIN_VALUE,a = <span class="number">0</span>,b = <span class="number">0</span>,c = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举中间k个长度数组，两边查找最大的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k;i &lt; nums.length-<span class="number">2</span>*k+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmpAns = leftEnum[i] + left[i-<span class="number">1</span>] + right[i+k];</span><br><span class="line">            <span class="keyword">if</span>(tmpAns &gt; ans)&#123;</span><br><span class="line">                a = lrange[i-<span class="number">1</span>];</span><br><span class="line">                b = i;</span><br><span class="line">                c = rrange[i+k];</span><br><span class="line">                ans = tmpAns;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b,c&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>==更优雅的代码==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] maxSumOfThreeSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line"><span class="keyword">int</span> N = nums.length;</span><br><span class="line"><span class="keyword">int</span>[] range = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">// range[i]代表 以i开始的k长度子数组和</span></span><br><span class="line"><span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[N];  <span class="comment">// left[i]代表 从0~i中最大k个长度子数组的开始位置</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line">range[<span class="number">0</span>] = sum;</span><br><span class="line">left[k - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max = sum;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; N; i++) &#123;</span><br><span class="line">sum = sum - nums[i - k] + nums[i];</span><br><span class="line">range[i - k + <span class="number">1</span>] = sum;</span><br><span class="line">left[i] = left[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (sum &gt; max) &#123;</span><br><span class="line">max = sum;</span><br><span class="line">left[i] = i - k + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= N - k; i--) &#123;</span><br><span class="line">sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line">max = sum;</span><br><span class="line"><span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[N];   <span class="comment">//right[i] 代表 i~length-1 中最大k个长度子数组开始位置</span></span><br><span class="line">right[N - k] = N - k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">sum = sum - nums[i + k] + nums[i];</span><br><span class="line">right[i] = right[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (sum &gt;= max) &#123;</span><br><span class="line">max = sum;</span><br><span class="line">right[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; N - <span class="number">2</span> * k + <span class="number">1</span>; i++) &#123; <span class="comment">// 中间一块的起始点 (0...k-1)选不了 i == N-1</span></span><br><span class="line"><span class="keyword">int</span> part1 = range[left[i - <span class="number">1</span>]];</span><br><span class="line"><span class="keyword">int</span> part2 = range[i];</span><br><span class="line"><span class="keyword">int</span> part3 = range[right[i + k]];</span><br><span class="line"><span class="keyword">if</span> (part1 + part2 + part3 &gt; max) &#123;</span><br><span class="line">max = part1 + part2 + part3;</span><br><span class="line">a = left[i - <span class="number">1</span>];</span><br><span class="line">b = i;</span><br><span class="line">c = right[i + k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; a, b, c &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 99 树链剖分问题</title>
      <link href="/2021/01/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-01-Problem-99-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E9%97%AE%E9%A2%98/"/>
      <url>/2021/01/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-01-Problem-99-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定数组father，大小为N，表示一共有N个节点<br>father[i] = j 表示点i的父亲是点j， father表示的树一定是一棵树而不是森林<br>给定数组values，大小为N，values[i]=v表示节点i的权值是v<br>实现如下4个方法，保证4个方法都很快！<br>1)让某个子树所有节点值加上v，入参：int head, int v<br>2)查询某个子树所有节点值的累加和，入参：int head<br>3)在树上从a到b的整条链上所有加上v，入参：int a, int b, int v<br>4)查询在树上从a到b的整条链上所有节点值的累加和，入参：int a, int b</p><p>21节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 98 回文子序列个数</title>
      <link href="/2020/12/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-31-Problem-98-%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/12/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-31-Problem-98-%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串str，当然可以生成很多子序列<br>返回有多少个子序列是回文子序列，空序列不算回文<br>比如，str = “aba”<br>回文子序列：{a}、{a}、 {a,a}、 {b}、{a,b,a}<br>返回5</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>定义dp[i][j]表示[i~j]内的回文子序列个数。转移方程为: </li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 97 完美洗牌问题</title>
      <link href="/2020/12/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-29-Problem-97-%E5%AE%8C%E7%BE%8E%E6%B4%97%E7%89%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-29-Problem-97-%E5%AE%8C%E7%BE%8E%E6%B4%97%E7%89%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>完美洗牌问题<br>给定一个长度为偶数的数组arr，假设长度为N*2, 左部分：arr[L1……Ln]    右部分： arr[R1……Rn]<br>请把arr调整成arr[L1,R1,L2,R2,L3,R3,…,Ln,Rn]<br>要求：时间复杂度O(N)，额外空间复杂度O(1)</p><p>20节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 96 公共因子的最大连接数量</title>
      <link href="/2020/12/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-29-Problem-96-%E5%85%AC%E5%85%B1%E5%9B%A0%E5%AD%90%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%87%8F/"/>
      <url>/2020/12/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-29-Problem-96-%E5%85%AC%E5%85%B1%E5%9B%A0%E5%AD%90%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/largest-component-size-by-common-factor/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-component-size-by-common-factor/</a></p><p>20节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>明显就是并查集，只有大于1的公共因子才进行连接，求最大集合的数目</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 95 生成后缀数组</title>
      <link href="/2020/12/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-28-Problem-95-%E7%94%9F%E6%88%90%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
      <url>/2020/12/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-28-Problem-95-%E7%94%9F%E6%88%90%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如果只给定一个二叉树前序遍历数组pre和中序遍历数组in，<br>能否不重建树，而直接生成这个二叉树的后序数组并返回<br>已知二叉树中没有重复值</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目比较简单，利用递归生成即可。注意 为了加快寻找根元素在中序数组中的位置以区分左右子树，可以 事先把元素打入map，存下元素对应的位置。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>略 </p>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 94 达标扑克方法数</title>
      <link href="/2020/12/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-24-Problem-94-%E8%BE%BE%E6%A0%87%E6%89%91%E5%85%8B%E6%96%B9%E6%B3%95%E6%95%B0/"/>
      <url>/2020/12/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-24-Problem-94-%E8%BE%BE%E6%A0%87%E6%89%91%E5%85%8B%E6%96%B9%E6%B3%95%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一张扑克有3个属性，每种属性有3种值（A、B、C）<br>比如”AAA”，第一个属性值A，第二个属性值A，第三个属性值A<br>比如”BCA”，第一个属性值B，第二个属性值C，第三个属性值A<br>给定一个字符串类型的数组cards[]，每一个字符串代表一张扑克<br>从中挑选三张扑克，一个属性达标的条件是：这个属性在三张扑克中全一样，或全不一样<br>挑选的三张扑克达标的要求是：每种属性都满足上面的条件<br>比如：”ABC”、”CBC”、”BBC”<br>第一张第一个属性为”A”、第二张第一个属性为”C”、第三张第一个属性为”B”，全不一样<br>第一张第二个属性为”B”、第二张第二个属性为”B”、第三张第二个属性为”B”，全一样<br>第一张第三个属性为”C”、第二张第三个属性为”C”、第三张第三个属性为”C”，全一样<br>每种属性都满足在三张扑克中全一样，或全不一样，所以这三张扑克达标<br>返回在cards[]中任意挑选三张扑克，达标的方法数</p><p>19节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 93 最小覆盖区间问题</title>
      <link href="/2020/12/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-23-Problem-93-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-23-Problem-93-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Problem 92 1~N中1的出现次数问题</title>
      <link href="/2020/12/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-22-Problem-92-1-N%E4%B8%AD1%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-22-Problem-92-1-N%E4%B8%AD1%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个正数N，比如N = 13，在纸上把所有数都列出来如下：<br>1 2 3 4 5 6 7 8 9 10 11 12 13<br>可以数出1这个字符出现了6次<br>给定一个正数N，如果把1~N都列出来，<br>返回1这个字符出现的多少次</p><p>19节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>也是一种数位思想，统计1出现的次数，那就按位置进行统计，统计每一位贡献出来的1</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Trie </tag>
            
            <tag> Dynacmic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 91 实现LFU</title>
      <link href="/2020/12/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-20-Problem-91-%E5%AE%9E%E7%8E%B0LFU/"/>
      <url>/2020/12/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-20-Problem-91-%E5%AE%9E%E7%8E%B0LFU/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>leetcode原题：</p><p> <a href="https://leetcode.com/problems/lfu-cache/" target="_blank" rel="noopener">https://leetcode.com/problems/lfu-cache/</a></p><p>19</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 90 实现LRU</title>
      <link href="/2020/12/17/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-17-Problem-90-%E5%AE%9E%E7%8E%B0LRU/"/>
      <url>/2020/12/17/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-17-Problem-90-%E5%AE%9E%E7%8E%B0LRU/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>leetcode原题：</p><p><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">https://leetcode.com/problems/lru-cache/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>利用链表增删改的操作是 O(1)，哈希表可用来进行判断是否存在也是O(1)，结合起来。</li><li>可以利用双向链表 实现起来比较简单。重要的是维护好head、last变量。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span></span>&#123; </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">            <span class="keyword">public</span> LinkedNode next;</span><br><span class="line">            <span class="keyword">public</span> LinkedNode pre;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">LinkedNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.key = key;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer,LinkedNode&gt; data;</span><br><span class="line">        LinkedNode head;</span><br><span class="line">        LinkedNode last;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">            data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> res = data.get(key) == <span class="keyword">null</span> ? -<span class="number">1</span> : data.get(key).value;</span><br><span class="line">            <span class="keyword">if</span>(data.get(key) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> LinkedNode node = data.get(key);</span><br><span class="line">                <span class="keyword">if</span>(head != node)&#123;</span><br><span class="line">                   evict(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//新增</span></span><br><span class="line">            <span class="keyword">if</span>(data.get(key) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count == capacity)&#123;</span><br><span class="line">                    data.remove(last.key);</span><br><span class="line">                    last = last.pre;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> LinkedNode node = <span class="keyword">new</span> LinkedNode(key, value);</span><br><span class="line">                node.key = key;</span><br><span class="line">                node.value = value;</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                    head = node;</span><br><span class="line">                    last = node;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.next = head;</span><br><span class="line">                    head.pre = node;</span><br><span class="line">                    head = node;</span><br><span class="line">                &#125;</span><br><span class="line">                data.put(key,node);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> LinkedNode node = data.get(key);</span><br><span class="line">                node.value = value;</span><br><span class="line">                <span class="keyword">if</span>(node == head)&#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                evict(node); <span class="comment">//把原节点摘下，前置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(LinkedNode node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(last == node)&#123; <span class="comment">//最后一个节点</span></span><br><span class="line">                last = last.pre;</span><br><span class="line">                last.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//普通节点</span></span><br><span class="line">                node.next.pre = node.pre;</span><br><span class="line">                node.pre.next = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head.pre = node;</span><br><span class="line">            head = node;</span><br><span class="line">            head.pre = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LRUCache lruCache = <span class="keyword">new</span> LRUCache(<span class="number">3</span>);</span><br><span class="line">        lruCache.put(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        lruCache.put(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        lruCache.put(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        lruCache.put(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">4</span>));</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">3</span>));</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">2</span>));</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">1</span>));</span><br><span class="line">        lruCache.put(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">2</span>));</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">3</span>)); </span><br><span class="line">        System.out.println(lruCache.get(<span class="number">4</span>));</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 89 两个有序数组间相加和的Topk问题 </title>
      <link href="/2020/12/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-13-Problem-89-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%97%B4%E7%9B%B8%E5%8A%A0%E5%92%8C%E7%9A%84Topk%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-13-Problem-89-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%97%B4%E7%9B%B8%E5%8A%A0%E5%92%8C%E7%9A%84Topk%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>牛客网原题：</p><p><a href="https://www.nowcoder.com/practice/7201cacf73e7495aa5f88b223bbbf6d1" target="_blank" rel="noopener">https://www.nowcoder.com/practice/7201cacf73e7495aa5f88b223bbbf6d1</a></p><p>18节 堆玩不转还是</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 88 最大路径和问题</title>
      <link href="/2020/12/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-13-Problem-88-%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-13-Problem-88-%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>牛客网原题：<br><a href="https://www.nowcoder.com/questionTerminal/8ecfe02124674e908b2aae65aad4efdf" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/8ecfe02124674e908b2aae65aad4efdf</a></p><p>18节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目的意思两条路径不能走相同的，这个题可以变通一下，变成同时走两条路，只不过走相同的位置只能获取一次，而且任意时刻，走的总格子数肯定是一样的</li><li>用递归是没问题的，但是必须优化，直接写递归可能是4个参数，开辟的缓存太大。我们发现，不管怎么走，任意时刻两个人走的总步数是一致的。可以根据这，降低一个维度。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//仔细分析之后吗，先去一次，再回来一次，等价于去了一次，在这状态上再去一次，只不是拿了之后就不能再拿了，那么，相当于两个人一块去，同时一个地方的时候，</span></span><br><span class="line">        <span class="comment">//只让一个人拿</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> M = scanner.nextInt();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = scanner.nextInt();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] ints = <span class="keyword">new</span> <span class="keyword">int</span>[M][N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                  ints[i][j] = scanner.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        final HashMap&lt;String, Integer&gt; dp = new HashMap&lt;&gt;(); hashmap依然超时</span></span><br><span class="line"><span class="comment">//        int[][][][] dp = new int[M][N][M][N]; //挂混存这个太大了，最后一个case 堆溢出了 50多M</span></span><br><span class="line">        <span class="comment">//可是直接做dp 四个变量，四个纬度，边界都搞不出来来，比较麻烦</span></span><br><span class="line">        <span class="comment">//所以还是想办法降低缓存大小,这个人的位置是二维，降成一维</span></span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[M][N][M];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N ;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; M;k++) dp[i][j][k] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(process(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ints, M, N,dp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义函数为 这两人到达右下角获取的的最大价值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> i1,<span class="keyword">int</span> j1,<span class="keyword">int</span> i2,<span class="keyword">int</span>[][] map,<span class="keyword">int</span> M,<span class="keyword">int</span> N, <span class="keyword">int</span>[][][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i1 &gt;= M || j1 &gt;= N || i2 &gt;= M || (i1+j1-i2) &gt;= N) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//越界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[i1][j1][i2] != -<span class="number">1</span>) <span class="keyword">return</span> dp[i1][j1][i2];</span><br><span class="line">        <span class="keyword">if</span>(i1 == M-<span class="number">1</span> &amp;&amp; j1 == N-<span class="number">1</span>)&#123; <span class="comment">//到达</span></span><br><span class="line">            dp[i1][j1][i2] = map[i1][j1];</span><br><span class="line">            <span class="keyword">return</span> map[i1][j1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p1 = process(i1,j1+<span class="number">1</span>,i2,map,M,N,dp);</span><br><span class="line">        <span class="keyword">int</span> p2 = process(i1,j1+<span class="number">1</span>,i2+<span class="number">1</span>,map,M,N,dp);</span><br><span class="line">        <span class="keyword">int</span> p3 = process(i1+<span class="number">1</span>,j1,i2,map,M,N,dp);</span><br><span class="line">        <span class="keyword">int</span> p4 = process(i1+<span class="number">1</span>,j1,i2+<span class="number">1</span>,map,M,N,dp);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> max = Math.max(Math.max(Math.max(p1, p2), p3), p4);</span><br><span class="line">        <span class="keyword">int</span> res = max + (i1 == i2 &amp;&amp; j1 == (i1+j1-i2) ? map[i1][j1] : map[i1][j1] + map[i2][i1+j1-i2]);</span><br><span class="line">        dp[i1][j1][i2] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 87 连接岛屿的最短桥问题</title>
      <link href="/2020/12/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-10-Problem-87-%E8%BF%9E%E6%8E%A5%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E7%9F%AD%E6%A1%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-10-Problem-87-%E8%BF%9E%E6%8E%A5%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E7%9F%AD%E6%A1%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 原题：</p><p><a href="https://leetcode.com/problems/shortest-bridge/" target="_blank" rel="noopener">https://leetcode.com/problems/shortest-bridge/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目含义比较明确，就是有两座孤立的岛屿，然后看看连接起来 需要翻转几个0，显然bfs会很简单。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dirction_x = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dirction_y = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">shortestBridge</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = grid.length;</span><br><span class="line">        <span class="comment">//从一个1开始，记录下第一个岛屿的所有点,然后从这个岛屿进行bfs遍历，第一个遇到非同组的1，表明遇到另一个岛屿了</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] group = <span class="keyword">new</span> <span class="keyword">int</span>[N*N];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j != N)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找其中一个连续的岛屿</span></span><br><span class="line">        dfs(N,i,j,group,grid);</span><br><span class="line">        <span class="comment">//对这个连续对岛屿进行bfs 广播，一直到另一个岛屿</span></span><br><span class="line">        <span class="keyword">return</span> bfs(N, group, grid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span>[] group,<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = row * N + col;</span><br><span class="line">        <span class="keyword">if</span>(!peek(N,row,col)||group[index] == <span class="number">1</span> || grid[row][col] == <span class="number">0</span>)&#123;<span class="comment">//已经访问过了,或者越界</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        group[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">            dfs(N,row+dirction_x[i],col+dirction_y[i],group,grid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span>[] group,<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] queue = <span class="keyword">new</span> <span class="keyword">int</span>[N*N+<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> map[] = <span class="keyword">new</span> <span class="keyword">int</span>[N*N]; <span class="comment">//记录岛屿到达此点的距离</span></span><br><span class="line">        <span class="keyword">int</span> visited[] = <span class="keyword">new</span> <span class="keyword">int</span>[N*N]; <span class="comment">//代表是否入过队了</span></span><br><span class="line">        <span class="keyword">int</span> front  = <span class="number">0</span>,rear = <span class="number">0</span>;<span class="comment">//rear虚指，front实指</span></span><br><span class="line">        <span class="comment">//初始化，岛屿全部元素入队,并且初始化距离为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(group[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                queue[rear++] = i;</span><br><span class="line">                map[i] = <span class="number">0</span>;</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rear != front)&#123; <span class="comment">//队列不空</span></span><br><span class="line">             <span class="keyword">int</span> index = queue[front++];</span><br><span class="line">             <span class="keyword">int</span> col = index % N;</span><br><span class="line">             <span class="keyword">int</span> row = index / N;</span><br><span class="line">             <span class="comment">//探测</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">                 <span class="keyword">int</span> row_t =  row + dirction_x[i];</span><br><span class="line">                 <span class="keyword">int</span> col_t =  col + dirction_y[i];</span><br><span class="line">                 <span class="keyword">int</span> index_t = row_t * N + col_t;</span><br><span class="line">                 <span class="keyword">if</span> (peek(N,row_t,col_t)) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(visited[index_t] == <span class="number">0</span>)&#123;</span><br><span class="line">                         <span class="keyword">if</span> (grid[row_t][col_t] == <span class="number">1</span>) &#123;</span><br><span class="line">                             <span class="keyword">return</span> map[index];</span><br><span class="line">                         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                             map[index_t] = map[index] + <span class="number">1</span>;</span><br><span class="line">                             queue[rear++] = index_t;</span><br><span class="line">                             visited[index_t] = <span class="number">1</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//true代表不越界</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">peek</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; N &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 86 汉诺塔的状态判断问题</title>
      <link href="/2020/12/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-08-Problem-86-%E6%B1%89%E8%AF%BA%E5%A1%94%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-08-Problem-86-%E6%B1%89%E8%AF%BA%E5%A1%94%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组arr，长度为N，arr中的值只有1，2，3三种<br>arr[i] == 1，代表汉诺塔问题中，从上往下第i个圆盘目前在左<br>arr[i] == 2，代表汉诺塔问题中，从上往下第i个圆盘目前在中<br>arr[i] == 3，代表汉诺塔问题中，从上往下第i个圆盘目前在右<br>那么arr整体就代表汉诺塔游戏过程中的一个状况<br>如果这个状况不是汉诺塔最优解运动过程中的状况，返回-1<br>如果这个状况是汉诺塔最优解运动过程中的状况，返回它是第几个状况</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>汉诺塔问题再熟悉不过了，这种问法感觉很不错。</li><li>首先数组中只会出现1,2,3这三种值。在汉诺塔中，如果想把第七个由左挪到右，需要先将前六个诺过去，然后直接将第7个挪到右，也就是说此时正在挪第7个的话，那么第7个之可能是在左盘子（还没挪）或者是右盘子 （刚挪完），把握住这一点，就好办了。</li><li>按照正常的汉诺塔递归过程去编写代码，在任意时刻一定时在挪某一层。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStepth</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> process = process(N - <span class="number">1</span>, arr, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> process;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[0～index] 第index+1层搬走,返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span>[] arr,<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[index] == mid) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index] == from ? <span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[index] == from)&#123;</span><br><span class="line">        <span class="keyword">return</span>  process(index-<span class="number">1</span>,arr,from,mid,to);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = process(index-<span class="number">1</span>,arr,mid,to,from);</span><br><span class="line">        <span class="keyword">if</span>(t == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;(index))+t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 85 子序列字面值问题</title>
      <link href="/2020/12/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-08-Problem-85-%E5%AD%90%E5%BA%8F%E5%88%97%E5%AD%97%E9%9D%A2%E5%80%BC%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-08-Problem-85-%E5%AD%90%E5%BA%8F%E5%88%97%E5%AD%97%E9%9D%A2%E5%80%BC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol><li>给定两个字符串S和T ，返回S的所有子序列中 有多少个子序列的字面值等于T</li><li>给定一个字符串Str 返回Str的所有子序列中有多少不同的字面值</li></ol><p>​        Leetcode原题：<a href="https://leetcode.com/problems/distinct-subsequences-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/distinct-subsequences-ii/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><p>第一问比较简单,定义dp[i][j]表示，[0~i]上子序列字面值等于t[0~j]的个数 则转移方程为<code>dp[i][j] = dp[i - 1][j] + (s[i - 1] == t[j - 1] ? dp[i - 1][j - 1] : 0);</code></p></li><li><p>第二问 可能比较难想，暴力自然不可以通过了，想的就是怎么在遍历字符过程中去除重复，认真观察，重复的子序列必然是由重复字符引起的。</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题目一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] t = T.toCharArray();</span><br><span class="line"><span class="comment">// dp[i][j] : s[0..i] T[0...j]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[i][j] : s只拿前i个字符做子序列，有多少个子序列，字面值等于T的前j个字符的前缀串</span></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length + <span class="number">1</span>][t.length + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// dp[0][0]</span></span><br><span class="line"><span class="comment">// dp[0][j] = s只拿前0个字符做子序列, T前j个字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t.length; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.length; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>] ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[s.length][t.length];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//题目二</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">distinctSubseqII</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> MOD = <span class="number">1000000000</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">if</span>( N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//字符上次出现后新增的</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(map.get(chars[i])==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    map.put(chars[i],cur);</span><br><span class="line">                    cur = (cur * <span class="number">2</span>)%MOD;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = cur;</span><br><span class="line">                    cur = ((cur *<span class="number">2</span>)%MOD-map.get(chars[i]) + MOD)%MOD;</span><br><span class="line">                    map.put(chars[i],tmp);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(cur-<span class="number">1</span>+MOD)%MOD;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 84 回文对问题</title>
      <link href="/2020/12/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-05-Problem-84-%E5%9B%9E%E6%96%87%E5%AF%B9%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-05-Problem-84-%E5%9B%9E%E6%96%87%E5%AF%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/palindrome-pairs/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-pairs/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 83 有序矩阵查第k小的数</title>
      <link href="/2020/12/03/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-03-Problem-83-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
      <url>/2020/12/03/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-03-Problem-83-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个每一行有序、每一列也有序，整体可能无序的二维数组<br>在给定一个正数k，<br>返回二维数组中，最小的第k个数</p><p>Leetcode原题：<br><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>需要利用82题的搜索过程，我们取出矩阵中的最小值和最大值，对这区间的数进行二分，每次搜索一个数，得出这个数的最小排名，从而去逼近K，最终得到答案。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> l = matrix[<span class="number">0</span>][<span class="number">0</span>],r = matrix[N-<span class="number">1</span>][N-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> real_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] res = find(matrix, mid);</span><br><span class="line">            <span class="keyword">if</span>(res[<span class="number">0</span>] == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> res[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (res[<span class="number">0</span>] &lt; k)&#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                real_num = res[<span class="number">1</span>];</span><br><span class="line">                r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> real_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] find(<span class="keyword">int</span>[][] m,<span class="keyword">double</span> num)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = m[<span class="number">0</span>].length-<span class="number">1</span>,res = <span class="number">0</span>,real_num = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; m.length &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] &lt;= num)&#123;</span><br><span class="line">                real_num =Math.max(m[i][j],real_num);</span><br><span class="line">                res += j+<span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;res,real_num&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 81 给数组打补丁问题</title>
      <link href="/2020/12/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-01-Problem-81-%E7%BB%99%E6%95%B0%E7%BB%84%E6%89%93%E8%A1%A5%E4%B8%81%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-01-Problem-81-%E7%BB%99%E6%95%B0%E7%BB%84%E6%89%93%E8%A1%A5%E4%B8%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/patching-array/" target="_blank" rel="noopener">https://leetcode.com/problems/patching-array/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>要求添加数字 使得数组内能累加到[1,n]这类题目也挺常见的，假设有[1,2，3],此时可以拿到的最小值是1，最大值是1+2+3 = 6，因为1，2，3是连续的，所以 [1,6]内的任意一个数字都可以拿到。但此时来了一个5，所以现在能拿到的最大值是6+5= 11,由于5+1 = 6，正好和之前[1,2,3]构成的数组[1~6]可以交接上，所以此时可以拿大的连续数字成了[1~11],此时再来一个7，7+1 = 8，7+11 = 18，所以又可以扩展[1~18],此时再来一个19，19+1 = 20，19+18 = 37，现在由19可以单独填充，正好扩展出[1~37]，但此时若来了39，39+1 =40，此时38就得不到了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> range = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[cur] &lt;= range+<span class="number">1</span>)&#123;</span><br><span class="line">                range += nums[cur++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res++; <span class="comment">//补range+1</span></span><br><span class="line">                range += range+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(range &gt;= n) <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (range &lt; n)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            range += range+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 82 有序矩阵值是否存在问题</title>
      <link href="/2020/12/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-01-Problem-82-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E5%80%BC%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-01-Problem-82-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E5%80%BC%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个每一行有序、每一列也有序，整体可能无序的二维数组<br>再给定一个数num，<br>返回二维数组中有没有num这个数</p><p> <a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/search-a-2d-matrix-ii/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>看到有序，先想二分。每次都能去除掉一部分元素，最终就能判定出</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length,N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = N-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (inEdge(l,r,M,N))&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[l][r] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[l][r] &gt; target)&#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">inEdge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &gt;= <span class="number">0</span> &amp;&amp; l &lt; m &amp;&amp; r &gt;= <span class="number">0</span> &amp;&amp; r &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 79 不能累加的最小正数</title>
      <link href="/2020/11/30/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-30-Problem-79-%E4%B8%8D%E8%83%BD%E7%B4%AF%E5%8A%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B0/"/>
      <url>/2020/11/30/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-30-Problem-79-%E4%B8%8D%E8%83%BD%E7%B4%AF%E5%8A%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个正数数组arr，<br>返回arr的子集不能累加出的最小正数<br>1）正常怎么做？<br>2）如果arr中肯定有1这个值，怎么做？</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这道题和前面的题目比较像， 都是要求数字连续这个特性。第二问中，如果有1，那么可以做到O(n)的复杂度。假设已经可以达到range了，下一个数字如果是range+1那是没问题的，提升range到range+1,下一个数字如果是大于range+1那么range+1就拼不出来了，为什么能确定拼不出来，要先排序！确保后面的数不会再减小，那么一定是拼不出来了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unformedSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(arr); <span class="comment">// O (N * logN)</span></span><br><span class="line"><span class="keyword">int</span> range = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// arr[0] == 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; range + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> range + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">range += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> range + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 80 挑选子集问题</title>
      <link href="/2020/11/30/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-30-Problem-80-%E6%8C%91%E9%80%89%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/30/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-30-Problem-80-%E6%8C%91%E9%80%89%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个有正、有负、有0的数组arr，<br>给定一个整数k，<br>返回arr的子集是否能累加出k<br>1）正常怎么做？<br>2）如果arr中的数值很大，但是arr的长度不大，怎么做？</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>1) 正常做法 还是递归，背包思想去凑 k就可以，但是因为有负数，所有dp数组index会出现负数，这时候就得涉及到进行偏移，保证数组index不会出现负数</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 78 约瑟夫环问题</title>
      <link href="/2020/11/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-26-Problem-78-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-26-Problem-78-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>约瑟夫环问题</p><p>给定一个链表头节点head，和一个正数m<br>从头开始，每次数到m就杀死当前节点<br>然后被杀节点的下一个节点从1开始重新数，<br>周而复始直到只剩一个节点，返回最后的节点<br>Leetcode :<br><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</a></p><p>16节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Problem 77 股票系列问题</title>
      <link href="/2020/11/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-23-Problem-77-%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-23-Problem-77-%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>15节</p><p>股票问题1：</p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p><p>股票问题2：</p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>股票问题3:</p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p><p>股票问题4：</p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/</a></p><p>股票问题5：</p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><p>股票问题6：</p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>今天来吧股票问题整一个大总结</p><ul><li>问题一：买一次，卖一次，转化问题，找左边的最小值，与当前值做差，求最大值.</li><li>问题二：相当于无限次，转化也就是找所有的增长区间段。</li><li>问题三: 可以操作两次了，最大的收益。</li><li>问题四：最大可以操作K次，最大收益。</li></ul><p>和明显，问题三和问题四实际是一问，解决四就ok，最简单的办法就是dp，dp[i][k]的含义是从0～i上完成交易不超过k次的最大利润。那么对i位置，只有两种可能性 要么参与交易，要么不参与。参与了也好说，只可能是卖出，因为是完整的交易，进行斜率优化之后，便可以得出如下代码。</p><ul><li>问题五:其实本质没变，还是那个dp模型，所以下面的代码几乎一样，只不过稍微调整下，加了一个限制。</li><li>问题五:暂放。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题一:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            min = Math.min(prices[i],min);</span><br><span class="line">            res = Math.max(res,prices[i]-min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题二:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; prices.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            res  += Math.max(<span class="number">0</span>,prices[i+<span class="number">1</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题四:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = prices.length;</span><br><span class="line">        <span class="comment">//先进行边界处理</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt;= N/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//相当于不加限制,找所有的连续增长段</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">                res += Math.max(<span class="number">0</span>,prices[i+<span class="number">1</span>]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][k+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//第i个利用第i-1个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; k+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N;i++)&#123;</span><br><span class="line">                t = Math.max(t,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">                dp[i][j] = Math.max(t+prices[i],dp[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N-<span class="number">1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题三:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//第i个利用第i-1个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; <span class="number">2</span>+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N ;i++)&#123;</span><br><span class="line">                t = Math.max(t,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">                dp[i][j] = Math.max(t+prices[i],dp[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N-<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题五:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//表示0~i上无限次交易的最大利润</span></span><br><span class="line">        <span class="keyword">if</span>(N &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(<span class="number">0</span>,prices[<span class="number">1</span>]-prices[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> t = Math.max(-prices[<span class="number">1</span>],-prices[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++)&#123;</span><br><span class="line">            t = Math.max(t,dp[i-<span class="number">2</span>]-prices[i]);</span><br><span class="line">            dp[i] = Math.max(t+prices[i],dp[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 76 第一个缺失的正数</title>
      <link href="/2020/11/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-23-Problem-76-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B0/"/>
      <url>/2020/11/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-23-Problem-76-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode原题：</p><p>​    <a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">https://leetcode.com/problems/first-missing-positive/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这类题目使用的一种我管它称作 “占位”的思想<ul><li>对于直接判定垃圾值，会占用有效空间，所以减小连续的最大值</li><li>暂时无法判定是否为垃圾值，进行归位。</li></ul></li><li>需要用L保证扫描过的是连续空间，否则无法判断当前已经连续到哪个值了</li><li>是从1开始的，用双指针可能会很简单</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">法一:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>; <span class="comment">//L,R为虚指,所谓的有效区得保证有效，关键是连续，也就是扫描过去的元素得是连续的才行,L位置必须是放L+1的值</span></span><br><span class="line">        <span class="keyword">int</span> R = nums.length-<span class="number">1</span>; <span class="comment">//R+1代表可连续增长的最大值</span></span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[L]==L+<span class="number">1</span>)&#123;</span><br><span class="line">               L++;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[L] &lt;= L||nums[L] &gt; R+<span class="number">1</span> ||nums[L] == nums[nums[L]-<span class="number">1</span>])&#123;</span><br><span class="line">               swap(nums,L,R);</span><br><span class="line">               R--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               swap(nums,L,nums[L]-<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> loc1,<span class="keyword">int</span> loc2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num[loc1];</span><br><span class="line">        num[loc1] = num[loc2];</span><br><span class="line">        num[loc2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">法二:双指针</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 75 修复BST</title>
      <link href="/2020/11/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-21-Problem-75-%E4%BF%AE%E5%A4%8DBST/"/>
      <url>/2020/11/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-21-Problem-75-%E4%BF%AE%E5%A4%8DBST/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/recover-binary-search-tree/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目中只有两个节点会出错，那么实际中序遍历 要么出现降序一次，要么两次，要是一次只需要交换降序的两个节点，要是两次 需要把第一个降序的节点和最后一个节点交换</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode[] twoErrors(TreeNode head) &#123;</span><br><span class="line">TreeNode[] ans = <span class="keyword">new</span> TreeNode[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode cur = head;</span><br><span class="line">TreeNode mostRight = <span class="keyword">null</span>;</span><br><span class="line">TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">TreeNode e1 = <span class="keyword">null</span>;</span><br><span class="line">TreeNode e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">mostRight = cur.left;</span><br><span class="line"><span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">mostRight = mostRight.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">mostRight.right = cur;</span><br><span class="line">cur = cur.left;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= cur.val) &#123;</span><br><span class="line">e1 = e1 == <span class="keyword">null</span> ? pre : e1;</span><br><span class="line">e2 = cur;</span><br><span class="line">&#125;</span><br><span class="line">pre = cur;</span><br><span class="line">cur = cur.right;</span><br><span class="line">&#125;</span><br><span class="line">ans[<span class="number">0</span>] = e1;</span><br><span class="line">ans[<span class="number">1</span>] = e2;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 73</title>
      <link href="/2020/11/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-21-Problem-73/"/>
      <url>/2020/11/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-21-Problem-73/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从二叉树的某个节点x开始，往下子节点都要的，叫子树；<br>在二叉树上只要能连起来的任何结构，叫子拓扑结构；<br>返回二叉树上满足搜索二叉树性质的、最大子拓扑结构的节点数</p><p>14节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 72 小于K的最大子数组和</title>
      <link href="/2020/11/18/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-18-Problem-72-%E5%B0%8F%E4%BA%8EK%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
      <url>/2020/11/18/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-18-Problem-72-%E5%B0%8F%E4%BA%8EK%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    请返回arr中，求子数组的累加和，是&lt;=K的并且是最大的<br>返回这个最大的累加和</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>考察的是前缀和的应用！前缀和已经多次提到了，就看你能不能灵活应用了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请返回arr中，求个子数组的累加和，是&lt;=K的，并且是最大的。</span></span><br><span class="line"><span class="comment">// 返回这个最大的累加和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxLessOrEqualK</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 记录i之前的，前缀和，按照有序表组织</span></span><br><span class="line">TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 一个数也没有的时候，就已经有一个前缀和是0了</span></span><br><span class="line">set.add(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 每一步的i，都求子数组必须以i结尾的情况下，求个子数组的累加和，是&lt;=K的，并且是最大的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">sum += arr[i]; <span class="comment">// sum -&gt; arr[0..i];</span></span><br><span class="line"><span class="keyword">if</span> (set.ceiling(sum - K) != <span class="keyword">null</span>) &#123;</span><br><span class="line">max = Math.max(max, sum - set.ceiling(sum - K));</span><br><span class="line">&#125;</span><br><span class="line">set.add(sum); <span class="comment">// 当前的前缀和加入到set中去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 71 最长的有效括号的子串</title>
      <link href="/2020/11/18/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-18-Problem-71-%E6%9C%80%E9%95%BF%E7%9A%84%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/11/18/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-18-Problem-71-%E6%9C%80%E9%95%BF%E7%9A%84%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个只由左括号和右括号的字符串<br>返回最长的有效括号子串的长度</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>分析题目，dp[i]代表以当前i位置结尾，最长的有效括号的子串长度。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s只由(和)组成</span></span><br><span class="line"><span class="comment">// 求最长有效括号子串长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="comment">// dp[i] : 子串必须以i位置结尾的情况下，往左最远能扩出多长的有效区域</span></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str.length];</span><br><span class="line"><span class="comment">// dp[0] = 0; （  ）</span></span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">')'</span>) &#123;</span><br><span class="line"><span class="comment">// 当前谁和i位置的)，去配！</span></span><br><span class="line">pre = i - dp[i - <span class="number">1</span>] - <span class="number">1</span>; <span class="comment">// 与str[i]配对的左括号的位置 pre</span></span><br><span class="line"><span class="keyword">if</span> (pre &gt;= <span class="number">0</span> &amp;&amp; str[pre] == <span class="string">'('</span>) &#123;</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span> + (pre &gt; <span class="number">0</span> ? dp[pre - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = Math.max(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 70 数组调整的逆序对问题</title>
      <link href="/2020/11/15/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-15-Problem-70-%E6%95%B0%E7%BB%84%E8%B0%83%E6%95%B4%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/15/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-15-Problem-70-%E6%95%B0%E7%BB%84%E8%B0%83%E6%95%B4%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定整数power，给定一个数组arr，给定一个数组reverse，<br>含义如下：<br>arr的长度一定是2的power次方<br>reverse中的每个值一定都在0~power范围。<br>例如power = 2, arr = {3, 1, 4, 2}，reverse = {0, 1, 0, 2}</p><p>任何一个在前的数字可以和任何一个在后的数组，构成一对数<br>可能是升序关系、相等关系或者降序关系<br>比如arr开始时有如下的降序对：(3,1)、(3,2)、(4,2)，一共3个<br>接下来根据reverse对arr进行调整：<br>reverse[0] = 0, 表示在arr中，划分每1(2的0次方)个数一组然后每个小组内部逆序，那么arr变成[3,1,4,2]，此时有3个逆序对</p><p>reverse[1] = 1, 表示在arr中，划分每2(2的1次方)个数一组，然后每个小组内部逆序，那么arr变成[1,3,2,4]，此时有1个逆序对<br>reverse[2] = 0, 表示在arr中，划分每1(2的0次方)个数一组，然后每个小组内部逆序，那么arr变成[1,3,2,4]，此时有1个逆序对<br>reverse[3] = 2, 表示在arr中，划分每4(2的2次方)个数一组，然后每个小组内部逆序，那么arr变成[4,2,3,1]，此时有4个逆序对<br>所以返回[3,1,1,4]，表示每次调整之后的逆序对数量</p><p>输入数据状况：<br>power的范围[0,20]<br>arr长度范围[1,10的7次方]<br>reverse长度范围[1,10的6次方]</p><p>16节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 69 回文对</title>
      <link href="/2020/11/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-12-Problem-69-%E5%9B%9E%E6%96%87%E5%AF%B9/"/>
      <url>/2020/11/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-12-Problem-69-%E5%9B%9E%E6%96%87%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode原题：</p><p>​    <a href="https://leetcode.com/problems/palindrome-pairs/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-pairs/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题简单思路是暴力 能做的。</li><li>提供第二种思路。我们针对每个字符串，要是能直接找出来与之配对能成为回文的，就不需要无脑的匹配再判断是不是回文了。那如果找是关键，是突破口！判断是回文的前缀，将后面逆序放前面则是回文！同理，判断是回文的后缀逆序，将前缀逆序放后面则是回文串！</li><li>同时，判断哪些前缀是回文，可以用mancher算法提前预处理得出，算是一个优化。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; palindromePairs(String[] words) &#123;</span><br><span class="line">HashMap&lt;String, Integer&gt; wordset = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">wordset.put(words[i], i);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//&#123; [6,23] 、 [7,13] &#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line"><span class="comment">// i words[i]</span></span><br><span class="line"><span class="comment">// findAll(字符串，在i位置，wordset) 返回所有生成的结果返回</span></span><br><span class="line">res.addAll(findAll(words[i], i, wordset));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; findAll(String word, <span class="keyword">int</span> index, HashMap&lt;String, Integer&gt; words) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">String reverse = reverse(word);</span><br><span class="line">Integer rest = words.get(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (rest != <span class="keyword">null</span> &amp;&amp; rest != index &amp;&amp; word.equals(reverse)) &#123;</span><br><span class="line">addRecord(res, rest, index);</span><br><span class="line">addRecord(res, index, rest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] rs = manacherss(word);</span><br><span class="line"><span class="keyword">int</span> mid = rs.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mid; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i - rs[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">rest = words.get(reverse.substring(<span class="number">0</span>, mid - i));</span><br><span class="line"><span class="keyword">if</span> (rest != <span class="keyword">null</span> &amp;&amp; rest != index) &#123;</span><br><span class="line">addRecord(res, rest, index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt; rs.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i + rs[i] == rs.length) &#123;</span><br><span class="line">rest = words.get(reverse.substring((mid &lt;&lt; <span class="number">1</span>) - i));</span><br><span class="line"><span class="keyword">if</span> (rest != <span class="keyword">null</span> &amp;&amp; rest != index) &#123;</span><br><span class="line">addRecord(res, index, rest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addRecord</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; newr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">newr.add(left);</span><br><span class="line">newr.add(right);</span><br><span class="line">res.add(newr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] manacherss(String word) &#123;</span><br><span class="line"><span class="keyword">char</span>[] mchs = manachercs(word);</span><br><span class="line"><span class="keyword">int</span>[] rs = <span class="keyword">new</span> <span class="keyword">int</span>[mchs.length];</span><br><span class="line"><span class="keyword">int</span> center = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pr = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != mchs.length; i++) &#123;</span><br><span class="line">rs[i] = pr &gt; i ? Math.min(rs[(center &lt;&lt; <span class="number">1</span>) - i], pr - i) : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i + rs[i] &lt; mchs.length &amp;&amp; i - rs[i] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mchs[i + rs[i]] != mchs[i - rs[i]]) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">rs[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + rs[i] &gt; pr) &#123;</span><br><span class="line">pr = i + rs[i];</span><br><span class="line">center = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] manachercs(String word) &#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] mchs = <span class="keyword">new</span> <span class="keyword">char</span>[chs.length * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != mchs.length; i++) &#123;</span><br><span class="line">mchs[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? <span class="string">'#'</span> : chs[index++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mchs;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r = chs.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">char</span> tmp = chs[l];</span><br><span class="line">chs[l++] = chs[r];</span><br><span class="line">chs[r--] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(chs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 68 修复BST</title>
      <link href="/2020/11/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-12-Problem-68-%E4%BF%AE%E5%A4%8DBST/"/>
      <url>/2020/11/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-12-Problem-68-%E4%BF%AE%E5%A4%8DBST/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode原题：</p><p>​    <a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/recover-binary-search-tree/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目比较简答，因为BST中序遍历是升序，任意调换两个节点，正常的影响就是把中序中这两个元素进行调换会出现两段降序。case1 还提示了 也会有情况出现一段降序。所以说最多两段降序。我们给交换回来即可。</li><li>用chi[]数组，0位置代表pre。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123; </span><br><span class="line">          TreeNode[] chs = <span class="keyword">new</span> TreeNode[<span class="number">3</span>];</span><br><span class="line">          InOrder(root,chs);</span><br><span class="line">          <span class="keyword">int</span> temp = chs[<span class="number">1</span>].val;</span><br><span class="line">          chs[<span class="number">1</span>].val = chs[<span class="number">2</span>].val;</span><br><span class="line">          chs[<span class="number">2</span>].val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(TreeNode root,TreeNode[] chs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        InOrder(root.left,chs);</span><br><span class="line">        <span class="keyword">if</span> (chs[<span class="number">0</span>] != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chs[<span class="number">0</span>].val &gt; root.val) &#123;</span><br><span class="line">                chs[<span class="number">1</span>] = chs[<span class="number">1</span>] == <span class="keyword">null</span> ? chs[<span class="number">0</span>] : chs[<span class="number">1</span>];</span><br><span class="line">                chs[<span class="number">2</span>] = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chs[<span class="number">0</span>] = root;</span><br><span class="line">        InOrder(root.right,chs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 67 打砖块</title>
      <link href="/2020/11/11/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-11-Problem-67-%E6%89%93%E7%A0%96%E5%9D%97/"/>
      <url>/2020/11/11/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-11-Problem-67-%E6%89%93%E7%A0%96%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/bricks-falling-when-hit/" target="_blank" rel="noopener">https://leetcode.com/problems/bricks-falling-when-hit/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>首先一定要熟悉并查集。此题是并查集的逆运用，思考并查集核心思想在于集合的合并。而击落砖块问的是掉落之后的个数，相当于初始情况是一个大集合，不断的击落砖块时，集合分散之后，那些无连接的集合大小。所以可以，倒过来想，从击落最后一块砖块开始，此时是分散集合，不断的把击落的往回放，则相当于集合合并了。</li><li>涉及到连接天花板，我们可以设计天花板集合、天花板元素 这种变量。通过此题我们可以学会灵活设计变量这技巧。</li><li>小技巧:<code>cellSet[parent1]^cellSet[parent2]</code>判断是否相同</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> parent[];</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> cellSize;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> cellSet[];</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> size[];</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] grid;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> M,N;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            M = grid.length;</span><br><span class="line">            N = grid[<span class="number">0</span>].length;</span><br><span class="line">            <span class="keyword">this</span>.grid = grid;</span><br><span class="line">            size = <span class="keyword">new</span> <span class="keyword">int</span>[M*N];</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[M*N];</span><br><span class="line">            cellSet = <span class="keyword">new</span> <span class="keyword">boolean</span>[M*N];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> index = i*N+j;</span><br><span class="line">                    <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                        parent[index] = index;</span><br><span class="line">                        size[index] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                            cellSet[index] = <span class="keyword">true</span>;</span><br><span class="line">                            cellSize++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            initConnnet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initConnnet</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123; <span class="comment">//直接上下左右的去连，边界处理，交给下游</span></span><br><span class="line">                    union(i,j,i-<span class="number">1</span>,j);</span><br><span class="line">                    union(i,j,i+<span class="number">1</span>,j);</span><br><span class="line">                    union(i,j,i,j-<span class="number">1</span>);</span><br><span class="line">                    union(i,j,i,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> par = parent[index];</span><br><span class="line">            <span class="keyword">while</span> (par != parent[par])&#123;</span><br><span class="line">                par = parent[par];</span><br><span class="line">            &#125;</span><br><span class="line">            parent[index] = par;</span><br><span class="line">            <span class="keyword">return</span> par;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> r1,<span class="keyword">int</span> c1,<span class="keyword">int</span> r2,<span class="keyword">int</span> c2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(validLoc(r1,c1) &amp;&amp; validLoc(r2,c2))&#123;</span><br><span class="line">                <span class="keyword">int</span> loc1 = r1*N+c1;</span><br><span class="line">                <span class="keyword">int</span> loc2 = r2*N+c2;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> parent1 = find(loc1);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> parent2 = find(loc2);</span><br><span class="line">                <span class="keyword">if</span>(parent1 != parent2)&#123;</span><br><span class="line">                    parent[parent1] = parent2;</span><br><span class="line">                    <span class="keyword">if</span>(cellSet[parent1]^cellSet[parent2])&#123;</span><br><span class="line">                        cellSize += cellSet[parent1] ? size[parent2]:size[parent1];</span><br><span class="line">                        cellSet[parent2] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    size[parent2] += size[parent1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validLoc</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; M &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; N &amp;&amp; grid[r][c] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">            grid[r][c] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = r*N+c;</span><br><span class="line">            parent[cur] = cur;</span><br><span class="line">            size[cur] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> pre = cellSize;</span><br><span class="line">            <span class="keyword">if</span>(r == <span class="number">0</span>)&#123; <span class="comment">// 该恢复恢复，0行的肯定是天花板的元素,所以要是打的这里，本身就要先加入到天花板集合里</span></span><br><span class="line">                cellSize++;</span><br><span class="line">                cellSet[cur] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            union(r,c,r-<span class="number">1</span>,c);</span><br><span class="line">            union(r,c,r+<span class="number">1</span>,c);</span><br><span class="line">            union(r,c,r,c-<span class="number">1</span>);</span><br><span class="line">            union(r,c,r,c+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> now = cellSize;</span><br><span class="line">            <span class="keyword">return</span> now == pre ? <span class="number">0</span> : now-pre-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] hitBricks(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span>[][] hits) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[hits.length];</span><br><span class="line">        <span class="keyword">int</span> n = hits.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; hits.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[hits[i][<span class="number">0</span>]][hits[i][<span class="number">1</span>]] == <span class="number">1</span>)&#123;</span><br><span class="line">                grid[hits[i][<span class="number">0</span>]][hits[i][<span class="number">1</span>]] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> UnionFind uf = <span class="keyword">new</span> UnionFind(grid);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hits.length-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[hits[i][<span class="number">0</span>]][hits[i][<span class="number">1</span>]] == <span class="number">2</span>)&#123;</span><br><span class="line">                ans[i] =  uf.connect(hits[i][<span class="number">0</span>],hits[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] ints = hitBricks(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">1</span>&#125;&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">4</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;&#125;);</span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 66. 扰乱字符串</title>
      <link href="/2020/11/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-08-Problem-66-%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/11/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-08-Problem-66-%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode原题：</p><p><a href="https://leetcode.com/problems/scramble-string/" target="_blank" rel="noopener">https://leetcode.com/problems/scramble-string/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>思路比较直接，更加考察编程能力，包括这些位置的推断。以及递归的设计</li><li>普通递归，不去优化会卡在最后连个case上，加上缓存就可以顺利通过。主要是能快速写出来程序，所以没有进一步优化，也可以进一步写成数组严格递归的形式，甚至用斜率优化</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars2 = s2.toCharArray();</span><br><span class="line">        <span class="keyword">if</span> (s1.length() != s2.length()) <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//        return process(chars1,0,chars2,0,s1.length());</span></span><br><span class="line">        <span class="keyword">int</span>[][][]dp = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length()][s1.length()][s1.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process1(chars1,<span class="number">0</span>,chars2,<span class="number">0</span>,s1.length(),dp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] s1, <span class="keyword">int</span> l1, <span class="keyword">char</span>[] s2, <span class="keyword">int</span> l2, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">1</span>) <span class="keyword">return</span> s1[l1] == s2[l2];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> leftOffset = <span class="number">0</span>;leftOffset &lt; size-<span class="number">1</span>;leftOffset++)&#123; <span class="comment">//枚举交换点</span></span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            <span class="keyword">if</span> (isSameType(s1,l1,l1+leftOffset,s2,l2,l2+leftOffset) &amp;&amp; isSameType(s1,l1+leftOffset+<span class="number">1</span>,l1+size-<span class="number">1</span>,s2,l2+leftOffset+<span class="number">1</span>,l2+size-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(process(s1,l1,s2,l2,leftOffset+<span class="number">1</span>) &amp;&amp; process(s1,l1+leftOffset+<span class="number">1</span>,s2,l2+leftOffset+<span class="number">1</span>,size-leftOffset-<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSameType(s1,l1,l1+leftOffset,s2,l2+size-<span class="number">1</span>-leftOffset,l2+size-<span class="number">1</span>) &amp;&amp; isSameType(s1,l1+leftOffset+<span class="number">1</span>,l1+size-<span class="number">1</span>,s2,l2,l2+size-<span class="number">1</span>-leftOffset-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span> (process(s1,l1,s2,l2+size-<span class="number">1</span>-leftOffset,leftOffset+<span class="number">1</span>) &amp;&amp; process(s1,l1+leftOffset+<span class="number">1</span>,s2,l2,size-leftOffset-<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process1</span><span class="params">(<span class="keyword">char</span>[] s1, <span class="keyword">int</span> l1, <span class="keyword">char</span>[] s2, <span class="keyword">int</span> l2, <span class="keyword">int</span> size,<span class="keyword">int</span>[][][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[l1][l2][size]!=<span class="number">0</span>) <span class="keyword">return</span> dp[l1][l2][size]==<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">1</span>) <span class="keyword">return</span> s1[l1] == s2[l2];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> leftOffset = <span class="number">0</span>;leftOffset &lt; size-<span class="number">1</span>;leftOffset++)&#123; <span class="comment">//枚举交换点</span></span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            <span class="keyword">if</span> (isSameType(s1,l1,l1+leftOffset,s2,l2,l2+leftOffset) &amp;&amp; isSameType(s1,l1+leftOffset+<span class="number">1</span>,l1+size-<span class="number">1</span>,s2,l2+leftOffset+<span class="number">1</span>,l2+size-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(process1(s1,l1,s2,l2,leftOffset+<span class="number">1</span>,dp) &amp;&amp; process1(s1,l1+leftOffset+<span class="number">1</span>,s2,l2+leftOffset+<span class="number">1</span>,size-leftOffset-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                    dp[l1][l2][size] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSameType(s1,l1,l1+leftOffset,s2,l2+size-<span class="number">1</span>-leftOffset,l2+size-<span class="number">1</span>) &amp;&amp; isSameType(s1,l1+leftOffset+<span class="number">1</span>,l1+size-<span class="number">1</span>,s2,l2,l2+size-<span class="number">1</span>-leftOffset-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span> (process1(s1,l1,s2,l2+size-<span class="number">1</span>-leftOffset,leftOffset+<span class="number">1</span>,dp) &amp;&amp; process1(s1,l1+leftOffset+<span class="number">1</span>,s2,l2,size-leftOffset-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                    dp[l1][l2][size] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l1][l2][size] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">isSameType</span><span class="params">(<span class="keyword">char</span>[] s1,<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,<span class="keyword">char</span>[] s2,<span class="keyword">int</span> l2,<span class="keyword">int</span> r2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]  map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l1; i &lt;= r1 ; i++) &#123;</span><br><span class="line">            map[s1[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l2;i &lt;= r2;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--map[s2[i]] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 65 超级洗衣机</title>
      <link href="/2020/11/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-08-Problem-65-%E8%B6%85%E7%BA%A7%E6%B4%97%E8%A1%A3%E6%9C%BA/"/>
      <url>/2020/11/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-08-Problem-65-%E8%B6%85%E7%BA%A7%E6%B4%97%E8%A1%A3%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>  Leetcode原题：<br>  <a href="https://leetcode.com/problems/super-washing-machines/" target="_blank" rel="noopener">https://leetcode.com/problems/super-washing-machines/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>考察单点瓶颈问题。诸如此类的还有接雨水问题等 都是考察 ”最短处“，整个问题的解决在于“痛点”。洗衣机每个都可以一次扔一件衣服，因为可以并发进行。那么只要找到需要扔到最多的，问题就解决了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinMoves</span><span class="params">(<span class="keyword">int</span>[] machines)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; machines.length;i++)&#123;</span><br><span class="line">           sum += machines[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % machines.length !=<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> avg = sum / machines.length;</span><br><span class="line">        <span class="keyword">int</span> leftSum = <span class="number">0</span>,ans = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; machines.length;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> leftRest = leftSum - i*avg;</span><br><span class="line">           <span class="keyword">int</span> rightRest = (sum - leftSum - machines[i]) - (machines.length-<span class="number">1</span>-i) * avg;</span><br><span class="line">           <span class="keyword">if</span>(leftRest &lt; <span class="number">0</span> &amp;&amp; rightRest &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               ans = Math.max(ans,Math.abs(leftRest) + Math.abs(rightRest));</span><br><span class="line">           &#125;<span class="keyword">else</span></span><br><span class="line">               ans = Math.max(ans,Math.max(Math.abs(leftRest),Math.abs(rightRest)));</span><br><span class="line">           leftSum += machines[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 64 谷歌抽牌问题</title>
      <link href="/2020/11/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-05-Problem-64-%E8%B0%B7%E6%AD%8C%E6%8A%BD%E7%89%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-05-Problem-64-%E8%B0%B7%E6%AD%8C%E6%8A%BD%E7%89%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    谷歌面试题扩展版<br>面值为1~N的牌组成一组，<br>每次你从组里等概率的抽出1~N中的一张<br>下次抽会换一个新的组，有无限组<br>当累加和<a时，你将一直抽牌当累加和>=a且<b时，你将获胜当累加和>=b时，你将失败<br>返回获胜的概率，给定的参数为N，a，b</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>可能一上来不知道如何下手，这种就想先定义递归含义。依据定义的含义在去写递归体，最后想递归边界，以及优化点。</li><li>这个题想到大概思路之后，还要注意优化，关键在于(a,b)之间的距离</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">1</span> || a &gt;= b || a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b - a &gt;= N) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所有参数都合法，并且b-a &lt; N</span></span><br><span class="line"><span class="keyword">return</span> p(<span class="number">0</span>, N, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏规则，如上，int N, int a, int b，固定参数！</span></span><br><span class="line"><span class="comment">// cur，目前到达了cur的累加和</span></span><br><span class="line"><span class="comment">// 返回赢的概率</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> N, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cur &gt;= a &amp;&amp; cur &lt; b) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur &gt;= b) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> w = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">w += p(cur + i, N, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> w / N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 63</title>
      <link href="/2020/11/04/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-04-Problem-63/"/>
      <url>/2020/11/04/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-04-Problem-63/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>好题。考察递归，重点思考后面元素是*或者.，需要对这种特殊清楚进行分析可能性。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][p.length()];</span><br><span class="line">        <span class="keyword">return</span> process2(s.toCharArray(),<span class="number">0</span>,p.toCharArray(),<span class="number">0</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> i,<span class="keyword">char</span>[] exp,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j==exp.length) <span class="keyword">return</span> i ==str.length;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span> != exp.length &amp;&amp; exp[j+<span class="number">1</span>] != <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i != str.length &amp;&amp; (str[i]==exp[j] || exp[j]==<span class="string">'.'</span>) &amp;&amp; process(str,i+<span class="number">1</span>,exp,j+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> == exp.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span> == str.length &amp;&amp; (str[i]==exp[j] || exp[j]==<span class="string">'.'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> c = i;</span><br><span class="line">                <span class="keyword">while</span> (c &lt; str.length &amp;&amp; (str[c]==exp[j]||exp[j]==<span class="string">'.'</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (process(str,c+<span class="number">1</span>,exp,j+<span class="number">2</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    c++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  process(str,i,exp,j+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process2</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> i,<span class="keyword">char</span>[] exp,<span class="keyword">int</span> j,<span class="keyword">boolean</span>[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j == exp.length) &#123;</span><br><span class="line">            dp[i][j] = i == str.length;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> != exp.length &amp;&amp; exp[j + <span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">            dp[i][j] = i != str.length &amp;&amp; (str[i] == exp[j] || exp[j] == <span class="string">'.'</span>) &amp;&amp; process(str, i + <span class="number">1</span>, exp, j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> == exp.length) &#123;</span><br><span class="line">                dp[i][j] = i + <span class="number">1</span> == str.length &amp;&amp; (str[i] == exp[j] || exp[j] == <span class="string">'.'</span>);</span><br><span class="line">                <span class="keyword">return</span> dp[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> c = i;</span><br><span class="line">                <span class="keyword">while</span> (c &lt; str.length &amp;&amp; (str[c] == exp[j] || exp[j] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (process(str, c + <span class="number">1</span>, exp, j + <span class="number">2</span>)) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    c++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = process(str, i, exp, j + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--进行斜率优化，优化掉循环</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process2(s.toCharArray(),<span class="number">0</span>,p.toCharArray(),<span class="number">0</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> i,<span class="keyword">char</span>[] exp,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j==exp.length) <span class="keyword">return</span> i ==str.length;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span> != exp.length &amp;&amp; exp[j+<span class="number">1</span>] != <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i != str.length &amp;&amp; (str[i]==exp[j] || exp[j]==<span class="string">'.'</span>) &amp;&amp; process(str,i+<span class="number">1</span>,exp,j+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> == exp.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span> == str.length &amp;&amp; (str[i]==exp[j] || exp[j]==<span class="string">'.'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> c = i;</span><br><span class="line">                <span class="keyword">while</span> (c &lt; str.length &amp;&amp; (str[c]==exp[j]||exp[j]==<span class="string">'.'</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (process(str,c+<span class="number">1</span>,exp,j+<span class="number">2</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    c++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  process(str,i,exp,j+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process2</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> i,<span class="keyword">char</span>[] exp,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>) <span class="keyword">return</span> dp[i][j]==<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == exp.length) &#123;</span><br><span class="line">           res = i == str.length;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> != exp.length &amp;&amp; exp[j + <span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != str.length &amp;&amp; (str[i] == exp[j] || exp[j] == <span class="string">'.'</span>) &amp;&amp; process2(str, i + <span class="number">1</span>, exp, j + <span class="number">1</span>,dp))&#123;</span><br><span class="line">                    res = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> == exp.length) &#123;</span><br><span class="line">                    res =  i + <span class="number">1</span> == str.length &amp;&amp; (str[i] == exp[j] || exp[j] == <span class="string">'.'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">                        res = process2(str, i, exp, j + <span class="number">2</span>,dp);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(str[i] != exp[j] &amp;&amp; exp[j] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                            res =  process2(str, i, exp, j + <span class="number">2</span>,dp);</span><br><span class="line">                        &#125;<span class="keyword">else</span></span><br><span class="line">                            res = process2(str, i, exp, j + <span class="number">2</span>,dp) || process2(str, i+<span class="number">1</span>, exp, j,dp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = res?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 62 最长连续序列</title>
      <link href="/2020/11/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-01-Problem-62-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
      <url>/2020/11/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-01-Problem-62-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-consecutive-sequence/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>和之前的播放流题目类似，用头表，尾表的思想实现，只不过这个题是用map，不是基于链表的</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>)<span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, Integer&gt; head = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, Integer&gt; tail = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(head.containsKey(nums[i]) || tail.containsKey(nums[i]))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                head.put(nums[i],<span class="number">1</span>);</span><br><span class="line">                tail.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//和前面连一块</span></span><br><span class="line">            <span class="keyword">if</span> (tail.containsKey(nums[i] - <span class="number">1</span>)) &#123;</span><br><span class="line">                head.remove(nums[i]);</span><br><span class="line">                <span class="keyword">final</span> Integer preLen = tail.get(nums[i] - <span class="number">1</span>);</span><br><span class="line">                head.put(nums[i] - preLen, head.get(nums[i] - preLen) + <span class="number">1</span>);</span><br><span class="line">                tail.put(nums[i], preLen + <span class="number">1</span>);</span><br><span class="line">                res = Math.max(res,preLen+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//和后面连上，注意同时更新前面的连续序列</span></span><br><span class="line">            <span class="keyword">if</span> (head.containsKey(nums[i] + <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Integer posLen = head.get(nums[i] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">final</span> Integer preLen = tail.get(nums[i]);</span><br><span class="line">                head.put(nums[i]-preLen+<span class="number">1</span>,preLen+posLen);</span><br><span class="line">                tail.put(nums[i]+posLen,preLen+posLen);</span><br><span class="line">                res = Math.max(res,preLen+posLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 61 两个有序数整体K小</title>
      <link href="/2020/10/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-31-Problem-61-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E6%95%B4%E4%BD%93K%E5%B0%8F/"/>
      <url>/2020/10/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-31-Problem-61-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E6%95%B4%E4%BD%93K%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode.com/problems/median-of-two-sorted-arrays/</a><br>进阶问题：<br>在两个都有序的数组中找整体第K小的数<br>可以做到O(log(Min(M,N)))</p><p>12节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 60 查找种类及个数相同的子串</title>
      <link href="/2020/10/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-28-Problem-60-%E6%9F%A5%E6%89%BE%E7%A7%8D%E7%B1%BB%E5%8F%8A%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/10/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-28-Problem-60-%E6%9F%A5%E6%89%BE%E7%A7%8D%E7%B1%BB%E5%8F%8A%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定长度为m的字符串aim，以及一个长度为n的字符串str<br>问能否在str中找到一个长度为m的连续子串，<br>使得这个子串刚好由aim的m个字符组成，顺序无所谓，<br>返回任意满足条件的一个子串的起始位置，未找到返回-1</p><p>Leetcode:567</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目比较简单 使用滑动窗口+字符表映射就可以解决</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">containExactly</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span> || s1.length() &lt; s2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> M = str2.length;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            count[str2[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> all = M;</span><br><span class="line">        <span class="keyword">char</span>[] str1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0~M-1</span></span><br><span class="line">        <span class="keyword">for</span> (; R &lt; M; R++) &#123; <span class="comment">// 最早的M个字符，让其窗口初步形成</span></span><br><span class="line">            <span class="keyword">if</span> (count[str1[R]]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                all--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 窗口初步形成了，并没有判断有效无效，决定下一个位置一上来判断</span></span><br><span class="line">        <span class="comment">// 接下来的过程，窗口右进一个，左吐一个</span></span><br><span class="line">        <span class="keyword">for</span> (; R &lt; str1.length; R++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (all == <span class="number">0</span>) &#123; <span class="comment">// R-1</span></span><br><span class="line">                <span class="keyword">return</span> R - M;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count[str1[R]]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                all--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count[str1[R - M]]++ &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                all++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> all == <span class="number">0</span> ? R - M : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 59 切分回文串的最少刀数</title>
      <link href="/2020/10/27/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-27-Problem-59-%E5%88%87%E5%88%86%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%80%E6%95%B0/"/>
      <url>/2020/10/27/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-27-Problem-59-%E5%88%87%E5%88%86%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%80%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    问题一：一个字符串至少要切几刀能让切出来的子串都是回文串</p><p>问题二：返回问题一的其中一种划分结果</p><p>问题三：返回问题一的所有划分结果</p><p>11jie</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 58 整体回文串的所有添加结果</title>
      <link href="/2020/10/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-24-Problem-58-%E6%95%B4%E4%BD%93%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%89%80%E6%9C%89%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%9C/"/>
      <url>/2020/10/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-24-Problem-58-%E6%95%B4%E4%BD%93%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%89%80%E6%9C%89%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>问题一：一个字符串至少需要添加多少个字符能整体变成回文串</p><p><a href="https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/</a></p><p>问题二：返回问题一的其中一种添加结果</p><p>问题三：返回问题一的所有添加结果</p><p>11节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目原型比较简单，普通的dp 行列模型。主要是通过此题目 总结一下通过dp矩阵查找答案的方法。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>问题一:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> N = chars.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = chars[i]==chars[i+<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">3</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">2</span>;j &lt; N;j++)&#123;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i+<span class="number">1</span>][j]+<span class="number">1</span>),dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + (chars[i]==chars[j] ?<span class="number">0</span>:<span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][N-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题二 :</p><p>其实可能性的划分，第三种可视为只有当chars[i] == chars[j]的时候 才会可能去取dp[i+1][j-1]的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题第二问，返回其中一种结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minInsertionsOneWay</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> N = str.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[i][i + <span class="number">1</span>] = str[i] == str[i + <span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; N; j++) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (str[i] == str[j]) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R = N - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span>[] ans = <span class="keyword">new</span> <span class="keyword">char</span>[N + dp[L][R]];</span><br><span class="line"><span class="keyword">int</span> ansl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ansr = ans.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[L][R - <span class="number">1</span>] == dp[L][R] - <span class="number">1</span>) &#123;</span><br><span class="line">ans[ansl++] = str[R];</span><br><span class="line">ans[ansr--] = str[R--];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[L + <span class="number">1</span>][R] == dp[L][R] - <span class="number">1</span>) &#123;</span><br><span class="line">ans[ansl++] = str[L];</span><br><span class="line">ans[ansr--] = str[L++];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans[ansl++] = str[L++];</span><br><span class="line">ans[ansr--] = str[R--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">ans[ansl] = str[L];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题三:</p><p>问题三，完全成了深度优先遍历。走dp去枚举所有可能性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题第三问，返回所有可能的结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">minInsertionsAllWays</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">ans.add(s);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> N = str.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[i][i + <span class="number">1</span>] = str[i] == str[i + <span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; N; j++) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (str[i] == str[j]) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> M = N + dp[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span>[] path = <span class="keyword">new</span> <span class="keyword">char</span>[M];</span><br><span class="line">process(str, dp, <span class="number">0</span>, N - <span class="number">1</span>, path, <span class="number">0</span>, M - <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前来到的动态规划中的格子，(L,R)</span></span><br><span class="line"><span class="comment">// path ....  [pl....pr] ....</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span>[][] dp, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">char</span>[] path, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr, List&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt;= R) &#123; <span class="comment">// L &gt; R  L==R</span></span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">path[pl] = str[L];</span><br><span class="line">&#125;</span><br><span class="line">ans.add(String.valueOf(path));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[L][R - <span class="number">1</span>] == dp[L][R] - <span class="number">1</span>) &#123;</span><br><span class="line">path[pl] = str[R];</span><br><span class="line">path[pr] = str[R];</span><br><span class="line">process(str, dp, L, R - <span class="number">1</span>, path, pl + <span class="number">1</span>, pr - <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dp[L + <span class="number">1</span>][R] == dp[L][R] - <span class="number">1</span>) &#123;</span><br><span class="line">path[pl] = str[L];</span><br><span class="line">path[pr] = str[L];</span><br><span class="line">process(str, dp, L + <span class="number">1</span>, R, path, pl + <span class="number">1</span>, pr - <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str[L] == str[R] &amp;&amp; (L == R - <span class="number">1</span> || dp[L + <span class="number">1</span>][R - <span class="number">1</span>] == dp[L][R])) &#123;</span><br><span class="line">path[pl] = str[L];</span><br><span class="line">path[pr] = str[R];</span><br><span class="line">process(str, dp, L + <span class="number">1</span>, R - <span class="number">1</span>, path, pl + <span class="number">1</span>, pr - <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 57 布尔运算</title>
      <link href="/2020/10/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-23-Problem-57-%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97/"/>
      <url>/2020/10/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-23-Problem-57-%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode-cn.com/problems/boolean-evaluation-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/boolean-evaluation-lcci/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题也是很类似的思想，比如讲，求最大子数组和？不管哪个子数组和最大，子数组一定是以某个元素结尾，所以我们找以当前元素为结尾的最大子数组，最终找到答案。此题求的是加括号的方法数，首先每个运算符号一定都会生效。通过加括号使得答案最终为1，那么一定是最后那个运算符起了决定作用得到1。所以我们遍历当前符号，看它左边有多少种为0位1的方案，右面有多少种，分别递归得到，得到之后，我们通过运算算出 当前符号最后生效时的方案数，全部累加即可得到。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> zeroCount;</span><br><span class="line">        <span class="keyword">int</span> OneCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(<span class="keyword">int</span> zeroCount, <span class="keyword">int</span> OneCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.zeroCount = zeroCount;</span><br><span class="line">            <span class="keyword">this</span>.OneCount = OneCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">countEval</span><span class="params">(String s, <span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Result[][] dp = <span class="keyword">new</span> Result[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">final</span> Result res = process(s.toCharArray(), <span class="number">0</span>, s.length() - <span class="number">1</span>,dp);</span><br><span class="line">        <span class="keyword">return</span> result == <span class="number">0</span>?res.zeroCount : res.OneCount;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【s，e】一定是两个字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] arr,<span class="keyword">int</span> s,<span class="keyword">int</span> e,Result[][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == e)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = arr[s]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(cnt^<span class="number">1</span>,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[s][e]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[s][e];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> zeroCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oneCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s+<span class="number">1</span>;i &lt; e;i +=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//以i字符划分</span></span><br><span class="line">            <span class="keyword">final</span> Result left = process(arr, s, i - <span class="number">1</span>,dp);</span><br><span class="line">            <span class="keyword">final</span> Result right = process(arr, i + <span class="number">1</span>, e,dp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (arr[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&amp;'</span>:&#123;</span><br><span class="line">                    oneCount += left.OneCount * right.OneCount;</span><br><span class="line">                    zeroCount += left.zeroCount * right.OneCount + left.zeroCount * right.zeroCount + left.OneCount * right.zeroCount;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'|'</span>:&#123;</span><br><span class="line">                    oneCount += left.OneCount* right.OneCount + left.zeroCount * right.OneCount + left.OneCount * right.zeroCount;</span><br><span class="line">                    zeroCount += left.zeroCount * right.zeroCount;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'^'</span>:&#123;</span><br><span class="line">                    oneCount += left.OneCount * right.zeroCount + left.zeroCount * right.OneCount;</span><br><span class="line">                    zeroCount += left.zeroCount * right.zeroCount + left.OneCount * right.OneCount;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[s][e] = <span class="keyword">new</span> Result(zeroCount,oneCount);</span><br><span class="line">        <span class="keyword">return</span> dp[s][e];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 55 K个逆序对数组</title>
      <link href="/2020/10/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-22-Problem-55-K%E4%B8%AA%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E7%BB%84/"/>
      <url>/2020/10/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-22-Problem-55-K%E4%B8%AA%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/k-inverse-pairs-array/" target="_blank" rel="noopener">https://leetcode.com/problems/k-inverse-pairs-array/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这道题目是一道很不错的dp题目，这道题目如果去写几个例子，很容易发现特点，做好空间优化。</li><li>结果要取模运算的时候，任何一处加法减法都要加模再去取模，一个时防止溢出，一个是防止计算出现负数。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kInversePairs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; i)&#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j])%MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = ((dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j])%MOD - dp[i-<span class="number">1</span>][j-i]+MOD)%MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 56 BST转有序双向列表</title>
      <link href="/2020/10/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-22-Problem-56-BST%E8%BD%AC%E6%9C%89%E5%BA%8F%E5%8F%8C%E5%90%91%E5%88%97%E8%A1%A8/"/>
      <url>/2020/10/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-22-Problem-56-BST%E8%BD%AC%E6%9C%89%E5%BA%8F%E5%8F%8C%E5%90%91%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode原题：</p><p>​    给定一棵搜索二叉树头节点，转化成首尾相接的有序双向链表</p><p><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目不难，就是麻烦点，用树的递归遍历就可以搞定。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>​    略</p>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 54</title>
      <link href="/2020/10/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-20-Problem-54/"/>
      <url>/2020/10/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-20-Problem-54/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Lintcode原题：</p><p><a href="https://www.lintcode.com/problem/top-k-frequent-words-ii/" target="_blank" rel="noopener">https://www.lintcode.com/problem/top-k-frequent-words-ii/</a></p><p>第10节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 53 跳跃游戏</title>
      <link href="/2020/10/19/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-19-Problem-53-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/10/19/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-19-Problem-53-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game-ii/</a></p><p>补:</p><p><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><p>这两道题目都非常有特点，考察这种先遍历后更新的技巧，两道题目要一块看。</p></li><li><p>重点理解一下跳跃游戏II的三个变量</p><ul><li>Step : 当前走的步数</li><li>cur：当前步数以内能到达的位置</li><li>next: 如果多走一步 能到达的位置</li></ul><p>那么只有走到cur位置的下一个位置，相当于需要再跳，所以step++, cur = next即可。主要在更新next，保持next在多走一步情况下的最大位置。</p></li><li><p>题目二就是因为要考察最小步数,需要step记录，同时在遍历的同时要想办法记录何时去更新step。</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; cur)&#123;</span><br><span class="line">                step++;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            next = Math.max(nums[i]+i,next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; max_pos) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                max_pos = Math.max(i + nums[i],max_pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 52 step sum问题</title>
      <link href="/2020/10/17/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-17-Problem-52-step-sum%E9%97%AE%E9%A2%98/"/>
      <url>/2020/10/17/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-17-Problem-52-step-sum%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    定义何为step sum？<br>比如680，680 + 68 + 6 = 754，680的step sum叫754<br>给定一个正数num，判断它是不是某个数的step sum</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题目考查的二分。拿到题目务必好好观察特点。明显这个数组拆分累加之后是变大的。所以说 给一个数x，它是某个数字的step sum 取值一定在1到x之间。所以可以用二分来枚举。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isStepSum</span><span class="params">(<span class="keyword">int</span> stepSum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R = stepSum;</span><br><span class="line"><span class="keyword">int</span> M = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">M = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">cur = stepSum(M);</span><br><span class="line"><span class="keyword">if</span> (cur == stepSum) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &lt; stepSum) &#123;</span><br><span class="line">L = M + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">R = M - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stepSum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">num /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 51 俄罗斯套娃问题</title>
      <link href="/2020/10/14/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-14-Problem-51-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E9%97%AE%E9%A2%98/"/>
      <url>/2020/10/14/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-14-Problem-51-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    俄罗斯套娃问题</p><p>​    Leetcode 原题：</p><p>​    <a href="https://leetcode.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">https://leetcode.com/problems/russian-doll-envelopes/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典题目，是LIS问题的应用。有长和高两个维度，我们将信封按照长升序，并且长相等时按照宽降序。这样做的目的就是，当我们把宽单独拿出来，此时的最长递增子序列的长度就是嵌套层次。而如果宽也是升序排序，此时的LIS长度 就会因为长度相等而产生干扰，而宽度降序就会直接排除掉干扰。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Model</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> edge;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Model</span><span class="params">(<span class="keyword">int</span> edge, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.edge = edge;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Model[] model = <span class="keyword">new</span> Model[envelopes.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; envelopes.length; i++) &#123;</span><br><span class="line">            model[i] = <span class="keyword">new</span> Model(envelopes[i][<span class="number">0</span>],envelopes[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(model,(t1,t2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (t1.edge != t2.edge) <span class="keyword">return</span> t1.edge - t2.edge;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t2.height -t1.height;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] lis = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; model.length; i++) &#123;</span><br><span class="line">            lis[i] = model[i].height;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getLis(lis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLis</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        end[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> valid_loc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>,r = valid_loc;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(end[mid] &gt;= arr[i])&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    l = mid +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end[l] &lt; arr[i])&#123;</span><br><span class="line">                end[l+<span class="number">1</span>] = arr[i];</span><br><span class="line">                valid_loc++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end[l] = arr[i]; <span class="comment">//更新对应长度的子序列的最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid_loc+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 50 最长递增子序列</title>
      <link href="/2020/10/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-13-Problem-50-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2020/10/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-13-Problem-50-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    经典算法之最长递增子序列</p><p>​    Leetcode 原题：</p><p>​    <a href="https://leetcode.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">https://leetcode.com/problems/longest-increasing-subsequence</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>LIS 经典问题。普通的dp树N^2^的，不容易过，采用end数组的方式实现N*logN的</li><li>End[i]代表所有长度为i +1的递增子序列中的最小结尾。明确end数组含义，开始遍历数组arr，对每个值在end数组中查找第一个单于等于arr[i]的位置end[j]，说明arr[i]无法延伸到j+2长度，而是只能降低j+1递增子序列的末尾值。所以更新end[j]的值，同时记录dp[i]。end数组由含义决定是严格递增的对于end数组使用二分查找。整个过程就是N*logN。</li><li>实际上dp的记录可以省掉。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        end[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> valid_loc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>,r = valid_loc;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(end[mid] &gt;= arr[i])&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    l = mid +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end[l] &lt; arr[i])&#123;</span><br><span class="line">                end[l+<span class="number">1</span>] = arr[i];</span><br><span class="line">                valid_loc++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end[l] = arr[i]; <span class="comment">//更新对应长度的子序列的最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid_loc+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 49 移除无效括号</title>
      <link href="/2020/10/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-13-Problem-49-%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
      <url>/2020/10/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-13-Problem-49-%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode 原题：</p><p>​    <a href="https://leetcode.com/problems/remove-invalid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-invalid-parentheses/</a></p><p>第9节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 48 点灯问题</title>
      <link href="/2020/10/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-12-Problem-48-%E7%82%B9%E7%81%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2020/10/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-12-Problem-48-%E7%82%B9%E7%81%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组arr，长度为N，arr中的值不是0就是1。arr[i]表示第i栈灯的状态，0代表灭灯，1代表亮灯<br>每一栈灯都有开关，但是按下i号灯的开关，会同时改变i-1、i、i+1栈灯的状态<br>问题一：如果N栈灯排成一条直线,请问最少按下多少次开关？<br>i为中间位置时，i号灯的开关能影响i-1、i和i+1<br>0号灯的开关只能影响0和1位置的灯<br>N-1号灯的开关只能影响N-2和N-1位置的灯</p><p>问题二：如果N栈灯排成一个圈,请问最少按下多少次开关,能让灯都亮起来<br>i为中间位置时，i号灯的开关能影响i-1、i和i+1<br>0号灯的开关能影响N-1、0和1位置的灯<br>N-1号灯的开关能影响N-2、N-1和0位置的灯</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典的点灯问题。贪心的思路，尽可能少的点灯。然后 对于圈，无非是第一个位置比较特殊，单独对待一下。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无环的点灯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method01</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span>) <span class="keyword">return</span> arr[<span class="number">0</span>]^<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">2</span>) <span class="keyword">return</span> arr[<span class="number">0</span>]!=arr[<span class="number">1</span>]?Integer.MAX_VALUE : arr[<span class="number">0</span>]^<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] arr2 = Arrays.copyOf(arr,  arr.length);</span><br><span class="line">        <span class="comment">//可能性一</span></span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        p1 = loop2(arr,p1);</span><br><span class="line">        <span class="comment">//可能性二</span></span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">0</span>] ^= <span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">1</span>] ^=<span class="number">1</span>;</span><br><span class="line">        p2 = loop2(arr2,p2);</span><br><span class="line">        <span class="keyword">return</span> Math.min(p1,p2);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">loop2</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i - <span class="number">1</span>] == <span class="number">0</span>) &#123; <span class="comment">//灭灯</span></span><br><span class="line">                p++;</span><br><span class="line">                arr[i - <span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">                arr[i] ^= <span class="number">1</span>;</span><br><span class="line">                arr[(i+<span class="number">1</span>)%arr.length]^=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[arr.length-<span class="number">1</span>] == <span class="number">0</span> || arr[<span class="number">0</span>] == <span class="number">0</span>) p = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//循环点灯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span>) <span class="keyword">return</span> arr[<span class="number">0</span>]^<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">2</span>) <span class="keyword">return</span> arr[<span class="number">0</span>]!=arr[<span class="number">1</span>]?Integer.MAX_VALUE : arr[<span class="number">0</span>]^<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = Arrays.copyOf(arr,  arr.length);</span><br><span class="line">        <span class="comment">//前两位，你是不知道该取什么情况的，因为它不在我们说的普遍的位置，普遍的位置就希望左边过来的都是1</span></span><br><span class="line">        <span class="comment">//可能性一  0 不变，1不变</span></span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        p1 = loop2(arr2,p1);</span><br><span class="line">        <span class="comment">//可能性二 0不变 1变</span></span><br><span class="line">        arr2 = Arrays.copyOf(arr,  arr.length);</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">0</span>] ^=<span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">1</span>] ^=<span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">2</span>] ^=<span class="number">1</span>;</span><br><span class="line">        p2 = loop2(arr2,p2);</span><br><span class="line">        <span class="comment">//可能性三 0变 1不变</span></span><br><span class="line">        arr2 = Arrays.copyOf(arr,  arr.length);</span><br><span class="line">        <span class="keyword">int</span> p3 = <span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">0</span>] ^= <span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">1</span>] ^=<span class="number">1</span>;</span><br><span class="line">        arr2[N-<span class="number">1</span>] ^=<span class="number">1</span>;</span><br><span class="line">        p3 = loop2(arr2,p3);</span><br><span class="line">        <span class="comment">//可能性四 0变 1变</span></span><br><span class="line">        <span class="keyword">int</span> p4 = <span class="number">2</span>;</span><br><span class="line">        arr2 = Arrays.copyOf(arr,  arr.length);</span><br><span class="line">        arr2[N-<span class="number">1</span>] ^=<span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">2</span>] ^=<span class="number">1</span>;</span><br><span class="line">        p4 = loop2(arr2,p4);</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(Math.min(p1,p2),p3),p4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Greed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 47 蛇前进游戏</title>
      <link href="/2020/10/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-12-Problem-47-%E8%9B%87%E5%89%8D%E8%BF%9B%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/10/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-12-Problem-47-%E8%9B%87%E5%89%8D%E8%BF%9B%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个矩阵matrix，值有正、负、0<br>蛇可以空降到最左列的任何一个位置，初始增长值是0<br>蛇每一步可以选择右上、右、右下三个方向的任何一个前进<br>沿途的数字累加起来，作为增长值；但是蛇一旦增长值为负数，就会死去<br>蛇有一种能力，可以使用一次：把某个格子里的数变成相反数<br>蛇可以走到任何格子的时候停止<br>返回蛇能获得的最大增长值</p><p>第8节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>考察的是递归，无非是增加了一些条件。我们就按照最普通的递归来写，枚举所有的可能性，找出最大值。这样在数据量小的情况下肯定能过的，如果数据量大，就需要再思考如何优化。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snake</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = process(matrix,i,<span class="number">0</span>,<span class="keyword">false</span>,<span class="number">0</span>,M,N);</span><br><span class="line">            max = Math.max(t,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">boolean</span> used,<span class="keyword">int</span> sum,<span class="keyword">int</span> M,<span class="keyword">int</span> N)</span></span>&#123;  <span class="comment">//从i,j出发可以获得最大值</span></span><br><span class="line">        <span class="keyword">if</span>(!InEdge(i,j,M,N) || sum &lt; <span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">int</span> p1=Integer.MIN_VALUE,p2 = Integer.MIN_VALUE,p3 = Integer.MIN_VALUE,p4= Integer.MIN_VALUE,p5 = Integer.MIN_VALUE,p6= Integer.MIN_VALUE,p7 = Integer.MIN_VALUE,</span><br><span class="line">                p8 = Integer.MIN_VALUE,p9 = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p10 = sum + matrix[i][j], p11 = used ? Integer.MIN_VALUE:sum - matrix[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!used)&#123;</span><br><span class="line">            p1 = process(matrix,i-<span class="number">1</span>,j+<span class="number">1</span>,<span class="keyword">true</span>,sum-matrix[i][j],M,N);</span><br><span class="line">            p2 = process(matrix,i-<span class="number">1</span>,j+<span class="number">1</span>,<span class="keyword">false</span>,sum+matrix[i][j],M,N);</span><br><span class="line"></span><br><span class="line">            p3 = process(matrix,i,j+<span class="number">1</span>,<span class="keyword">true</span>,sum-matrix[i][j],M,N);</span><br><span class="line">            p4 = process(matrix,i,j+<span class="number">1</span>,<span class="keyword">false</span>,sum+matrix[i][j],M,N);</span><br><span class="line"></span><br><span class="line">            p5 = process(matrix,i+<span class="number">1</span>,j+<span class="number">1</span>,<span class="keyword">true</span>,sum-matrix[i][j],M,N);</span><br><span class="line">            p6= process(matrix,i+<span class="number">1</span>,j+<span class="number">1</span>,<span class="keyword">false</span>,sum+matrix[i][j],M,N);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p7 = process(matrix,i-<span class="number">1</span>,j+<span class="number">1</span>,<span class="keyword">true</span>,sum+matrix[i][j],M,N);</span><br><span class="line">            p8 = process(matrix,i,j+<span class="number">1</span>,<span class="keyword">true</span>,sum+matrix[i][j],M,N);</span><br><span class="line">            p9 = process(matrix,i+<span class="number">1</span>,j+<span class="number">1</span>,<span class="keyword">true</span>,sum+matrix[i][j],M,N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_no_stop = Math.max(Math.max(Math.max(Math.max(Math.max(Math.max(Math.max(p3,Math.max(p1,p2)),p4),p5),p6),p7),p8),p9);</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(max_no_stop,p10),p11);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 46 寻找word</title>
      <link href="/2020/10/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-10-Problem-46-%E5%AF%BB%E6%89%BEword/"/>
      <url>/2020/10/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-10-Problem-46-%E5%AF%BB%E6%89%BEword/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个char[][] matrix，也就是char类型的二维数组，再给定一个字符串word，<br>可以从任何一个某个位置出发，可以走上下左右，能不能找到word？<br> char[][] m = {  { ‘a’, ‘b’, ‘z’ },<br>                       { ‘c’, ‘d’, ‘o’ },<br>                       { ‘f’, ‘e’, ‘o’ }}<br>设定1：可以走重复路的情况下，返回能不能找到<br>比如，word = “zoooz”，是可以找到的，z -&gt; o -&gt; o -&gt; o -&gt; z，因为允许走一条路径中已经走过的字符<br>设定2：不可以走重复路的情况下，返回能不能找到<br>比如，word = “zoooz”，是不可以找到的，因为允许走一条路径中已经走过的字符不能重复走 </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>从每个字符 去感染一下，普通的递归题目</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以走重复路</span></span><br><span class="line"><span class="comment">// 从m[i][j]这个字符出发，能不能找到str[k...]这个后缀串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canLoop</span><span class="params">(<span class="keyword">char</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] str, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k == str.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == -<span class="number">1</span> || i == m.length || j == -<span class="number">1</span> || j == m[<span class="number">0</span>].length || m[i][j] != str[k]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不越界！m[i][j] == str[k] 对的上的！</span></span><br><span class="line"><span class="comment">// str[k+1....]</span></span><br><span class="line"><span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (canLoop(m, i + <span class="number">1</span>, j, str, k + <span class="number">1</span>) || canLoop(m, i - <span class="number">1</span>, j, str, k + <span class="number">1</span>) || canLoop(m, i, j + <span class="number">1</span>, str, k + <span class="number">1</span>)</span><br><span class="line">|| canLoop(m, i, j - <span class="number">1</span>, str, k + <span class="number">1</span>)) &#123;</span><br><span class="line">ans = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能走重复路</span></span><br><span class="line"><span class="comment">// 从m[i][j]这个字符出发，能不能找到str[k...]这个后缀串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">noLoop</span><span class="params">(<span class="keyword">char</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] str, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k == str.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == -<span class="number">1</span> || i == m.length || j == -<span class="number">1</span> || j == m[<span class="number">0</span>].length || m[i][j] != str[k]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不越界！也不是回头路！m[i][j] == str[k] 也对的上！</span></span><br><span class="line">m[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (noLoop(m, i + <span class="number">1</span>, j, str, k + <span class="number">1</span>) || noLoop(m, i - <span class="number">1</span>, j, str, k + <span class="number">1</span>) || noLoop(m, i, j + <span class="number">1</span>, str, k + <span class="number">1</span>)</span><br><span class="line">|| noLoop(m, i, j - <span class="number">1</span>, str, k + <span class="number">1</span>)) &#123;</span><br><span class="line">ans = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">m[i][j] = str[k];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 45 最多盛水问题</title>
      <link href="/2020/10/07/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-07-Problem-45-%E6%9C%80%E5%A4%9A%E7%9B%9B%E6%B0%B4%E9%97%AE%E9%A2%98/"/>
      <url>/2020/10/07/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-07-Problem-45-%E6%9C%80%E5%A4%9A%E7%9B%9B%E6%B0%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode.com/problems/container-with-most-water/</a>    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>最多盛水问题，双指针，想不明白的话就是比较绕，关键点就是不断的把答案进行推高,最终逼近答案.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[p1] &lt; height[p2])&#123;</span><br><span class="line">               res = Math.max((p2-p1)*height[p1],res);</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max((p2-p1)*height[p2],res);</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 44 计算多括号表达式</title>
      <link href="/2020/10/03/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-03-Problem-44-%E8%AE%A1%E7%AE%97%E5%A4%9A%E6%8B%AC%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/10/03/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-03-Problem-44-%E8%AE%A1%E7%AE%97%E5%A4%9A%E6%8B%AC%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个字符串str，str表示一个公式，公式里可能有整数、加减乘除符号和左右括号 返回公式的计算结果，难点在于括号可能嵌套很多层,如：</p><p>str=”48<em>((70-65)-43)+8</em>1”，返回-1816。<br>str=”3+1<em>4”，返回7。<br>str=”3+(1</em>4)”，返回7。<br>【说明】<br>1.可以认为给定的字符串一定是正确的公式，即不需要对str做公式有效性检查<br>2.如果是负数，就需要用括号括起来，比如“4<em>(-3)”但如果负数作为公式的开头或括号部分的开头，则可以没有括号，比如”-3</em>4”和”(-3*4)”都是合法的。<br>3.不用考虑计算过程中会发生溢出的情况。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>常见的思路是利用栈结合操作符的优先级别进行计算，但递归本质上也是利用系统栈，我们利用递归来解决这种“优先级”的问题。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过递归计算括号优先级 1+10*3+4*5+7</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method1</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> (String)process(stack,<span class="number">0</span>,chars)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Object[] process(Stack&lt;String&gt; stack,<span class="keyword">int</span> i,<span class="keyword">char</span>[] chs)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = i;</span><br><span class="line">        <span class="keyword">if</span>(chs[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            stack.push(<span class="string">"0"</span>);</span><br><span class="line">            stack.push(<span class="string">"-"</span>);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; chs.length)&#123;</span><br><span class="line">            Double num = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//表示已经得出数字</span></span><br><span class="line">            <span class="keyword">if</span>(chs[start] == <span class="string">'('</span> )&#123;</span><br><span class="line">                <span class="keyword">final</span> Object[] ans = process(<span class="keyword">new</span> Stack&lt;String&gt;(), start + <span class="number">1</span>, chs);</span><br><span class="line">                start = (Integer) ans[<span class="number">1</span>];</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                num = Double.valueOf((String)ans[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                <span class="keyword">while</span> (start &lt; chs.length &amp;&amp; chs[start] &lt;= <span class="string">'9'</span> &amp;&amp; chs[start] &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">                    num = num *<span class="number">10</span> + (chs[start] - <span class="string">'0'</span>);</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Character op = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(start &lt; chs.length)&#123;</span><br><span class="line">                op = chs[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//push 之前如果是乘除法 先算</span></span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty()&amp;&amp;(stack.peek().equals(<span class="string">"*"</span>) || stack.peek().equals(<span class="string">"/"</span>)))&#123;</span><br><span class="line">                <span class="keyword">final</span> String tmp_op = stack.pop();</span><br><span class="line">                <span class="keyword">final</span> String num_a = stack.pop();</span><br><span class="line">                num = Double.valueOf(getCalculateRes(tmp_op,num_a,num.toString())) ;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(num.toString());</span><br><span class="line">            <span class="keyword">if</span>(op != <span class="keyword">null</span> &amp;&amp; op != <span class="string">')'</span>)</span><br><span class="line">                stack.push(op.toString());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算栈中加减运算表达式的值</span></span><br><span class="line">        String res = stack.pop();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(isOption(stack.peek()))&#123;</span><br><span class="line">                String option = stack.pop();</span><br><span class="line">                String temp = stack.pop();</span><br><span class="line">                res = getCalculateRes(option,temp,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object[]&#123;res,start&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getCalculateRes</span><span class="params">(String op, String a, String b)</span> </span>&#123;</span><br><span class="line">        Double res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:&#123;</span><br><span class="line">                res = Double.valueOf(a) * Double.valueOf(b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:&#123;</span><br><span class="line">                res = Double.valueOf(a) / Double.valueOf(b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:&#123;</span><br><span class="line">                res = Double.valueOf(a) + Double.valueOf(b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:&#123;</span><br><span class="line">                res = Double.valueOf(a) - Double.valueOf(b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOption</span><span class="params">(String op)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(op.length() ==<span class="number">1</span> &amp;&amp; (op.equals(<span class="string">"+"</span>) || op.equals(<span class="string">"-"</span>))) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 43</title>
      <link href="/2020/09/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-29-Problem-43/"/>
      <url>/2020/09/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-29-Problem-43/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 42 单词表拼接字符串种数</title>
      <link href="/2020/09/27/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-27-Problem-42-%E5%8D%95%E8%AF%8D%E8%A1%A8%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%8D%E6%95%B0/"/>
      <url>/2020/09/27/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-27-Problem-42-%E5%8D%95%E8%AF%8D%E8%A1%A8%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    假设所有字符都是小写字母  大字符串是str,arr是去重的单词表, 每个单词都不是空字符串且可以使用任意次.<br>使用arr中的单词有多少种拼接str的方式. 返回方法数.</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是说长的字符串用单词来拼起来，看看有几种方式。首先不难想的是，对字符串进行判断，在index位置，判断单词表中哪个单词可以作为开头，切割之后进行递归。此处，需要单词表，枚举每个单词之后，需要判断是不是可以作为当前字符串开头，这又是和平均字符串长度有关。</li><li>看到这种单词表的形式，我们常常想到用Trie来进行优化，把单词表用前缀树组织起来，这样在判断是不是有单词作为前缀时，可以在树上走一个平均长度就能判断出来，省去了每次递归都遍历单词表的时间。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：DP  dp[i..length-1] 表示这个字符串由单词拼接的方法数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">(String str,String words[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> N = str.length();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        dp[N] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; words.length;j++)&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> t = str.substring(i).indexOf(words[j]);</span><br><span class="line">                <span class="keyword">if</span>(t == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] += dp[i+words[j].length()];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：Dp 可以看到套了两个循环，indexOf方法查子串 底层kmp O(n),几乎是三阶的</span></span><br><span class="line">    <span class="comment">//优化点在于，我当前i开始的串 在查找d单词时候，能匹配上的单词 一定是前缀关系</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">(String str,String words[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> N = str.length();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        dp[N] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            prefixTree.addWord(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dp[i]表示 以i开始的字符串可以被words拼成的方法数</span></span><br><span class="line">            <span class="keyword">final</span> PrefixTree.Node root = prefixTree.root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = N-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">                dp[i] = <span class="number">0</span>;</span><br><span class="line">                PrefixTree.Node cur = root;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; chars.length)&#123;</span><br><span class="line">                    PrefixTree.Node temp = cur.chars[chars[j]-<span class="string">'a'</span>];</span><br><span class="line">                    <span class="keyword">if</span>(temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(temp.isWord)&#123;</span><br><span class="line">                            dp[i] += dp[j+<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        cur = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        Node root;</span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isWord;</span><br><span class="line">            Node[] chars;</span><br><span class="line">            String word;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.chars = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                cur.chars[chars[i]-<span class="string">'a'</span>] = cur.chars[chars[i]-<span class="string">'a'</span>] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node() : cur.chars[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">                cur = cur.chars[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">            cur.word = word;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
            <tag> Bit Manipuldate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 41 平方后数种类</title>
      <link href="/2020/09/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-25-Problem-41-%E5%B9%B3%E6%96%B9%E5%90%8E%E6%95%B0%E7%A7%8D%E7%B1%BB/"/>
      <url>/2020/09/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-25-Problem-41-%E5%B9%B3%E6%96%B9%E5%90%8E%E6%95%B0%E7%A7%8D%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    1.给定一个有序数组arr，其中值可能为正、负、0<br>​    返回arr中每个数都平方之后不同的结果有多少种？</p><p>​    2.给定一个数组arr，先递减然后递增，<br>​    返回arr中有多少个不同的数字？</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>两道题目实际是一道，想象成低谷，两个变量两边遍历一下即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>​    略</p>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 40 排序后的最大差值</title>
      <link href="/2020/09/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-25-Problem-40-%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/"/>
      <url>/2020/09/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-25-Problem-40-%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个数组arr，返回如果排序之后，相邻两数的最大差值 要求：时间复杂度O(N)</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题需要好好思考，其实没什么明显的知识点的提示，这时候就得想些 “特殊技巧”。这个题 N个数，可以分到N+1个桶中，把元素[min,max]，给把区间平均分配到桶中，间隔最大的两个元素 一定是夸桶！所以只需要在桶中维护最大，最小元素，最后挨个桶考察一下即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>]; <span class="comment">//0列放最小值,1列放最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            bucket[i][<span class="number">0</span>] = Integer.MAX_VALUE;</span><br><span class="line">            bucket[i][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_num = Integer.MAX_VALUE,max_num = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            max_num = arr[i] &gt; max_num ? arr[i] : max_num;</span><br><span class="line">            min_num = arr[i] &lt; min_num ? arr[i] : min_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> step_len = (<span class="keyword">double</span>)(max_num - min_num)/n; <span class="comment">//是一个range，然后平均到 每个桶，这么大个范围</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> buloc = (<span class="keyword">int</span>)((arr[i]-min_num)/step_len);</span><br><span class="line">            buloc = buloc &lt; n ? buloc : buloc-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//更新buloc这个桶的最值</span></span><br><span class="line">            bucket[buloc][<span class="number">0</span>] =  arr[i] &lt; bucket[buloc][<span class="number">0</span>] ? arr[i] : bucket[buloc][<span class="number">0</span>];</span><br><span class="line">            bucket[buloc][<span class="number">1</span>] =  arr[i] &gt; bucket[buloc][<span class="number">1</span>] ? arr[i] : bucket[buloc][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastMax = bucket[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket[i][<span class="number">0</span>] == Integer.MAX_VALUE)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = bucket[i][<span class="number">0</span>] - lastMax &gt; res ? bucket[i][<span class="number">0</span>] - lastMax : res;</span><br><span class="line">            lastMax = bucket[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Problem 39 监控二叉树</title>
      <link href="/2020/09/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-25-Problem-39-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/09/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-25-Problem-39-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-cameras/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-cameras/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>贪心的思路，因为目标是很明确的，就是照完整棵树，相机树最少，那就是能不放则不放，主要考察两个小变量，放了没有?照到了没有？</li><li>结合二叉树的递归套路可解。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val;&#125;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="keyword">this</span>.val = val;</span><br><span class="line">         <span class="keyword">this</span>.left = left;</span><br><span class="line">         <span class="keyword">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">boolean</span> isMonitor; <span class="comment">//节点放了没</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">boolean</span> isSet;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> isMonitor, <span class="keyword">int</span> num, <span class="keyword">boolean</span> isSet)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.isMonitor = isMonitor;</span><br><span class="line">           <span class="keyword">this</span>.num = num;</span><br><span class="line">           <span class="keyword">this</span>.isSet = isSet;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right ==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">final</span> Info info = process1(root);</span><br><span class="line">       <span class="keyword">return</span> info.isMonitor == <span class="keyword">false</span> ?info.num+<span class="number">1</span>:info.num ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//贪心解法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Info <span class="title">process1</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">boolean</span> isSet = <span class="keyword">false</span>,isMonitor = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">final</span> Info leftInfo = process1(node.left);</span><br><span class="line">       <span class="keyword">final</span> Info rightInfo = process1(node.right);</span><br><span class="line">       <span class="keyword">if</span>(leftInfo == <span class="keyword">null</span> &amp;&amp; rightInfo == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">false</span>,<span class="number">0</span>,<span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(leftInfo != <span class="keyword">null</span> &amp;&amp; rightInfo == <span class="keyword">null</span>)&#123;</span><br><span class="line">           num += leftInfo.num;</span><br><span class="line">           isSet = leftInfo.isMonitor == <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span>(isSet) &#123;</span><br><span class="line">               num++;</span><br><span class="line">               isMonitor = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(leftInfo.isSet)&#123;</span><br><span class="line">               isMonitor = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>  <span class="keyword">if</span>( rightInfo != <span class="keyword">null</span> &amp;&amp; leftInfo == <span class="keyword">null</span>)&#123;</span><br><span class="line">           num += rightInfo.num;</span><br><span class="line">           isSet = rightInfo.isMonitor == <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span>(isSet) &#123;</span><br><span class="line">               num++;</span><br><span class="line">               isMonitor = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(rightInfo.isSet)</span><br><span class="line">               isMonitor = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           num += leftInfo.num + rightInfo.num;</span><br><span class="line">           isSet = (!leftInfo.isMonitor || !rightInfo.isMonitor);</span><br><span class="line">           <span class="keyword">if</span>(isSet)&#123;</span><br><span class="line">               num++;</span><br><span class="line">               isMonitor = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(leftInfo.isSet || rightInfo.isSet)&#123;</span><br><span class="line">               isMonitor = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Info(isMonitor,num,isSet);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Greed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 38 最大与运算</title>
      <link href="/2020/09/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-22-Problem-38-%E6%9C%80%E5%A4%A7%E4%B8%8E%E8%BF%90%E7%AE%97/"/>
      <url>/2020/09/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-22-Problem-38-%E6%9C%80%E5%A4%A7%E4%B8%8E%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个非负数组成的数组，长度一定大于1 想知道数组中哪两个数&amp;的结果最大<br>返回这个最大结果.时间复杂度O(N)，额外空间复杂度O(1)</p><p>第7节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
            <tag> Bit Manipuldate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 37 Nim博弈</title>
      <link href="/2020/09/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-21-Problem-37-Nim%E5%8D%9A/"/>
      <url>/2020/09/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-21-Problem-37-Nim%E5%8D%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Nim博弈. 给定一个正数数组arr 先手和后手每次可以选择在一个位置拿走若干值，值要大于0，但是要小于该处的剩余 谁最先拿空arr，谁赢。根据arr，返回谁赢</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目理解之后。需要转换思路。如果先手能保证每次拿一个数之后，异或值是0 ，不断的拿之后，最后后手面对异或和为0的情况 一定全是0，所以先手只能能保证当前异或值不是0，那就每次拿成0，这样 先手一定赢。</li><li>有一点在于，能不能保证每次把异或值不是0的这些数，通过拿某些数。异或和为0 ，答案是能。因为异或和的值 想象一下每一位 0或者1，一定是对应有一个数 在这一位上有0或者1。那这样一定是可以拆分出来保证异或值为0的。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printWinner</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">eor ^= num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (eor == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"后手赢"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"先手赢"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
            <tag> Bit Manipuldate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 36 异或和为0的最多子数组个数</title>
      <link href="/2020/09/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-21-Problem-36-%E5%BC%82%E6%88%96%E5%92%8C%E4%B8%BA0%E7%9A%84%E6%9C%80%E5%A4%9A%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/09/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-21-Problem-36-%E5%BC%82%E6%88%96%E5%92%8C%E4%B8%BA0%E7%9A%84%E6%9C%80%E5%A4%9A%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    数组中所有数都异或起来的结果，叫做异或和 给定一个数组arr，可以任意切分成若干个不相交的子数组<br>其中一定存在一种最优方案，使得切出异或和为0的子数组最多 返回这个最多数量</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>看到子数组先想DP ，打出前缀和，自己异或自己是0，利用这几点，题目就很简单了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划，利用异或的前缀和</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MosteorZeroParts2</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span>[] pre_xor = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length],dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">      <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      pre_xor[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">      map.put(<span class="number">0</span>,-<span class="number">1</span>); <span class="comment">//初始值，防止前面整个数组异或和为0的情况 ,注意踩坑</span></span><br><span class="line">      map.put(arr[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">      dp[<span class="number">0</span>] = arr[<span class="number">0</span>] == <span class="number">0</span>? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">          pre_xor[i] =  pre_xor[i-<span class="number">1</span>] ^ arr[i];</span><br><span class="line">          dp[i] =  map.get(pre_xor[i]) == <span class="keyword">null</span> ? dp[i-<span class="number">1</span>] : Math.max((map.get(pre_xor[i])&lt;<span class="number">0</span>?<span class="number">0</span>:dp[map.get(pre_xor[i])])+<span class="number">1</span>,dp[i-<span class="number">1</span>]);</span><br><span class="line">          map.put(pre_xor[i],i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[arr.length-<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Bit Manipuldate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 35 与数组中元素的最大异或值</title>
      <link href="/2020/09/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-20-Problem-35-%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/"/>
      <url>/2020/09/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-20-Problem-35-%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    <a href="https://leetcode.com/problems/maximum-xor-with-an-element-from-array/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-xor-with-an-element-from-array/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题还是比较经典的，有两种思路，一种是来个简单的，直接把查询的mi 和 数组都按照从小到大排序，加入前缀树中，代码几乎和34题一样</li><li>前缀树，节点可以存放一些附加信息，比如以当前路径为前缀的单词个数，当前节点是不是单词等等，这个地方存放以当前节点为前缀树的最小值，只有这棵树的最小值符合条件才可以往下走</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] maximizeXor(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[][] queries) &#123;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            prefixTree.addNum(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[queries.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.length; i++) &#123;</span><br><span class="line">           res[i] = prefixTree.getMaxXoR(queries[i][<span class="number">0</span>],queries[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            Node[] nodes;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                nodes = <span class="keyword">new</span> Node[<span class="number">2</span>];</span><br><span class="line">                min = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.min = min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Node root;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            Node cur = root;</span><br><span class="line">            root.min = root.min &gt; num ? num:root.min;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (num&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">                cur.nodes[temp] = cur.nodes[temp] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node():cur.nodes[temp];</span><br><span class="line">                cur.nodes[temp].min = cur.nodes[temp].min &gt; num ? num:cur.nodes[temp].min;</span><br><span class="line">                cur = cur.nodes[temp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxXoR</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.min &gt; limit) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">int</span> res = num;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (num&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> expect = temp^<span class="number">1</span>;</span><br><span class="line">                expect ^= ( cur.nodes[expect]!= <span class="keyword">null</span> &amp;&amp; cur.nodes[expect].min &lt;= limit)? <span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">                res ^= (expect&lt;&lt;i);</span><br><span class="line">                cur = cur.nodes[expect];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (num&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur.nodes[temp] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.nodes[temp];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Bit Manipuldate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 34 最大异或和的两个数</title>
      <link href="/2020/09/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-16-Problem-34-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/09/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-16-Problem-34-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    数组中所有数都异或起来的结果，叫做异或和 给定一个数组arr，想知道arr中哪两个数的异或结果最大<br>返回最大的异或结果<br><a href="https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>是33题的简化版。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">       prefixTree.addNum(nums[<span class="number">0</span>]);</span><br><span class="line">       <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           res = Math.max(res,prefixTree.getMaxXor(nums[i]));</span><br><span class="line">           prefixTree.addNum(nums[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">           <span class="keyword">public</span> Node[] nodes;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               nodes = <span class="keyword">new</span> Node[<span class="number">2</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Node root;</span><br><span class="line">       <span class="keyword">int</span> size;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           root = <span class="keyword">new</span> Node();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">           Node cur = root;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">               <span class="keyword">int</span> temp = (num&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">               cur.nodes[temp] = cur.nodes[temp] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node():cur.nodes[temp];</span><br><span class="line">               cur = cur.nodes[temp];</span><br><span class="line">           &#125;</span><br><span class="line">           size++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxXor</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">           Node cur = root.nodes[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">int</span> res = num;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">               <span class="keyword">int</span> temp = (num&gt;&gt;i) &amp; <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">int</span> t = cur.nodes[temp^<span class="number">1</span>] == <span class="keyword">null</span> ? temp : temp^<span class="number">1</span>;</span><br><span class="line">               cur = cur.nodes[t];</span><br><span class="line">               res ^= (t&lt;&lt;i);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 33 最大异或和子数组</title>
      <link href="/2020/09/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-12-Problem-33-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2020/09/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-12-Problem-33-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    数组中所有数都异或起来的结果，叫做异或和,给定一个数组arr，返回arr的最大子数组异或和    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>首先看到这种和啊，数组啊，应该想到”前缀和“ ，要有这种意识，总要有些经验上的积累。</li><li>先做出前缀的异或和数组，这样对于数组preSum[i],和前置的哪个元素异或 得到最大值，最大值是多少？</li><li>preSum元素放到前缀树上，利用数位 的贪心思想即可求解。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaxSubXOR</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length == <span class="number">0</span> || arr == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        prefixTree.addNum(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>,res = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            xor ^= arr[i];</span><br><span class="line">            res = Math.max(prefixTree.getMaxXor(xor),res);</span><br><span class="line">            prefixTree.addNum(xor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            <span class="keyword">public</span> HashMap&lt;Integer,Node&gt; map;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (num&gt;&gt;i) &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur.map.get(temp) == <span class="keyword">null</span>) cur.map.put(temp,<span class="keyword">new</span> Node());</span><br><span class="line">                cur = cur.map.get(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxXor</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">int</span> res = num;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (num&gt;&gt;i) &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">31</span>)&#123;</span><br><span class="line">                    x = cur.map.get(temp)==<span class="keyword">null</span>?temp^<span class="number">1</span>:temp;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    x = cur.map.get(temp^<span class="number">1</span>)==<span class="keyword">null</span>?temp:temp^<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(x == <span class="number">1</span>)</span><br><span class="line">                    res ^=(x&lt;&lt;i);</span><br><span class="line">                cur = cur.map.get(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Bit Manipulate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 32 最少删除字符成为其子串</title>
      <link href="/2020/09/09/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-09-Problem-32-%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E6%88%90%E4%B8%BA%E5%85%B6%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/09/09/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-09-Problem-32-%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E6%88%90%E4%B8%BA%E5%85%B6%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？比如 s1 = “abcde”，s2 = “axbc”</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>一种暴力思路，将s2进行挑选，挑选删除字符少的子序列 看是不是s1子串。</li><li>编辑距离思路，挑选出s1的所有子串，挨个进行编辑距离的dp</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法一：暴力枚举，删除一个的时候，删除两个的时候，从小开始删，其实删完就是子序列，只要一个中，就中了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MyminCost1</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s2.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s2.length();i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(MyProcess1(i,s1,chars,<span class="number">0</span>,<span class="string">""</span>,<span class="keyword">new</span> HashMap&lt;String,Boolean&gt;())) <span class="keyword">return</span> s2.length()-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">MyProcess1</span><span class="params">(<span class="keyword">int</span> rest, String s1,<span class="keyword">char</span>[] s2,<span class="keyword">int</span> index, String subsquence, HashMap&lt;String,Boolean&gt; cache)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rest &gt; s2.length-index) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//必须挑完rest个，要固定从大到小枚举子序列，减枝</span></span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(subsquence) &amp;&amp; !cache.get(subsquence)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rest == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cache.containsKey(subsquence)) <span class="keyword">return</span> cache.get(subsquence);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> res = s1.indexOf(subsquence);</span><br><span class="line">                    cache.put(subsquence, res != -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> res != -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">boolean</span> p1 = MyProcess1(rest-<span class="number">1</span>,s1,s2,index+<span class="number">1</span>,subsquence+s2[index],cache);</span><br><span class="line">        <span class="keyword">boolean</span> p2 = MyProcess1(rest,s1,s2,index+<span class="number">1</span>,subsquence,cache);</span><br><span class="line">        <span class="keyword">return</span> p1 || p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解法二：就是编辑问题的子问题，把s1的字串枚举出来，看看s2变成这个 花费多少删除代价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MyminCost2</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = s2.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; s1.length();j++)&#123;</span><br><span class="line">                String subStr = s1.substring(i,j+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> c = MyProcess2(subStr,s2);</span><br><span class="line">                <span class="keyword">if</span>(c == -<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res = Math.min(res,c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MyProcess2</span><span class="params">(String  s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] arr1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] arr2 = s2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length()+<span class="number">1</span>][s2.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt; s1.length()+<span class="number">1</span>;i++)  dp[i][<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;s2.length()+<span class="number">1</span>;j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s1.length()+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; s2.length()+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] !=-<span class="number">1</span> &amp;&amp;  arr1[i-<span class="number">1</span>] == arr2[j-<span class="number">1</span>]?dp[i-<span class="number">1</span>][j-<span class="number">1</span>]:Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">int</span> p2 = dp[i][j-<span class="number">1</span>]!=-<span class="number">1</span> ? dp[i][j-<span class="number">1</span>] + <span class="number">1</span> : Integer.MAX_VALUE;</span><br><span class="line">                dp[i][j] = p1==Integer.MAX_VALUE&amp;&amp;p2==Integer.MAX_VALUE? -<span class="number">1</span>:Math.min(p1,p2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 31 编辑距离问题</title>
      <link href="/2020/09/06/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-06-Problem-31-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2020/09/06/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-06-Problem-31-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    一个字符串 可以有插入（insert）、删除（delete）、替换（replace）操作，每种操作都有对应的代价。求一个字符串变成另一个最小的代价。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ol><li>经典的题目。动态规划中的行列模型。列举所有的可能性。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法：编辑距离问题，考察代价最小的最优解 ，典型的行列模型，关键在于，找准转换的所有可能性</span><br><span class="line">   public static int MyminCost(String s1, String s2, int ic, int dc, int rc) &#123;</span><br><span class="line">       final char[] arr1 &#x3D; s1.toCharArray();</span><br><span class="line">       final char[] arr2 &#x3D; s2.toCharArray();</span><br><span class="line">       int M &#x3D; arr1.length,N &#x3D; arr2.length;</span><br><span class="line">       final int[][] dp &#x3D; new int[M+1][N+1];</span><br><span class="line">       dp[0][0] &#x3D; 0;</span><br><span class="line">       for(int i &#x3D; 1;i &lt; M+1;i++)&#123;</span><br><span class="line">           dp[i][0] &#x3D; i*dc;</span><br><span class="line">       &#125;</span><br><span class="line">       for(int j &#x3D; 1;j &lt; N+1;j++)&#123;</span><br><span class="line">           dp[0][j] &#x3D; j*ic;</span><br><span class="line">       &#125;</span><br><span class="line">       for(int i &#x3D; 1;i &lt;&#x3D; M;i++)&#123;</span><br><span class="line">           for(int j &#x3D; 1; j &lt;&#x3D; N;j++)&#123;</span><br><span class="line">               dp[i][j] &#x3D; dp[i-1][j] + dc;</span><br><span class="line">               if(arr1[i-1]&#x3D;&#x3D;arr2[j-1]) dp[i][j] &#x3D; Math.min(dp[i][j],dp[i-1][j-1]);</span><br><span class="line">               dp[i][j] &#x3D; Math.min(dp[i][j],dp[i-1][j-1]+rc);</span><br><span class="line">               dp[i][j] &#x3D; Math.min(dp[i][j],dp[i-1][j-1]+ic+dc);</span><br><span class="line">               dp[i][j] &#x3D; Math.min(dp[i][j],dp[i][j-1]+ic);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return dp[M][N];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 30 相等子树</title>
      <link href="/2020/09/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-05-Problem-30-%E7%9B%B8%E7%AD%89%E5%AD%90%E6%A0%91/"/>
      <url>/2020/09/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-05-Problem-30-%E7%9B%B8%E7%AD%89%E5%AD%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如果一个节点X，它左树结构和右树结构完全一样,那么我们说以X为头的树是相等树。给定一棵二叉树的头节点head ，返回head整棵树上有多少棵相等子树</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>既然是比较树是不是一样的，那我们可以通过序列化的方式来描述一棵树。运用二叉树的递归套路，返回以head为头节点有多少个相等树，同时返回序列化结果。那么当拿到左右孩子的info信息时，便可以决定当前节点的相等子树个数。此外，比较序列化结果时，可以做一下hash。这样整体则是O(N)的运算。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> ans;</span><br><span class="line">        <span class="keyword">public</span> String str;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> a, String s)</span> </span>&#123;</span><br><span class="line">            ans = a;</span><br><span class="line">            str = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//方法一:朴素的做法，遍历每个节点来求相等节点个数,判断是不是相等,</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isSameTree</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> process1(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> leftNum = process1(node.left);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> rightNum = process1(node.right);</span><br><span class="line">        <span class="keyword">int</span> res = leftNum + rightNum;</span><br><span class="line">        <span class="keyword">final</span> String strLeft = preOrderSquence(node.left);</span><br><span class="line">        <span class="keyword">final</span> String strRight = preOrderSquence(node.right);</span><br><span class="line">        <span class="keyword">return</span> strLeft.equals(strRight) ? res+<span class="number">1</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">preOrderSquence</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"null,"</span>;</span><br><span class="line">        String str = node.value+<span class="string">","</span>;</span><br><span class="line">        <span class="keyword">final</span> String leftStr = preOrderSquence(node.left);</span><br><span class="line">        <span class="keyword">final</span> String rightStr = preOrderSquence(node.right);</span><br><span class="line">        <span class="keyword">return</span> str + leftStr + rightStr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//改进: 对序列化串做hash。时间复杂度O(N)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sameNumber2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        String algorithm = <span class="string">"SHA-256"</span>;</span><br><span class="line">        Hash hash = <span class="keyword">new</span> Hash(algorithm);</span><br><span class="line">        <span class="keyword">return</span> process(head, hash).ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node head, Hash hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="number">0</span>, hash.hashCode(<span class="string">"#,"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Info l = process(head.left, hash);</span><br><span class="line">        Info r = process(head.right, hash);</span><br><span class="line">        <span class="keyword">int</span> ans = (l.str.equals(r.str) ? <span class="number">1</span> : <span class="number">0</span>) + l.ans + r.ans;</span><br><span class="line">        String str = hash.hashCode(String.valueOf(head.value) + <span class="string">","</span> + l.str + r.str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(ans, str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 29 BST先序构造树</title>
      <link href="/2020/09/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-05-Problem-29-BST%E5%85%88%E5%BA%8F%E6%9E%84%E9%80%A0%E6%A0%91/"/>
      <url>/2020/09/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-05-Problem-29-BST%E5%85%88%E5%BA%8F%E6%9E%84%E9%80%A0%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​        已知一棵搜索二叉树上没有重复值的节点，现在有一个数组arr，是这棵搜索二叉树先序遍历的结果<br>请根据arr生成整棵树并返回头节点</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是递归在区间l-r中创建树,寻找左子树，右子树时候，因为是寻找第一个大于的,用二分正好，总体就是nlogn的</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法一：就是递归在区间l-r中创建树,寻找左子树，右子树时候，因为是寻找第一个大于的,用二分正好，总体就是nlogn的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  TreeNode <span class="title">bstFromPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( preorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>  process(preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[l]);</span><br><span class="line">        <span class="keyword">final</span> TreeNode root = <span class="keyword">new</span> TreeNode(preorder[l]);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bigger_index = binarySearch(preorder, l + <span class="number">1</span>, r, preorder[l]);</span><br><span class="line">        <span class="keyword">final</span> TreeNode leftChild = process(preorder, l + <span class="number">1</span>, bigger_index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> TreeNode rightChild = process(preorder, bigger_index, r);</span><br><span class="line">        root.left = leftChild;root.right = rightChild;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//查找第一个大于key的下标,-1为不存在</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = from,r = to;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(preorder[mid] &gt; key)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preorder[l] &gt; key ? l : l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 28 大楼轮廓线问题</title>
      <link href="/2020/09/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-01-Problem-28-%E5%A4%A7%E6%A5%BC%E8%BD%AE%E5%BB%93%E7%BA%BF%E9%97%AE%E9%A2%98/"/>
      <url>/2020/09/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-01-Problem-28-%E5%A4%A7%E6%A5%BC%E8%BD%AE%E5%BB%93%E7%BA%BF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    大楼轮廓线问题<br>​    <a href="https://leetcode.com/problems/the-skyline-problem/" target="_blank" rel="noopener">https://leetcode.com/problems/the-skyline-problem/</a></p><p>第4节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 27 字符串交错组成</title>
      <link href="/2020/09/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-01-Problem-27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E9%94%99%E7%BB%84%E6%88%90/"/>
      <url>/2020/09/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-01-Problem-27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E9%94%99%E7%BB%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    字符串交错组成<br>​    <a href="https://leetcode.com/problems/interleaving-string/" target="_blank" rel="noopener">https://leetcode.com/problems/interleaving-string/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>典型的dp行列模型，定义dp[i][j]表示s1的前i个和s2的前j个字符是否能组成s3的前i+j个字符</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] arr1 = s1.toCharArray(),arr2 = s2.toCharArray(),arr3 = s3.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> M = s1.length(),N = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(M+N != s3.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[M + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= M;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = arr1[i-<span class="number">1</span>] == arr3[i-<span class="number">1</span>] ? dp[i-<span class="number">1</span>][<span class="number">0</span>] : <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= N;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = arr2[j-<span class="number">1</span>] == arr3[j-<span class="number">1</span>] ? dp[<span class="number">0</span>][j-<span class="number">1</span>]:<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= M;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= N;j++)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> p1 = <span class="keyword">false</span>,p2 = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(arr1[i-<span class="number">1</span>] == arr3[i+j-<span class="number">1</span>])&#123;</span><br><span class="line">                    p1 = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(arr2[j-<span class="number">1</span>] == arr3[i+j-<span class="number">1</span>])&#123;</span><br><span class="line">                    p2 = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = p1|p2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[M][N];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 26 达标数组问题</title>
      <link href="/2020/08/30/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-30-Problem-26-%E8%BE%BE%E6%A0%87%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/08/30/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-30-Problem-26-%E8%BE%BE%E6%A0%87%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    生成长度为size的达标数组，什么叫达标？</p><p>达标：对于任意的 i&lt;k&lt;j，满足 [i] + [j] != [k] * 2</p><p>给定一个正数size，返回长度为size的达标数组</p><p>第4节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Problem 25 分糖果问题</title>
      <link href="/2020/08/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-26-Problem-25-%E5%88%86%E7%B3%96%E6%9E%9C%E9%97%AE%E9%A2%98/"/>
      <url>/2020/08/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-26-Problem-25-%E5%88%86%E7%B3%96%E6%9E%9C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    原问题：<a href="https://leetcode.com/problems/candy/" target="_blank" rel="noopener">https://leetcode.com/problems/candy/</a></p><p>​    进阶问题：在原问题的基础上，增加一个原则：<br>​        相邻的孩子间如果分数一样，分的糖果数必须一样<br>​    返回至少需要分多少糖</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>和原题基本一样通过两次遍历，先满足比左邻居的大，再遍历一次 满足比右边邻居的大。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(ratings.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> N = ratings.length;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       left[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i &lt; N;i++)&#123;</span><br><span class="line">           left[i] = ratings[i] &gt; ratings[i-<span class="number">1</span>]?left[i-<span class="number">1</span>]+<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       right[N-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = N-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">           right[j] = ratings[j] &gt; ratings[j+<span class="number">1</span>] ? right[j+<span class="number">1</span>]+<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">           res += Math.max(left[i],right[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 24 不相邻的最大子序列和</title>
      <link href="/2020/08/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-25-Problem-24-%E4%B8%8D%E7%9B%B8%E9%82%BB%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
      <url>/2020/08/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-25-Problem-24-%E4%B8%8D%E7%9B%B8%E9%82%BB%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    返回一个数组中，选择的数字不能相邻的情况下，最大子序列累加和</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这种子序列，首选DP，不相邻只是一个限制条件。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNotNearMaxSub</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || N ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = arr[arr.length-<span class="number">2</span>] &gt; arr[arr.length-<span class="number">1</span>] ? arr[arr.length-<span class="number">2</span>] :arr[arr.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> next_next = arr[arr.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = arr[N-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N-<span class="number">3</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp_next = next;</span><br><span class="line">            next = Math.max(Math.max(next,next_next + arr[i]),arr[i]); <span class="comment">//求当前dp对应的值，提前更新迭代，正好存下来</span></span><br><span class="line">            next_next = temp_next;</span><br><span class="line">            res = Math.max(res,next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 23 最大子矩阵和</title>
      <link href="/2020/08/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-22-Problem-23-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C/"/>
      <url>/2020/08/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-22-Problem-23-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    返回一个二维数组中，子矩阵最大累加和</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>子矩阵的最大累加和，子矩阵是任意的一个。做这种题目就是要想办法从某一个方向入手，能去枚举可能性。子矩阵可以分为以第一行为底的矩阵，第二行为底的子矩阵，第三行为底的子矩阵。同时我们想，在纵方向上进行累加起来，比如第一行和第二行的值累加成一个数组，此时这个数组的最大连续子数组实际就是以第二行为底，高为2的矩阵中，最大的子矩阵。通过枚举所有的子矩阵，利用寻找最大连续子数组的方式就可以找到最大的连续子矩阵。</li><li>整体思路就是 矩阵压缩+最大连续子数组</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getMaxMatrix(<span class="keyword">int</span>[][] matrix)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> r1 = <span class="number">0</span>,c1 = <span class="number">0</span>,r2 = <span class="number">0</span>,c2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = matrix.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> M = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>;start &lt; N;start++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">                sum[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> end = start;end &lt; N;end++)&#123;</span><br><span class="line">                sum[<span class="number">0</span>] += matrix[end][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> pre = sum[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> pre_srart = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; M;j++)&#123;</span><br><span class="line">                    sum[j] += matrix[end][j];</span><br><span class="line">                  <span class="keyword">if</span>(pre+sum[j] &gt; sum[j])&#123;</span><br><span class="line">                      pre = pre+sum[j];</span><br><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                      pre = sum[j];</span><br><span class="line">                      pre_srart = j;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span>(pre &gt; res)&#123;</span><br><span class="line">                      res = pre;</span><br><span class="line">                      r1 = start;</span><br><span class="line">                      c1 = pre_srart;</span><br><span class="line">                      r2 = end;</span><br><span class="line">                      c2 = j;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r1,c1,r2,c2&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 22 子数组最大累积和</title>
      <link href="/2020/08/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-22-Problem-22-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E7%A7%AF%E5%92%8C/"/>
      <url>/2020/08/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-22-Problem-22-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E7%A7%AF%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    返回一个数组中，子数组最大累加和</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题目就太常见了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max_subarr_sum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            pre = Math.max(arr[i],arr[i]+pre);</span><br><span class="line">            res = Math.max(res,pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 21 设计查询区间上目标数个数</title>
      <link href="/2020/08/19/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-19-Problem-21-%E8%AE%BE%E8%AE%A1%E6%9F%A5%E8%AF%A2%E5%8C%BA%E9%97%B4%E4%B8%8A%E7%9B%AE%E6%A0%87%E6%95%B0%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/08/19/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-19-Problem-21-%E8%AE%BE%E8%AE%A1%E6%9F%A5%E8%AF%A2%E5%8C%BA%E9%97%B4%E4%B8%8A%E7%9B%AE%E6%A0%87%E6%95%B0%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>数组为{3, 2, 2, 3, 1}，查询为(0, 3, 2)，意思是在数组里下标0~3这个范围上，有几个2？答案返回2。<br>假设给你一个数组arr，对这个数组的查询非常频繁，都给出来。</p><p>请返回 所有查询的结果</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>数据结构的题目 通常都是考察某种思想，而且这种思想 在工作中，碰到的各种组建都会有应用到的地方，是可以落地使用的。</li><li>此题可以用一种反向索引表，也就是key是待查的元素，v是一个list，存的是递增的index。查找时可以在list上用二分查找。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Finder</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] num;</span><br><span class="line">        HashMap&lt;Integer, List&lt;Integer&gt;&gt;  re_index;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">            num = Arrays.copyOfRange(arr,<span class="number">0</span>,arr.length);</span><br><span class="line">            re_index = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(re_index.containsKey(num[i]) ) &#123;</span><br><span class="line">                    re_index.get(num[i]).add(i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    list.add(i);</span><br><span class="line">                    re_index.put(num[i],list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> elem)</span></span>&#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;Integer&gt; list = re_index.get(elem);</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> a = binarySearch(list, l);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> b = binarySearch(list, r + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> b-a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Integer&gt; list,<span class="keyword">int</span> elem)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>,r = list.size()-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(list.get(mid) &gt;= elem)</span><br><span class="line">                    r = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list.get(l) &gt;= elem ? l:l+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Finder finder = <span class="keyword">new</span> Finder();</span><br><span class="line">            finder.build(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;);</span><br><span class="line">            System.out.println(finder.find(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 20 距离K的树节点</title>
      <link href="/2020/08/18/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-18-Problem-20-%E8%B7%9D%E7%A6%BBK%E7%9A%84%E6%A0%91%E8%8A%82%E7%82%B9/"/>
      <url>/2020/08/18/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-18-Problem-20-%E8%B7%9D%E7%A6%BBK%E7%9A%84%E6%A0%91%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定三个参数：<br>二叉树的头节点head，树上某个节点target，正数K<br>从target开始，可以向上走或者向下走，返回与target的距离是K的所有节点    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>可以往上走，那就是3个方向，找距离为K的，那不就是图的bfs吗。所以说思路要打开。树是不带父亲的路径的，需要自己用有序表存一下。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getKDistanceNodes</span><span class="params">(Node root, Node target, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Node, Node&gt; parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Node&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="keyword">null</span>,parent);</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">int</span> next_step = <span class="number">0</span>,next_batch = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        queue.add(target);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp_count = <span class="number">0</span>,temp_next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp_count &lt; next_batch)&#123;</span><br><span class="line">                <span class="keyword">final</span> Node node = queue.poll();</span><br><span class="line">                visited.add(node);</span><br><span class="line">                <span class="keyword">if</span>(next_step == K)&#123;</span><br><span class="line">                    list.add(node);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span> &amp;&amp; !visited.contains(node.left))&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                    temp_next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span> &amp;&amp; !visited.contains(node.right))&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                    temp_next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(parent.get(node) != <span class="keyword">null</span> &amp;&amp; !visited.contains(parent.get(node)))&#123;</span><br><span class="line">                    queue.add(parent.get(node));</span><br><span class="line">                    temp_next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp_count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(next_step == K) <span class="keyword">break</span>;</span><br><span class="line">            next_step++;</span><br><span class="line">            next_batch =temp_next_batch;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node cur,Node parent,Map&lt;Node,Node&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(cur,parent);</span><br><span class="line">            dfs(cur.left,cur,map);</span><br><span class="line">            dfs(cur.right,cur,map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 19</title>
      <link href="/2020/08/14/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-14-Problem-19-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/"/>
      <url>/2020/08/14/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-14-Problem-19-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode 自由之路</p><p>​    <a href="https://leetcode.com/problems/freedom-trail/" target="_blank" rel="noopener">https://leetcode.com/problems/freedom-trail/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Problem 18 最接近sum的子序列累加和问题</title>
      <link href="/2020/08/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-12-Problem-18-%E6%9C%80%E6%8E%A5%E8%BF%91sum%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E7%B4%AF%E5%8A%A0%E5%92%8C%E9%97%AE%E9%A2%98md/"/>
      <url>/2020/08/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-12-Problem-18-%E6%9C%80%E6%8E%A5%E8%BF%91sum%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E7%B4%AF%E5%8A%A0%E5%92%8C%E9%97%AE%E9%A2%98md/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode 最接近sum的子序列累加和问题</p><p>​    <a href="https://leetcode.com/problems/closest-subsequence-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/closest-subsequence-sum/</a></p><p>​    3节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Problem 17 最少坐船数</title>
      <link href="/2020/08/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-12-Problem-17-%E6%9C%80%E5%B0%91%E5%9D%90%E8%88%B9%E6%95%B0md/"/>
      <url>/2020/08/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-12-Problem-17-%E6%9C%80%E5%B0%91%E5%9D%90%E8%88%B9%E6%95%B0md/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个正数数组arr，代表若干人的体重. 再给定一个正数limit，表示所有船共同拥有的载重量 每艘船最多坐两人，且不能超过载重 ,想让所有的人同时过河，并且用最好的分配方法让船尽量少。返回最少的船数</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>上道题目是同向的双指针，这就是对撞型的。尽可能少的，那就是让胖的尽可能捎带一个小的，稍不过来就单独成船。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getShipCout</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>,j = arr.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[j] &gt; limit)&#123;</span><br><span class="line">               <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (arr[i] + arr[j] &gt; limit ) &#123;</span><br><span class="line">               j--;</span><br><span class="line">               c++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               i++;</span><br><span class="line">               j--;</span><br><span class="line">               c++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(i == j) c++;</span><br><span class="line">       <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 16 最多比赛数</title>
      <link href="/2020/08/09/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-09-Problem-16-%E6%9C%80%E5%A4%9A%E6%AF%94%E8%B5%9B%E6%95%B0/"/>
      <url>/2020/08/09/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-09-Problem-16-%E6%9C%80%E5%A4%9A%E6%AF%94%E8%B5%9B%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个数组arr，代表每个人的能力值。再给定一个非负数k 如果两个人能力差值正好为k，那么可以凑在一起比赛 一局比赛只有两个人<br>返回最多可以同时有多少场比赛。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>双指针。注意双指针常用法有同向，也有对撞的。相差k，肯定是一个大，一个小呀，所以排序一下，用大的减小的为K，同时注意标记 。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">TotalGeme</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>,R = <span class="number">0</span>,N = arr.length,res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length];</span><br><span class="line">        <span class="keyword">while</span> (L &lt; N &amp;&amp; R &lt; N)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[L]) &#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">                    R++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[R] - arr[L] == k)&#123;</span><br><span class="line">                        used[L] = <span class="keyword">true</span>;</span><br><span class="line">                        used[R] = <span class="keyword">true</span>;</span><br><span class="line">                        L++;</span><br><span class="line">                        R++;</span><br><span class="line">                        res++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[R] - arr[L] &gt; k)&#123;</span><br><span class="line">                        L++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        R++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 15 最大正方形</title>
      <link href="/2020/08/07/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-07-Problem-15-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
      <url>/2020/08/07/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-07-Problem-15-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个只有0和1组成的二维数组,返回边框全是1的最大正方形面积</p><p>​    leetcode:<a href="https://leetcode.com/problems/largest-1-bordered-square/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-1-bordered-square/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>先来分析一下。求的是边框是1，是空心的。没有任何知识点的提示，那就从从数据规模上看，N的3次方是能满足的。所以我们不妨用暴力来做。</li><li>枚举长方形是 N的4次方，枚举正方形是N的3次方，此外，枚举完了正方形 我们还要判定是不是边框是1，不能再增加阶数了，我们希望是在常数操作下就可以判断出来，当然想到预处理.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largest1BorderedSquare</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = grid.length;</span><br><span class="line">        <span class="keyword">int</span> N = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (M == <span class="number">0</span> || N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//预处理数组，下1的个数,右1的个数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] downNum = <span class="keyword">new</span> <span class="keyword">int</span>[M][N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            downNum[M-<span class="number">1</span>][i]  = grid[M-<span class="number">1</span>][i] == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = M-<span class="number">2</span>;i &gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span> ;j &lt; N;j++)&#123;</span><br><span class="line">                downNum[i][j] = grid[i][j] == <span class="number">1</span> ? downNum[i+<span class="number">1</span>][j]+<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] rightNum = <span class="keyword">new</span> <span class="keyword">int</span>[M][N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            rightNum[i][N-<span class="number">1</span>]= grid[i][N-<span class="number">1</span>] == <span class="number">1</span>?<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = N-<span class="number">2</span>;j &gt;= <span class="number">0</span>;j --)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M;i++)&#123;</span><br><span class="line">                rightNum[i][j] =grid[i][j] == <span class="number">0</span>? <span class="number">0</span>:rightNum[i][j+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> border = <span class="number">1</span>; border &lt;= Math.min(N-j,M-i);border++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(downNum[i][j] &lt; border || rightNum[i][j] &lt; border)</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(rightNum[i+border-<span class="number">1</span>][j] &lt; border)</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(downNum[i][j+border-<span class="number">1</span>] &lt; border)</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            res = Math.max(res,border*border);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 13 字符串种类</title>
      <link href="/2020/08/04/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-04-Problem-13-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%8D%E7%B1%BB/"/>
      <url>/2020/08/04/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-04-Problem-13-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%8D%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    只由小写字母（a~z）组成的一批字符串 都放在字符类型的数组String[] arr中 如果其中某两个字符串所含有的字符种类完全一样 就将两个字符串算作一类 比如：baacbba和bac就算作一类 返回arr中有多少类？</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>很容易想到，一个字符串用一个map表来表示只与种类有关。但实际上26个字母，26位 利用一个整数就可以表示。所以有几个整数就是有几类。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countKind</span><span class="params">(String[] strings)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">            set.add(getInt(strings[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">getInt</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = string.charAt(i)-<span class="string">'a'</span>;</span><br><span class="line">            res |= <span class="number">1</span>&lt;&lt;index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Bit Manipulate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 12</title>
      <link href="/2020/07/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-31-Problem-14/"/>
      <url>/2020/07/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-31-Problem-14/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Problem 12 整体有序的最小子数组</title>
      <link href="/2020/07/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-29-Problem-12-%E6%95%B4%E4%BD%93%E6%9C%89%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2020/07/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-29-Problem-12-%E6%95%B4%E4%BD%93%E6%9C%89%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个数组arr，只能对arr中的一个子数组排序，但是想让arr整体都有序 返回满足这一设定的子数组中，最短的是多长。</p><p>leetcode 链接:<a href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/shortest-unsorted-continuous-subarray/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典题目，简单分析一下，假设第一个元素比最后一个元素大，降序，那只能整体排序。如果第一个元素不是最小的，最后一个元素也不是最大的，他们都得参与排序，那么整体也得排序。</li><li>推广一下，也就是，对于当前元素 只有右面存在一个元素比我小就完蛋，当前元素就得参与排序，同理，左边有一个比我大的，就完蛋 我一样得参与排序，这就有了，我们分别从左边遍历，找到最后一个需要参与排序的元素， 从右面遍历找到参与排序的第一个元素，搞定！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinSubLen</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> max_l = nums[<span class="number">0</span>],index_l = <span class="number">0</span>,min_r = nums[nums.length-<span class="number">1</span>],index_r = nums.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i] &gt;= max_l )&#123;</span><br><span class="line">               max_l = nums[i];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               index_l = i;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>-i] &lt;= min_r)&#123;</span><br><span class="line">               min_r = nums[nums.length-<span class="number">1</span>-i];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               index_r = nums.length-<span class="number">1</span>-i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> index_l - index_r + <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span>: index_l - index_r + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 11 设计setAll</title>
      <link href="/2020/07/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-28-Problem-11-%E8%AE%BE%E8%AE%A1setAll/"/>
      <url>/2020/07/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-28-Problem-11-%E8%AE%BE%E8%AE%A1setAll/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    设计有setAll功能的哈希表</p><p>​    put、get、setAll方法，时间复杂度O(1)</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>考察思想 “版本”，利用时间戳做版本的思想。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValue</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> V value;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyValue</span><span class="params">(V v, <span class="keyword">long</span> t)</span> </span>&#123;</span><br><span class="line">value = v;</span><br><span class="line">time = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HashMap&lt;K, MyValue&lt;V&gt;&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"><span class="keyword">private</span> MyValue&lt;V&gt; setAll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">time = <span class="number">0</span>;</span><br><span class="line">setAll = <span class="keyword">new</span> MyValue&lt;V&gt;(<span class="keyword">null</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">map.put(key, <span class="keyword">new</span> MyValue&lt;V&gt;(value, time++));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAll</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">setAll = <span class="keyword">new</span> MyValue&lt;V&gt;(value, time++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (map.get(key).time &gt; setAll.time) &#123;</span><br><span class="line"><span class="keyword">return</span> map.get(key).value;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> setAll.value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 10 司机调度</title>
      <link href="/2020/07/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-26-Problem-10-%E5%8F%B8%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
      <url>/2020/07/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-26-Problem-10-%E5%8F%B8%E6%9C%BA%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    现有司机N*2人，调度中心会将所有司机平分给A、B两个区域<br>​            第 i 个司机去A可得收入为income[i][0]，<br>​            第 i 个司机去B可得收入为income[i][1]，<br>返回所有调度方案中能使所有司机总收入最高的方案，是多少钱</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>最优解，一般考虑贪心 、dp。这个题实际贪心就可以。主要找出贪心策略，同一个人去A可能钱很多，去B可能钱也很多，那去A去B对这个人来说关系不大，而另一个人 去A钱很多，而去B钱很少，为了整体最优，去A的人当然优选第二个人，所以策略就来了。数组排序，排序策略是 income[i][0] - income[i][1] 降序。说明越大的 越适合去A，这样前N个去A，后N个去B即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxMoney</span><span class="params">(<span class="keyword">int</span>[][] income)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = income.length;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">arr[i] = income[i][<span class="number">1</span>] - income[i][<span class="number">0</span>];</span><br><span class="line">sum += income[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">int</span> M = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= M; i--) &#123;</span><br><span class="line">sum += arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 9 数据流问题</title>
      <link href="/2020/07/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-23-Problem-9-%E6%95%B0%E6%8D%AE%E6%B5%81%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-23-Problem-9-%E6%95%B0%E6%8D%AE%E6%B5%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    已知一个消息流会不断地吐出整数 1~N，但不一定按照顺序依次吐出 如果上次打印的序号为i， 那么当i+1出现时 请打印 i+1 及其之后接收过的并且连续的所有数 直到1~N全部接收并打印完<br>请设计这种接收并打印的结构。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典题目。大思路就是构建头链表，构建尾链表，来一个元素就要去头链中 拽出来前面的元素，同时检查这个元素是否在尾链中，同理也要尝试拽尾链中的元素。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> key;</span><br><span class="line">       String info;</span><br><span class="line">       Node next;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String info)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.info = info;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Browse</span></span>&#123;</span><br><span class="line">       <span class="keyword">static</span> HashMap&lt;Integer,Node&gt; head;</span><br><span class="line">       <span class="keyword">static</span> HashMap&lt;Integer,Node&gt; tail;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> waitNo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           head = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           tail = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">           <span class="comment">//检查前面有没有尾巴和它连</span></span><br><span class="line">           <span class="keyword">if</span>(tail.containsKey(node.key-<span class="number">1</span>))&#123;</span><br><span class="line">               tail.get(node.key-<span class="number">1</span>).next = node;</span><br><span class="line">               tail.remove(node.key-<span class="number">1</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123; <span class="comment">//</span></span><br><span class="line">               head.put(node.key,node);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//检查有没有下面的头和它相连</span></span><br><span class="line">           <span class="keyword">if</span>(head.containsKey(node.key+<span class="number">1</span>))&#123;</span><br><span class="line">               node.next = head.get(node.key+<span class="number">1</span>);</span><br><span class="line">               head.remove(node.key+<span class="number">1</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               tail.put(node.key,node);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(waitNo == node.key)&#123;</span><br><span class="line">               print(node);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">           head.remove(node.key);</span><br><span class="line">           String str = <span class="string">""</span> + node.info;</span><br><span class="line">           waitNo++;</span><br><span class="line">           <span class="keyword">while</span> (node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">               str += node.next.info + <span class="string">" "</span>;</span><br><span class="line">               waitNo++;</span><br><span class="line">               node = node.next;</span><br><span class="line">           &#125;</span><br><span class="line">           tail.remove(node.key);</span><br><span class="line">           System.out.println(str);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Browse box = <span class="keyword">new</span> Browse();</span><br><span class="line"></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">2</span>,<span class="string">"B"</span>)); <span class="comment">// - 2"</span></span><br><span class="line">       System.out.println(<span class="string">"这是2来到的时候"</span>);</span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">1</span>,<span class="string">"A"</span>)); <span class="comment">// 1 2 -&gt; print, trigger is 1</span></span><br><span class="line">       System.out.println(<span class="string">"这是1来到的时候"</span>);</span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">4</span>,<span class="string">"D"</span>)); <span class="comment">// - 4</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">5</span>,<span class="string">"E"</span>)); <span class="comment">// - 4 5</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">7</span>,<span class="string">"G"</span>)); <span class="comment">// - 4 5 - 7</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">8</span>,<span class="string">"H"</span>)); <span class="comment">// - 4 5 - 7 8</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">6</span>,<span class="string">"F"</span>)); <span class="comment">// - 4 5 6 7 8</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">3</span>,<span class="string">"C"</span>)); <span class="comment">// 3 4 5 6 7 8 -&gt; print, trigger is 3</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">9</span>,<span class="string">"I"</span>)); <span class="comment">// 9 -&gt; print, trigger is 9</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">10</span>,<span class="string">"J"</span>)); <span class="comment">// 10 -&gt; print, trigger is 10</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">12</span>,<span class="string">"L"</span>)); <span class="comment">// - 12</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">13</span>,<span class="string">"M"</span>)); <span class="comment">// - 12 13</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">11</span>,<span class="string">"K"</span>)); <span class="comment">// 11 12 13 -&gt; print, trigger is 11</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 8  可乐找零问题</title>
      <link href="/2020/07/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-22-Problem-8-%E5%8F%AF%E4%B9%90%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-22-Problem-8-%E5%8F%AF%E4%B9%90%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    贩卖机只支持硬币支付，且收退都只支持10 ，50，100三种面额<br>一次购买只能出一瓶可乐，且投钱和找零都遵循优先使用大钱的原则<br>需要购买的可乐数量是m，<br>其中手头拥有的10、50、100的数量分别为a、b、c<br>可乐的价格是x(x是10的倍数)<br>请计算出需要投入硬币次数？</p><p>2节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 7 最好收入问题</title>
      <link href="/2020/07/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-20-Problem-7-%E6%9C%80%E5%A5%BD%E6%94%B6%E5%85%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-20-Problem-7-%E6%9C%80%E5%A5%BD%E6%94%B6%E5%85%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定数组hard和money，长度都为N hard[i]表示i号的难度， money[i]表示i号工作的收入 ，给定数组ability，长度都为M，ability[j]表示j号人的能力 ，每一号工作，都可以提供无数的岗位，难度和收入都一样<br>但是人的能力必须&gt;=这份工作的难度，才能上班。<br>返回一个长度为M的数组ans，ans[j]表示j号人能获得的最好收入</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>先想一下 最简单的暴力，对每个人 我们去找到最好的工作，就得遍历所有的工作，为了减少遍历，我们可以事先把工作先按照收益升序，难度降序的方式排列起来，这样再对每个员工查找合适的工作时候，找到第一个难度可以胜任的工作就是满足要求的。那对每个员工，依然得从头去遍历数组，最差还是O(N^2^),再想办法优化一下 </li><li>想办法 避免回退！比如第一个人已经走到工作数组index = 5才胜任，对于第二个人，要是保证前5个工作一定是不合适的，那么就可以从index=5继续遍历了。其实把人提前按能力降序，再去遍历就是这个特点，因为涉及到排序 整个复杂度就是 O(N*logN),当然这个也可以用两个堆来代替。</li><li>其实还有更简洁的办法，我们想 同样难度下当然是工资越高越好，同样难度，工资小的那个工作直接丢掉。这样就可以直接在treemap里面，找到自己能适应的难度的工作就可以。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Position</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> hard;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> money;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Position</span><span class="params">(<span class="keyword">int</span> hard, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.hard = hard;</span><br><span class="line">            <span class="keyword">this</span>.money = money;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双堆 nlogn</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxProfit</span><span class="params">(<span class="keyword">int</span>[] hard,<span class="keyword">int</span>[] money,<span class="keyword">int</span>[] ability)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hard.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_profits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> PriorityQueue&lt;Position&gt; min_heap= <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a.hard-b.hard);</span><br><span class="line">        <span class="keyword">final</span> PriorityQueue&lt;Position&gt; max_heap= <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b.money - a.money);</span><br><span class="line">        Arrays.sort(ability);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hard.length; i++) &#123;</span><br><span class="line">            min_heap.add(<span class="keyword">new</span> Position(hard[i],money[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ability.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!min_heap.isEmpty() &amp;&amp; min_heap.peek().hard &lt;= ability[i])&#123;</span><br><span class="line">                max_heap.add(min_heap.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!max_heap.isEmpty())</span><br><span class="line">                max_profits += max_heap.peek().money;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_profits;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//法二：提前预处理，精简职位</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> money;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> hard;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">money = m;</span><br><span class="line">hard = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JobComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Job o1, Job o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1.hard != o2.hard ? (o1.hard - o2.hard) : (o2.money - o1.money);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getMoneys(Job[] job, <span class="keyword">int</span>[] ability) &#123;</span><br><span class="line">Arrays.sort(job, <span class="keyword">new</span> JobComparator());</span><br><span class="line"><span class="comment">// key : 难度   value：报酬</span></span><br><span class="line">TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">map.put(job[<span class="number">0</span>].hard, job[<span class="number">0</span>].money);</span><br><span class="line"><span class="comment">// pre : 上一份进入map的工作</span></span><br><span class="line">Job pre = job[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; job.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (job[i].hard != pre.hard &amp;&amp; job[i].money &gt; pre.money) &#123;</span><br><span class="line">pre = job[i];</span><br><span class="line">map.put(pre.hard, pre.money);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//最终的map 就是难度升序，并且对应的薪水也是升序的</span></span><br><span class="line"><span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[ability.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ability.length; i++) &#123;</span><br><span class="line"><span class="comment">// ability[i] 当前人的能力 &lt;= ability[i]  且离它最近的</span></span><br><span class="line">Integer key = map.floorKey(ability[i]);</span><br><span class="line">ans[i] = key != <span class="keyword">null</span> ? map.get(key) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 6 正负符号累加数字的方法数</title>
      <link href="/2020/07/17/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-17-Problem-6-%E6%AD%A3%E8%B4%9F%E7%AC%A6%E5%8F%B7%E7%B4%AF%E5%8A%A0%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0/"/>
      <url>/2020/07/17/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-17-Problem-6-%E6%AD%A3%E8%B4%9F%E7%AC%A6%E5%8F%B7%E7%B4%AF%E5%8A%A0%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个数组arr，你可以在每个数字之前决定+或者-  但是必须所有数字都参与 ,再给定一个数target，请问最后算出target的方法数是多少？</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>乍一看 ，典型的从左到右背包模型,可以给出dp的最优解。但实际上 想想看，这个target 可能是负的 ，dp[index][target]代表index到len-1的位置能组成target的方法数，这个target的变化值是很大的。所以直接做不合适。</li><li>既然直接做不合适，我们就想到去想办法转化题目<ul><li>首先想到 可以认为arr中都是非负数，因为即便是arr中有负数，比如[3,-4,2] 因为你能在每个数前面用+或者-号 所以[3,-4,2]其实和[3,4,2]达成一样的效果 那么我们就全把arr变成非负数，不会影响结果的</li><li>比如说给定一个数组, arr = [1, 2, 3, 4, 5] 并且 target = 3<br>其中一个方案是 : +1 -2 +3 -4 +5 = 3<br>该方案中取了正的集合为P = {1，3，5}<br>该方案中取了负的集合为N = {2，4}<br>所以任何一种方案，都一定有 sum(P) - sum(N) = target<br>现在我们来处理一下这个等式，把左右两边都加上sum(P) + sum(N)，那么就会变成如下：<br>sum(P) - sum(N) + sum(P) + sum(N) = target + sum(P) + sum(N)<br>2 * sum(P) = target + 数组所有数的累加和<br>sum(P) = (target + 数组所有数的累加和) / 2<br>也就是说，任何一个集合，只要累加和是(target + 数组所有数的累加和) / 2<br>那么就一定对应一种target的方式<br>也就是说，比如非负数组arr，target = 7, 而所有数累加和是11<br>求有多少方法组成7，其实就是求有多少种达到累加和(7+11)/2=9的方法</li><li>此外还可以添加一些 判定条件，如果arr都是非负数，并且所有数的累加和是sum，那么如果target&lt;sum，很明显没有任何方法可以达到target，可以直接返回0</li><li>arr内部的数组，不管怎么+和-，最终的结果都一定不会改变奇偶性  所以，如果所有数的累加和是sum</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : arr) &#123;</span><br><span class="line">sum += n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum &lt; target || ((target &amp; <span class="number">1</span>) ^ (sum &amp; <span class="number">1</span>)) != <span class="number">0</span> ? <span class="number">0</span> : subset2(arr, (target + sum) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求非负数组nums有多少个子集，累加和是s</span></span><br><span class="line"><span class="comment">// 二维动态规划</span></span><br><span class="line"><span class="comment">// 不用空间压缩</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">subset1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n = nums.length;</span><br><span class="line"><span class="comment">// dp[i][j] : nums前缀长度为i的所有子集，有多少累加和是j？</span></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][s + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// nums前缀长度为0的所有子集，有多少累加和是0？一个：空集</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] += dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][s];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间压缩</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">subset2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &gt;= n; i--) &#123;</span><br><span class="line">dp[i] += dp[i - n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[s];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 5 释放AOE</title>
      <link href="/2020/07/14/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-14-Problem-5-%E9%87%8A%E6%94%BEAOE/"/>
      <url>/2020/07/14/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-14-Problem-5-%E9%87%8A%E6%94%BEAOE/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个非负数组x和hp，长度都是N，再给定一个正数range  ,x有序，x[i]表示i号怪兽在x轴上的位置；hp[i]表示i号怪兽的血量  再给定一个正数range，表示如果法师释放技能的范围长度 被打到的每只怪兽损失1点血量。<br>返回要把所有怪兽血量清空，至少需要释放多少次AOE技能？</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>首先这个题目注意是双向释放技能，那不管怎么说，也得遍历一头一头的来杀死怪兽，那怎么杀死？要释放的技能尽可能少，只要让每个技能都发挥最大的效益就可以，既然双向释放技能，对于当前的怪兽，最好的杀死策略就是让怪兽正好位于技能释放的最左端！</li><li>优化点在于，我们释放技能在一个区间上减1，在区间上做操作，可以用线段树</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一:贪心 O(N^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinAoe1</span><span class="params">(<span class="keyword">int</span>[] x,<span class="keyword">int</span>[] hp,<span class="keyword">int</span> range)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = x.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightEdge = <span class="number">0</span>,rightCenter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hp[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//对当前怪兽，找到最右面能打到的地方</span></span><br><span class="line">                <span class="keyword">while</span> (rightCenter &lt;N &amp;&amp; x[rightCenter] - x[i] &lt;= range)&#123;</span><br><span class="line">                    rightCenter++;</span><br><span class="line">                &#125;</span><br><span class="line">                rightCenter = rightCenter-<span class="number">1</span>; <span class="comment">//右面释放AOE的位置</span></span><br><span class="line">                <span class="keyword">while</span> (rightEdge &lt; N &amp;&amp; x[rightEdge] - x[rightCenter] &lt;= range)&#123;</span><br><span class="line">                    rightEdge++;</span><br><span class="line">                &#125;</span><br><span class="line">                rightEdge = rightEdge-<span class="number">1</span>;</span><br><span class="line">                res += hp[i];</span><br><span class="line">                AoeBlood(hp,i,rightEdge,hp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AoeBlood</span><span class="params">(<span class="keyword">int</span>[] hp,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hp[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                hp[i] = hp[i] - num &gt; <span class="number">0</span> ? hp[i] - num  : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//方法二：因为涉及到区间删除，所以可以用线段树优化成O(N*logN)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] sum;</span><br><span class="line">        <span class="keyword">int</span>[] data;</span><br><span class="line">        <span class="keyword">int</span>[] lazy;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(<span class="keyword">int</span>[] x)</span> </span>&#123;</span><br><span class="line">            data = Arrays.copyOfRange(x, <span class="number">0</span>, x.length);</span><br><span class="line">            sum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span> * x.length];</span><br><span class="line">            lazy =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span> * x.length];</span><br><span class="line">            build(<span class="number">1</span>,<span class="number">0</span>,x.length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            lazy[index&lt;&lt;<span class="number">1</span>] += lazy[index];</span><br><span class="line">            lazy[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] += lazy[index];</span><br><span class="line">            sum[index&lt;&lt;<span class="number">1</span>] +=  (mid-l+<span class="number">1</span>)*lazy[index];</span><br><span class="line">            sum[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] +=  (r-mid)*lazy[index];</span><br><span class="line">            lazy[index] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">                sum[index] = data[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            build(index&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">            build((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">            sum[index] = sum[index&lt;&lt;<span class="number">1</span>] + sum[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l == L &amp;&amp; r ==R)&#123;</span><br><span class="line">                <span class="keyword">return</span> sum[index];</span><br><span class="line">            &#125;</span><br><span class="line">            pushDown(index,l,r);</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(R &lt;= mid)</span><br><span class="line">                <span class="keyword">return</span> query(index&lt;&lt;<span class="number">1</span>,l,mid,L,R);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(L &gt;= mid+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> query((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> query(index&lt;&lt;<span class="number">1</span>,l,mid,L,mid) + query((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> elem)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l == L &amp;&amp; r == R)&#123;</span><br><span class="line">                lazy[index] += elem;</span><br><span class="line">                sum[index] += elem * (r-l+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(R &lt;= mid)</span><br><span class="line">                add(index&lt;&lt;<span class="number">1</span>,l,mid,L,R,elem);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(L &gt;= mid+<span class="number">1</span>)</span><br><span class="line">                add((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R,elem);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                add(index&lt;&lt;<span class="number">1</span>,l,mid,L,mid,elem);</span><br><span class="line">                add((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,R,elem);</span><br><span class="line">            &#125;</span><br><span class="line">            sum[index] = sum[index&lt;&lt;<span class="number">1</span>] + sum[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinAoe2</span><span class="params">(<span class="keyword">int</span>[] x,<span class="keyword">int</span>[] hp,<span class="keyword">int</span> range)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> SegmentTree seg = <span class="keyword">new</span> SegmentTree(hp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> cur_hp = seg.query(<span class="number">1</span>, <span class="number">0</span>, x.length - <span class="number">1</span>, i, i);</span><br><span class="line">            <span class="keyword">if</span>(cur_hp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> center = i;</span><br><span class="line">                <span class="keyword">int</span> right = i;</span><br><span class="line">                <span class="keyword">while</span> (center &lt; x.length &amp;&amp; x[center]-x[i] &lt;= range) center++;</span><br><span class="line">                center--;</span><br><span class="line">                <span class="keyword">while</span> (right &lt; x.length &amp;&amp; x[right] - x[center] &lt;= range) right++;</span><br><span class="line">                right--;</span><br><span class="line">                seg.add(<span class="number">1</span>,<span class="number">0</span>,x.length-<span class="number">1</span>,i,right,-cur_hp);</span><br><span class="line">                res+= cur_hp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Greed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 4 最少交换次数</title>
      <link href="/2020/07/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-13-Problem-4-%E6%9C%80%E5%B0%91%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0/"/>
      <url>/2020/07/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-13-Problem-4-%E6%9C%80%E5%B0%91%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    一个数组中只有两种字符’G’和’B’，可以让所有的G都放在左侧，所有的B都放在右侧 或者可以让所有的G都放在右侧，所有的B都放在左侧但是只能在相邻字符之间进行交换操作，返回至少需要交换几次</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题其实很简单，就是怕被说辞给吓住了，G在左侧，因为是最少的交换，所以一定从左侧开始让G移动。这样求的G在左侧的最少移动次数。同理，求的B在左侧的最少移动次数，也就是G在右侧，比较这两种情况</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以让G在左，或者在右</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minSteps2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.equals(<span class="string">""</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> step1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> step2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> gi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'G'</span>) &#123; <span class="comment">// 当前的G，去左边   方案1</span></span><br><span class="line">step1 += i - (gi++);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 当前的B，去左边   方案2</span></span><br><span class="line">step2 += i - (bi++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.min(step1, step2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Greed </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 3 2的某次幂</title>
      <link href="/2020/07/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-12-Problem-3-2%E7%9A%84%E6%9F%90%E6%AC%A1%E5%B9%82/"/>
      <url>/2020/07/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-12-Problem-3-2%E7%9A%84%E6%9F%90%E6%AC%A1%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个非负整数num，如何不用循环语句，返回&gt;=num，并且离num最近的，2的某次方。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><p>考察位运算，不太好想。比如求<code>00001010</code>，求比它大的2的某次方,应该是<code>0010000</code>,实际上就是<code>00001111</code>加1，也就是说我们把原数最左侧的1的位置，右面全部变成1得到的就是答案。利用位运算，比如<code>00100000</code>,</p><ul><li>右移1次与原数或可得<code>00110000</code></li><li>再右移2次与原数或可得<code>00111100</code></li><li>再右移4次与原数或可得<code>00111111</code></li></ul><p>如果是<code>10000000</code>，经过上述的3步，也一定能变成<code>11111111</code>,所以对于int类型32位，我们按照上述步骤操作5次，不管原数是多大，一定能变成第一个1右侧全部是1的数字</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">n--;         <span class="comment">//特殊处理防止原数是2的某次幂，方便后续的统一处理</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 2 统计文件数量</title>
      <link href="/2020/07/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-08-Problem-2-%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%95%B0%E9%87%8F/"/>
      <url>/2020/07/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-08-Problem-2-%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个文件目录的路径，写一个函数统计这个目录下所有的文件数量并返回，隐藏文件也算，但是文件夹不算。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目说的很清楚了，考的就是一个简单的递归，使用一下文件相关的api即可。 </li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这个函数也会统计隐藏文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFileNumber</span><span class="params">(String folderPath)</span> </span>&#123;</span><br><span class="line">File root = <span class="keyword">new</span> File(folderPath);</span><br><span class="line"><span class="keyword">if</span> (!root.isDirectory() &amp;&amp; !root.isFile()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root.isFile()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Stack&lt;File&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">stack.add(root);</span><br><span class="line"><span class="keyword">int</span> files = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">File folder = stack.pop();</span><br><span class="line"><span class="keyword">for</span> (File next : folder.listFiles()) &#123;</span><br><span class="line"><span class="keyword">if</span> (next.isFile()) &#123;</span><br><span class="line">files++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (next.isDirectory()) &#123;</span><br><span class="line">stack.push(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 1 绳子压点问题</title>
      <link href="/2020/07/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-05-Problem-1-%E7%BB%B3%E5%AD%90%E5%8E%8B%E7%82%B9%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-05-Problem-1-%E7%BB%B3%E5%AD%90%E5%8E%8B%E7%82%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个有序数组arr，代表坐落在X轴上的点，给定一个正数K，代表绳子的长度<br>返回绳子最多压中几个点？<br>注意：即使绳子边缘处盖住点也算盖住。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>有一个比较容易想到的思路就是把绳子看成长度固定的滑动窗口就可以了，依次遍历每个点作为绳子左端点的情况下 能压住几个点即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoint</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> N = arr.length;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; N) &#123;</span><br><span class="line"><span class="keyword">while</span> (right &lt; N &amp;&amp; arr[right] - arr[left] &lt;= L) &#123;  <span class="comment">//扩展窗口，扫描绳子长度内的点</span></span><br><span class="line">right++;</span><br><span class="line">&#125;</span><br><span class="line">max = Math.max(max, right - (left++));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>412. Fizz Buzz </title>
      <link href="/2018/11/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-11-412-Fizz-Buzz/"/>
      <url>/2018/11/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-11-412-Fizz-Buzz/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/fizz-buzz/" target="_blank" rel="noopener">https://leetcode.com/problems/fizz-buzz/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em>a string array</em> <code>answer</code> <em>(<strong>1-indexed</strong>) where</em>:</p><ul><li><code>answer[i] == &quot;FizzBuzz&quot;</code> if <code>i</code> is divisible by <code>3</code> and <code>5</code>.</li><li><code>answer[i] == &quot;Fizz&quot;</code> if <code>i</code> is divisible by <code>3</code>.</li><li><code>answer[i] == &quot;Buzz&quot;</code> if <code>i</code> is divisible by <code>5</code>.</li><li><code>answer[i] == i</code> (as a string) if none of the above conditions are true.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 5</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 15</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;7&quot;,&quot;8&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;11&quot;,&quot;Fizz&quot;,&quot;13&quot;,&quot;14&quot;,&quot;FizzBuzz&quot;]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>考察会不会编程</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">3</span>==<span class="number">0</span> &amp;&amp; (i+<span class="number">1</span>) %<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(<span class="string">"Fizz"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(<span class="string">"Buzz"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                list.add((i+<span class="number">1</span>)+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>395. Longest Substring with At Least K Repeating Characters</title>
      <link href="/2018/11/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-11-395-Longest-Substring-with-At-Least-K-Repeating-Characters/"/>
      <url>/2018/11/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-11-395-Longest-Substring-with-At-Least-K-Repeating-Characters/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> and an integer <code>k</code>, return <em>the length of the longest substring of</em> <code>s</code> <em>such that the frequency of each character in this substring is greater than or equal to</em> <code>k</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aaabb&quot;, k &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest substring is &quot;aaa&quot;, as &#39;a&#39; is repeated 3 times.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ababbc&quot;, k &#x3D; 2</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest substring is &quot;ababb&quot;, as &#39;a&#39; is repeated 2 times and &#39;b&#39; is repeated 3 times.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> consists of only lowercase English letters.</li><li><code>1 &lt;= k &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>乍一看 特像滑动窗口对吧，直接用，一会发现，窗口结束不了，比如说，L =  0，R取扫描，对于abbbcccdefg    k =2的情况，明明只要L=1，R = 6位置就能得到答案的，结果R = 6，不满足条件啊，因为a还不够2啊，所以R 继续扫，又引入了新的字符，永远满足不了条件！</li><li>这个窗口不能直接用，就是因为你会不断的引入新字符，你得给认为的中断！比如讲，每次用窗口，认为的规定字符种类就必须是2种，那么遇到c的时候 L必须前移！</li><li>好好体会这道 窗口不能直接用的题目！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">//<span class="doctag">TODO:</span>做的还是慢</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">26</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">           <span class="keyword">int</span> kind = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (p1 &lt; chars.length)&#123;</span><br><span class="line">               <span class="keyword">while</span> (p2 &lt; chars.length)&#123;</span><br><span class="line">                   <span class="keyword">int</span> expect = chars[p2]-<span class="string">'a'</span>;</span><br><span class="line">                   <span class="keyword">if</span>(visited[expect] == <span class="number">0</span>)&#123;</span><br><span class="line">                       <span class="keyword">if</span>(kind+<span class="number">1</span> &gt; i)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                       kind++;</span><br><span class="line">                       set.add(expect);</span><br><span class="line">                   &#125;</span><br><span class="line">                   visited[expect]++;</span><br><span class="line">                   p2++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(kind == i)&#123;</span><br><span class="line">                   <span class="keyword">final</span> Iterator&lt;Integer&gt; iterator = set.iterator();</span><br><span class="line">                   <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                       <span class="keyword">final</span> Integer next = iterator.next();</span><br><span class="line">                       <span class="keyword">if</span>(visited[next] &lt; k)&#123;</span><br><span class="line">                           flag = <span class="keyword">false</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                       res = Math.max(res,p2-p1);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(--visited[chars[p1]-<span class="string">'a'</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                   kind--;</span><br><span class="line">                   set.remove(chars[p1]-<span class="string">'a'</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               p1++;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>387. First Unique Character in a String</title>
      <link href="/2018/11/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-11-387-First-Unique-Character-in-a-String/"/>
      <url>/2018/11/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-11-387-First-Unique-Character-in-a-String/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">https://leetcode.com/problems/first-unique-character-in-a-string/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code>, <em>find the first non-repeating character in it and return its index</em>. If it does not exist, return <code>-1</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcode&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;loveleetcode&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aabb&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s</code> consists of only lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>无</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            map[chars[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[chars[i]] == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>384. Shuffle an Array</title>
      <link href="/2018/11/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-11-384-Shuffle-an-Array/"/>
      <url>/2018/11/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-11-384-Shuffle-an-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/shuffle-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/shuffle-an-array/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, design an algorithm to randomly shuffle the array. All permutations of the array should be <strong>equally likely</strong> as a result of the shuffling.</p><p>Implement the <code>Solution</code> class:</p><ul><li><code>Solution(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li><li><code>int[] reset()</code> Resets the array to its original configuration and returns it.</li><li><code>int[] shuffle()</code> Returns a random shuffling of the array.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;, &quot;shuffle&quot;, &quot;reset&quot;, &quot;shuffle&quot;]</span><br><span class="line">[[[1, 2, 3]], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Solution solution &#x3D; new Solution([1, 2, 3]);</span><br><span class="line">solution.shuffle();    &#x2F;&#x2F; Shuffle the array [1,2,3] and return its result.</span><br><span class="line">                       &#x2F;&#x2F; Any permutation of [1,2,3] must be equally likely to be returned.</span><br><span class="line">                       &#x2F;&#x2F; Example: return [3, 1, 2]</span><br><span class="line">solution.reset();      &#x2F;&#x2F; Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]</span><br><span class="line">solution.shuffle();    &#x2F;&#x2F; Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 50</code></li><li><code>-106 &lt;= nums[i] &lt;= 106</code></li><li>All the elements of <code>nums</code> are <strong>unique</strong>.</li><li>At most <code>104</code> calls <strong>in total</strong> will be made to <code>reset</code> and <code>shuffle</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>利用随机交换就可以，注意踩坑.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cap;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        cap = Arrays.copyOf(nums, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(cap,cap.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] t = Arrays.copyOf(cap, cap.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t.length-<span class="number">1</span>; i&gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> loc = random.nextInt(i+<span class="number">1</span>);<span class="comment">//  踩坑</span></span><br><span class="line">            swap(t,i,loc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * int[] param_1 = obj.reset();</span></span><br><span class="line"><span class="comment"> * int[] param_2 = obj.shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>380. Insert Delete GetRandom O(1)</title>
      <link href="/2018/11/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-11-380-Insert-Delete-GetRandom-O-1/"/>
      <url>/2018/11/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-11-380-Insert-Delete-GetRandom-O-1/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="noopener">https://leetcode.com/problems/insert-delete-getrandom-o1/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement the <code>RandomizedSet</code> class:</p><ul><li><code>RandomizedSet()</code> Initializes the <code>RandomizedSet</code> object.</li><li><code>bool insert(int val)</code> Inserts an item <code>val</code> into the set if not present. Returns <code>true</code> if the item was not present, <code>false</code> otherwise.</li><li><code>bool remove(int val)</code> Removes an item <code>val</code> from the set if present. Returns <code>true</code> if the item was present, <code>false</code> otherwise.</li><li><code>int getRandom()</code> Returns a random element from the current set of elements (it’s guaranteed that at least one element exists when this method is called). Each element must have the <strong>same probability</strong> of being returned.</li></ul><p>You must implement the functions of the class such that each function works in <strong>average</strong> <code>O(1)</code> time complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">Output</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">RandomizedSet randomizedSet &#x3D; new RandomizedSet();</span><br><span class="line">randomizedSet.insert(1); &#x2F;&#x2F; Inserts 1 to the set. Returns true as 1 was inserted successfully.</span><br><span class="line">randomizedSet.remove(2); &#x2F;&#x2F; Returns false as 2 does not exist in the set.</span><br><span class="line">randomizedSet.insert(2); &#x2F;&#x2F; Inserts 2 to the set, returns true. Set now contains [1,2].</span><br><span class="line">randomizedSet.getRandom(); &#x2F;&#x2F; getRandom() should return either 1 or 2 randomly.</span><br><span class="line">randomizedSet.remove(1); &#x2F;&#x2F; Removes 1 from the set, returns true. Set now contains [2].</span><br><span class="line">randomizedSet.insert(2); &#x2F;&#x2F; 2 was already in the set, so return false.</span><br><span class="line">randomizedSet.getRandom(); &#x2F;&#x2F; Since 2 is the only number in the set, getRandom() will always return 2.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li>At most <code>2 * ``105</code> calls will be made to <code>insert</code>, <code>remove</code>, and <code>getRandom</code>.</li><li>There will be <strong>at least one</strong> element in the data structure when <code>getRandom</code> is called.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>数据结构题目，要求每个操作都是O(1)的，主要是删除操作，删掉之后就不连续了呀，那取随机值的时候，取到空就麻烦了，可以做一个映射表，记录索引，这时候就可以用交换操作代替直接删除，注意更新映射表，很有用的小技巧。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*<span class="number">100005</span>];</span><br><span class="line">     Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(val) != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        num[size++] = val;</span><br><span class="line">        map.put(val,size-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Integer loc = map.get(val);</span><br><span class="line">        <span class="keyword">if</span>(loc == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        map.remove(val);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (loc == size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(num,loc,size);</span><br><span class="line">        map.put(num[loc],loc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i = random.nextInt(size);</span><br><span class="line">        <span class="keyword">return</span> num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>454. 4Sum II</title>
      <link href="/2018/11/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-11-454-4Sum-II/"/>
      <url>/2018/11/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-11-454-4Sum-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/4sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/4sum-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The two tuples are:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>n == nums3.length</code></li><li><code>n == nums4.length</code></li><li><code>1 &lt;= n &lt;= 200</code></li><li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题告诉我们 还是要学会变通，4个数和为0的组合数几种，先前两个数组组合，后两个数组组合，注意sum的种数，最后再两两组合。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.length; j++) &#123;</span><br><span class="line">sum = A[i] + B[j];</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(sum)) &#123;</span><br><span class="line">map.put(sum, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(sum, map.get(sum) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D.length; j++) &#123;</span><br><span class="line">sum = C[i] + D[j];</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(-sum)) &#123;</span><br><span class="line">ans += map.get(-sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>378. Kth Smallest Element in a Sorted Matrix</title>
      <link href="/2018/11/10/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-10-378-Kth-Smallest-Element-in-a-Sorted-Matrix/"/>
      <url>/2018/11/10/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-10-378-Kth-Smallest-Element-in-a-Sorted-Matrix/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>n x n</code> <code>matrix</code> where each of the rows and columns is sorted in ascending order, return <em>the</em> <code>kth</code> <em>smallest element in the matrix</em>.</p><p>Note that it is the <code>kth</code> smallest element <strong>in the sorted order</strong>, not the <code>kth</code> <strong>distinct</strong> element.</p><p>You must find a solution with a memory complexity better than <code>O(n2)</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,5,9],[10,11,13],[12,13,15]], k &#x3D; 8</span><br><span class="line">Output: 13</span><br><span class="line">Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[-5]], k &#x3D; 1</span><br><span class="line">Output: -5</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li><li>All the rows and columns of <code>matrix</code> are <strong>guaranteed</strong> to be sorted in <strong>non-decreasing order</strong>.</li><li><code>1 &lt;= k &lt;= n2</code></li></ul><p><strong>Follow up:</strong></p><ul><li>Could you solve the problem with a constant memory (i.e., <code>O(1)</code> memory complexity)?</li><li>Could you solve the problem in <code>O(n)</code> time complexity? The solution may be too advanced for an interview but you may find reading <a href="http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf" target="_blank" rel="noopener">this paper</a> fun.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题应用到了 之前矩阵二分那道题目的搜索过程，此外我们可以用二分去搜索可能存在的值，每次搜索都可以判断这个数值所在的至少的排名，可能会更前，只要每次都可以去掉一部分数据，最终就可以逼近到想要的数据。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> l = matrix[<span class="number">0</span>][<span class="number">0</span>],r = matrix[N-<span class="number">1</span>][N-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> real_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] res = find(matrix, mid);</span><br><span class="line">            <span class="keyword">if</span>(res[<span class="number">0</span>] == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> res[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (res[<span class="number">0</span>] &lt; k)&#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                real_num = res[<span class="number">1</span>];</span><br><span class="line">                r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> real_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] find(<span class="keyword">int</span>[][] m,<span class="keyword">double</span> num)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = m[<span class="number">0</span>].length-<span class="number">1</span>,res = <span class="number">0</span>,real_num = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m.length &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] &lt;= num)&#123;</span><br><span class="line">                real_num =Math.max(m[i][j],real_num);</span><br><span class="line">                res += j+<span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;res,real_num&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>371. Sum of Two Integers</title>
      <link href="/2018/11/10/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-10-371-Sum-of-Two-Integers/"/>
      <url>/2018/11/10/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-10-371-Sum-of-Two-Integers/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-of-two-integers/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integers <code>a</code> and <code>b</code>, return <em>the sum of the two integers without using the operators</em> <code>+</code> <em>and</em> <code>-</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 1, b &#x3D; 2</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 2, b &#x3D; 3</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-1000 &lt;= a, b &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>利用位运算做加法，其实很简单，你只要利用好真值表，表示出对应和的位运算操作，进位的位元算操作，就有了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>,elem1 = <span class="number">0</span>,elem2 = <span class="number">0</span>,jie = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">            elem1 = (a &gt;&gt; i)&amp;<span class="number">1</span>;</span><br><span class="line">            elem2 = (b &gt;&gt; i)&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = elem1 ^ elem2 ^ jie; <span class="comment">//当前位</span></span><br><span class="line">            jie =jie&amp;(elem1^elem2)|elem1&amp;elem2;</span><br><span class="line">            res |= (t&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>350. Intersection of Two Arrays II</title>
      <link href="/2018/11/10/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-10-350-Intersection-of-Two-Arrays-II/"/>
      <url>/2018/11/10/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-10-350-Intersection-of-Two-Arrays-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-arrays-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must appear as many times as it shows in both arrays and you may return the result in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">Output: [2,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">Output: [4,9]</span><br><span class="line">Explanation: [9,4] is also accepted.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目简单，但是可以学到东西，看下数值范围，拿数组存下，再次遍历只要数组元素大于0，就统计，统计完记得减掉一个 。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1005</span>];</span><br><span class="line">            <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> elem : nums1) &#123;</span><br><span class="line">              map[elem]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> elem : nums2) &#123;</span><br><span class="line">               <span class="keyword">if</span>(map[elem]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                   res[cnt++] = elem;</span><br><span class="line">                   map[elem]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(res,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>347. Top K Frequent Elements</title>
      <link href="/2018/11/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-09-347-Top-K-Frequent-Elements/"/>
      <url>/2018/11/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-09-347-Top-K-Frequent-Elements/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">https://leetcode.com/problems/top-k-frequent-elements/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li><li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>主要考察堆的典型Top K应用</li><li>先统计词频（小知识点），然后维护一个K的最小堆。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">num = k;</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1.count - o2.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">HashMap&lt;Integer, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(num)) &#123;</span><br><span class="line">map.put(num, <span class="keyword">new</span> Node(num));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.get(num).count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> CountComparator());</span><br><span class="line"><span class="keyword">for</span> (Node node : map.values()) &#123;</span><br><span class="line"><span class="keyword">if</span> (heap.size() &lt; k || (heap.size() == k &amp;&amp; node.count &gt; heap.peek().count)) &#123;</span><br><span class="line">heap.add(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">heap.poll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">ans[index++] = heap.poll().num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Heap </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>344. Reverse String</title>
      <link href="/2018/11/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-09-344-Reverse-String/"/>
      <url>/2018/11/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-09-344-Reverse-String/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/reverse-string/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-string/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p><p>You must do this by modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a> with <code>O(1)</code> extra memory.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>无</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = s[i];</span><br><span class="line">            s[i] = s[s.length-<span class="number">1</span>-i];</span><br><span class="line">            s[s.length-<span class="number">1</span>-i] = (<span class="keyword">char</span>)t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>341. Flatten Nested List Iterator</title>
      <link href="/2018/11/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-09-341-Flatten-Nested-List-Iterator/"/>
      <url>/2018/11/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-09-341-Flatten-Nested-List-Iterator/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>334. Increasing Triplet Subsequence</title>
      <link href="/2018/11/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-09-334-Increasing-Triplet-Subsequence/"/>
      <url>/2018/11/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-09-334-Increasing-Triplet-Subsequence/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/increasing-triplet-subsequence/" target="_blank" rel="noopener">https://leetcode.com/problems/increasing-triplet-subsequence/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, return <code>true</code> <em>if there exists a triple of indices</em> <code>(i, j, k)</code> <em>such that</em> <code>i &lt; j &lt; k</code> <em>and</em> <code>nums[i] &lt; nums[j] &lt; nums[k]</code>. If no such indices exists, return <code>false</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Any triplet where i &lt; j &lt; k is valid.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,4,3,2,1]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: No triplet exists.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,1,5,0,4,6]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The triplet (3, 4, 5) is valid because nums[3] &#x3D;&#x3D; 0 &lt; nums[4] &#x3D;&#x3D; 4 &lt; nums[5] &#x3D;&#x3D; 6.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题其实就是再问存不存在长度&gt;=3的递增子序列。首先普通dp方法是O(N^2)的肯定过不了。</li><li>使用end数组，这个在优化最长递增子序列问题时时O(N*logN),大概思路时 使用end数组,end[i]代表长度为i+1的最长递增子序列结尾的最小值，那么只要i推到2时候，就满足条件了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">//end[i] 代表 长度为i+1的子序列结尾的最小值</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = binarySearch(end, nums[i], c); <span class="comment">//c代表长度</span></span><br><span class="line">            <span class="keyword">if</span>(index == c) &#123; <span class="comment">//说明没找到，应该扩展</span></span><br><span class="line">                end[c++] = nums[i];</span><br><span class="line">                <span class="keyword">if</span>(c &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                end[index] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] end,<span class="keyword">int</span> x,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = t-<span class="number">1</span>,index = t;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(end[mid] &gt;= x)&#123;</span><br><span class="line">                index = mid;</span><br><span class="line">                r = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>329. Longest Increasing Path in a Matrix</title>
      <link href="/2018/11/07/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-07-329-Longest-Increasing-Path-in-a-Matrix/"/>
      <url>/2018/11/07/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-07-329-Longest-Increasing-Path-in-a-Matrix/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​     <a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-increasing-path-in-a-matrix/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> integers <code>matrix</code>, return <em>the length of the longest increasing path in</em> <code>matrix</code>.</p><p>From each cell, you can either move in four directions: left, right, up, or down. You <strong>may not</strong> move <strong>diagonally</strong> or move <strong>outside the boundary</strong> (i.e., wrap-around is not allowed).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[9,9,4],[6,6,8],[2,1,1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing path is [1, 2, 6, 9].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[3,4,5],[3,2,6],[2,2,1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= matrix[i][j] &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>遍历一下，配合上缓存，查找最长的路径即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dirx = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] diry = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> maxn = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; matrix[<span class="number">0</span>].length; i1++) &#123;</span><br><span class="line">                maxn = Math.max(maxn,process(matrix,i,i1,-<span class="number">1</span>, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> elem,<span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= matrix.length || j &lt; <span class="number">0</span> || j &gt;= matrix[<span class="number">0</span>].length||matrix[i][j] &lt;= elem) &#123; <span class="comment">//越界</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">4</span>;d++)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = process(matrix,i+dirx[d],j+diry[d],matrix[i][j],dp);</span><br><span class="line">                res = Math.max(t+<span class="number">1</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>328. Odd Even Linked List</title>
      <link href="/2018/11/06/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-06-328-Odd-Even-Linked-List/"/>
      <url>/2018/11/06/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-06-328-Odd-Even-Linked-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/odd-even-linked-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return <em>the reordered list</em>.</p><p>The <strong>first</strong> node is considered <strong>odd</strong>, and the <strong>second</strong> node is <strong>even</strong>, and so on.</p><p>Note that the relative order inside both the even and odd groups should remain as it was in the input.</p><p>You must solve the problem in <code>O(1)</code> extra space complexity and <code>O(n)</code> time complexity.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: [1,3,5,2,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [2,1,3,5,6,4,7]</span><br><span class="line">Output: [2,3,6,7,1,5,4]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the linked list is in the range <code>[0, 104]</code>.</li><li><code>-106 &lt;= Node.val &lt;= 106</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是遍历一趟把奇数的节点和偶数的节点分成两个链表</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next == <span class="keyword">null</span> || head.next.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode odd = head;</span><br><span class="line">        ListNode even_head = head.next;</span><br><span class="line">        ListNode even = head.next;</span><br><span class="line">        ListNode cur = even.next;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((step&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                odd.next = cur;</span><br><span class="line">                odd = odd.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                even.next = cur;</span><br><span class="line">                even = even.next;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">            cur= cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">       odd.next = even_head;</span><br><span class="line">        even.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>326. Power of Three</title>
      <link href="/2018/11/04/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-04-326-Power-of-Three/"/>
      <url>/2018/11/04/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-04-326-Power-of-Three/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/power-of-three/" target="_blank" rel="noopener">https://leetcode.com/problems/power-of-three/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em><code>true</code> if it is a power of three. Otherwise, return <code>false</code></em>.</p><p>An integer <code>n</code> is a power of three, if there exists an integer <code>x</code> such that <code>n == 3x</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 27</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 0</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 9</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= n &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>可以简单的模拟，也可以用打表法，打出在int范围内，3^x的最大值，那么只要被n整除，n就是3的某次方</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>324. Wiggle Sort II</title>
      <link href="/2018/11/04/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-04-324-Wiggle-Sort-II/"/>
      <url>/2018/11/04/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-04-324-Wiggle-Sort-II/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>322. Coin Change</title>
      <link href="/2018/11/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-01-322-Coin-Change/"/>
      <url>/2018/11/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-11-01-322-Coin-Change/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">https://leetcode.com/problems/coin-change/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p><p>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p><p>You may assume that you have an infinite number of each kind of coin.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [1,2,5], amount &#x3D; 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [1], amount &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>典型的DP。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = coins.length;</span><br><span class="line">        <span class="keyword">int</span> N = amount;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[M+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i++) dp[M][i] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = M-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= N;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span>(j-coins[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i][j-coins[i]] != Integer.MAX_VALUE)&#123;</span><br><span class="line">                    p1 =  dp[i][j-coins[i]]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> p2 = dp[i+<span class="number">1</span>][j];</span><br><span class="line">                dp[i][j] = Math.min(p1,p2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][N]==Integer.MAX_VALUE ? -<span class="number">1</span>:dp[<span class="number">0</span>][N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>315. Count of Smaller Numbers After Self</title>
      <link href="/2018/10/29/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-29-315-Count-of-Smaller-Numbers-After-Self/"/>
      <url>/2018/10/29/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-29-315-Count-of-Smaller-Numbers-After-Self/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">https://leetcode.com/problems/count-of-smaller-numbers-after-self/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>nums</code> and you have to return a new <code>counts</code> array. The <code>counts</code> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,2,6,1]</span><br><span class="line">Output: [2,1,1,0]</span><br><span class="line">Explanation:</span><br><span class="line">To the right of 5 there are 2 smaller elements (2 and 1).</span><br><span class="line">To the right of 2 there is only 1 smaller element (1).</span><br><span class="line">To the right of 6 there is 1 smaller element (1).</span><br><span class="line">To the right of 1 there is 0 smaller element.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,-1]</span><br><span class="line">Output: [0,0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>愚蠢了，没反应过来，一开始看成了，在他后面是第几小元素，实际人家问的是后面有几个比它小的，典型的逆序对，用归并排序去解决 。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeInfo</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeInfo</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"NodeInfo&#123;"</span> +</span><br><span class="line">                    <span class="string">"value="</span> + value +</span><br><span class="line">                    <span class="string">", index="</span> + index +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        NodeInfo[] nodes = <span class="keyword">new</span> NodeInfo[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nodes[i] = <span class="keyword">new</span> NodeInfo(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) list.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt; <span class="number">1</span>) <span class="keyword">return</span> list;</span><br><span class="line">        process(nodes,<span class="number">0</span>,nodes.length-<span class="number">1</span>,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(NodeInfo[] num,<span class="keyword">int</span> l,<span class="keyword">int</span> r,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        process(num,l,mid,list);</span><br><span class="line">        process(num,mid+<span class="number">1</span>,r,list);</span><br><span class="line">        merge(num,l,r,list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(NodeInfo[] num, <span class="keyword">int</span> l , <span class="keyword">int</span> r, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> NodeInfo[] t = <span class="keyword">new</span> NodeInfo[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = l,p2 = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[p2].value &gt;= num[p1].value)&#123;</span><br><span class="line">                list.set(num[p1].index,list.get(num[p1].index)+p2-mid-<span class="number">1</span>);</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid)&#123;</span><br><span class="line">            list.set(num[p1].index,list.get(num[p1].index)+r-mid);</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = l;</span><br><span class="line">        p2 = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[p1].value &lt; num[p2].value)&#123;</span><br><span class="line">                t[c++] = num[p1++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t[c++] = num[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid ) t[c++] = num[p1++];</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= r )   t[c++] = num[p2++];</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= r;i++)&#123;</span><br><span class="line">            num[i] = t[c++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Merge Sort </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>300. Longest Increasing Subsequence</title>
      <link href="/2018/10/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-28-300-Longest-Increasing-Subsequence/"/>
      <url>/2018/10/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-28-300-Longest-Increasing-Subsequence/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>297. Serialize and Deserialize Binary Tree</title>
      <link href="/2018/10/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-28-297-Serialize-and-Deserialize-Binary-Tree/"/>
      <url>/2018/10/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-28-297-Serialize-and-Deserialize-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/serialize-and-deserialize-binary-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p><strong>Clarification:</strong> The input/output format is the same as <a href="https://leetcode.com/faq/#binary-tree" target="_blank" rel="noopener">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,null,null,4,5]</span><br><span class="line">Output: [1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 104]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题目解"><a href="#题目解" class="headerlink" title="题目解"></a>题目解</h3><ul><li>树的序列化与反序列化，把null值用一个特殊符号代替即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        process(root,builder);</span><br><span class="line">        <span class="keyword">final</span> String str = builder.toString();</span><br><span class="line">        <span class="keyword">return</span> str.substring(<span class="number">0</span>,str.length()-<span class="number">1</span>); <span class="comment">//去掉最后一个#</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(TreeNode root,StringBuilder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            builder.append(<span class="string">"*#"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(root.val+<span class="string">"#"</span>);</span><br><span class="line">        process(root.left,builder);</span><br><span class="line">        process(root.right,builder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">""</span>.equals(data)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> String[] split = data.split(<span class="string">"#"</span>);</span><br><span class="line">        step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> unprocess(split);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">unprocess</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs[step].equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = Integer.parseInt(strs[step++]);</span><br><span class="line">            <span class="keyword">final</span> TreeNode cur = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">            cur.left = unprocess(strs);</span><br><span class="line">            cur.right = unprocess(strs);</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>295. Find Median from Data Stream</title>
      <link href="/2018/10/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-28-295-Find-Median-from-Data-Stream/"/>
      <url>/2018/10/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-28-295-Find-Median-from-Data-Stream/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">https://leetcode.com/problems/find-median-from-data-stream/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.</p><ul><li>For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.</li><li>For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li></ul><p>Implement the MedianFinder class:</p><ul><li><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.</li><li><code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.</li><li><code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10-5</code> of the actual answer will be accepted.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 1.5, null, 2.0]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MedianFinder medianFinder &#x3D; new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    &#x2F;&#x2F; arr &#x3D; [1]</span><br><span class="line">medianFinder.addNum(2);    &#x2F;&#x2F; arr &#x3D; [1, 2]</span><br><span class="line">medianFinder.findMedian(); &#x2F;&#x2F; return 1.5 (i.e., (1 + 2) &#x2F; 2)</span><br><span class="line">medianFinder.addNum(3);    &#x2F;&#x2F; arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); &#x2F;&#x2F; return 2.0</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-105 &lt;= num &lt;= 105</code></li><li>There will be at least one element in the data structure before calling <code>findMedian</code>.</li><li>At most <code>5 * 104</code> calls will be made to <code>addNum</code> and <code>findMedian</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>要求没输入一个数输出此前所有元素中的中位数，如果是偶数个元素，输出中间两个元素的平均值。</li><li>可以用BST，存下元素以及元素的个数、左子树的个数、右子树的个数，这样我们每次log级别的插入元素时候，是可以顺表数出来中位数的，But，BST最差会成链，所以还得改成AVL这种动态平衡的，那这个题就比较麻烦了，实际上我们只要最中间的两个数。</li><li>可以用堆，一个最大堆，保留前一半的数，一个最小堆保留后面的数。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span>  Queue&lt;Integer&gt; pre = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((a,b)-&gt;b-a);</span><br><span class="line">    <span class="keyword">public</span> Queue&lt;Integer&gt; post = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.isEmpty())&#123;</span><br><span class="line">            pre.add(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; pre.peek())&#123;</span><br><span class="line">            post.add(num);</span><br><span class="line">            <span class="keyword">if</span> (post.size() - pre.size() &gt; <span class="number">1</span>)</span><br><span class="line">                pre.add(post.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.add(num);</span><br><span class="line">            <span class="keyword">if</span> (pre.size() - post.size() &gt; <span class="number">1</span>)</span><br><span class="line">                post.add(pre.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.size() == post.size()) <span class="keyword">return</span> (pre.peek() + post.peek())*<span class="number">1.0</span>/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pre.size() &gt; post.size() ? pre.peek() : post.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Heap </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>289. Game of Life</title>
      <link href="/2018/10/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-28-289-Game-of-Life/"/>
      <url>/2018/10/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-28-289-Game-of-Life/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener">https://leetcode.com/problems/game-of-life/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    According to <a href="https://en.wikipedia.org/wiki/Conway&#39;s_Game_of_Life" target="_blank" rel="noopener">Wikipedia’s article</a>: “The <strong>Game of Life</strong>, also known simply as <strong>Life</strong>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p><p>The board is made up of an <code>m x n</code> grid of cells, where each cell has an initial state: <strong>live</strong> (represented by a <code>1</code>) or <strong>dead</strong> (represented by a <code>0</code>). Each cell interacts with its <a href="https://en.wikipedia.org/wiki/Moore_neighborhood" target="_blank" rel="noopener">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p><ol><li>Any live cell with fewer than two live neighbors dies as if caused by under-population.</li><li>Any live cell with two or three live neighbors lives on to the next generation.</li><li>Any live cell with more than three live neighbors dies, as if by over-population.</li><li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li></ol><p>The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the <code>m x n</code> grid <code>board</code>, return <em>the next state</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]</span><br><span class="line">Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[1,1],[1,0]]</span><br><span class="line">Output: [[1,1],[1,1]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 25</code></li><li><code>board[i][j]</code> is <code>0</code> or <code>1</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题，把题目读懂就不难，通过周围元素1的个数判断此元素的生死。</li><li>判断出此元素的生死，你还不能立即修改，因为，你该来会影响周围元素的判断呀，因为其实就是0和1代表生死，所以我们利用位元算，在权重为2的位置通过0和1来表示新状态。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        M = board.length;</span><br><span class="line">        N = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>,expect = <span class="number">0</span>; <span class="comment">//0不变，1取反</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">8</span>;d++)&#123;</span><br><span class="line">                    res +=getState(board,i+dir_x[d],j+dir_y[d]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; (res &lt;<span class="number">2</span> || res &gt; <span class="number">3</span>)) expect = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">0</span> &amp;&amp;res ==<span class="number">3</span>) expect = <span class="number">1</span>;</span><br><span class="line">                expect= (expect ^ board[i][j]);</span><br><span class="line">                board[i][j] = (expect&lt;&lt;<span class="number">1</span>)|board[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                board[i][j] &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">(<span class="keyword">int</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= M || j &lt;<span class="number">0</span> || j &gt;= N ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> board[i][j]&amp;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>287. Find the Duplicate Number</title>
      <link href="/2018/10/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-28-287-Find-the-Duplicate-Number/"/>
      <url>/2018/10/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-28-287-Find-the-Duplicate-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">https://leetcode.com/problems/find-the-duplicate-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.</p><p>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this repeated number</em>.</p><p>You must solve the problem <strong>without</strong> modifying the array <code>nums</code> and uses only constant extra space.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 105</code></li><li><code>nums.length == n + 1</code></li><li><code>1 &lt;= nums[i] &lt;= n</code></li><li>All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>利用数组的特性，让每个元素归位，就会找到重复元素。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[nums[i]-<span class="number">1</span>] == nums[i])</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                swap(nums,i,nums[i]-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>283. Move Zeroes</title>
      <link href="/2018/10/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-28-283-Move-Zeroes/"/>
      <url>/2018/10/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-28-283-Move-Zeroes/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/move-zeroes/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p><p><strong>Note</strong> that you must do this in-place without making a copy of the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>双指针交换即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p2 = <span class="number">0</span>; p2 &lt; nums.length; p2++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p2] != <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,p1++,p2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Two Pointers </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>239. Sliding Window Maximum</title>
      <link href="/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-239-Sliding-Window-Maximum/"/>
      <url>/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-239-Sliding-Window-Maximum/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>238. Product of Array Except Self</title>
      <link href="/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-238-Product-of-Array-Except-Self/"/>
      <url>/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-238-Product-of-Array-Except-Self/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">https://leetcode.com/problems/product-of-array-except-self/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.</p><p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p><p>You must write an algorithm that runs in <code>O(n)</code> time and without using the division operation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4]</span><br><span class="line">Output: [24,12,8,6]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,1,0,-3,3]</span><br><span class="line">Output: [0,0,9,0,0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目不难，我觉得这种小题就是好题，培养分析问题的思维。</li><li>提前构造一个辅助数组表示从右面的累成，然后从左遍历，保留左边的累成，这样就可以求出每个元素两边的累乘。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        suffix[nums.length-<span class="number">2</span>] = nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        suffix[nums.length-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = suffix.length-<span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            suffix[i] = suffix[i+<span class="number">1</span>] * nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            suffix[i] = suffix[i] * pre;</span><br><span class="line">            pre *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>237. Delete Node in a Linked List</title>
      <link href="/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-237-Delete-Node-in-a-Linked-List/"/>
      <url>/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-237-Delete-Node-in-a-Linked-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/delete-node-in-a-linked-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write a function to <strong>delete a node</strong> in a singly-linked list. You will <strong>not</strong> be given access to the <code>head</code> of the list, instead you will be given access to <strong>the node to be deleted</strong> directly.</p><p>It is <strong>guaranteed</strong> that the node to be deleted is <strong>not a tail node</strong> in the list.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/01/node1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [4,5,1,9], node &#x3D; 5</span><br><span class="line">Output: [4,1,9]</span><br><span class="line">Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/01/node2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [4,5,1,9], node &#x3D; 1</span><br><span class="line">Output: [4,5,9]</span><br><span class="line">Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of the nodes in the given list is in the range <code>[2, 1000]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li>The value of each node in the list is <strong>unique</strong>.</li><li>The <code>node</code> to be deleted is <strong>in the list</strong> and is <strong>not a tail</strong> node</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题确实有点取巧，耍小聪明来。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">          ListNode next = node.next;</span><br><span class="line">          node.val = next.val;</span><br><span class="line">          node.next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>236. Lowest Common Ancestor of a Binary Tree</title>
      <link href="/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-236-Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
      <url>/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-236-Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[2, 105]</code>.</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>All <code>Node.val</code> are <strong>unique</strong>.</li><li><code>p != q</code></li><li><code>p</code> and <code>q</code> will exist in the tree.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>最近公共祖先问题 LCA问题，也是经典的问题，简单的做法就是 求出跟几点到这个节点的路径，两条路径拿出来，再找第一个相交节点即可</li><li>高级的做法是树链剖分，这个数据结构比较复杂，专门出一章来解释，现在先用简单的做法。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> ArrayList&lt;TreeNode&gt; path1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="keyword">final</span> ArrayList&lt;TreeNode&gt; path2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          findX(path1,root,p.val);</span><br><span class="line">          findX(path2,root,q.val);</span><br><span class="line">          <span class="keyword">int</span> i = path1.size()-<span class="number">1</span>,j = path2.size() -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; path1.size() - path2.size();k++) i--;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; path2.size() - path1.size();k++) j--;</span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (;i &gt;=<span class="number">0</span>;i--,j--) <span class="keyword">if</span> (path1.get(i) == path2.get(j)) <span class="keyword">return</span> path1.get(i);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Integer <span class="title">findX</span><span class="params">(List&lt;TreeNode&gt; path,TreeNode root,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          path.add(root);</span><br><span class="line">          <span class="keyword">if</span> (root.val == t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(findX(path,root.left,t)==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(findX(path,root.right,t) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>234. Palindrome Linked List</title>
      <link href="/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-234-Palindrome-Linked-List/"/>
      <url>/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-234-Palindrome-Linked-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-linked-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a singly linked list, return <code>true</code> if it is a palindrome.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is in the range <code>[1, 105]</code>.</li><li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目就是判断链表是不是回文，你当然可以用容器存下来去判断，那这样肯定是不好的。经典的做法就是 ，找到中点或者上中点，下半段反转，两端进行遍历对比，判断完之后，给人家翻回来。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.val == head.next.val;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next; <span class="comment">//目的是上中点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode mid = slow; <span class="comment">//slow 为 mid or up mid</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        slow = mid.next;</span><br><span class="line">        mid.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = slow.next;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        slow = pre;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( slow!= <span class="keyword">null</span> &amp;&amp; fast.val == slow.val)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> res = slow == <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//修正</span></span><br><span class="line">        slow = pre; <span class="comment">//pre在最后一个节点</span></span><br><span class="line">        pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre =slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        mid.next = pre;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>279. Perfect Squares</title>
      <link href="/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-279-Perfect-Squares/"/>
      <url>/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-279-Perfect-Squares/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">https://leetcode.com/problems/perfect-squares/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em>the least number of perfect square numbers that sum to</em> <code>n</code>.</p><p>A <strong>perfect square</strong> is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, <code>1</code>, <code>4</code>, <code>9</code>, and <code>16</code> are perfect squares while <code>3</code> and <code>11</code> are not.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 12</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>首先得知道 四数定理。一个数由平方数组合，不会超过4个。</li><li>结合打表，把，1和2的打出来，判断3的，3的没有就是4个，也挺快。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashSet&lt;Integer&gt; d_set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (set.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">                set.add(i*i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i;j++)&#123;</span><br><span class="line">                    d_set.add(i*i + j*j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单个平方数</span></span><br><span class="line">        <span class="keyword">if</span>(set.contains(n)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(d_set.contains(n)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">final</span> Iterator&lt;Integer&gt; iterator = set.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                <span class="keyword">int</span> t = n - iterator.next();</span><br><span class="line">                <span class="keyword">if</span>(d_set.contains(t)) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>268. Missing Number</title>
      <link href="/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-268-Missing-Number/"/>
      <url>/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-268-Missing-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/missing-number/" target="_blank" rel="noopener">https://leetcode.com/problems/missing-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: n &#x3D; 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: n &#x3D; 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: n &#x3D; 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= n</code></li><li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>因为数据大小是有范围的，这种就可以利用桶排的思想。遍历两次即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length; <span class="comment">//期望的是0-N-1满，这样返回就是N</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            ints[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ints[i] == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>242. Valid Anagram</title>
      <link href="/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-242-Valid-Anagram/"/>
      <url>/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-242-Valid-Anagram/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-anagram/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code> <em>otherwise</em>.</p><p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s</code> and <code>t</code> consist of lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>比较简单了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] chars = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars2 = t.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(chars1.length != chars2.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars1.length; i++) &#123;</span><br><span class="line">            chars[chars1[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(--chars[chars2[i]-<span class="string">'a'</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>240. Search a 2D Matrix II</title>
      <link href="/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-240-Search-a-2D-Matrix-II/"/>
      <url>/2018/10/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-27-240-Search-a-2D-Matrix-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/search-a-2d-matrix-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= n, m &lt;= 300</code></li><li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li><li>All the integers in each row are <strong>sorted</strong> in ascending order.</li><li>All the integers in each column are <strong>sorted</strong> in ascending order.</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>两个方向都是递增的，明显提示二分了，我们可以一个方向遍历，再另一个方向用二分</li><li>法一不好，没有充分利用二分特性！其实想清楚，只要在右上角，则可以不断的二分！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[M-<span class="number">1</span>][N-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == matrix[<span class="number">0</span>][<span class="number">0</span>] || target == matrix[M-<span class="number">1</span>][N-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = M-<span class="number">1</span> ;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(binarySearch(matrix[i],target))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = num.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r- l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(num[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num[mid] &lt; target) l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num[l] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length,N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = N-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (inEdge(l,r,M,N))&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[l][r] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[l][r] &gt; target)&#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">inEdge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &gt;= <span class="number">0</span> &amp;&amp; l &lt; m &amp;&amp; r &gt;= <span class="number">0</span> &amp;&amp; r &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>230. Kth Smallest Element in a BST</title>
      <link href="/2018/10/26/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-26-230-Kth-Smallest-Element-in-a-BST/"/>
      <url>/2018/10/26/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-26-230-Kth-Smallest-Element-in-a-BST/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-smallest-element-in-a-bst/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>kth</code> <em>smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is <code>n</code>.</li><li><code>1 &lt;= k &lt;= n &lt;= 104</code></li><li><code>0 &lt;= Node.val &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>BST中寻找第K小，其实就是中序遍历的第K个节点,直接递归时候找出来就行</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(root,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">process</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root== <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> l = process(root.left, k);</span><br><span class="line">        <span class="keyword">if</span> (l != -<span class="number">1</span>) <span class="keyword">return</span> l;</span><br><span class="line">        c++;</span><br><span class="line">        <span class="keyword">if</span>(c == k) <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> r = process(root.right, k);</span><br><span class="line">        <span class="keyword">if</span> (r != -<span class="number">1</span>) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>227. Basic Calculator II</title>
      <link href="/2018/10/25/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-25-227-Basic-Calculator-II/"/>
      <url>/2018/10/25/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-25-227-Basic-Calculator-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/basic-calculator-ii/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/basic-calculator-ii/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> which represents an expression, <em>evaluate this expression and return its value</em>. </p><p>The integer division should truncate toward zero.</p><p>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-231, 231 - 1]</code>.</p><p><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot; 3&#x2F;2 &quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot; 3+5 &#x2F; 2 &quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> consists of integers and operators <code>(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)</code> separated by some number of spaces.</li><li><code>s</code> represents <strong>a valid expression</strong>.</li><li>All the integers in the expression are non-negative integers in the range <code>[0, 231 - 1]</code>.</li><li>The answer is <strong>guaranteed</strong> to fit in a <strong>32-bit integer</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这道题目是一种常见的思路，乘除的时候先算，在队列里存放加减的序列,然后遍历计算一下可以。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Deque&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (chars[i] == <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] &lt;= <span class="string">'9'</span> &amp;&amp; chars[i] &gt;= <span class="string">'0'</span>) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (chars[i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addNum(queue,num);</span><br><span class="line">                queue.addLast(String.valueOf(chars[i]));</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addNum(queue,num);</span><br><span class="line">        <span class="keyword">return</span>  getRes(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(Deque&lt;String&gt; queue,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!queue.isEmpty() &amp;&amp; (queue.peekLast().equals(<span class="string">"*"</span>) || queue.peekLast().equals(<span class="string">"/"</span>))) &#123;</span><br><span class="line">            String exp = queue.removeLast();</span><br><span class="line">            Integer a = Integer.valueOf(queue.removeLast());</span><br><span class="line">            <span class="keyword">if</span> (exp.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">                num = a * num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num = a / num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.addLast(String.valueOf(num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRes</span><span class="params">(Deque&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.valueOf(queue.removeFirst());</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            String exp = queue.removeFirst();</span><br><span class="line">            String num = queue.removeFirst();</span><br><span class="line">            <span class="keyword">if</span>(exp.equals(<span class="string">"+"</span>))&#123;</span><br><span class="line">                res += Integer.valueOf(num);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                res -= Integer.valueOf(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>218. The Skyline Problem</title>
      <link href="/2018/10/25/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-25-218-The-Skyline-Problem/"/>
      <url>/2018/10/25/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-25-218-The-Skyline-Problem/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>217. Contains Duplicate</title>
      <link href="/2018/10/25/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-25-217-Contains-Duplicate/"/>
      <url>/2018/10/25/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-25-217-Contains-Duplicate/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/contains-duplicate/" target="_blank" rel="noopener">https://leetcode.com/problems/contains-duplicate/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, return <code>true</code> if any value appears <strong>at least twice</strong> in the array, and return <code>false</code> if every element is distinct.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>考察会不会编程。</li><li>发现 用for each 循环 比普通的循环要快！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; nums.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            if (set.contains(nums[i])) return true;</span></span><br><span class="line"><span class="comment">//            set.add(nums[i]);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(i)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>215. Kth Largest Element in an Array</title>
      <link href="/2018/10/22/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-22-215-Kth-Largest-Element-in-an-Array/"/>
      <url>/2018/10/22/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-22-215-Kth-Largest-Element-in-an-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-largest-element-in-an-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>kth</code> <em>largest element in the array</em>.</p><p>Note that it is the <code>kth</code> largest element in the sorted order, not the <code>kth</code> distinct element.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,5,6,4], k &#x3D; 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,3,1,2,4,5,5,6], k &#x3D; 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>利用快排枢轴的方法，寻找第K大元素，经典题目.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span>  nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> process(nums,k,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> kth,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line"><span class="comment">//            System.out.println("i:"+i +" j:"+j +" kth:"+kth);</span></span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp =  nums[i];</span><br><span class="line">        <span class="keyword">int</span> p1 = i,p2 = j;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; p2)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p2 &gt; p1 &amp;&amp; nums[p2] &lt; tmp)&#123;</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p1 &lt; p2)&#123;</span><br><span class="line">                nums[p1] = nums[p2];</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; p2 &amp;&amp; nums[p1] &gt;= tmp)&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p1 &lt; p2)&#123;</span><br><span class="line">                nums[p2] = nums[p1];</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[p1] = tmp; <span class="comment">//p1位置确定</span></span><br><span class="line">        <span class="keyword">int</span> cur_k = p1 - i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur_k == kth) <span class="keyword">return</span> nums[p1];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur_k &gt; kth) <span class="keyword">return</span> process(nums,kth,i,p1-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> process(nums,kth-cur_k,p1+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Quick Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>212. Word Search II</title>
      <link href="/2018/10/22/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-22-212-Word-Search-II/"/>
      <url>/2018/10/22/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-22-212-Word-Search-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/word-search-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> <code>board</code> of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.</p><p>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words &#x3D; [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class="line">Output: [&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words &#x3D; [&quot;abcb&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 12</code></li><li><code>board[i][j]</code> is a lowercase English letter.</li><li><code>1 &lt;= words.length &lt;= 3 * 104</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>words[i]</code> consists of lowercase English letters.</li><li>All the strings of <code>words</code> are unique.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个和word Search 一的区别是，一只是给了一个单词，去判定存不存在，直接暴力搜就行，现在是判断一堆单词 看看拿个存在，也就是暴力搜的时候，你这个字符不仅仅是和一个单词的字符去比了，你要看，当前路径形成的单词有没有这个单词啊？是不是某个单词的前缀啊？要是直接比那就麻烦了，需要用有序表遍历挨个比，所以应该想到什么，Trie！它去组织单词，给组织起来，当前位置是单词就是，如果是路径也可以继续走，如果不是则直接返回。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        Node root;</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            Node[] nodes;</span><br><span class="line">            <span class="keyword">boolean</span> isWord;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = chars[i]-<span class="string">'a'</span>;</span><br><span class="line">                cur.nodes[index] = cur.nodes[index] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node():cur.nodes[index];</span><br><span class="line">                cur = cur.nodes[index];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] path = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            prefixTree.insert(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                process(res,path,<span class="number">0</span>,i,j,prefixTree.root,board);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; res,<span class="keyword">char</span>[] path,<span class="keyword">int</span> k,<span class="keyword">int</span> i,<span class="keyword">int</span> j,PrefixTree.Node cur,<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index = board[i][j] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.nodes[index] == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">         path[k] = board[i][j];</span><br><span class="line">         board[i][j] = <span class="string">'-'</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur.nodes[index].isWord) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(path,<span class="number">0</span>,k+<span class="number">1</span>));</span><br><span class="line">            cur.nodes[index].isWord = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续以感染的方式 继续检测单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">4</span>;d++)&#123;</span><br><span class="line">            process(res,path,k+<span class="number">1</span>,i+dir_x[d],j+dir_y[d],cur.nodes[index],board);</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = path[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>210. Course Schedule II</title>
      <link href="/2018/10/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-21-210-Course-Schedule-II/"/>
      <url>/2018/10/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-21-210-Course-Schedule-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/course-schedule-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/course-schedule-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you <strong>must</strong> take course <code>bi</code> first if you want to take course <code>ai</code>.</p><ul><li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li></ul><p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 4, prerequisites &#x3D; [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">Output: [0,2,1,3]</span><br><span class="line">Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.</span><br><span class="line">So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 1, prerequisites &#x3D; []</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>ai != bi</code></li><li>All the pairs <code>[ai, bi]</code> are <strong>distinct</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>和课程安排一 没啥区别。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numCourses == <span class="number">1</span> ) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] v_edge = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, List&gt; adjacent = getAdjacent(prerequisites,v_edge);</span><br><span class="line">        <span class="keyword">return</span> judge(v_edge,adjacent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, List&gt; <span class="title">getAdjacent</span><span class="params">(<span class="keyword">int</span>[][] prerequisites, <span class="keyword">int</span>[] v_edge)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, List&gt; adject = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> from = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            v_edge[to]++;</span><br><span class="line">            <span class="keyword">if</span>(adject.containsKey(from))&#123;</span><br><span class="line">                adject.get(from).add(to);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(to);</span><br><span class="line">                adject.put(from,list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] judge(<span class="keyword">int</span>[] v_edge,Map&lt;Integer, List&gt; map)&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] collect = <span class="keyword">new</span> <span class="keyword">int</span>[v_edge.length];</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v_edge.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v_edge[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">final</span> Integer v = queue.poll();</span><br><span class="line">            collect[res++] = v;</span><br><span class="line">            <span class="keyword">final</span> List&lt;Integer&gt; list = map.get(v);</span><br><span class="line">            <span class="keyword">if</span>(list != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                    Integer t = list.get(i);</span><br><span class="line">                    <span class="keyword">if</span>(--v_edge[t] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res == v_edge.length) <span class="keyword">return</span> collect;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Topological Sorting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>208. Implement Trie (Prefix Tree)</title>
      <link href="/2018/10/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-21-208-Implement-Trie-Prefix-Tree/"/>
      <url>/2018/10/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-21-208-Implement-Trie-Prefix-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-trie-prefix-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A <a href="https://en.wikipedia.org/wiki/Trie" target="_blank" rel="noopener"><strong>trie</strong></a> (pronounced as “try”) or <strong>prefix tree</strong> is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p><p>Implement the Trie class:</p><ul><li><code>Trie()</code> Initializes the trie object.</li><li><code>void insert(String word)</code> Inserts the string <code>word</code> into the trie.</li><li><code>boolean search(String word)</code> Returns <code>true</code> if the string <code>word</code> is in the trie (i.e., was inserted before), and <code>false</code> otherwise.</li><li><code>boolean startsWith(String prefix)</code> Returns <code>true</code> if there is a previously inserted string <code>word</code> that has the prefix <code>prefix</code>, and <code>false</code> otherwise.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">Output</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; return True</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; return False</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; return True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; return True</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code> and <code>prefix</code> consist only of lowercase English letters.</li><li>At most <code>3 * 104</code> calls <strong>in total</strong> will be made to <code>insert</code>, <code>search</code>, and <code>startsWith</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个没什么难度，让实现一个Trie，只要学过这个东西，不难的。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Node[] nodes;</span><br><span class="line">        <span class="keyword">boolean</span> isWord;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = chars[i]-<span class="string">'a'</span>;</span><br><span class="line">            cur.nodes[index] = cur.nodes[index] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node():cur.nodes[index];</span><br><span class="line">            cur = cur.nodes[index];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = chars[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.nodes[index] != <span class="keyword">null</span>)</span><br><span class="line">                cur = cur.nodes[index];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = prefix.toCharArray();</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = chars[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.nodes[index] != <span class="keyword">null</span>)</span><br><span class="line">                cur = cur.nodes[index];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trie </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>207. Course Schedule</title>
      <link href="/2018/10/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-21-207-Course-Schedule/"/>
      <url>/2018/10/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-21-207-Course-Schedule/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">https://leetcode.com/problems/course-schedule/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you <strong>must</strong> take course <code>bi</code> first if you want to take course <code>ai</code>.</p><ul><li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li></ul><p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li>All the pairs prerequisites[i] are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>课程安排。典型的拓扑排序。图论的算法，有机会单独总结一次。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numCourses == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span>[] v_edge = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, List&gt; adjacent = getAdjacent(prerequisites,v_edge);</span><br><span class="line">        <span class="keyword">return</span> judge(v_edge,adjacent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, List&gt; <span class="title">getAdjacent</span><span class="params">(<span class="keyword">int</span>[][] prerequisites,<span class="keyword">int</span>[] v_edge)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, List&gt; adject = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> from = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            v_edge[to]++;</span><br><span class="line">            <span class="keyword">if</span>(adject.containsKey(from))&#123;</span><br><span class="line">                adject.get(from).add(to);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(to);</span><br><span class="line">                adject.put(from,list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span>[] v_edge,Map&lt;Integer, List&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v_edge.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v_edge[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">final</span> Integer v = queue.poll();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">final</span> List&lt;Integer&gt; list = map.get(v);</span><br><span class="line">            <span class="keyword">if</span>(list != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                    Integer t = list.get(i);</span><br><span class="line">                    <span class="keyword">if</span>(--v_edge[t] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == v_edge.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Algorithm -Topological Sorting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206. Reverse Linked List</title>
      <link href="/2018/10/18/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-18-206-Reverse-Linked-List/"/>
      <url>/2018/10/18/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-18-206-Reverse-Linked-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: [5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2]</span><br><span class="line">Output: [2,1]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个就是遍历一趟，把扫过的指针反向即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode cur = head,pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>204. Count Primes</title>
      <link href="/2018/10/15/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-15-204-Count-Primes/"/>
      <url>/2018/10/15/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-15-204-Count-Primes/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/count-primes/" target="_blank" rel="noopener">https://leetcode.com/problems/count-primes/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em>the number of prime numbers that are strictly less than</em> <code>n</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 10</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= n &lt;= 5 * 106</code></li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>数数素数，利用打表法，开数组，把素数打出来，再数就可以了。我们这里说的数素数指的是 埃及素数筛选法，时间复杂度是loglog(N)。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">boolean</span>[] primer = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9000000</span>]; <span class="comment">//false代表是</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; <span class="number">9000000</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!primer[i])&#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                    set.add(i);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>;j &lt; <span class="number">9000000</span>;j += i)&#123;</span><br><span class="line">                        primer[j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Integer primer_floor = set.floor(n);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> loc = list.indexOf(primer_floor);</span><br><span class="line">        <span class="keyword">if</span> (set.contains(n))&#123;</span><br><span class="line">            <span class="keyword">return</span> loc;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> loc +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>202. Happy Number</title>
      <link href="/2018/10/15/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-15-202-Happy-Number/"/>
      <url>/2018/10/15/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-15-202-Happy-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="noopener">https://leetcode.com/problems/happy-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write an algorithm to determine if a number <code>n</code> is happy.</p><p>A <strong>happy number</strong> is a number defined by the following process:</p><ul><li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li><li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li><li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li></ul><p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 19</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>看着是数学题，可是也不需要找规律，就是模拟实现一下就过了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!(set.contains(n) || n == <span class="number">1</span>))&#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            <span class="keyword">int</span> c = n;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (c != <span class="number">0</span>)&#123;</span><br><span class="line">                res += (c%<span class="number">10</span>)*(c%<span class="number">10</span>);</span><br><span class="line">                c /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !set.contains(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>200. Number of Islands</title>
      <link href="/2018/10/15/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-15-200-Number-of-Islands/"/>
      <url>/2018/10/15/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-15-200-Number-of-Islands/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-islands/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p><p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典的岛屿问题，数有多少个岛屿，一般两种做法，一个是感染的思路，遍历矩阵，对每个没遍历过的，从它开始进行BFS感染，把整个联通块串起来，并且标记好访问过，那么 循环矩阵时，进行过几次BFS，就是几个块。</li><li>典型的并查集，并查集的作用就是来判断两个元素是不是在同一个集合，进行集合的合并，同时可以记录有多少个集合，每个集合有多少个元素等。我们对矩阵中的元素，对每一个都看它的右面和下面，进行集合的合并。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span>[] parents;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">boolean</span>[] root; <span class="comment">//是不是根</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parent = c;</span><br><span class="line">        <span class="keyword">while</span> (parents[parent] != parent)&#123;</span><br><span class="line">            parent = parents[parent];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//路经压缩</span></span><br><span class="line">        parents[c] = parent;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root_a = find(a);</span><br><span class="line">        <span class="keyword">int</span> root_b = find(b);</span><br><span class="line">        <span class="keyword">if</span>(root_a != root_b)&#123;</span><br><span class="line">            parents[root_a] = root_b;</span><br><span class="line">            root[root_a] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        parents = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length*grid[<span class="number">0</span>].length];</span><br><span class="line">        root = <span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length*grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parents.length; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  =<span class="number">0</span> ;i &lt; grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    root[i*grid[<span class="number">0</span>].length+j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; grid[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[<span class="number">0</span>][i] == <span class="string">'1'</span> &amp;&amp; grid[<span class="number">0</span>][i-<span class="number">1</span>] ==<span class="string">'1'</span>)&#123;</span><br><span class="line">                union(i-<span class="number">1</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="comment">//看左面</span></span><br><span class="line">                    <span class="keyword">if</span>(j != <span class="number">0</span> &amp;&amp; grid[i][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                        union(i*grid[<span class="number">0</span>].length+j-<span class="number">1</span>,i*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(grid[i-<span class="number">1</span>][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                        union((i-<span class="number">1</span>)*grid[<span class="number">0</span>].length+j,i*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root[i]) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>198. House Robber</title>
      <link href="/2018/10/13/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-13-198-House-Robber/"/>
      <url>/2018/10/13/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-13-198-House-Robber/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">https://leetcode.com/problems/house-robber/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).</span><br><span class="line">Total amount you can rob &#x3D; 1 + 3 &#x3D; 4.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 2), rob house 3 (money &#x3D; 9) and rob house 5 (money &#x3D; 1).</span><br><span class="line">Total amount you can rob &#x3D; 2 + 9 + 1 &#x3D; 12.</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>打家劫舍 经典题目啊，像打家劫舍、循环的打家劫舍、点灯问题、循环的点灯问题 其实都差不多。</li><li>我们定义dp[i],代表 [i,len-1] 能拿到的最大值，那么此时有<script type="math/tex">dp[i] = max(dp[i+1],num[i]+dp[i+2])</script>,其实只跟后面两个元素有关，改成变量迭代的方式，省掉空间。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = nums[N-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = pre;</span><br><span class="line">            pre = Math.max(nums[i] + pre2,pre);</span><br><span class="line">            pre2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>191. Number of 1 Bits</title>
      <link href="/2018/10/10/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-10-191-Number-of-1-Bits/"/>
      <url>/2018/10/10/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-10-191-Number-of-1-Bits/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-1-bits/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">Hamming weight</a>).</p><p><strong>Note:</strong></p><ul><li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</li><li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two&#39;s_complement" target="_blank" rel="noopener">2’s complement notation</a>. Therefore, in <strong>Example 3</strong>, the input represents the signed integer. <code>-3</code>.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 00000000000000000000000000001011</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The input binary string 00000000000000000000000000001011 has a total of three &#39;1&#39; bits.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 00000000000000000000000010000000</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The input binary string 00000000000000000000000010000000 has a total of one &#39;1&#39; bit.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 11111111111111111111111111111101</span><br><span class="line">Output: 31</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &#39;1&#39; bits.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The input must be a <strong>binary string</strong> of length <code>32</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>遍历数一下就行，只不过这里，咱们通过取最右侧第一个1的方式，而不是一位一位无脑的遍历，这样就更快点。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( n!= <span class="number">0</span>)&#123;</span><br><span class="line">            n -= (n &amp; (-n));</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>190. Reverse Bits</title>
      <link href="/2018/10/10/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-10-190-Reverse-Bits/"/>
      <url>/2018/10/10/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-10-190-Reverse-Bits/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/reverse-bits/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-bits/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Reverse bits of a given 32 bits unsigned integer.</p><p><strong>Note:</strong></p><ul><li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</li><li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two&#39;s_complement" target="_blank" rel="noopener">2’s complement notation</a>. Therefore, in <strong>Example 2</strong> above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 00000010100101000001111010011100</span><br><span class="line">Output:    964176192 (00111001011110000010100101000000)</span><br><span class="line">Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 11111111111111111111111111111101</span><br><span class="line">Output:   3221225471 (10111111111111111111111111111111)</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The input must be a <strong>binary string</strong> of length <code>32</code></li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>我们就用一个比较简单的操作交换即可，就不借鉴各路大神的操作了。</li><li>对bit位交换，如果一样那就不用交换，如果不一样，各自位取反即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">16</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> M = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">            <span class="keyword">int</span> left = (M &amp; n);</span><br><span class="line">            <span class="keyword">int</span> right = (N &amp; n);</span><br><span class="line">            <span class="keyword">if</span>(left != <span class="number">0</span>&amp;&amp; right==<span class="number">0</span> || left==<span class="number">0</span> &amp;&amp; right!= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left == <span class="number">0</span>)&#123;</span><br><span class="line">                    n |= M;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    n &amp;= ~(M);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(right == <span class="number">0</span>)&#123;</span><br><span class="line">                    n |= N;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    n &amp;= ~(N);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>189. Rotate Array</title>
      <link href="/2018/10/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-09-189-Rotate-Array/"/>
      <url>/2018/10/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-09-189-Rotate-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-array/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,-100,3,99], k &#x3D; 2</span><br><span class="line">Output: [3,99,-1,-100]</span><br><span class="line">Explanation: </span><br><span class="line">rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class="line">rotate 2 steps to the right: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= k &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典的交换题目，三次交换即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; nums.length) k = k % nums.length;</span><br><span class="line">        swap(nums,nums.length-k,nums.length-<span class="number">1</span>);</span><br><span class="line">        swap(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>-k);</span><br><span class="line">        swap(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = l,p2 = r;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; p2)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[p1];</span><br><span class="line">            nums[p1] = nums[p2];</span><br><span class="line">            nums[p2] = temp;</span><br><span class="line">            p1++;</span><br><span class="line">            p2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>179. Largest Number</title>
      <link href="/2018/10/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-09-179-Largest-Number/"/>
      <url>/2018/10/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-09-179-Largest-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/largest-number/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a list of non-negative integers <code>nums</code>, arrange them such that they form the largest number and return it.</p><p>Since the result may be very large, so you need to return a string instead of an integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [10,2]</span><br><span class="line">Output: &quot;210&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,30,34,5,9]</span><br><span class="line">Output: &quot;9534330&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题是贪心，我们排序一下，排序时候，要不要交换，要看当前两个元素的是不交换拼接的值大，还是交换之后拼接的值大！</li><li>这就是贪心策略，应该多积累，见过就会，没见过就难想.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            list.add(String.valueOf(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        list.sort((a,b)-&gt;-(a+b).compareTo(b+a));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.length() != <span class="number">0</span> || !list.get(i).equals(<span class="string">"0"</span>) || i == list.size()-<span class="number">1</span>)</span><br><span class="line">                res.append(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Greed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>172. Factorial Trailing Zeroes</title>
      <link href="/2018/10/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-09-172-Factorial-Trailing-Zeroes/"/>
      <url>/2018/10/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-09-172-Factorial-Trailing-Zeroes/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/factorial-trailing-zeroes/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em>the number of trailing zeroes in</em> <code>n!</code>.</p><p>Note that <code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: 3! &#x3D; 6, no trailing zero.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 5</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 5! &#x3D; 120, one trailing zero.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= n &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这道题是与质数有关的题目，一个数的介乘分解质因数后有多少个质数a？这个是典型的题目</li><li>此题就是问，分解后有多少个5，因为2 * 5 = 10，而2的质数远比5多啊，所以取决于5</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">            res += n/<span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>171. Excel Sheet Column Number</title>
      <link href="/2018/10/08/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-08-171-Excel-Sheet-Column-Number/"/>
      <url>/2018/10/08/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-08-171-Excel-Sheet-Column-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">https://leetcode.com/problems/excel-sheet-column-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>columnTitle</code> that represents the column title as appears in an Excel sheet, return <em>its corresponding column number</em>.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: columnTitle &#x3D; &quot;A&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: columnTitle &#x3D; &quot;AB&quot;</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: columnTitle &#x3D; &quot;ZY&quot;</span><br><span class="line">Output: 701</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= columnTitle.length &lt;= 7</code></li><li><code>columnTitle</code> consists only of uppercase English letters.</li><li><code>columnTitle</code> is in the range <code>[&quot;A&quot;, &quot;FXSHRXW&quot;]</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是简单的映射</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String columnTitle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = columnTitle.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            res = res * <span class="number">26</span> + (chars[i] - <span class="string">'A'</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码解析</title>
      <link href="/2018/10/05/%E6%BA%90%E7%A0%81-jdk-2022-07-05-HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/10/05/%E6%BA%90%E7%A0%81-jdk-2022-07-05-HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>HashMap是特别常用的数据结构，源码很长,但底层原理并不复杂，本篇主要介绍hashmap的存储原理以及底层用到的数据结构，并对核心代码进行分析。</p></blockquote><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li><p>结构图</p><p>HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。其中当链表的长度大于等于 8 时， 链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表，整体的数据结构 如下：</p><p><img src="1.jpg" alt="结构图"></p></li><li><p>类注释信息</p><ul><li>允许 null 值，不同于 HashTable ，是线程不安全的;</li><li>load factor（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值，较高的 值会减少空间开销（扩容减少，数组大小增长速度变慢），但增加了查找成本（hash 冲突增加，链表长度变长），不扩容的条件：数组容量 &gt; 需要的数组大小 /load factor;</li><li>如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的 大小，这样可以防止在其过程中不断的扩容，影响性能；</li><li>HashMap 是非线程安全的，我们可以自己在外部加锁，或者通过Collections#synchronizedMap 来实现线程安全，Collections#synchronizedMap 的实 现是在每个方法上加上了 synchronized 锁；</li><li>在迭代过程中，如果 HashMap 的结构被修改，会快速失败。</li></ul></li><li><p>常见属性</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">   <span class="comment">//最大容量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">  <span class="comment">//负载因子默认值</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">   <span class="comment">//bin(桶)容量大于等于8时，链表转化成红黑树</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//bin(桶)容量小于等于6时，红黑树转化成链表</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//容量最小64时才会转会成红黑树</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于fail-fast的，记录HashMap结构发生变化(数量变化或rehash)的数目</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//HashMap 的实际大小，可能不准(因为当你拿到这个值的时候，可能又发生了变化)</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 扩容的门槛，如果初始化时，给定数组大小的话，通过tableSizeFor 方法计算，永远接近于 2 的幂次方</span></span><br><span class="line">   <span class="comment">// 如果是通过 resize 方法进行扩容后，大小 = 数组容量 * 0.75</span></span><br><span class="line">   <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//存放数据的数组</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ol><li><p>整体流程</p><p>新增 key，value 大概的步骤如下：</p><ol><li>空数组有无初始化，没有的话初始化；</li><li>如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；</li><li>如果 hash 冲突，两种解决方案：链表 or 红黑树；</li><li>如果是链表，递归循环，把新元素追加到队尾；</li><li>如果是红黑树，调用红黑树新增的方法；</li><li>通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；</li><li>判断是否需要扩容，需要扩容进行扩容，结束。</li></ol></li></ol><p>​    我们来画一张示意图来描述下：</p><p>​    <img src="2.jpg" alt="添加元素流程图"></p><ol><li><p>源码实现</p><ol><li>添加元素 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//如果数组为空，初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// hashCode的算法先右移16 在并上数组大小-1</span></span><br><span class="line">        <span class="comment">// 如果当前索引位置是空的，直接生成新的节点在当前索引位置上</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 如果hash冲突，当前索引上有值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 如果key equals都相等，那么当前节点就是我们要新增的</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 如果是红黑树，使用红黑树的方式新增</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 是个链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//如果是最后一个，还找不到和新增的元素相等的，直接新增</span></span><br><span class="line">                    <span class="comment">//节点是新增到链表最后的</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//p.next是新增的节点，但是e仍然是null</span></span><br><span class="line">                        <span class="comment">//e和p.next都是持有对null的引用,即使p.next后来赋予了值</span></span><br><span class="line">                        <span class="comment">// 只是改变了p.next指向的引用，和e没有关系</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//新增时，链表的长度大于等于8时，链表转红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//链表中有元素和新增的元素相等，结束循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//更改循环的当前元素</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//说明新增的元素table中原来就有</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">// 当前节点移动到队尾</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">//如果kv的实际大小大于扩容的门槛，开始扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 删除不经常使用的元素</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>链表添加细节</p><p> 链表的添加比较简单，和LinkedList的追加实现是一样的，上面代码中描述的很清楚了，注意一点，当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，此方法 有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，当数组 大小小于 64 时，只会触发扩容，不会转化成红黑树 ，转化成红黑树的过程也比较简单，此处不再赘述 。</p><p>至于为什么是8 才会转红黑树，源码中有注释，可以参照,大概意思如下文:</p><blockquote><p>链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候， 使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要 的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，所以我们需要定义出转化的边界值。</p><p>在考虑设计 8 这个值的时候，我们参考了泊松分布概率函数，由泊松分布中得出结论，链表各 个长度的命中概率为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 0:    0.60653066</span><br><span class="line">* 1:    0.30326533</span><br><span class="line">* 2:    0.07581633</span><br><span class="line">* 3:    0.01263606</span><br><span class="line">* 4:    0.00157952</span><br><span class="line">* 5:    0.00015795</span><br><span class="line">* 6:    0.00001316</span><br><span class="line">* 7:    0.00000094</span><br><span class="line">* 8:    0.00000006</span><br><span class="line">* more: less than 1 in ten million</span><br></pre></td></tr></table></figure></blockquote><p>意思是，当链表的长度是 8 的时候，出现的概率是 0.00000006，不到千万分之一，所以说正常 情况下，链表的长度不可能到达 8 ，而一旦到达 8 时，肯定是 hash 算法出了问题，所以在这 种情况下，为了让 HashMap 仍然有较高的查询性能，所以让链表转化成红黑树，我们正常写 代码， 使用 HashMap 时， 几乎不会碰到链表转化成红黑树的情况， 毕竟概念只有千万分之 一。</p></li><li><p>红黑树添加细节</p><p>红黑树是一种动态平衡的数据结构 和AVL树、跳表类似，都具有动态平衡的特点，其实本身没多难，只是插入元素和删除元素后，需要平衡调整-“打补丁”操作,具体的调整规则就不再叙述了，红黑树不了解的可先跳过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树中加入节点</span></span><br><span class="line">        <span class="comment">//在计算新增的节点挂在那个节点上，是线程不安全的，</span></span><br><span class="line">        <span class="comment">//关键在于没有锁住tab,table可能是在动态的变化的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1:首先判断新增的节点在红黑树上是不是已经存在。</span></span><br><span class="line">        <span class="comment">//2:不在的话，根据hashcode，或者自定义的comparTo,递归找到要挂载的节点</span></span><br><span class="line">        <span class="comment">//3:和要挂载的节点建立父子，前后关系</span></span><br><span class="line">        <span class="comment">//4:判断是否需要着色，旋转。</span></span><br><span class="line">        <span class="comment">//5:对红黑树的根节点进行校验</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//h：key 的hash值</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//找到根节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">//自旋</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="comment">// p hash 值大于 h，说明 p 在 h 的右边</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// p hash 值小于 h，说明 p 在 h 的左边</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//要放进去key在当前树中已经存在了(equals来判断)</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="comment">//自己实现的Comparable的话，不能用hashcode比较了，需要用compareTo</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          <span class="comment">//得到key的Class类型，如果key没有实现Comparable就是null</span></span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                          <span class="comment">//当前节点pk和入参k不等</span></span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//找到和当前hashcode值相近的节点(当前节点的左右子节点其中一个为空即可)</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    <span class="comment">//生成新的节点</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="comment">//把新节点放在当前子节点为空的位置上</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">//当前节点和新节点建立父子，前后关系</span></span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    <span class="comment">//balanceInsertion 对红黑树进行着色或旋转，以达到更多的查找效率，着色或旋转的几种场景如下</span></span><br><span class="line">                    <span class="comment">//着色：新节点总是为红色；如果新节点的父亲是黑色，则不需要重新着色；如果父亲是红色，那么必须通过重新</span></span><br><span class="line">                    <span class="comment">//着色或者旋转的方法，再次达到红黑树的5个约束条件</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//旋转： 父亲是红色，叔叔是黑色时(前提是当前)</span></span><br><span class="line">                    <span class="comment">//如果当前节点是父亲的右节点，则进行左旋</span></span><br><span class="line">                    <span class="comment">//如果当前节点是父亲的左节点，则进行右旋</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//moveRootToFront 方法是把算出来的root放到根节点上</span></span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>HashMap 的查找主要分为以下三步：</p><ol><li><p>根据hashcode,算出数组的索引，找到槽点,槽点的key和查询的key相等，直接返回</p></li><li><p>判断当前节点有无 next 节点，有的话判断是链表类型，还是红黑树类型。</p></li><li><p>分别走链表和红黑树不同类型的查找方法。</p><ol><li><p>链表查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用自旋方式从链表中查找 key，e 初始为为链表的头节点 </span></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">// 如果当前节点 hash 等于 key 的 hash，并且 equals 相等，当前节点就是我们要找的节点 </span></span><br><span class="line">  <span class="comment">// 当 hash 冲突时，同一个 hash 值上是一个链表的时候，我们是通过 equals 方法来比较 key 是否相同</span></span><br><span class="line">  <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    <span class="keyword">return</span> e; </span><br><span class="line">  <span class="comment">// 否则，把当前节点的下一个节点拿出来继续寻找 &#125; </span></span><br><span class="line">&#125;<span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li><li><p>红黑树查找</p><p>说下思路:</p><ol><li><p>从根节点递归查找；</p></li><li><p>根据 hashcode，比较查找节点，左边节点，右边节点之间的大小，根本红黑树左小右大</p><p>的特性进行判断；</p></li><li><p>判断查找节点在第 2 步有无定位节点位置，有的话返回，没有的话重复 2，3 两步；</p></li><li><p>一直自旋到定位到节点位置为止。</p><p>如果红黑树比较平衡的话，每次查找的次数就是树的深度。</p></li></ol></li></ol></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​        HashMap 的内容虽然较多，但大多数 api 都只是对数组 + 链表 + 红黑树这种数据结构进行封 装而已，本文我们从新增和查找两个角度进行了源码的深入分析，分析了是如何对数组、链表 和红黑树进行操作的,更详细的内容可以自行阅读源码。</p>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>169. Majority Element</title>
      <link href="/2018/10/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-05-169-Majority-Element/"/>
      <url>/2018/10/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-05-169-Majority-Element/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">https://leetcode.com/problems/majority-element/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array <code>nums</code> of size <code>n</code>, return <em>the majority element</em>.</p><p>The majority element is the element that appears more than <code>⌊n / 2⌋</code> times. You may assume that the majority element always exists in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>水王问题、摩尔投票问题都是一类，这个考察的是，如果存在大于一半的元素，至多是一个，同理推导，对于N个元素中，要求个数大于 N/k的元素，这样元素至多是k-1个，不可能是k个。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>,elem = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == elem)&#123;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(--c &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    c = <span class="number">1</span>;</span><br><span class="line">                    elem = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>166. Fraction to Recurring Decimal</title>
      <link href="/2018/10/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-05-166-Fraction-to-Recurring-Decimal/"/>
      <url>/2018/10/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-05-166-Fraction-to-Recurring-Decimal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/fraction-to-recurring-decimal/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/fraction-to-recurring-decimal/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.</p><p>If the fractional part is repeating, enclose the repeating part in parentheses.</p><p>If multiple answers are possible, return <strong>any of them</strong>.</p><p>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>104</code> for all the given inputs.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numerator &#x3D; 1, denominator &#x3D; 2</span><br><span class="line">Output: &quot;0.5&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numerator &#x3D; 2, denominator &#x3D; 1</span><br><span class="line">Output: &quot;2&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numerator &#x3D; 4, denominator &#x3D; 333</span><br><span class="line">Output: &quot;0.(012)&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= numerator, denominator &lt;= 231 - 1</code></li><li><code>denominator != 0</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>做这道题 关键是寻找循环节，可以通过余数去判断。</li><li>用map去记录位置，找到循环节然后插入括号。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numerator == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">&#125;</span><br><span class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// "+" or "-"</span></span><br><span class="line">res.append(((numerator &gt; <span class="number">0</span>) ^ (denominator &gt; <span class="number">0</span>)) ? <span class="string">"-"</span> : <span class="string">""</span>);</span><br><span class="line"><span class="keyword">long</span> num = Math.abs((<span class="keyword">long</span>) numerator);</span><br><span class="line"><span class="keyword">long</span> den = Math.abs((<span class="keyword">long</span>) denominator);</span><br><span class="line"><span class="comment">// integral part</span></span><br><span class="line">res.append(num / den);</span><br><span class="line">num %= den;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fractional part</span></span><br><span class="line">res.append(<span class="string">"."</span>);</span><br><span class="line">HashMap&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Long, Integer&gt;();</span><br><span class="line">map.put(num, res.length());</span><br><span class="line"><span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">num *= <span class="number">10</span>;</span><br><span class="line">res.append(num / den);</span><br><span class="line">num %= den;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(num)) &#123;</span><br><span class="line"><span class="keyword">int</span> index = map.get(num);</span><br><span class="line">res.insert(index, <span class="string">"("</span>);</span><br><span class="line">res.append(<span class="string">")"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(num, res.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>162. Find Peak Element</title>
      <link href="/2018/10/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-05-162-Find-Peak-Element/"/>
      <url>/2018/10/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-05-162-Find-Peak-Element/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="noopener">https://leetcode.com/problems/find-peak-element/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A peak element is an element that is strictly greater than its neighbors.</p><p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <strong>any of the peaks</strong>.</p><p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</p><p>You must write an algorithm that runs in <code>O(log n)</code> time.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>nums[i] != nums[i + 1]</code> for all valid <code>i</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>要求log(N)，提示很明确了二分。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> res = isPeek(nums, mid);</span><br><span class="line">            <span class="keyword">if</span>(res == <span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(res &lt; <span class="number">0</span>) r = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isPeek</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mid == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[mid+<span class="number">1</span>] &lt; nums[mid] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (mid == nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[mid] &gt; nums[mid-<span class="number">1</span>] ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid-<span class="number">1</span>] &lt; nums[mid] &amp;&amp; nums[mid] &lt; nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//往右走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid-<span class="number">1</span>] &gt; nums[mid] &amp;&amp; nums[mid] &gt; nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//往左走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid-<span class="number">1</span>] &gt; nums[mid] &amp;&amp; nums[mid] &lt; nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160. Intersection of Two Linked Lists</title>
      <link href="/2018/10/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-05-160-Intersection-of-Two-Linked-Lists/"/>
      <url>/2018/10/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-05-160-Intersection-of-Two-Linked-Lists/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-linked-lists/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p><p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_statement.png" alt="img"></p><p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p><p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p><p><strong>Custom Judge:</strong></p><p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p><ul><li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li><li><code>listA</code> - The first linked list.</li><li><code>listB</code> - The second linked list.</li><li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li><li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li></ul><p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">Output: Intersected at &#39;8&#39;</span><br><span class="line">Explanation: The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect).</span><br><span class="line">From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">Output: Intersected at &#39;2&#39;</span><br><span class="line">Explanation: The intersected node&#39;s value is 2 (note that this must not be 0 if the two lists intersect).</span><br><span class="line">From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">Output: No intersection</span><br><span class="line">Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.</span><br><span class="line">Explanation: The two lists do not intersect, so return null.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes of <code>listA</code> is in the <code>m</code>.</li><li>The number of nodes of <code>listB</code> is in the <code>n</code>.</li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt; m</code></li><li><code>0 &lt;= skipB &lt; n</code></li><li><code>intersectVal</code> is <code>0</code> if <code>listA</code> and <code>listB</code> do not intersect.</li><li><code>intersectVal == listA[skipA] == listB[skipB]</code> if <code>listA</code> and <code>listB</code> intersect.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个就是找第一个公共结点，只需要让长度长的链表提前跑，使两个链表指针，在从后面开始数长度相同的位置开始，一块遍历即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> &amp;&amp; headB != <span class="keyword">null</span> || headB == <span class="keyword">null</span> &amp;&amp; headA != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cntA = <span class="number">0</span>,cntB = <span class="number">0</span>;</span><br><span class="line">        ListNode p1 = headA,p2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cntA++;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cntB++;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = headA;</span><br><span class="line">        p2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (cntA - cntB &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            cntA--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cntB - cntA &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            cntB--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span> &amp;&amp; p1 != p2)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>155. Min Stack</title>
      <link href="/2018/10/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-05-155-Min-Stack/"/>
      <url>/2018/10/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-05-155-Min-Stack/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">https://leetcode.com/problems/min-stack/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><p>Implement the <code>MinStack</code> class:</p><ul><li><code>MinStack()</code> initializes the stack object.</li><li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li><li><code>void pop()</code> removes the element on the top of the stack.</li><li><code>int top()</code> gets the top element of the stack.</li><li><code>int getMin()</code> retrieves the minimum element in the stack.</li></ul><p>You must implement a solution with <code>O(1)</code> time complexity for each function.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin(); &#x2F;&#x2F; return -3</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();    &#x2F;&#x2F; return 0</span><br><span class="line">minStack.getMin(); &#x2F;&#x2F; return -2</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.</li><li>At most <code>3 * 104</code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此类题目就是要求你重做数据结构，实现某种功能    </li><li>此题考查的是栈</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     Stack&lt;Integer&gt; stack;</span><br><span class="line">    Stack&lt;Integer&gt; min_stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        min_stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       stack.push(val);</span><br><span class="line">        <span class="keyword">if</span> (min_stack.isEmpty())&#123;</span><br><span class="line">            min_stack.push(val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            min_stack.push(val &lt; min_stack.peek()?val:min_stack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        min_stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>152. Maximum Product Subarray</title>
      <link href="/2018/10/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-05-152-Maximum-Product-Subarray/"/>
      <url>/2018/10/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-05-152-Maximum-Product-Subarray/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-product-subarray/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, find a contiguous non-empty subarray within the array that has the largest product, and return <em>the product</em>.</p><p>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p><p>A <strong>subarray</strong> is a contiguous subsequence of the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,-2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [2,3] has the largest product 6.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,0,-1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>最大乘积子数组，dp_max[i]表示 以i结尾的最大乘积子数组，dp_min[i]表示以i结尾的最小乘积子数组,主要是数值可能是负的，可能会出现负负得正的情况，那我们可以避开这种详细的讨论，因为答案一定在与dp_min数组或者dp_max数组乘积中可以得出。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min_pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max_pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = max_pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = Math.min(Math.min(nums[i],min_pre*nums[i]),nums[i]*max_pre);</span><br><span class="line">            max_pre = Math.max(Math.max(nums[i],max_pre*nums[i]),nums[i]*min_pre);</span><br><span class="line">            min_pre = tmp;</span><br><span class="line">            res = Math.max(res,max_pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>150. Evaluate Reverse Polish Notation</title>
      <link href="/2018/10/03/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-03-150-Evaluate-Reverse-Polish-Notation/"/>
      <url>/2018/10/03/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-03-150-Evaluate-Reverse-Polish-Notation/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">https://leetcode.com/problems/evaluate-reverse-polish-notation/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank" rel="noopener">Reverse Polish Notation</a>.</p><p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. Each operand may be an integer or another expression.</p><p><strong>Note</strong> that division between two integers should truncate toward zero.</p><p>It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: ((2 + 1) * 3) &#x3D; 9</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;&#x2F;&quot;,&quot;+&quot;]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: (4 + (13 &#x2F; 5)) &#x3D; 6</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;&#x2F;&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">Output: 22</span><br><span class="line">Explanation: ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> is either an operator: <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, <code>&quot;*&quot;</code>, or <code>&quot;/&quot;</code>, or an integer in the range <code>[-200, 200]</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是计算后缀表达式</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> [] stack = <span class="keyword">new</span> <span class="keyword">int</span>[tokens.length];</span><br><span class="line">        <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">            String c = tokens[i];</span><br><span class="line">            <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"+"</span>:&#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> a = stack[top--];</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> b = stack[top--];</span><br><span class="line">                    stack[++top] = a + b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"-"</span>:&#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> a = stack[top--];</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> b = stack[top--];</span><br><span class="line">                    stack[++top] = b-a;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"*"</span>:&#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> a = stack[top--];</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> b = stack[top--];</span><br><span class="line">                    stack[++top] = a * b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"/"</span> : &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> a = stack[top--];</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> b = stack[top--];</span><br><span class="line">                    stack[++top] = b /a ;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:&#123;</span><br><span class="line">                    <span class="comment">//操作数</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> v = Integer.parseInt(c);</span><br><span class="line">                    stack[++top] = v;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)stack[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>149. Max Points on a Line</title>
      <link href="/2018/10/03/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-03-149-Max-Points-on-a-Line/"/>
      <url>/2018/10/03/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-03-149-Max-Points-on-a-Line/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">https://leetcode.com/problems/max-points-on-a-line/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of <code>points</code> where <code>points[i] = [xi, yi]</code> represents a point on the <strong>X-Y</strong> plane, return <em>the maximum number of points that lie on the same straight line</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[1,1],[2,2],[3,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= points.length &lt;= 300</code></li><li><code>points[i].length == 2</code></li><li><code>-104 &lt;= xi, yi &lt;= 104</code></li><li>All the <code>points</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个看规模 长度最大 300，300个点，就for循环遍历一点问题没有</li><li>分析题目，其实就查 和你在一条直线上的点，用两个点计算出表达式，计算后面点是不是在表达式上，统计个数，拿出最大值即可。</li><li>注意！做差和0比的时候，double 这种浮点数容易出现精度问题，导致结果不是0，拿精度比。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line">        <span class="keyword">int</span> N = points.length;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p1 = <span class="number">0</span>; p1 &lt; N - <span class="number">1</span>; p1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = p1 + <span class="number">1</span>; t &lt; N; t++) &#123;</span><br><span class="line">                <span class="comment">//计算斜率及直线表达式</span></span><br><span class="line">                <span class="keyword">double</span> k = points[t][<span class="number">0</span>] - points[p1][<span class="number">0</span>] == <span class="number">0</span> ? Integer.MAX_VALUE : (<span class="keyword">double</span>)(points[t][<span class="number">1</span>] - points[p1][<span class="number">1</span>]) / (points[t][<span class="number">0</span>] - points[p1][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">double</span> b = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (k != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    b = points[p1][<span class="number">1</span>] - k * points[p1][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> tmp_max = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> p2 = t + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 扫描共线点</span></span><br><span class="line">                <span class="keyword">if</span> (k == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (p2 &lt; N) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (points[p2][<span class="number">0</span>] == points[p1][<span class="number">0</span>]) &#123;</span><br><span class="line">                            tmp_max++;</span><br><span class="line">                            res = Math.max(tmp_max, res);</span><br><span class="line">                        &#125;</span><br><span class="line">                        p2++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (p2 &lt; N) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (Math.abs(points[p2][<span class="number">1</span>]-(k * points[p2][<span class="number">0</span>] + b)) &lt; eps) &#123;</span><br><span class="line">                            tmp_max++;</span><br><span class="line">                            res = Math.max(tmp_max, res);</span><br><span class="line">                        &#125;</span><br><span class="line">                        p2++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>148. Sort List</title>
      <link href="/2018/10/02/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-02-148-Sort-List/"/>
      <url>/2018/10/02/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-02-148-Sort-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/sort-list/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [4,2,1,3]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [-1,5,3,4,0]</span><br><span class="line">Output: [-1,0,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is in the range <code>[0, 5 * 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目难度中等。首先题目是对链表排序，首先想到什么？大声喊出来，没错，我听到了你的回答，归并排序，一个简单而又神奇的算法！</li><li>归并排序，二路归并需要中间分开，可以用快慢指针的方法找到上中点，这些小技巧啊 平时都要用起来才行。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//链表的归并,时间复杂度是N*logN</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> process(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">process</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next ==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">       ListNode fast = head.next,slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode right = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode left = process(head);</span><br><span class="line">        right = process(right);</span><br><span class="line">        <span class="keyword">return</span>  merge(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">merge</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right!= <span class="keyword">null</span>)&#123;</span><br><span class="line">              ListNode cur =<span class="keyword">null</span>,head = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                  ListNode tmp;</span><br><span class="line">                  <span class="keyword">if</span>(left.val &lt; right.val)&#123;</span><br><span class="line">                      tmp = left;</span><br><span class="line">                      left = left.next;</span><br><span class="line">                  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                      tmp = right;</span><br><span class="line">                      right = right.next;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span>(cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      cur = tmp;</span><br><span class="line">                      head = cur;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      cur.next = tmp;</span><br><span class="line">                      cur = cur.next;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">while</span> (left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                  cur.next = left;</span><br><span class="line">                  left = left.next;</span><br><span class="line">                  cur = cur.next;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">while</span> (right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                  cur.next = right;</span><br><span class="line">                  right = right.next;</span><br><span class="line">                  cur = cur.next;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> head;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>146. LRU Cache</title>
      <link href="/2018/10/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-01-146-LRU-Cache/"/>
      <url>/2018/10/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-01-146-LRU-Cache/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>141. Linked List Cycle</title>
      <link href="/2018/10/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-01-141-Linked-List-Cycle/"/>
      <url>/2018/10/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-01-141-Linked-List-Cycle/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p><p>Return <code>true</code> <em>if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of the nodes in the list is in the range <code>[0, 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>掌握一个技巧，使用快慢指针，如果成环，他们相遇的第一个节点就是入环节点，很有用的这个技巧，原理证明不用管。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode slow = head,fast = head.next.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>&amp;&amp;fast.next != <span class="keyword">null</span> &amp;&amp; slow != fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow == fast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>140. Word Break II</title>
      <link href="/2018/10/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-01-140-Word-Break-II/"/>
      <url>/2018/10/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-01-140-Word-Break-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/word-break-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p><p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsanddog&quot;, wordDict &#x3D; [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]</span><br><span class="line">Output: [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;pineapplepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]</span><br><span class="line">Output: [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]</span><br><span class="line">Explanation: Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li><li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li><li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题难度为Hard，但其实和单词分解一差不多，这个要求的不仅仅判断能不能分解，而且把所有的情况都找出来，那这肯定得递归来收集答案了。</li><li>问题是，我们收集时候，即使当前单词能被拆分，那怎么判断这种情况要不要递归下去，因为递归下去目的就是收集答案，我们可以在单词分解一的基础上，利用DP数组，来进行判断是否选择递归。</li><li>一个一个单元点组合起来，就成了一道难题了，要是没有单词分解一的铺垫，你能不能想到，提前打一个dp出来来收集答案呢？其实之前有遇到过类似，比如：回文串分解。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            <span class="keyword">public</span> Node[] nodes; <span class="comment">//26个字母</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">            <span class="keyword">public</span>  String word;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">                isWord = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Node root;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="keyword">null</span> || <span class="string">""</span>.equals(word)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                cur.nodes[chars[i]-<span class="string">'a'</span>] = cur.nodes[chars[i]-<span class="string">'a'</span>] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node(): cur.nodes[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">                cur = cur.nodes[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">            cur.word = word;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordDict.size(); i++) &#123;</span><br><span class="line">            prefixTree.addWord(wordDict.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[N+<span class="number">1</span>];</span><br><span class="line">        dp[N] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] word = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            PrefixTree.Node cur = prefixTree.root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.nodes[word[j]-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur.nodes[word[j]-<span class="string">'a'</span>].isWord&amp;&amp;dp[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur = cur.nodes[word[j]-<span class="string">'a'</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        process(word,<span class="number">0</span>,prefixTree,<span class="keyword">new</span> StringBuilder(),res,dp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] word, <span class="keyword">int</span> index, PrefixTree ptree, StringBuilder builder, List&lt;String&gt; res,<span class="keyword">boolean</span>[] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index  == word.length) &#123;</span><br><span class="line">            builder.deleteCharAt(builder.length() - <span class="number">1</span>);</span><br><span class="line">            res.add(builder.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PrefixTree.Node cur = ptree.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index;i &lt; word.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.nodes[word[i]-<span class="string">'a'</span>] != <span class="keyword">null</span> &amp;&amp; cur.nodes[word[i]-<span class="string">'a'</span>].isWord &amp;&amp; dp[i+<span class="number">1</span>])&#123;</span><br><span class="line">                builder.append(cur.nodes[word[i]-<span class="string">'a'</span>].word+<span class="string">" "</span>);</span><br><span class="line">                process(word,i+<span class="number">1</span>,ptree,builder,res,dp);</span><br><span class="line">                builder.delete(builder.lastIndexOf(cur.nodes[word[i]-<span class="string">'a'</span>].word),builder.length());</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.nodes[word[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>139. Word Break</title>
      <link href="/2018/10/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-01-139-Word-Break/"/>
      <url>/2018/10/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-10-01-139-Word-Break/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-break/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/word-break/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;,&quot;code&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.</span><br><span class="line">Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 300</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li><li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li><li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>不难想，无非就是递归来切这个字符串，每切的时候还得判断，当前切的这一下是在单词表中的吗？把单词表用有序表存起来，查找时间仍和这个查找的字符串长度有关。我们可以用Trie，把单词表组织起来，有路代表能组成单词，可以加快查找过程。</li><li>此外，我们定义dp[i]，代表[i,len-1]的字符串能否被单词表分解？dp[0]则是答案。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            <span class="keyword">public</span> Node[] nodes; <span class="comment">//26个字母</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">            <span class="keyword">public</span>  String word;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">                isWord = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Node root;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="keyword">null</span> || <span class="string">""</span>.equals(word)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                cur.nodes[chars[i]-<span class="string">'a'</span>] = cur.nodes[chars[i]-<span class="string">'a'</span>] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node(): cur.nodes[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">                cur = cur.nodes[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">            cur.word = word;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordDict.size(); i++) &#123;</span><br><span class="line">            prefixTree.addWord(wordDict.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[N+<span class="number">1</span>];</span><br><span class="line">        dp[N] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] word = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            PrefixTree.Node cur = prefixTree.root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.nodes[word[j]-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur.nodes[word[j]-<span class="string">'a'</span>].isWord&amp;&amp;dp[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur = cur.nodes[word[j]-<span class="string">'a'</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>138. Copy List with Random Pointer</title>
      <link href="/2018/09/29/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-29-138-Copy-List-with-Random-Pointer/"/>
      <url>/2018/09/29/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-29-138-Copy-List-with-Random-Pointer/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">https://leetcode.com/problems/copy-list-with-random-pointer/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p><p>Construct a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="noopener"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p><p>For example, if there are two nodes <code>X</code> and <code>Y</code> in the original list, where <code>X.random --&gt; Y</code>, then for the corresponding two nodes <code>x</code> and <code>y</code> in the copied list, <code>x.random --&gt; y</code>.</p><p>Return <em>the head of the copied linked list</em>.</p><p>The linked list is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p><ul><li><code>val</code>: an integer representing <code>Node.val</code></li><li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</li></ul><p>Your code will <strong>only</strong> be given the <code>head</code> of the original linked list.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/12/18/e1.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/12/18/e2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [[1,1],[2,1]]</span><br><span class="line">Output: [[1,1],[2,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2019/12/18/e3.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [[3,null],[3,0],[3,null]]</span><br><span class="line">Output: [[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>-104 &lt;= Node.val &lt;= 104</code></li><li><code>Node.random</code> is <code>null</code> or is pointing to some node in the linked list.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目难度中等，看你会不会灵活处理。对已有的链表，模仿着创造出一条新的来，random也要指向对应新的节点才可以。</li><li>遍历3次，第一次再节点后面插入一个新的节点，第二次将对应的random指向好，第三次，将对应的新节点串联起来。 </li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node new_node = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">            new_node.next = cur.next;</span><br><span class="line">            cur.next = new_node;</span><br><span class="line">            cur = new_node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        Node new_head  = <span class="keyword">null</span>;</span><br><span class="line">        Node new_last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node random = cur.random;</span><br><span class="line">            <span class="keyword">if</span> (random != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> Node new_random = random.next;</span><br><span class="line">                cur.next.random = new_random;</span><br><span class="line">            &#125;</span><br><span class="line">             cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (new_head == <span class="keyword">null</span>)&#123;</span><br><span class="line">                new_head = cur.next;</span><br><span class="line">                new_last = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                new_last.next = cur.next;</span><br><span class="line">                new_last = new_last.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136. Single Number</title>
      <link href="/2018/09/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-28-136-Single-Number/"/>
      <url>/2018/09/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-28-136-Single-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a <strong>non-empty</strong> array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p><p>You must implement a solution with a linear runtime complexity and use only constant extra space.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-3 * 104 &lt;= nums[i] &lt;= 3 * 104</code></li><li>Each element in the array appears twice except for one element which appears only once.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，考察位运算，我们知道异或运算是不同为1，相同为0，而0与任何数异或都是数字本身，所以 异或一遍就能得到答案</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            n ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>134. Gas Station</title>
      <link href="/2018/09/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-28-134-Gas-Station/"/>
      <url>/2018/09/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-28-134-Gas-Station/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">https://leetcode.com/problems/gas-station/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>ith</code> station is <code>gas[i]</code>.</p><p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>ith</code> station to its next <code>(i + 1)th</code> station. You begin the journey with an empty tank at one of the gas stations.</p><p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4</span><br><span class="line">Travel to station 4. Your tank &#x3D; 4 - 1 + 5 &#x3D; 8</span><br><span class="line">Travel to station 0. Your tank &#x3D; 8 - 2 + 1 &#x3D; 7</span><br><span class="line">Travel to station 1. Your tank &#x3D; 7 - 3 + 2 &#x3D; 6</span><br><span class="line">Travel to station 2. Your tank &#x3D; 6 - 4 + 3 &#x3D; 5</span><br><span class="line">Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.</span><br><span class="line">Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: gas &#x3D; [2,3,4], cost &#x3D; [3,4,3]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">You can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class="line">Let&#39;s start at station 2 and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4</span><br><span class="line">Travel to station 0. Your tank &#x3D; 4 - 3 + 2 &#x3D; 3</span><br><span class="line">Travel to station 1. Your tank &#x3D; 3 - 3 + 3 &#x3D; 3</span><br><span class="line">You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.</span><br><span class="line">Therefore, you can&#39;t travel around the circuit once no matter where you start.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == gas.length == cost.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= gas[i], cost[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>加油站问题，经典题目！我们这个地方用滑动窗口解</li><li>我们首先用cost数组减掉gas数组，存回cost数组，这样&gt;=0表示从这出发能到达下个点，我们从L位置遍历过程中，进行累加cost数组前缀和preSum，如果出现负数肯定是到达不了下个位置了。</li><li>滑动窗口要找单调性，不能回退，比如说 [L,R]，此时不满足情况即preSum &lt; 0，那么[L+1,R] 的位置一定也不满足，因为当初你有可能携带汽油到达L位置，结果从L都到不了R，现在从L+1的位置 怎么可能到达了R! </li><li>为了节省空间，在cost数组本身进行环形增长，达到长度N，其实完全可以再开辟个数组，复制一遍不用这么麻烦</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = cost.length;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> gas[<span class="number">0</span>]-cost[<span class="number">0</span>] &gt;= <span class="number">0</span>?<span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            cost[i] = gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; N)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; N &amp;&amp;cost[p1] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p1 &lt; N)&#123;</span><br><span class="line">                <span class="keyword">int</span> p2 = p1,preSum = cost[p1];</span><br><span class="line">                <span class="comment">//窗口增长</span></span><br><span class="line">                <span class="keyword">while</span> ((p2-p1+N)%N+<span class="number">1</span>&lt;N &amp;&amp; preSum &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    p2 = (p2+<span class="number">1</span>)%N;</span><br><span class="line">                    preSum += cost[p2];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(preSum &gt;= <span class="number">0</span> ) <span class="keyword">return</span> p1;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p2 &gt; p1) p1 = p2;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>131. Palindrome Partitioning</title>
      <link href="/2018/09/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-27-131-Palindrome-Partitioning/"/>
      <url>/2018/09/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-27-131-Palindrome-Partitioning/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-partitioning/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a <strong>palindrome</strong>. Return all possible palindrome partitioning of <code>s</code>.</p><p>A <strong>palindrome</strong> string is a string that reads the same backward as forward.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aab&quot;</span><br><span class="line">Output: [[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;</span><br><span class="line">Output: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s</code> contains only lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>中等难度。要求我们输出所有的切分之后每一块都是回文串的可能性，要枚举第一刀切在哪，要保证切出来的是回文串，切完第一刀之后，我们可以递归去收集答案，第一刀切出来的这个部分是不是回文串还要判断</li><li>为了加速判断，可以事先用DP把回文串的下标求出来，加速判断过程，但怪异的事，这种做法竟然不如现判断的效果好，八成leetcode的测试用例不行。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事先dp 求解回文串下标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            dp[i][i]  = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; N)</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = chars[i] == chars[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">3</span>;i &gt;=<span class="number">0</span> ;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">2</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(chars[i] != chars[j]) dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        process(res,list,<span class="number">0</span>,s,dp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;List&lt;String&gt;&gt; res,List&lt;String&gt; path,<span class="keyword">int</span> index,String str,<span class="keyword">boolean</span>[][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = str.length();</span><br><span class="line">        <span class="keyword">if</span>(index == N)&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">            res.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index;i &lt; N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[index][i])&#123;</span><br><span class="line">                path.add(str.substring(index,i+<span class="number">1</span>));</span><br><span class="line">                process(res,path,i+<span class="number">1</span>,str,dp);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现判断</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        partitioning(<span class="number">0</span>, s, result, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">partitioning</span><span class="params">(<span class="keyword">int</span> index, String s, List&lt;List&lt;String&gt;&gt; result, List&lt;String&gt; ds)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (index == s.length())&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(ds));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s, index, i))&#123;</span><br><span class="line">                ds.add(s.substring(index, i+<span class="number">1</span>));</span><br><span class="line">                partitioning(i+<span class="number">1</span>, s, result, ds);</span><br><span class="line">                ds.remove(ds.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(start) != s.charAt(end))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>130. Surrounded Regions</title>
      <link href="/2018/09/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-27-130-Surrounded-Regions/"/>
      <url>/2018/09/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-27-130-Surrounded-Regions/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">https://leetcode.com/problems/surrounded-regions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> matrix <code>board</code> containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>, <em>capture all regions that are 4-directionally surrounded by</em> <code>&#39;X&#39;</code>.</p><p>A region is <strong>captured</strong> by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">Output: [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">Explanation: Notice that an &#39;O&#39; should not be flipped if:</span><br><span class="line">- It is on the border, or</span><br><span class="line">- It is adjacent to an &#39;O&#39; that should not be flipped.</span><br><span class="line">The bottom &#39;O&#39; is on the border, so it is not flipped.</span><br><span class="line">The other three &#39;O&#39; form a surrounded region, so they are flipped.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;X&quot;]]</span><br><span class="line">Output: [[&quot;X&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>board[i][j]</code> is <code>&#39;X&#39;</code> or <code>&#39;O&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题说的是，把完全包起来的区域里的O-&gt;X,边界上能联通的O不要变，这个还是挺好的，要求你转换思路，我们先把O存成另一个字符C，然后从边界出发去进行BFS 也就是 感染操作，上下左右的去联通，联通了就置成另一个字符K，那么我们再进行遍历，所有的C变成X，所有的K变回O即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> M,N;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        M = board.length;</span><br><span class="line">        N = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            <span class="comment">//统一表示成'C'</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> ( board[i][j] == <span class="string">'O'</span>)</span><br><span class="line">                         board[i][j] = <span class="string">'C'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始从边界进行扫描</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++) &#123;</span><br><span class="line">            infect(board,<span class="number">0</span>,i);</span><br><span class="line">            infect(board,M-<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            infect(board,i,<span class="number">0</span>);</span><br><span class="line">            infect(board,i,N-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            <span class="comment">//统一表示成'C'</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> ( board[i][j] == <span class="string">'C'</span>)</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">if</span> ( board[i][j] == <span class="string">'K'</span>)</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isJudge(i,j) &amp;&amp; board[i][j] == <span class="string">'C'</span>)&#123;</span><br><span class="line">            board[i][j] = <span class="string">'K'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">4</span>;d++)&#123;</span><br><span class="line">                infect(board,i+dir_x[d],j + dir_y[d]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">isJudge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; M &amp;&amp; j &gt;= <span class="number">0</span>&amp;&amp; j&lt;N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>128. Longest Consecutive Sequence</title>
      <link href="/2018/09/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-27-128-Longest-Consecutive-Sequence/"/>
      <url>/2018/09/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-27-128-Longest-Consecutive-Sequence/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-consecutive-sequence/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence.</em></p><p>You must write an algorithm that runs in <code>O(n)</code> time.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [100,4,200,1,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求最长连续序列，需要两个容器，一个装头，一个装尾，每个元素来了，要看看它前面的元素在尾里面？在的话把自己添加进去，同时存储对应前面的值，接下来再看它后面的 是头吗？如果是，需要重新更正之前的头对应后面的个数，与信息流的题目类似。head容器、tail容器。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>)<span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, Integer&gt; head = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, Integer&gt; tail = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(head.containsKey(nums[i]) || tail.containsKey(nums[i]))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                head.put(nums[i],<span class="number">1</span>);</span><br><span class="line">                tail.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//和前面连一块</span></span><br><span class="line">            <span class="keyword">if</span> (tail.containsKey(nums[i] - <span class="number">1</span>)) &#123;</span><br><span class="line">                head.remove(nums[i]);</span><br><span class="line">                <span class="keyword">final</span> Integer preLen = tail.get(nums[i] - <span class="number">1</span>);</span><br><span class="line">                head.put(nums[i] - preLen, head.get(nums[i] - preLen) + <span class="number">1</span>);</span><br><span class="line">                tail.put(nums[i], preLen + <span class="number">1</span>);</span><br><span class="line">                res = Math.max(res,preLen+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//和后面连上，注意同时更新前面的连续序列</span></span><br><span class="line">            <span class="keyword">if</span> (head.containsKey(nums[i] + <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Integer posLen = head.get(nums[i] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">final</span> Integer preLen = tail.get(nums[i]);</span><br><span class="line">                head.put(nums[i]-preLen+<span class="number">1</span>,preLen+posLen);</span><br><span class="line">                tail.put(nums[i]+posLen,preLen+posLen);</span><br><span class="line">                res = Math.max(res,preLen+posLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>127. Word Ladder</title>
      <link href="/2018/09/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-27-127-Word-Ladder/"/>
      <url>/2018/09/27/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-27-127-Word-Ladder/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">https://leetcode.com/problems/word-ladder/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code> such that:</p><ul><li>Every adjacent pair of words differs by a single letter.</li><li>Every <code>si</code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li><li><code>sk == endWord</code></li></ul><p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or</em> <code>0</code> <em>if no such sequence exists.</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= beginWord.length &lt;= 10</code></li><li><code>endWord.length == beginWord.length</code></li><li><code>1 &lt;= wordList.length &lt;= 5000</code></li><li><code>wordList[i].length == beginWord.length</code></li><li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li><li><code>beginWord != endWord</code></li><li>All the words in <code>wordList</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题其实就是图，以每个单词为顶点，相邻的顶点是差一个字母的单词，构造出邻接表之后，把起点也加到图中，那么就是求起点到终点的最短路径问题，单源最短路径有迪杰斯特拉算法 或者更简单的BFS即可。</li><li>再构造邻接表的时候注意，对这个单词寻找邻居时候，不要直接遍历单词表，而是对这个单词的每个字母去调整出新单词，判断单词表中是否存在，这样会更快.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] vToStr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String,Integer&gt; strToMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = wordList.size()+<span class="number">1</span>;</span><br><span class="line">        vToStr = <span class="keyword">new</span> String[N];</span><br><span class="line">        strToMap =  <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        wordList.add(beginWord);</span><br><span class="line">        <span class="comment">// 处理映射</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            vToStr[i] = wordList.get(i);</span><br><span class="line">            strToMap.put(vToStr[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Integer end = strToMap.get(endWord);</span><br><span class="line">        <span class="keyword">if</span>(end == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; adjectTb = getAdjectTb();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bfs = bfs(adjectTb,N,strToMap.get(beginWord),end);</span><br><span class="line">        <span class="keyword">return</span> bfs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; getAdjectTb()&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vToStr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> String str = vToStr[i];</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; chars.length; i1++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">'a'</span>;k &lt;= <span class="string">'z'</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(chars[i1] == k)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">char</span> tmp = chars[i1];</span><br><span class="line">                    chars[i1] = k;</span><br><span class="line">                    <span class="keyword">final</span> String s = <span class="keyword">new</span> String(chars);</span><br><span class="line">                    <span class="keyword">final</span> Integer con = strToMap.get(s);</span><br><span class="line">                    <span class="keyword">if</span>(con != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        list.add(con);</span><br><span class="line">                    &#125;</span><br><span class="line">                    chars[i1] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; adjectTb ,<span class="keyword">int</span> N,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] queue = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>,rear = <span class="number">0</span>;</span><br><span class="line">        queue[rear++] = begin;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        visited[begin] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (front != rear)&#123;</span><br><span class="line">            <span class="keyword">int</span> next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; batchSize;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = queue[front++];</span><br><span class="line">                <span class="keyword">if</span>(tmp == end)</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">final</span> List&lt;Integer&gt; adjents = adjectTb.get(tmp);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adjents.size(); j++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Integer t = adjents.get(j);</span><br><span class="line">                    <span class="keyword">if</span>(!visited[t])&#123;</span><br><span class="line">                        queue[rear++] = t;</span><br><span class="line">                        visited[t] = <span class="keyword">true</span>;</span><br><span class="line">                        next_batch++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">            batchSize = next_batch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125. Valid Palindrome</title>
      <link href="/2018/09/26/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-26-125-Valid-Palindrome/"/>
      <url>/2018/09/26/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-26-125-Valid-Palindrome/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-palindrome/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p><p>Given a string <code>s</code>, return <code>true</code> <em>if it is a <strong>palindrome</strong>, or</em> <code>false</code> <em>otherwise</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;amanaplanacanalpanama&quot; is a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;race a car&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;raceacar&quot; is not a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot; &quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: s is an empty string &quot;&quot; after removing non-alphanumeric characters.</span><br><span class="line">Since an empty string reads the same forward and backward, it is a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 2 * 105</code></li><li><code>s</code> consists only of printable ASCII characters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目不难，就是注意字符类型，判断好就行</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R = str.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line"><span class="comment">// 英文（大小写） + 数字</span></span><br><span class="line"><span class="keyword">if</span> (validChar(str[L]) &amp;&amp; validChar(str[R])) &#123;</span><br><span class="line"><span class="keyword">if</span> (!equal(str[L], str[R])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">L++;</span><br><span class="line">R--;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">L += validChar(str[L]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">R -= validChar(str[R]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validChar</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isLetter(c) || isNumber(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equal</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isNumber(c1) || isNumber(c2)) &#123;</span><br><span class="line"><span class="keyword">return</span> c1 == c2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a  A   32</span></span><br><span class="line"><span class="comment">// b  B   32</span></span><br><span class="line"><span class="comment">// c  C   32</span></span><br><span class="line"><span class="keyword">return</span> (c1 == c2) || (Math.max(c1, c2) - Math.min(c1, c2) == <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLetter</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>124. Binary Tree Maximum Path Sum</title>
      <link href="/2018/09/24/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-24-124-Binary-Tree-Maximum-Path-Sum/"/>
      <url>/2018/09/24/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-24-124-Binary-Tree-Maximum-Path-Sum/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-maximum-path-sum/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p><p>The <strong>path sum</strong> of a path is the sum of the node’s values in the path.</p><p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 &#x3D; 6.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">Output: 42</span><br><span class="line">Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 &#x3D; 42.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 3 * 104]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>二叉树的递归套路，主要靠一点区分就是，这个最大路径要么经过我root，要么不经过，如果经过的话，一定要和子树经过头的最大路径连起来才可以。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeInfo</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSum;</span><br><span class="line">        <span class="keyword">int</span> fromHeadMaxSum;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeInfo</span><span class="params">(<span class="keyword">int</span> maxSum, <span class="keyword">int</span> fromHeadMaxSum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.maxSum = maxSum;</span><br><span class="line">            <span class="keyword">this</span>.fromHeadMaxSum = fromHeadMaxSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxPathSumProcess(root).maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NodeInfo <span class="title">maxPathSumProcess</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSum = root.val;</span><br><span class="line">        <span class="keyword">int</span> fromHeadMaxSum = root.val;</span><br><span class="line">        <span class="keyword">final</span> NodeInfo leftInfo = maxPathSumProcess(root.left);</span><br><span class="line">        <span class="keyword">final</span> NodeInfo rightInfo = maxPathSumProcess(root.right);</span><br><span class="line">        <span class="comment">//第一种情况，不经过root</span></span><br><span class="line">        <span class="keyword">if</span>(leftInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">            maxSum = Math.max(leftInfo.maxSum,maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">            maxSum = Math.max(rightInfo.maxSum,maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二种，经过root了</span></span><br><span class="line">        <span class="keyword">if</span> (leftInfo!=<span class="keyword">null</span> &amp;&amp; leftInfo.fromHeadMaxSum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            maxSum = Math.max(maxSum, leftInfo.fromHeadMaxSum + root.val);</span><br><span class="line">            fromHeadMaxSum = Math.max(leftInfo.fromHeadMaxSum + root.val,fromHeadMaxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightInfo!=<span class="keyword">null</span> &amp;&amp; rightInfo.fromHeadMaxSum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            maxSum = Math.max(maxSum, rightInfo.fromHeadMaxSum + root.val);</span><br><span class="line">            fromHeadMaxSum = Math.max(rightInfo.fromHeadMaxSum + root.val,fromHeadMaxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span> &amp;&amp; rightInfo != <span class="keyword">null</span> &amp;&amp; leftInfo.fromHeadMaxSum &gt; <span class="number">0</span> &amp;&amp; rightInfo.fromHeadMaxSum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            maxSum = Math.max(maxSum, leftInfo.fromHeadMaxSum + root.val + rightInfo.fromHeadMaxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NodeInfo(maxSum,fromHeadMaxSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>122. Best Time to Buy and Sell Stock II</title>
      <link href="/2018/09/23/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-23-122-Best-Time-to-Buy-and-Sell-Stock-II/"/>
      <url>/2018/09/23/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-23-122-Best-Time-to-Buy-and-Sell-Stock-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p><p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.</span><br><span class="line">Total profit is 4 + 3 &#x3D; 7.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Total profit is 4.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>股票系列问题 第二问，是说 同时可以持有一份股票，可以当天买，当天卖，交易次数不限，求最大利润，问题其实可以转换成，再上坡，下坡中，求所有上坡的和</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; prices.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            res  += Math.max(<span class="number">0</span>,prices[i+<span class="number">1</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>121. Best Time to Buy and Sell Stock</title>
      <link href="/2018/09/23/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-23-121-Best-Time-to-Buy-and-Sell-Stock/"/>
      <url>/2018/09/23/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-23-121-Best-Time-to-Buy-and-Sell-Stock/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p><p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-1 &#x3D; 5.</span><br><span class="line">Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transactions are done and the max profit &#x3D; 0.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>股票系列问题可是经典题目，这是股票一，买一次，卖一次求最大利润，题目转化成，对当前i位置，减去我左边的最小值，即为当前位置卖出的最大利润，遍历一趟得结果</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            min = Math.min(prices[i],min);</span><br><span class="line">            res = Math.max(res,prices[i]-min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>118. Pascal&#39;s Triangle</title>
      <link href="/2018/09/23/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-23-118-Pascal-s-Triangle/"/>
      <url>/2018/09/23/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-23-118-Pascal-s-Triangle/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/pascals-triangle/" target="_blank" rel="noopener">https://leetcode.com/problems/pascals-triangle/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>numRows</code>, return the first numRows of <strong>Pascal’s triangle</strong>.</p><p>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numRows &#x3D; 5</span><br><span class="line">Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numRows &#x3D; 1</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>杨辉三角，普通循环就搞定了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tmp.add(<span class="number">1</span>);</span><br><span class="line">        res.add(tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; numRows;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;Integer&gt; last = res.get(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            cur.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i;j++)&#123;</span><br><span class="line">                cur.add(last.get(j-<span class="number">1</span>) + (j &gt;= last.size()? <span class="number">0</span>:last.get(j)));</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>116. Populating Next Right Pointers in Each Node</title>
      <link href="/2018/09/22/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-22-116-Populating-Next-Right-Pointers-in-Each-Node/"/>
      <url>/2018/09/22/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-22-116-Populating-Next-Right-Pointers-in-Each-Node/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">https://leetcode.com/problems/populating-next-right-pointers-in-each-node/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 212 - 1]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>Follow-up:</strong></p><ul><li>You may only use constant extra space.</li><li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>T103 提到了层次遍历一次取一批的技巧，这个题就用的上了，一次取出来一批，设置好右节点即可 。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> bathSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            Node pre = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bathSize; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre = cur;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre.next = cur;</span><br><span class="line">                     pre = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(cur.left);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(cur.right);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bathSize = next_batch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>108. Convert Sorted Array to Binary Search Tree</title>
      <link href="/2018/09/22/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-22-108-Convert-Sorted-Array-to-Binary-Search-Tree/"/>
      <url>/2018/09/22/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-22-108-Convert-Sorted-Array-to-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a <strong>height-balanced</strong> binary search tree</em>.</p><p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line">Explanation: [0,-10,5,null,-3,null,9] is also accepted:</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3]</span><br><span class="line">Output: [3,1]</span><br><span class="line">Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> is sorted in a <strong>strictly increasing</strong> order.</li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这是个简单题，主要要求的很明确了，要是高度是平衡的，那么就用二分，中点当根，然后递归下去即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r -l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> TreeNode left = process(num, l, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> TreeNode right = process(num, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">final</span> TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        root.left = left;</span><br><span class="line">        root.right = right;</span><br><span class="line">        root.val = num[mid];</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/2018/09/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-21-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/"/>
      <url>/2018/09/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-21-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder &#x3D; [-1], inorder &#x3D; [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> and <code>inorder</code> consist of <strong>unique</strong> values.</li><li>Each value of <code>inorder</code> also appears in <code>preorder</code>.</li><li><code>preorder</code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.</li><li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>前序遍历与中序遍历，前序与层序，加上保证值不同，便可以唯一确定一棵树，先序确定出跟，然后另一个数组确定出对应的左右子树。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constuctTree(preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constuctTree</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,<span class="keyword">int</span> l2,<span class="keyword">int</span> r2,HashMap&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 &gt; r1) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(preorder[l1]);</span><br><span class="line">            <span class="keyword">final</span> Integer loc = map.get(root.val);</span><br><span class="line">            <span class="keyword">final</span> TreeNode left = constuctTree(preorder, l1 + <span class="number">1</span>, l1 + loc -l2, l2, loc - <span class="number">1</span>, map);</span><br><span class="line">            <span class="keyword">final</span> TreeNode right = constuctTree(preorder, l1 + loc - l2 + <span class="number">1</span>, l1 - l2 + r2, loc + <span class="number">1</span>, r2, map);</span><br><span class="line">            root.left = left;</span><br><span class="line">            root.right = right;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104. Maximum Depth of Binary Tree</title>
      <link href="/2018/09/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-21-104-Maximum-Depth-of-Binary-Tree/"/>
      <url>/2018/09/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-21-104-Maximum-Depth-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p><p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 104]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>很简单的递归套路</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> l = getHeight(root.left);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> r = getHeight(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l,r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>103. Binary Tree Zigzag Level Order Traversal</title>
      <link href="/2018/09/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-21-103-Binary-Tree-Zigzag-Level-Order-Traversal/"/>
      <url>/2018/09/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-21-103-Binary-Tree-Zigzag-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes’ values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[20,9],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是让你一层是从左到右，下一层又是从右到左</li><li>这里介绍一个特别重要的技巧，好多题目可以这么解，就是用队列层序遍历时候，每次从队列里拿元素，一次性拿一批，把这一层的都是拿出来，拿出来你想正着就正着，想倒着就倒着 再折腾一次就可以！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; batchSize;i++)&#123;</span><br><span class="line">                <span class="keyword">final</span> TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(node.left);</span><br><span class="line">                        next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(node.right);</span><br><span class="line">                        next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                c.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">                    reverse(c);</span><br><span class="line">                &#125;</span><br><span class="line">            batchSize = next_batch;</span><br><span class="line">            flag ^= <span class="number">1</span>;</span><br><span class="line">            list.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ArrayList&lt;Integer&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = c.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size()/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = c.get(i);</span><br><span class="line">            c.set(i,c.get(len-<span class="number">1</span>-i));</span><br><span class="line">            c.set(len-<span class="number">1</span>-i,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>102. Binary Tree Level Order Traversal</title>
      <link href="/2018/09/18/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-18-102-Binary-Tree-Level-Order-Traversal/"/>
      <url>/2018/09/18/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-18-102-Binary-Tree-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>二叉树的层序遍历，常规操作.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> batch = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> next_batch=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; batch;i++)&#123;</span><br><span class="line">                <span class="keyword">final</span> TreeNode tmp = queue.poll();</span><br><span class="line">                list.add(tmp.val);</span><br><span class="line">                <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(tmp.left);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(tmp.right);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">            batch = next_batch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>101. Symmetric Tree</title>
      <link href="/2018/09/18/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-18-101-Symmetric-Tree/"/>
      <url>/2018/09/18/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-18-101-Symmetric-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/symmetric-tree/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>好题啊好题，虽说是简单题，还蛮考验小聪明的，其实就是说你得始终验证每个节点的左树是不是和右树一样，对每个节点都得验证这是递归，进行验证的时候，你得拿到对应的兄弟节点，所以可以 直接传两次！把树直接传两次！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode leftRoot,TreeNode rightRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftRoot != <span class="keyword">null</span> &amp;&amp; rightRoot != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftRoot.val != rightRoot.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> isMirror(leftRoot.left,rightRoot.right) &amp;&amp; isMirror(leftRoot.right,rightRoot.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(leftRoot == <span class="keyword">null</span> &amp;&amp; rightRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>98. Validate Binary Search Tree</title>
      <link href="/2018/09/16/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-16-98-Validate-Binary-Search-Tree/"/>
      <url>/2018/09/16/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-16-98-Validate-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/validate-binary-search-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p><p>A <strong>valid BST</strong> is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&#39;s value is 5 but its right child&#39;s value is 4.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 104]</code>.</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>BST的中序遍历一定是递增的，验证这个条件即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root,list);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i) &lt;= list.get(i-<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left,list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inOrder(root.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>94. Binary Tree Inorder Traversal</title>
      <link href="/2018/09/13/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-13-94-Binary-Tree-Inorder-Traversal/"/>
      <url>/2018/09/13/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-13-94-Binary-Tree-Inorder-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-inorder-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes’ values</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2,3]</span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>普通的中序遍历</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        process(res,root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; res,TreeNode root)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">          process(res,root.left);</span><br><span class="line">          res.add(root.val);</span><br><span class="line">          process(res,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>91. Decode Ways</title>
      <link href="/2018/09/13/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-13-91-Decode-Ways/"/>
      <url>/2018/09/13/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-13-91-Decode-Ways/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">https://leetcode.com/problems/decode-ways/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A message containing letters from <code>A-Z</code> can be <strong>encoded</strong> into numbers using the following mapping:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; &quot;1&quot;</span><br><span class="line">&#39;B&#39; -&gt; &quot;2&quot;</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; &quot;26&quot;</span><br></pre></td></tr></table></figure><p>To <strong>decode</strong> an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, <code>&quot;11106&quot;</code> can be mapped into:</p><ul><li><code>&quot;AAJF&quot;</code> with the grouping <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> with the grouping <code>(11 10 6)</code></li></ul><p>Note that the grouping <code>(1 11 06)</code> is invalid because <code>&quot;06&quot;</code> cannot be mapped into <code>&#39;F&#39;</code> since <code>&quot;6&quot;</code> is different from <code>&quot;06&quot;</code>.</p><p>Given a string <code>s</code> containing only digits, return <em>the <strong>number</strong> of ways to <strong>decode</strong> it</em>.</p><p>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: &quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: &quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;06&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: &quot;06&quot; cannot be mapped to &quot;F&quot; because of the leading zero (&quot;6&quot; is different from &quot;06&quot;).</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> contains only digits and may contain leading zero(s).</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求解码的字符串种数，这种求种数、求最优解的都可以考虑dp，主要是思路来的快</li><li>定义dp[i]  表示 [i~len-1]区间上 解码字符串的种数</li><li>考虑当前 chars[i],字符单独解码的情况，考虑它与后面字符共同解码的情况，进行枚举即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">//明显的dp,dp[i]，表示i~s.lengtn-1有多少种解码方式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = chars.length;</span><br><span class="line">        <span class="keyword">int</span> pre1 = chars[N-<span class="number">1</span>] == <span class="string">'0'</span> ?  <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(chars[i] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//一位数的时候</span></span><br><span class="line">                <span class="keyword">if</span>(chars[i+<span class="number">1</span>] != <span class="string">'0'</span>)&#123;</span><br><span class="line">                    p1 = pre1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//两位数计算</span></span><br><span class="line">                <span class="keyword">int</span> num = (chars[i]-<span class="string">'0'</span>)*<span class="number">10</span>+(chars[i+<span class="number">1</span>]-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                    p2 = pre2;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = p1 + p2;</span><br><span class="line">            &#125;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>88. Merge Sorted Array</title>
      <link href="/2018/09/13/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-13-88-Merge-Sorted-Array/"/>
      <url>/2018/09/13/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-13-88-Merge-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p><p><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.</p><p>The final sorted array should not be returned by the function, but instead be <em>stored inside the array</em> <code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3</span><br><span class="line">Output: [1,2,2,3,5,6]</span><br><span class="line">Explanation: The arrays we are merging are [1,2,3] and [2,5,6].</span><br><span class="line">The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The arrays we are merging are [1] and [].</span><br><span class="line">The result of the merge is [1].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The arrays we are merging are [] and [1].</span><br><span class="line">The result of the merge is [1].</span><br><span class="line">Note that because m &#x3D; 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-109 &lt;= nums1[i], nums2[j] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>小小的考察，从后遍历，往后放置即可，还是从题目本身出发，好好分析！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m-<span class="number">1</span>,j = n-<span class="number">1</span>,k = nums1.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                    nums1[k--] = nums1[i--];</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k != -<span class="number">1</span> &amp;&amp; i == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (k &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> Merge Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>84. Largest Rectangle in Histogram</title>
      <link href="/2018/09/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-11-84-Largest-Rectangle-in-Histogram/"/>
      <url>/2018/09/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-11-84-Largest-Rectangle-in-Histogram/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-rectangle-in-histogram/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of integers <code>heights</code> representing the histogram’s bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: heights &#x3D; [2,1,5,6,2,3]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: The above is a histogram where width of each bar is 1.</span><br><span class="line">The largest rectangle is shown in the red area, which has an area &#x3D; 10 units.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: heights &#x3D; [2,4]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= heights.length &lt;= 105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个是单调栈的应用，单调栈求的是，以当前值为最小值的最大区间。</li><li>还是从题目本身出发，先分析，分析出哪个知识点，用哪个知识点，最大的矩形面积，这个矩形一定是以某个高度为高，然后以这个高度尽可能向两边扩形成一个最大矩形。此外，这个高度一定是在所有的高度里面的，所以我们就可以遍历这些高度，对这些高度，找每个高度形成的最大区间，所有里面的最大面积就是答案。所以说，我们一定要通过分析，找到一个突破点，可以通过枚举去找到所有可能性，进而找到答案。</li><li>有关单调栈的实现这一块，看其它文章的总结。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> N = heights.length,top = -<span class="number">1</span>,res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (top != -<span class="number">1</span> &amp;&amp; heights[stack[top]] &gt;= heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> elem = stack[top--];</span><br><span class="line">                <span class="keyword">int</span> leftMin = top == -<span class="number">1</span> ? -<span class="number">1</span> : stack[top];</span><br><span class="line">                <span class="keyword">int</span> rightMin = i;</span><br><span class="line">                <span class="keyword">int</span> num = (rightMin - <span class="number">1</span> - leftMin) * heights[elem];</span><br><span class="line">                res =  Math.max(res,num);</span><br><span class="line">            &#125;</span><br><span class="line">            stack[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (top!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> elem = stack[top--];</span><br><span class="line">            <span class="keyword">int</span> leftMin = top == -<span class="number">1</span> ? -<span class="number">1</span> : stack[top];</span><br><span class="line">            <span class="keyword">int</span> rightMin = N;</span><br><span class="line">            <span class="keyword">int</span> num = (rightMin - <span class="number">1</span> - leftMin) * heights[elem];</span><br><span class="line">            res = Math.max(res,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Monotonic Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>79. Word Search</title>
      <link href="/2018/09/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-11-79-Word-Search/"/>
      <url>/2018/09/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-11-79-Word-Search/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">https://leetcode.com/problems/word-search/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</p><p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;SEE&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCB&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是简单的暴力搜索即可。</li><li>下面两个方法，其实思路时一模一样，但是 方法二，就是省掉了数组标记，而是在自身上做标记，用回溯的方法，判断也少点，就这它的时间比方法一快了一倍。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board[<span class="number">0</span>].length * board.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] arr = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(i,j,<span class="number">0</span>,arr,board,visited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法一，暴力搜索，dfs，对每个位置去搜索单词即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> index,<span class="keyword">char</span>[] arr,<span class="keyword">char</span>[][] board,<span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> loc = i*board[<span class="number">0</span>].length + j;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span>|| j &gt;= board[<span class="number">0</span>].length || visited[loc])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[index] == board[i][j];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == arr[index])&#123;</span><br><span class="line">                visited[loc] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">4</span>;d++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(i+dir_x[d],j+dir_y[d],index+<span class="number">1</span>,arr,board,visited))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[loc] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] w = word.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (f(board, i, j, w, <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前到达了b[i][j]，word[k....]</span></span><br><span class="line"><span class="comment">// 从b[i][j]出发，能不能搞定word[k....] true false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>[][] b, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] w, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k == w.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// word[k.....] 有字符</span></span><br><span class="line"><span class="comment">// 如果(i,j)越界，返回false</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == b.length || j &lt; <span class="number">0</span> || j == b[<span class="number">0</span>].length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b[i][j] != w[k]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> tmp = b[i][j];</span><br><span class="line">b[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> ans = f(b, i - <span class="number">1</span>, j, w, k + <span class="number">1</span>) </span><br><span class="line">|| f(b, i + <span class="number">1</span>, j, w, k + <span class="number">1</span>) </span><br><span class="line">|| f(b, i, j - <span class="number">1</span>, w, k + <span class="number">1</span>)</span><br><span class="line">|| f(b, i, j + <span class="number">1</span>, w, k + <span class="number">1</span>);</span><br><span class="line">b[i][j] = tmp;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>78. Subsets</title>
      <link href="/2018/09/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-11-78-Subsets/"/>
      <url>/2018/09/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-11-78-Subsets/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode.com/problems/subsets/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible subsets (the power set)</em>.</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: [[],[0]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求子集，从左到右递归枚举，加上回溯，收集起来即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; fin = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fin.add(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            fin.add(nums[i]);</span><br><span class="line">            process(res,path,nums,<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        res.add(fin);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; path,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index,<span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lim == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">            res.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index==nums.length || nums.length-index &lt; lim)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(nums[index]);</span><br><span class="line">        process(res,path,nums,index+<span class="number">1</span>,lim-<span class="number">1</span>);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        process(res,path,nums,index+<span class="number">1</span>,lim);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>76. Minimum Window Substring</title>
      <link href="/2018/09/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-11-76-Minimum-Window-Substring/"/>
      <url>/2018/09/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-11-76-Minimum-Window-Substring/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-window-substring/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window substring</strong> of</em> <code>s</code> <em>such that every character in</em> <code>t</code> <em>(<strong>including duplicates</strong>) is included in the window. If there is no such substring**, return the empty string</em> <code>&quot;&quot;</code><em>.</em></p><p>The testcases will be generated such that the answer is <strong>unique</strong>.</p><p>A <strong>substring</strong> is a contiguous sequence of characters within the string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot;</span><br><span class="line">Output: &quot;BANC&quot;</span><br><span class="line">Explanation: The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;, t &#x3D; &quot;a&quot;</span><br><span class="line">Output: &quot;a&quot;</span><br><span class="line">Explanation: The entire string s is the minimum window.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;, t &#x3D; &quot;aa&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: Both &#39;a&#39;s from t must be included in the window.</span><br><span class="line">Since the largest window of s only has one &#39;a&#39;, return empty string.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == s.length</code></li><li><code>n == t.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><p>尝试考虑滑动窗口，滑动窗口能使用，一定要具有单调性，能保证求解的时候，R可以不回退！比如说</p><p>L=2，R=6，此时满足条件了，记录下来，继续考量L = 3，R= 6是否是更优的，来逼近答案，那为什么不考虑 L = 3，R = 4，5 这两个窗口呢？这两个窗口不是被跳过去了吗？因为L = 2,R = 5的时候 都不满足条件，那L=3，R= 5这个更小的窗口 怎么可能满足条件呢！所以这叫R 不回退！</p></li><li><p>第二点，如何判断此时窗口是满足条件的窗口，窗口内的元素是包含制定字符串元素，种类以及对应的个数。我们引入一种“欠债表”的思想，这个表内，初始化时，是我们要还的字符，也就是指定的字符串对应字符及个数，此外维护一个变量是代表 我们还欠着多少，当变量为0时，表明此窗口如何符合条件。具体看代码来理解。</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] tb = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>]; <span class="comment">//欠债表</span></span><br><span class="line">        <span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] p_str = t.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p_str.length; i++) &#123;</span><br><span class="line">            tb[p_str[i]]++;</span><br><span class="line">            in++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_n = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sloc = <span class="number">0</span>,eloc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;p1 &lt; str.length;p1++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p2 &lt; str.length &amp;&amp; in &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (--tb[str[p2++]] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    in--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(in == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p2 - p1 &lt; min_n)&#123;</span><br><span class="line">                    min_n = p2-p1;</span><br><span class="line">                    sloc = p1;</span><br><span class="line">                    eloc = p2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++tb[str[p1]] &gt; <span class="number">0</span>)&#123; in++; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(sloc,eloc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75. Sort Colors</title>
      <link href="/2018/09/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-11-75-Sort-Colors/"/>
      <url>/2018/09/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-11-75-Sort-Colors/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-colors/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p><p>We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.</p><p>You must solve this problem without using the library’s sort function.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,0,1]</span><br><span class="line">Output: [0,1,2]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>nums[i]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这就是经典的三色旗问题呢，高频题里还是主要以经典题目为主。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>,p3 = nums.length-<span class="number">1</span>,p2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= p3)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[p2] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,p1,p2);</span><br><span class="line">                p2++;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[p2] == <span class="number">2</span>)&#123;</span><br><span class="line">                swap(nums,p2,p3);</span><br><span class="line">                p3--;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                p2++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>73. Set Matrix Zeroes</title>
      <link href="/2018/09/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-11-73-Set-Matrix-Zeroes/"/>
      <url>/2018/09/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-11-73-Set-Matrix-Zeroes/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/set-matrix-zeroes/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>‘s.</p><p>You must do it <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in place</a>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: [[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[0].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>-231 &lt;= matrix[i][j] &lt;= 231 - 1</code></li></ul><p><strong>Follow up:</strong></p><ul><li>A straightforward solution using <code>O(mn)</code> space is probably a bad idea.</li><li>A simple improvement uses <code>O(m + n)</code> space, but still not the best solution.</li><li>Could you devise a constant space solution?</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题有点像炸弹人游戏，我们遍历一趟就可以，简单的做法就是利用数组标记下哪一行，哪一列需要置0</li><li>Follow Up中，提示 能不能用常量空间做标记，这种优化，在面试中也常问。我们想的就是怎么节省空间？自然想办法就是在给的空间上想办法利用，</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>​    方法一:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length];</span><br><span class="line">        <span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    row[i] = <span class="number">1</span>;</span><br><span class="line">                    col[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] == <span class="number">1</span> || col[j]==<span class="number">1</span>)&#123;</span><br><span class="line">                   matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    优化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> col0 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">col0 = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = matrix.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (col0) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>70. Climbing Stairs</title>
      <link href="/2018/09/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-09-70-Climbing-Stairs/"/>
      <url>/2018/09/09/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-09-70-Climbing-Stairs/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">https://leetcode.com/problems/climbing-stairs/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p><p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>比较经典的递归问题了，现在回过头来看，用动归的递推，还是挺简单的。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">2</span>,pre2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = pre1 + pre2;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>69. Sqrt(x)</title>
      <link href="/2018/09/07/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-07-69-Sqrt-x/"/>
      <url>/2018/09/07/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-07-69-Sqrt-x/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">https://leetcode.com/problems/sqrtx/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a non-negative integer <code>x</code>, compute and return <em>the square root of</em> <code>x</code>.</p><p>Since the return type is an integer, the decimal digits are <strong>truncated</strong>, and only <strong>the integer part</strong> of the result is returned.</p><p><strong>Note:</strong> You are not allowed to use any built-in exponent function or operator, such as <code>pow(x, 0.5)</code> or <code>x ** 0.5</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= x &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这就是经典的二分求根号，不过这个题更简单，求的就是第一个满足((long)mid * mid) &lt;= x的整数。用res保留下解，不断的去推进这个值，这种写法简单好用，推荐！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = x;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(((<span class="keyword">long</span>)mid * mid) &lt;= x)&#123;</span><br><span class="line">               res = mid;</span><br><span class="line">               l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66. Plus One</title>
      <link href="/2018/09/07/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-07-66-Plus-One/"/>
      <url>/2018/09/07/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-07-66-Plus-One/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">https://leetcode.com/problems/plus-one/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given a <strong>large integer</strong> represented as an integer array <code>digits</code>, where each <code>digits[i]</code> is the <code>ith</code> digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading <code>0</code>‘s.</p><p>Increment the large integer by one and return <em>the resulting array of digits</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br><span class="line">Incrementing by one gives 123 + 1 &#x3D; 124.</span><br><span class="line">Thus, the result should be [1,2,4].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br><span class="line">Incrementing by one gives 4321 + 1 &#x3D; 4322.</span><br><span class="line">Thus, the result should be [4,3,2,2].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; [9]</span><br><span class="line">Output: [1,0]</span><br><span class="line">Explanation: The array represents the integer 9.</span><br><span class="line">Incrementing by one gives 9 + 1 &#x3D; 10.</span><br><span class="line">Thus, the result should be [1,0].</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li><li><code>digits</code> does not contain any leading <code>0</code>‘s.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>其实就是用数组进行大数运算，这个比较简单，只是简单的加法，累加时候注意加入进位，最后要判断是不是仍有进位，如果还有，要注意扩容数组</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有点类似大数运算，需要考虑进位情况，这个是比较简答的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> jie = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(jie == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> mod = (digits[i] + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (digits[i] + jie)/<span class="number">10</span>;</span><br><span class="line">            digits[i] = mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jie == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[]  new_digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; digits.length;i++) new_digits[i] = digits[i];</span><br><span class="line">            new_digits[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> new_digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>62. Unique Paths</title>
      <link href="/2018/09/04/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-04-62-Unique-Paths/"/>
      <url>/2018/09/04/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-04-62-Unique-Paths/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">https://leetcode.com/problems/unique-paths/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p><p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p>The test cases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: m &#x3D; 3, n &#x3D; 7</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Down</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题实际就是求排列组合，能想到这就简单，不然就吃力了，因为是矩型，而且只能左到右，上到下的走，所以从开始点到结束点，从左到右，从上到下 一定都是固定的步数。</li><li>排列组合的计算，方法数有很多，主要是用到简化公式的方法，不然直接计算 很容易就溢出了，至于计算方法，待我其它文章详细总结。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)C2(m+n-<span class="number">2</span>,m-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">C2</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            res =res*(n-m+i)/i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55. Jump Game</title>
      <link href="/2018/09/03/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-03-55-Jump-Game/"/>
      <url>/2018/09/03/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-03-55-Jump-Game/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/jump-game/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game/submissions/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>nums</code>. You are initially positioned at the array’s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p><p>Return <code>true</code> <em>if you can reach the last index, or</em> <code>false</code> <em>otherwise</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典题目。这个题就是考察“不回退”的技巧，用一个变量去扩展可以走到的路。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; max_pos) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                max_pos = Math.max(i + nums[i],max_pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>54. Spiral Matrix</title>
      <link href="/2018/09/03/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-03-54-Spiral-Matrix/"/>
      <url>/2018/09/03/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-03-54-Spiral-Matrix/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/spiral-matrix/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题不难，也没什么特殊的知识点，就是一个技巧，用几个变量控制好 从左到右，从右到左，从上到下，从下到上的范围，循环进行即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> d_left=<span class="number">0</span>,d_right=N-<span class="number">1</span>,d_up=<span class="number">0</span>,d_down = M-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>,cur_row = -<span class="number">1</span>,cur_col = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (c &lt; M*N)&#123;</span><br><span class="line">            <span class="comment">//往右</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d_left;i &lt;= d_right;i++)&#123;</span><br><span class="line">                list.add(matrix[d_up][i]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_up++;</span><br><span class="line">            <span class="comment">//往下</span></span><br><span class="line">            <span class="keyword">if</span>(c &gt;= M * N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = d_up;i &lt;= d_down;i++)&#123;</span><br><span class="line">                list.add(matrix[i][d_right]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_right--;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= M * N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//往左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = d_right;i &gt;= d_left;i--)&#123;</span><br><span class="line">                list.add(matrix[d_down][i]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_down--;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= M * N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//往上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d_down;i &gt;= d_up;i--)&#123;</span><br><span class="line">                list.add(matrix[i][d_left]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>53. Maximum Subarray</title>
      <link href="/2018/09/03/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-03-53-Maximum-Subarray/"/>
      <url>/2018/09/03/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-03-53-Maximum-Subarray/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.</p><p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,4,-1,7,8]</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution using the <strong>divide and conquer</strong> approach, which is more subtle.</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>比较常见的dp模型，从左到右,dp[i] 表示以i结尾的最大字数组的和</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = arr.length;</span><br><span class="line">        <span class="keyword">int</span> pre = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            pre = Math.max(arr[i],arr[i]+pre);</span><br><span class="line">            res = Math.max(res,pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. Merge Intervals</title>
      <link href="/2018/09/03/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-03-56-Merge-Intervals/"/>
      <url>/2018/09/03/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-03-56-Merge-Intervals/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-intervals/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目比较简单，就是输出有多少个覆盖的区间，遍历一趟，记录下来即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = intervals.length;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= end)&#123;</span><br><span class="line">                end = Math.max(intervals[i][<span class="number">1</span>],end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                intervals[t][<span class="number">0</span>] = start;</span><br><span class="line">                intervals[t++][<span class="number">1</span>] = end;</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals[t][<span class="number">0</span>] = start;</span><br><span class="line">        intervals[t++][<span class="number">1</span>] = end;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[t][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t;i++)&#123;</span><br><span class="line">            res[i][<span class="number">0</span>] = intervals[i][<span class="number">0</span>];</span><br><span class="line">            res[i][<span class="number">1</span>] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50. Pow(x, n)</title>
      <link href="/2018/09/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-01-50-Pow-x-n/"/>
      <url>/2018/09/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-01-50-Pow-x-n/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">https://leetcode.com/problems/powx-n/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(x, n)</a>, which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>xn</code>).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li><code>-231 &lt;= n &lt;= 231-1</code></li><li><code>-104 &lt;= xn &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求m^n，可以对n用二分，加快累乘的速度</li><li>m^ (-n) = 1/m^n,这容易，所以，如果是负的，我们统一成正的处理，最后看是不是用1除即可。</li><li>注意边界，(-n)可能是Integer的最小值，所以如果直接转成绝对值就出错了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> raw = n;</span><br><span class="line">        n = n &gt; <span class="number">0</span> ? n : (n == Integer.MIN_VALUE ? Integer.MAX_VALUE : -n);</span><br><span class="line">        <span class="keyword">double</span> power = x;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                res *= power;</span><br><span class="line">            &#125;</span><br><span class="line">            power *= power;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> raw &gt; <span class="number">0</span> ? res : <span class="number">1</span>/res/(raw == Integer.MIN_VALUE ? x:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49. Group Anagrams</title>
      <link href="/2018/09/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-01-49-Group-Anagrams/"/>
      <url>/2018/09/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-01-49-Group-Anagrams/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener">https://leetcode.com/problems/group-anagrams/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p><p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]</span><br><span class="line">Output: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;&quot;]</span><br><span class="line">Output: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;a&quot;]</span><br><span class="line">Output: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> consists of lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>与字母种数有关，与字母顺序无关，这种题目出现的很高，也不难，做一个词频映射表表，能表示出来哪个字符出现的次数即可</li><li>是26个字符，所以char[26], 即可，注意这个地方就是要用char类型数组，因为不同的频次对应不同的字符。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        HashMap&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = strs[i].toCharArray();</span><br><span class="line">            <span class="keyword">char</span>[] dic = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; chars.length; i1++) &#123;</span><br><span class="line">                dic[chars[i1]-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> String dic_key = <span class="keyword">new</span> String(dic);</span><br><span class="line">            <span class="keyword">if</span>(map.get(dic_key) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(strs[i]);</span><br><span class="line">                map.put(dic_key,list);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.get(dic_key).add(strs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        map.forEach((k,v)-&gt;lists.add(v));</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48. Rotate Image</title>
      <link href="/2018/09/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-01-48-Rotate-Image/"/>
      <url>/2018/09/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-09-01-48-Rotate-Image/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/rotate-image/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-image/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <strong>90</strong> degrees (clockwise).</p><p>You have to rotate the image <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>第一次做还没反应过来怎么做。其实就注意一个点，是矩阵，90度旋转，它同一圈的不会转出去，所以就又一个对焦，一圈一圈转就行。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">0</span>,c = matrix.length-<span class="number">1</span>,d = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &lt; c)&#123;</span><br><span class="line">            rotateSwap(matrix,a++,b++,c--,d--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotateSwap</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d-b;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = matrix[a][b+i];</span><br><span class="line">            matrix[a][b+i] = matrix[c-i][b];</span><br><span class="line">            matrix[c-i][b] = matrix[c][d-i];</span><br><span class="line">            matrix[c][d-i] = matrix[a+i][d];</span><br><span class="line">            matrix[a+i][d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>46. Permutations</title>
      <link href="/2018/08/30/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-30-46-Permutations/"/>
      <url>/2018/08/30/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-30-46-Permutations/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1]</span><br><span class="line">Output: [[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>All the integers of <code>nums</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>全排列，基础的递归题目。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        process(list,nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回[index,len-1]位置的全排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length)&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                tmp.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            swap(nums,index,i);</span><br><span class="line">            process(list,nums,index+<span class="number">1</span>);</span><br><span class="line">            swap(nums,index,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = num[i];</span><br><span class="line">        num[i] = num[j];</span><br><span class="line">        num[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>44. Wildcard Matching</title>
      <link href="/2018/08/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-28-44-Wildcard-Matching/"/>
      <url>/2018/08/28/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-28-44-Wildcard-Matching/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/wildcard-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/wildcard-matching/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code> where:</p><ul><li><code>&#39;?&#39;</code> Matches any single character.</li><li><code>&#39;*&#39;</code> Matches any sequence of characters (including the empty sequence).</li></ul><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; matches any sequence.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cb&quot;, p &#x3D; &quot;?a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length, p.length &lt;= 2000</code></li><li><code>s</code> contains only lowercase English letters.</li><li><code>p</code> contains only lowercase English letters, <code>&#39;?&#39;</code> or <code>&#39;*&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目是通配符匹配，用动态规划会简单点, i,j的含义是s的前0~i字符能否与p的0~j字符匹配,然后根据p[j]是什么样的字符进行可能性的枚举即可。</li><li></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"**"</span>.equals(p) || <span class="string">"*"</span>.equals(p))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] p_str = p.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str.length + <span class="number">1</span>][p_str.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process(str,p_str,s.length()-<span class="number">1</span>,p.length()-<span class="number">1</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">char</span>[] p,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j+<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span>)&#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = i==-<span class="number">1</span>?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j;k &gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[k] != <span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p[j] == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i;k &gt;= -<span class="number">1</span>;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(process(str,p,k,j-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p[j] == <span class="string">'?'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (process(str,p,i-<span class="number">1</span>,j-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==p[j]&amp;&amp;process(str,p,i-<span class="number">1</span>,j-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. Trapping Rain Water</title>
      <link href="/2018/08/26/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-26-42-Trapping-Rain-Water/"/>
      <url>/2018/08/26/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-26-42-Trapping-Rain-Water/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">https://leetcode.com/problems/trapping-rain-water/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [4,2,0,3,2,5]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>乍一看，以为是单调栈，单调栈最大的特点就是，能求以当前元素为最小值的最长区间，这个题实际上并不适合，所以说上来先不要急着套模型，先从题目本身出发，去思考如何解决。</li><li>每个柱子都有可能接住雨水，接的大小实际就是它能“涨”多高，不就是取决于它左边最高高度和右面最高高度的最小值么。想明白这个地方，这个题就有了。</li><li>构造出辅助数组left[i],表示从0~i中的最大值，right[i]，表示i~lenth-1中的最大值，其中left可以再第二次遍历求每个柱子接水的时候一并算出，这样两个循环就搞定了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        <span class="keyword">int</span> max_n = height[height.length-<span class="number">1</span>];</span><br><span class="line">        right[height.length-<span class="number">1</span>] = max_n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = height.length-<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            max_n = Math.max(height[i],max_n);</span><br><span class="line">            right[i] = max_n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        max_n = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; height.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> expect = Math.min(max_n,right[i+<span class="number">1</span>]);</span><br><span class="line">            res += expect &lt; height[i] ? <span class="number">0</span> : expect-height[i];</span><br><span class="line">            max_n = Math.max(max_n,height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>41. First Missing Positive</title>
      <link href="/2018/08/23/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-23-41-First-Missing-Positive/"/>
      <url>/2018/08/23/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-23-41-First-Missing-Positive/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">https://leetcode.com/problems/first-missing-positive/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an unsorted integer array <code>nums</code>, return the smallest missing positive integer.</p><p>You must implement an algorithm that runs in <code>O(n)</code> time and uses constant extra space.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,0]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,4,-1,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题为hard 难度,不过确实不错！理解好题目，要求O(N),那肯定不能排序。</li><li>假设数组长度为N，最理想的情况就是return N+1，说明1～N 全部出现了，那如果，在我们遍历过程中，出现了一个 不在[1,N]区间的元素或者重复出现[1,N]中的元素 意味着，我们期待的N+1不可能实现了，因为有其他元素 “占位”了，此时最理想的情况是 [1,N-1]仍然满足条件，return N,所以，当扫描到异常元素时，会导致我们期望的值缩小。</li><li>有一点，我们怎么保证我们扫描过的元素是连续的，并且是不重复的，因为重复的会占位，所以我们用双指针，L代表扫描过有效的元素。R代表我们期望的，利用下表与值的关系来重新排列，让元素在对应的下表位置(O(N)),</li><li>特别注意<code>nums[L] == nums[nums[L]-1]</code>,当要置位的元素已经存在时候，说明也是垃圾值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>; <span class="comment">//L,R为虚指,所谓的有效区得保证有效，关键是连续，也就是扫描过去的元素得是连续的才行,L位置必须是放L+1的值</span></span><br><span class="line">        <span class="keyword">int</span> R = nums.length-<span class="number">1</span>; <span class="comment">//R+1代表可连续增长的最大值</span></span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[L]==L+<span class="number">1</span>)&#123;</span><br><span class="line">               L++;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[L] &lt;= L||nums[L] &gt; R+<span class="number">1</span> ||nums[L] == nums[nums[L]-<span class="number">1</span>])&#123;</span><br><span class="line">               swap(nums,L,R);</span><br><span class="line">               R--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               swap(nums,L,nums[L]-<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> loc1,<span class="keyword">int</span> loc2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num[loc1];</span><br><span class="line">        num[loc1] = num[loc2];</span><br><span class="line">        num[loc2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Two Pointer </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>38. Count and Say</title>
      <link href="/2018/08/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-21-38-Count-and-Say/"/>
      <url>/2018/08/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-21-38-Count-and-Say/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">https://leetcode.com/problems/count-and-say/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    The <strong>count-and-say</strong> sequence is a sequence of digit strings defined by the recursive formula:</p><ul><li><code>countAndSay(1) = &quot;1&quot;</code></li><li><code>countAndSay(n)</code> is the way you would “say” the digit string from <code>countAndSay(n-1)</code>, which is then converted into a different digit string.</li></ul><p>To determine how you “say” a digit string, split it into the <strong>minimal</strong> number of substrings such that each substring contains exactly <strong>one</strong> unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.</p><p>For example, the saying and conversion for digit string <code>&quot;3322251&quot;</code>:</p><p><img src="https://assets.leetcode.com/uploads/2020/10/23/countandsay.jpg" alt="img"></p><p>Given a positive integer <code>n</code>, return <em>the</em> <code>nth</code> <em>term of the <strong>count-and-say</strong> sequence</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: &quot;1&quot;</span><br><span class="line">Explanation: This is the base case.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 4</span><br><span class="line">Output: &quot;1211&quot;</span><br><span class="line">Explanation:</span><br><span class="line">countAndSay(1) &#x3D; &quot;1&quot;</span><br><span class="line">countAndSay(2) &#x3D; say &quot;1&quot; &#x3D; one 1 &#x3D; &quot;11&quot;</span><br><span class="line">countAndSay(3) &#x3D; say &quot;11&quot; &#x3D; two 1&#39;s &#x3D; &quot;21&quot;</span><br><span class="line">countAndSay(4) &#x3D; say &quot;21&quot; &#x3D; one 2 + one 1 &#x3D; &quot;12&quot; + &quot;11&quot; &#x3D; &quot;1211&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 30</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>很多题目只是表面花里胡哨，读懂了，把题目简化一下，就发现时一个很普通的模型，此题就属于这类，写好递归即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] last = countAndSay(n - <span class="number">1</span>).toCharArray();</span><br><span class="line">StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; last.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (last[i - <span class="number">1</span>] == last[i]) &#123;</span><br><span class="line">times++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans.append(times);</span><br><span class="line">ans.append(last[i - <span class="number">1</span>]);</span><br><span class="line">times = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.append(times);</span><br><span class="line">ans.append(last[last.length - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36. Valid Sudoku</title>
      <link href="/2018/08/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-21-36-Valid-Sudoku/"/>
      <url>/2018/08/21/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-21-36-Valid-Sudoku/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode.com/problems/valid-sudoku/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-sudoku/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Determine if a <code>9 x 9</code> Sudoku board is valid. Only the filled cells need to be validated <strong>according to the following rules</strong>:</p><ol><li>Each row must contain the digits <code>1-9</code> without repetition.</li><li>Each column must contain the digits <code>1-9</code> without repetition.</li><li>Each of the nine <code>3 x 3</code> sub-boxes of the grid must contain the digits <code>1-9</code> without repetition.</li></ol><p><strong>Note:</strong></p><ul><li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li><li>Only the filled cells need to be validated according to the mentioned rules.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; </span><br><span class="line">[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> is a digit <code>1-9</code> or <code>&#39;.&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>其实就是遍历，判断一下此时在列方向、行方向是不是不满足条件，遍历过程中标记好条件即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//主要是存当前行、当前列、当前子块</span></span><br><span class="line">        <span class="keyword">int</span>[][] rowVisited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">10</span>]; <span class="comment">// 第二维是数字</span></span><br><span class="line">        <span class="keyword">int</span>[][] colVisited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">10</span>]; <span class="comment">//第二维是数字</span></span><br><span class="line">        <span class="keyword">int</span>[][] subMatrixVisited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> subId =<span class="number">3</span> * (i/<span class="number">3</span>) + j/<span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">char</span> t = board[i][j]; </span><br><span class="line">                    <span class="keyword">if</span>(t == <span class="string">'.'</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> num = t - <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(rowVisited[i][num] == <span class="number">1</span> || colVisited[j][num] == <span class="number">1</span> || subMatrixVisited[subId][num]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rowVisited[i][num] = <span class="number">1</span>;</span><br><span class="line">                    colVisited[j][num] = <span class="number">1</span>;</span><br><span class="line">                    subMatrixVisited[subId][num]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34. Find First and Last Position of Element in Sorted Array</title>
      <link href="/2018/08/20/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-20-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/"/>
      <url>/2018/08/20/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-20-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p><p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [], target &#x3D; 0</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>nums</code> is a non-decreasing array.</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>二分的典型应用，查找第一个满足条件的值，其实 二分在求某个函数的解时，威力无穷，有机会专门总结一下。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.length==<span class="number">0</span>?<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125; : (nums[<span class="number">0</span>]==target ? <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125; : <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = binarySearch(nums, target );</span><br><span class="line">        <span class="keyword">if</span>(left == Integer.MAX_VALUE||nums[left] &gt; target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> right = binarySearch(nums, target + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right == Integer.MAX_VALUE ? nums.length-<span class="number">1</span>:right-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找 查找第一个一个大于等于target的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r =nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                res = Math.min(res,mid);</span><br><span class="line">                r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                l = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>33. Search in Rotated Sorted Array</title>
      <link href="/2018/08/20/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-20-33-Search-in-Rotated-Sorted-Array/"/>
      <url>/2018/08/20/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-20-33-Search-in-Rotated-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/search-in-rotated-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p><p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p><p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of</em> <code>target</code> <em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li>All values of <code>nums</code> are <strong>unique</strong>.</li><li><code>nums</code> is an ascending array that is possibly rotated.</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目不错，已经要求你log(n)的时间复杂度，那只能往二分上去想了，这是很明确的吧。</li><li>既然二分，关键在于根据题目的特点，找到能每次二分的点，每次能砍掉近一半的数据，此题的特点是原先是上升的，如果出现了下降的元素，那么就是发生了旋转,我们可以先通过比较l和r位置元素判断出此时是否是旋转区间，如果不是，直接二分查找，如果是可以通过l、mid、r三个位置的元素来确定哪个区间出现了旋转区间，对于无旋转区间的 可以直接判断出target是否存在此区间。</li><li>利用好，无旋转区间，即上升区间的特点，可以减少很多复杂的判断，最终目的就是缩小解空间，最终逼近答案</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[r])&#123; <span class="comment">//l 到 r内 是递增区间，无旋转点，直接二分查找</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//l 到 r内 含有旋转点 ,进一步通过mid 来定位旋转点</span></span><br><span class="line">                <span class="keyword">if</span>(nums[l] &lt;= nums[mid])&#123; <span class="comment">//左边无旋转点,从[l,mid]是升区间</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[l] &lt;= target &amp;&amp; nums[mid] &gt;= target)&#123;</span><br><span class="line">                        <span class="comment">//来此区间找</span></span><br><span class="line">                        r = mid -<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        l = mid +<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  <span class="comment">//从mid+1到r才是正常区间</span></span><br><span class="line">                        <span class="comment">//左边有旋转区间,右边无旋转点，即问题变成了，此时如何判断target是在左变还是右边?通过右区间判断</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[mid] &lt;= target &amp;&amp; nums[r] &gt;=target)&#123; <span class="comment">//来右边</span></span><br><span class="line">                        l = mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                        r = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>29. Divide Two Integers</title>
      <link href="/2018/08/20/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-20-29-Divide-Two-Integers/"/>
      <url>/2018/08/20/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-20-29-Divide-Two-Integers/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/divide-two-integers/" target="_blank" rel="noopener">https://leetcode.com/problems/divide-two-integers/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers <strong>without</strong> using multiplication, division, and mod operator.</p><p>The integer division should truncate toward zero, which means losing its fractional part. For example, <code>8.345</code> would be truncated to <code>8</code>, and <code>-2.7335</code> would be truncated to <code>-2</code>.</p><p>Return <em>the <strong>quotient</strong> after dividing</em> <code>dividend</code> <em>by</em> <code>divisor</code>.</p><p><strong>Note:</strong> Assume we are dealing with an environment that could only store integers within the <strong>32-bit</strong> signed integer range: <code>[−231, 231 − 1]</code>. For this problem, if the quotient is <strong>strictly greater than</strong> <code>231 - 1</code>, then return <code>231 - 1</code>, and if the quotient is <strong>strictly less than</strong> <code>-231</code>, then return <code>-231</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend &#x3D; 10, divisor &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 10&#x2F;3 &#x3D; 3.33333.. which is truncated to 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend &#x3D; 7, divisor &#x3D; -3</span><br><span class="line">Output: -2</span><br><span class="line">Explanation: 7&#x2F;-3 &#x3D; -2.33333.. which is truncated to -2.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= dividend, divisor &lt;= 231 - 1</code></li><li><code>divisor != 0</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这题leetcode标注为中等难度，点踩的人特别多， 我也比较晕 不知道考察什么，可能还没领会到精髓。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//溢出的情况判断</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> dividend/divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28. Implement strStr()</title>
      <link href="/2018/08/20/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-20-28-Implement-strStr/"/>
      <url>/2018/08/20/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-20-28-Implement-strStr/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-strstr/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strStr()</a>.</p><p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p><p><strong>Clarification:</strong></p><p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p><p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C’s <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strstr()</a> and Java’s <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String" target="_blank" rel="noopener">indexOf()</a>).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> and <code>needle</code> consist of only lowercase English characters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题leetcode是标注是easy,其实考察的是kmp字符串匹配算法，疑问java的indexOf方法底层实际就是kmp的实现，所以这个地方就偷个懒了，有关Kmp方法以及它的改进，有机会我会详细讲解。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26. Remove Duplicates from Sorted Array</title>
      <link href="/2018/08/20/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-20-26-Remove-Duplicates-from-Sorted-Array/"/>
      <url>/2018/08/20/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-20-26-Remove-Duplicates-from-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>.</p><p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code> should hold the final result. It does not matter what you leave beyond the first <code>k</code> elements.</p><p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p><p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p><p><strong>Custom Judge:</strong></p><p>The judge will test your solution with the following code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums &#x3D; [...]; &#x2F;&#x2F; Input array</span><br><span class="line">int[] expectedNums &#x3D; [...]; &#x2F;&#x2F; The expected answer with correct length</span><br><span class="line"></span><br><span class="line">int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; Calls your implementation</span><br><span class="line"></span><br><span class="line">assert k &#x3D;&#x3D; expectedNums.length;</span><br><span class="line">for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] &#x3D;&#x3D; expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,2]</span><br><span class="line">Output: 2, nums &#x3D; [1,2,_]</span><br><span class="line">Explanation: Your function should return k &#x3D; 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">Output: 5, nums &#x3D; [0,1,2,3,4,_,_,_,_,_]</span><br><span class="line">Explanation: Your function should return k &#x3D; 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li><li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，双指针，通过一次遍历把重复元素去除掉，简答题目第一次能做出来也挺不错的，不知道为什么那么多人点踩。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>; <span class="comment">//p1实指，p1以及之后都是留下来的了</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> p2 = <span class="number">0</span>;p2 &lt; nums.length;p2++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p1] != nums[p2])&#123;</span><br><span class="line">                nums[++p1] = nums[p2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23. Merge k Sorted Lists</title>
      <link href="/2018/08/17/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-17-23-Merge-k-Sorted-Lists/"/>
      <url>/2018/08/17/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-17-23-Merge-k-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-k-sorted-lists/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p><p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">Output: [1,1,2,3,4,4,5,6]</span><br><span class="line">Explanation: The linked-lists are:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">merging them into one sorted list:</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; [[]]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 104</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-104 &lt;= lists[i][j] &lt;= 104</code></li><li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li><li>The sum of <code>lists[i].length</code> will not exceed <code>10^4</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>难度不大，主要考察堆，属于堆的典型题目，再配合链表，算是常考题目了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        ListNode last = <span class="keyword">null</span>;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;((a,b)-&gt;a.val - b.val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                heap.add(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">final</span> ListNode t = heap.poll();</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">                head = t;</span><br><span class="line">                last = t;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                last.next = t;</span><br><span class="line">                last = last.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                heap.add(t.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22. Generate Parentheses</title>
      <link href="/2018/08/15/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-15-22-Generate-Parentheses/"/>
      <url>/2018/08/15/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-15-22-Generate-Parentheses/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/generate-parentheses/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: [&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: [&quot;()&quot;]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>普通题，考察写递归的能力。</li><li>要的是全部解，这种全部可能性的肯定是递归来收集答案了，注意递归的写法，确定递归函数中需要哪些信息来确定参数，要尽可能的减少参数</li><li>递归中，假设到[0,index-1]的已经正确的填完了，现在来填index的位置，每次填，用条件保证填对，这样到length的位置，递归结束，此时的填写的path是正确的一种，不用再进行判断。如何判断此时填什么符合？<ul><li>首先，leftSize表示还能填左括号的个数，开始默认是n个,那么leftSize &gt; 0，此时可以填 左括号,填完leftSize 需要减1</li><li>右括号填写的条件是，已经填的右括号的个数: $index-(N-leftSize)$  仍然小于左括号个数：$N-leftSize$,整理可得$index &lt; 2 *(N-leftSize)$</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        process(n,<span class="number">0</span>,res,path,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> leftRest,<span class="keyword">int</span> index,List&lt;String&gt; res,StringBuilder path,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">2</span>*N)&#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftRest &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            process(leftRest-<span class="number">1</span>,index+<span class="number">1</span>,res,path.append(<span class="string">"("</span>),N);</span><br><span class="line">            path.deleteCharAt(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">2</span> *(N-leftRest))&#123;</span><br><span class="line">            process(leftRest,index+<span class="number">1</span>,res,path.append(<span class="string">")"</span>),N);</span><br><span class="line">            path.deleteCharAt(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21. Merge Two Sorted Lists</title>
      <link href="/2018/08/15/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-15-21-Merge-Two-Sorted-Lists/"/>
      <url>/2018/08/15/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-15-21-Merge-Two-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p> <a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p><p>Merge the two lists in a one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p><p>Return <em>the head of the merged linked list</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: list1 &#x3D; [1,2,4], list2 &#x3D; [1,3,4]</span><br><span class="line">Output: [1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: list1 &#x3D; [], list2 &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: list1 &#x3D; [], list2 &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>Both <code>list1</code> and <code>list2</code> are sorted in <strong>non-decreasing</strong> order.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，细心点就可以了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">        ListNode head = list1;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">                pre = pre ==<span class="keyword">null</span>?list1:pre.next;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode tmp = list2.next;</span><br><span class="line">                list2.next = list1;</span><br><span class="line">                <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre = list2;</span><br><span class="line">                    head = list2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre.next = list2;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                list2 = tmp;</span><br><span class="line">                list1 = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list2 != <span class="keyword">null</span>)</span><br><span class="line">            pre.next = list2;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20. Valid Parentheses</title>
      <link href="/2018/08/15/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-15-20-Valid-Parentheses/"/>
      <url>/2018/08/15/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-15-20-Valid-Parentheses/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-parentheses/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> consists of parentheses only <code>&#39;()[]{}&#39;</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>很简单，栈的最基本应用</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> N = str.length;</span><br><span class="line"><span class="keyword">char</span>[] stack = <span class="keyword">new</span> <span class="keyword">char</span>[N];</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> cha = str[i];</span><br><span class="line"><span class="keyword">if</span> (cha == <span class="string">'('</span> || cha == <span class="string">'['</span> || cha == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">stack[size++] = cha == <span class="string">'('</span> ? <span class="string">')'</span> : (cha == <span class="string">'['</span> ? <span class="string">']'</span> : <span class="string">'&#125;'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> last = stack[--size];</span><br><span class="line"><span class="keyword">if</span> (cha != last) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19. Remove Nth Node From End of List</title>
      <link href="/2018/08/15/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-15-19-Remove-Nth-Node-From-End-of-List/"/>
      <url>/2018/08/15/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-15-19-Remove-Nth-Node-From-End-of-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-nth-node-from-end-of-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">Output: [1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1], n &#x3D; 1</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], n &#x3D; 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is <code>sz</code>.</li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，考察数据结构基本功，写的时候耐心点，细节点即可。</li><li>小技巧，保留一个pre和cur遍历指针相隔K个，这样等cur==null时，pre指向的就是要的元素。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          ListNode cur = head,pre = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(step &gt;= n)&#123;</span><br><span class="line">                  pre = pre == <span class="keyword">null</span> ? head : pre.next;</span><br><span class="line">              &#125;</span><br><span class="line">              cur = cur.next;</span><br><span class="line">              step++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> head.next;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              pre.next = pre.next.next;</span><br><span class="line">              <span class="keyword">return</span> head;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17. Letter Combinations of a Phone Number</title>
      <link href="/2018/08/14/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-14-17-Letter-Combinations-of-a-Phone-Number/"/>
      <url>/2018/08/14/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-14-17-Letter-Combinations-of-a-Phone-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">https://leetcode.com/problems/letter-combinations-of-a-phone-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p><p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><img src="https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png" alt="img"></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; &quot;&quot;</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; &quot;2&quot;</span><br><span class="line">Output: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> is a digit in the range <code>[&#39;2&#39;, &#39;9&#39;]</code>.</li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>不难，主要是考察会不会写递归，在递归中收集组合</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[][] phone = &#123; </span><br><span class="line">&#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> &#125;, <span class="comment">// 2    0</span></span><br><span class="line">&#123; <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span> &#125;, <span class="comment">// 3    1</span></span><br><span class="line">&#123; <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span> &#125;, <span class="comment">// 4    2</span></span><br><span class="line">&#123; <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span> &#125;, <span class="comment">// 5    3</span></span><br><span class="line">&#123; <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span> &#125;, <span class="comment">// 6    </span></span><br><span class="line">&#123; <span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span> &#125;, <span class="comment">// 7 </span></span><br><span class="line">&#123; <span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span> &#125;,   <span class="comment">// 8</span></span><br><span class="line">&#123; <span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span> &#125;, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "23"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = digits.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] path = <span class="keyword">new</span> <span class="keyword">char</span>[str.length];</span><br><span class="line">process(str, <span class="number">0</span>, path, ans);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> index, <span class="keyword">char</span>[] path, List&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == str.length) &#123;</span><br><span class="line">ans.add(String.valueOf(path));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">char</span>[] cands = phone[str[index] - <span class="string">'2'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> cur : cands) &#123;</span><br><span class="line">path[index] = cur;</span><br><span class="line">process(str, index + <span class="number">1</span>, path, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 3Sum</title>
      <link href="/2018/08/13/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-13-15-3Sum/"/>
      <url>/2018/08/13/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-13-15-3Sum/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p><p>Notice that the solution set must not contain duplicate triplets.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,0,1,2,-1,-4]</span><br><span class="line">Output: [[-1,-1,2],[-1,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">nums[0] + nums[1] + nums[1] &#x3D; (-1) + 0 + 1 &#x3D; 0.</span><br><span class="line">nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0.</span><br><span class="line">nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0.</span><br><span class="line">The distinct triplets are [-1,0,1] and [-1,-1,2].</span><br><span class="line">Notice that the order of the output and the order of the triplets does not matter.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,1]</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The only possible triplet does not sum up to 0.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,0,0]</span><br><span class="line">Output: [[0,0,0]]</span><br><span class="line">Explanation: The only possible triplet sums up to 0.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>中等难度，不错的题目。先理解题目，要求输出的三元组 是元素的值，并且list里面的3元组不能重复</li><li>可以这样想3元组和为0，3个元素一定是小中大的关系，可以枚举小的元素，再去找中和大的元素。可以将元素排序，这样依次枚举，枚举的一定是小的元素，巧妙的避免重复。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> p1 = i+<span class="number">1</span>,p2 = nums.length-<span class="number">1</span>,target = <span class="number">0</span>-nums[i];</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; p2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[p1]+nums[p2] == target)&#123;</span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    tmp.add(nums[i]);</span><br><span class="line">                    tmp.add(nums[p1++]);</span><br><span class="line">                    tmp.add(nums[p2--]);</span><br><span class="line">                    list.add(tmp);</span><br><span class="line">                    <span class="keyword">while</span> (p2 &gt; p1 &amp;&amp; nums[p2] == nums[p2+<span class="number">1</span>]) p2--;</span><br><span class="line">                    <span class="keyword">while</span> (p1 &lt; p2 &amp;&amp; nums[p1] == nums[p1-<span class="number">1</span>]) p1++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[p1]+nums[p2] &lt; target)&#123;</span><br><span class="line">                    p1++;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14. Longest Common Prefix</title>
      <link href="/2018/08/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-11-14-Longest-Common-Prefix/"/>
      <url>/2018/08/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-11-14-Longest-Common-Prefix/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-common-prefix/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> consists of only lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>遍历，不断缩短前缀即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String commonPrefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[i].indexOf(commonPrefix) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> length = commonPrefix.length();</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> ( j = length-<span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(strs[i].indexOf(commonPrefix.substring(<span class="number">0</span>,j)) == <span class="number">0</span>)&#123;</span><br><span class="line">                        commonPrefix = commonPrefix.substring(<span class="number">0</span>,j);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    commonPrefix = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> commonPrefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13. Roman to Integer</title>
      <link href="/2018/08/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-11-13-Roman-to-Integer/"/>
      <url>/2018/08/11/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-11-13-Roman-to-Integer/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/roman-to-integer/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>For example, <code>2</code> is written as <code>II</code> in Roman numeral, just two ones added together. <code>12</code> is written as <code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;III&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: III &#x3D; 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 15</code></li><li><code>s</code> contains only the characters <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code>.</li><li>It is <strong>guaranteed</strong> that <code>s</code> is a valid roman numeral in the range <code>[1, 3999]</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>水题，比较简单，看懂题意就能做.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">// C     M     X   C     I   X</span></span><br><span class="line"><span class="comment">// 100  1000  10   100   1   10</span></span><br><span class="line"><span class="keyword">int</span> nums[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">switch</span> (s.charAt(i)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">nums[i] = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">nums[i] = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">nums[i] = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">nums[i] = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">nums[i] = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">nums[i] = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">nums[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">sum -= nums[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum + nums[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Container With Most Water</title>
      <link href="/2018/08/08/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-08-11-Container-With-Most-Water/"/>
      <url>/2018/08/08/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-08-11-Container-With-Most-Water/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode.com/problems/container-with-most-water/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>ith</code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p><p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p><p>Return <em>the maximum amount of water a container can store</em>.</p><p><strong>Notice</strong> that you may not slant the container.</p><p><strong>Example 1:</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br><span class="line">Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [1,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>绝对的经典问题，通过双指针，不断的推高答案，不是一下找到答案，而是尽可能的寻找到最接近答案的值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[p1] &lt; height[p2])&#123;</span><br><span class="line">               res = Math.max((p2-p1)*height[p1],res);</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max((p2-p1)*height[p2],res);</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two pointer </tag>
            
            <tag> greed </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10. Regular Expression Matching</title>
      <link href="/2018/08/08/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-08-10-Regular-Expression-Matching/"/>
      <url>/2018/08/08/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-08-10-Regular-Expression-Matching/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an input string <code>s</code> and a pattern <code>p</code>, implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code> where:</p><ul><li><code>&#39;.&#39;</code> Matches any single character.</li><li><code>&#39;*&#39;</code> Matches zero or more of the preceding element.</li></ul><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ab&quot;, p &#x3D; &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= p.length &lt;= 30</code></li><li><code>s</code> contains only lowercase English letters.</li><li><code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and <code>&#39;*&#39;</code>.</li><li>It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题，第一次做的的话 会比较麻烦。用i代表字符串的当前字符，j代表正则表达式的当前字符，主要分区，后面的字符是不是<em>这种情况，如果是\</em>，说明当前i未必非得让j来匹配，i和j不同要继续看i和j+2可不可能匹配，如果i后面是一串连续相同的字符，要考虑j是匹配几个着同样的字符呢？</li><li>进行斜率优化，其实，递归是从左到右进行的，循环是可以通过观察替换出来的。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(s.toCharArray(),<span class="number">0</span>,p.toCharArray(),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> i,<span class="keyword">char</span>[] exp,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==exp.length) <span class="keyword">return</span> i ==str.length;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span> != exp.length &amp;&amp; exp[j+<span class="number">1</span>] != <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i != str.length &amp;&amp; (str[i]==exp[j] || exp[j]==<span class="string">'.'</span>) &amp;&amp; process(str,i+<span class="number">1</span>,exp,j+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> == exp.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span> == str.length &amp;&amp; (str[i]==exp[j] || exp[j]==<span class="string">'.'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> c = i;</span><br><span class="line">                <span class="keyword">while</span> (c &lt; str.length &amp;&amp; (str[c]==exp[j]||exp[j]==<span class="string">'.'</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (process(str,c+<span class="number">1</span>,exp,j+<span class="number">2</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    c++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  process(str,i,exp,j+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process(s.toCharArray(),<span class="number">0</span>,p.toCharArray(),<span class="number">0</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> i,<span class="keyword">char</span>[] exp,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>) <span class="keyword">return</span> dp[i][j]==<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == exp.length) &#123;</span><br><span class="line">           res = i == str.length;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> != exp.length &amp;&amp; exp[j + <span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != str.length &amp;&amp; (str[i] == exp[j] || exp[j] == <span class="string">'.'</span>) &amp;&amp; process2(str, i + <span class="number">1</span>, exp, j + <span class="number">1</span>,dp))&#123;</span><br><span class="line">                    res = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> == exp.length) &#123;</span><br><span class="line">                    res =  i + <span class="number">1</span> == str.length &amp;&amp; (str[i] == exp[j] || exp[j] == <span class="string">'.'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">                        res = process2(str, i, exp, j + <span class="number">2</span>,dp);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(str[i] != exp[j] &amp;&amp; exp[j] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                            res =  process2(str, i, exp, j + <span class="number">2</span>,dp);</span><br><span class="line">                        &#125;<span class="keyword">else</span></span><br><span class="line">                            res = process2(str, i, exp, j + <span class="number">2</span>,dp) || process2(str, i+<span class="number">1</span>, exp, j,dp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = res?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8. String to Integer (atoi)</title>
      <link href="/2018/08/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-05-8-String-to-Integer-atoi/"/>
      <url>/2018/08/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-05-8-String-to-Integer-atoi/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode.com/problems/string-to-integer-atoi/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer (similar to C/C++’s <code>atoi</code> function).</p><p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p><ol><li>Read in and ignore any leading whitespace.</li><li>Check if the next character (if not already at the end of the string) is <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code>. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.</li><li>Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.</li><li>Convert these digits into an integer (i.e. <code>&quot;123&quot; -&gt; 123</code>, <code>&quot;0032&quot; -&gt; 32</code>). If no digits were read, then the integer is <code>0</code>. Change the sign as necessary (from step 2).</li><li>If the integer is out of the 32-bit signed integer range <code>[-231, 231 - 1]</code>, then clamp the integer so that it remains in the range. Specifically, integers less than <code>-231</code> should be clamped to <code>-231</code>, and integers greater than <code>231 - 1</code> should be clamped to <code>231 - 1</code>.</li><li>Return the integer as the final result.</li></ol><p><strong>Note:</strong></p><ul><li>Only the space character <code>&#39; &#39;</code> is considered a whitespace character.</li><li><strong>Do not ignore</strong> any characters other than the leading whitespace or the rest of the string after the digits.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;42&quot;</span><br><span class="line">Output: 42</span><br><span class="line">Explanation: The underlined characters are what is read in, the caret is the current reader position.</span><br><span class="line">Step 1: &quot;42&quot; (no characters read because there is no leading whitespace)</span><br><span class="line">         ^</span><br><span class="line">Step 2: &quot;42&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)</span><br><span class="line">         ^</span><br><span class="line">Step 3: &quot;42&quot; (&quot;42&quot; is read in)</span><br><span class="line">           ^</span><br><span class="line">The parsed integer is 42.</span><br><span class="line">Since 42 is in the range [-231, 231 - 1], the final result is 42.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation:</span><br><span class="line">Step 1: &quot;   -42&quot; (leading whitespace is read and ignored)</span><br><span class="line">            ^</span><br><span class="line">Step 2: &quot;   -42&quot; (&#39;-&#39; is read, so the result should be negative)</span><br><span class="line">             ^</span><br><span class="line">Step 3: &quot;   -42&quot; (&quot;42&quot; is read in)</span><br><span class="line">               ^</span><br><span class="line">The parsed integer is -42.</span><br><span class="line">Since -42 is in the range [-231, 231 - 1], the final result is -42.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation:</span><br><span class="line">Step 1: &quot;4193 with words&quot; (no characters read because there is no leading whitespace)</span><br><span class="line">         ^</span><br><span class="line">Step 2: &quot;4193 with words&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)</span><br><span class="line">         ^</span><br><span class="line">Step 3: &quot;4193 with words&quot; (&quot;4193&quot; is read in; reading stops because the next character is a non-digit)</span><br><span class="line">             ^</span><br><span class="line">The parsed integer is 4193.</span><br><span class="line">Since 4193 is in the range [-231, 231 - 1], the final result is 4193.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length &lt;= 200</code></li><li><code>s</code> consists of English letters (lower-case and upper-case), digits (<code>0-9</code>), <code>&#39; &#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;.&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这题点踩的人有点多，个人也感觉这个题不是很漂亮，主要条件描述不清楚，各种异常的情况 报错了才知道，而且也考察不出什么东西。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="keyword">if</span>(s.length() ==<span class="number">0</span> || s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span> c = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(c&lt;=<span class="string">'z'</span> &amp;&amp; c &gt;= <span class="string">'a'</span> || c == <span class="string">'.'</span> || c &lt;= <span class="string">'Z'</span>&amp;&amp; c &gt;= <span class="string">'A'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//一定是以数字或者字符或者空白开头</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span> || s.charAt(i) == <span class="string">'-'</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">if</span>(!(s.charAt(<span class="number">0</span>) &lt;= <span class="string">'9'</span> &amp;&amp; s.charAt(<span class="number">0</span>) &gt;= <span class="string">'0'</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.length() &amp;&amp; !(s.charAt(i+<span class="number">1</span>) &gt;=<span class="string">'0'</span> &amp;&amp; s.charAt(i+<span class="number">1</span>) &lt;=<span class="string">'9'</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String regex = <span class="string">"[-+]?\\d+"</span>;</span><br><span class="line">        <span class="keyword">final</span> Pattern pattern = Pattern.compile(regex);</span><br><span class="line">        <span class="keyword">final</span> Matcher matcher = pattern.matcher(s);</span><br><span class="line">        <span class="keyword">if</span>(matcher.find())&#123;</span><br><span class="line">            <span class="keyword">final</span> String int_str = matcher.group();</span><br><span class="line">            <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                l = Integer.parseInt(int_str);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">if</span>(int_str.charAt(<span class="number">0</span>) == <span class="string">'-'</span>)</span><br><span class="line">                    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7. Reverse Integer</title>
      <link href="/2018/08/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-05-7-Reverse-Integer/"/>
      <url>/2018/08/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-05-7-Reverse-Integer/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-integer/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a signed 32-bit integer <code>x</code>, return <code>x</code> <em>with its digits reversed</em>. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range <code>[-2^31, 2^31 - 1]</code>, then return <code>0</code>.</p><p><strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</strong></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= x &lt;= 23^1 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ol><li>此题偏简单，不能使用Long来存，反转之后，我们需要一位一位的进行计算存值，肯定会有溢出的情况，所以，我们要学会“提前处理”，<code>res==m &amp;&amp; x%10 &lt; o</code>  否则很有可能到最后是溢出的情况而我们又判断不出此时的情况。</li><li>可以将传入的整数以负数形式存储，这样存的值对于反转之后Integer.MIN来说正好存下，当然此题不会传入这种值，但若是以字符串形式传入，这个技巧就生效了。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> neg = x &lt; <span class="number">0</span>;</span><br><span class="line">        x = neg ? x : -x;   <span class="comment">//溢出是两个方向的，统一变负数处理，可以换成一个方向上 </span></span><br><span class="line">        <span class="keyword">int</span> m = Integer.MIN_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> o = Integer.MIN_VALUE % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res &lt; m || res==m &amp;&amp; x%<span class="number">10</span> &lt; o) <span class="comment">//提前进行整数溢出的判断</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neg ? res : Math.abs(res);  <span class="comment">//理论会有 负数没溢出，转绝对值溢出的情况，所以应该特殊处理，但这个题输入是一个整数，不会出现反转是-2147483647</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. Longest Palindromic Substring</title>
      <link href="/2018/08/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-05-5-Longest-Palindromic-Substring/"/>
      <url>/2018/08/05/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-05-5-Longest-Palindromic-Substring/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-palindromic-substring/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code>, return <em>the longest palindromic substring</em> in <code>s</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Explanation: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> consist of only digits and English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题是比较经典的DP问题，可以先对边界进行单独处理，转移方程如下:<script type="math/tex; mode=display">dp[i][j] = \begin{cases} true & i = j\\equal(chars[i],chars[j]) & j=i+1,j < N  \end{cases}</script>然后，再对非边界内元素进行递推即可:<script type="math/tex; mode=display">dp[i][j] = \begin{cases}  if (chars[i]=chars[j])  & dp[i+1][j-1]\\ else & false \end{cases}</script></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sd=<span class="number">0</span>,ed=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; N)&#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = chars[i]==chars[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][i+<span class="number">1</span>])&#123;</span><br><span class="line">                        res = <span class="number">2</span>;</span><br><span class="line">                        sd = i;</span><br><span class="line">                        ed = i+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">3</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">2</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[i] == chars[j])&#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i+<span class="number">1</span> &gt; res)&#123;</span><br><span class="line">                        res = j-i+<span class="number">1</span>;</span><br><span class="line">                        sd = i;</span><br><span class="line">                        ed = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(sd,ed+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. Add Two Numbers</title>
      <link href="/2018/08/04/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-04-2-Add-Two-Numbers/"/>
      <url>/2018/08/04/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-04-2-Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode.com/problems/add-two-numbers/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">Output: [7,0,8]</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">Output: [8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>It is guaranteed that the list represents a number that does not have leading zeros.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>注意几个点</p><ul><li>注意进位的处理，每次累加 记得加上进位</li><li>最后若仍有进位，需要单独新建一个节点来保留进位</li><li>为减少额外空间，可以将结果累加到l1上或者l2上而不必新建节点。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jie = <span class="number">0</span>;</span><br><span class="line">        ListNode p1 = l1;</span><br><span class="line">        ListNode p2 = l2;</span><br><span class="line">        ListNode p1_last = <span class="keyword">null</span>;;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = (p1.val + p2.val + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (p1.val + p2.val + jie)/<span class="number">10</span>;</span><br><span class="line">            p1.val = left;</span><br><span class="line">            p1_last = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = (p1.val + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (p1.val + jie)/<span class="number">10</span>;</span><br><span class="line">            p1.val = left;</span><br><span class="line">            p1_last = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = (p2.val + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (p2.val + jie)/<span class="number">10</span>;</span><br><span class="line">            p1_last.next = <span class="keyword">new</span> ListNode(left);</span><br><span class="line">            p1_last = p1_last.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jie != <span class="number">0</span>)&#123;</span><br><span class="line">            p1_last.next = <span class="keyword">new</span> ListNode(jie);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link href="/2018/08/04/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-04-3-Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2018/08/04/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-04-3-Longest-Substring-Without-Repeating-Characters/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a> </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a string <code>s</code>, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3.</span><br><span class="line">Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> consists of English letters, digits, symbols and spaces.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题相对简单，属于中等难度，可以使用滑动窗口或者动态规划来做，看到最优解，习惯性的使用DP来解</li><li>定义dp[i]含义为以i位置结尾的最长不重复子串长度，思考如何用dp[i]推导出dp[i+1],由于是不重复子串， 所以i+1位置结尾的子串，需要考虑i+1位置自符出现的位置,可以建立一个辅助map，来记录当前字符上次出现的位置,递推方程如下:</li></ul><script type="math/tex; mode=display">dp[i] = \left\{dp[i-1],i-map[chars[i]] \right\}\left ( i=1,2...n-1 \right )</script><ul><li>动态规划在分析过程中，经常是“需要什么就要创建什么”，通常要建立一些辅助数组来推导最优解</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">            map[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[chars[<span class="number">0</span>]] = <span class="number">0</span>;<span class="comment">//注意记录字符最近一次出现的位置，不要漏掉首个字符</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p1 = dp[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> p2 = i-map[chars[i]];</span><br><span class="line">            dp[i] = Math.min(p1,p2);</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">            map[chars[i]]  = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. Median of Two Sorted Arrays</title>
      <link href="/2018/08/04/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-04-4-Median-of-Two-Sorted-Arrays/"/>
      <url>/2018/08/04/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-04-4-Median-of-Two-Sorted-Arrays/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/2018/08/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-01-1-Two-Sum/"/>
      <url>/2018/08/01/leetcode-leetcode%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98-2018-08-01-1-Two-Sum/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p> <a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p><p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p><p>You can return the answer in any order.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: Because nums[0] + nums[1] &#x3D;&#x3D; 9, we return [0, 1].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">Output: [0,1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>Only one valid answer exists.</strong></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>此题比较简单，可以学到一个基本技巧-“在遍历过程中寻找已经处理过的元素”，并且尽可能快的查找元素，优先考虑到有序表结构。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(target - nums[i]), i &#125;;</span><br><span class="line">&#125;</span><br><span class="line">map.put(nums[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
