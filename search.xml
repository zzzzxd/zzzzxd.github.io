<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql的操作规范</title>
      <link href="/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E6%93%8D%E4%BD%9C%E8%A7%84%E8%8C%83/"/>
      <url>/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E6%93%8D%E4%BD%9C%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天来看一下，比较通用的规范操作。</p><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>1.1、表名建议使用有业务意义的英文词汇，必要时可加数字和下划线，并以英文字母开头；</p><p>1.2、库、表、字段全部采用小写；</p><p>MySQL 在 Linux 下默认是区分大小写的，而在 Windows 下不区分大小写。因此，防止出现问题，建议都设置为小写。</p><p>1.3、避免用 MySQL 的保留字， MySQL 保留字请参考<a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html" target="_blank" rel="noopener">官方手册：9.3 Keywords and Reserved Words</a>；</p><p>1.4、命名（包括表名、列名）禁止超过 30 个字符；</p><p>1.5、临时库、表名必须以 tmp 为前缀，并以日期为后缀，如：tmp_shop_info_20190404；</p><p>1.6、备份库、表必须以 bak 为前缀，并以日期为后缀，如：bak_shop_info_20190404；</p><p>1.7、索引命名：</p><ul><li>非唯一索引必须按照“idx_字段名称”进行命名；</li><li>唯一索引必须按照“uniq_字段名称”进行命名。</li></ul><h2 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h2><ol><li>主键：</li></ol><ul><li>表必须有主键；</li><li>不使用更新频繁的列做主键；</li><li>尽量不选择字符串列做主键；</li><li>不使用 UUID MD5 HASH 做主键；</li><li>默认使用非空的唯一键。</li></ul><ol><li><p>如无特殊要求，建议都使用 InnoDB 引擎；</p></li><li><p>默认使用 utf8mb4 字符集，数据排序规则使用 utf8mb4_general_ci；</p></li></ol><p>原因：utf8mb4 为万国码，无乱码风险；与 utf8 编码相比，utf8mb4 能支持 Emoji 表情。</p><ol><li>所有表、字段都需要增加 comment 来描述此表、字段所表示的含义；</li></ol><p>比如：data_status TINYINT NOT NULL DEFAULT ‘1’ COMMENT ‘1代表记录有效，0代表记录无效’。</p><ol><li><p>、如无说明，表必须包含 create_time 和 update_time 字段，即表必须包含记录创建时间和修改时间的字段；</p></li><li><p>用尽量少的存储空间来存数一个字段的数据：</p></li></ol><ul><li>能用 int 的就不用 char 或者 varchar；</li><li>能用 tinyint 的就不用 int；</li><li>使用 UNSIGNED 存储非负数值；</li><li>只存储年使用 YEAR 类型；</li><li>只存储日期使用 DATE 类型。</li></ul><ol><li>存储精确浮点数必须使用 DECIMAL 替代 FLOAT 和 DOUBLE；</li></ol><p>原因：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。</p><ol><li>尽可能不使用 TEXT、BLOB 类型；</li></ol><p>原因：会浪费更多的磁盘和内存空间，非必要的大量大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能。如果实在有某个字段过长需要使用 TEXT、BLOB 类型，则建议独立出来一张表，用主键来对应，避免影响原表的查询效率。</p><ol><li><p>禁止在数据库中存储明文密码；</p></li><li><p>索引设计规范：</p></li></ol><ul><li><p>需要添加索引的字段</p><ul><li><p>UPDATE、DELETE 语句的 WHERE 条件列；</p></li><li><p>ORDER BY、GROUP BY、DISTINCT 的字段（原因可复习<a href="https://www.imooc.com/read/43/article/686" target="_blank" rel="noopener">第 6 节</a>）；</p></li><li><p>多表 JOIN 的字段（原因可复习<a href="https://www.imooc.com/read/43/article/688" target="_blank" rel="noopener">第 8 节</a>）。</p></li></ul></li><li><p>单表索引建议控制在 5 个以内；</p></li><li><p>适当配置联合索引；</p></li></ul><p>比如方便查询能走覆盖索引，或者几个字段同时作为条件的概率很高时，当然还有其他很多种情况可以设置联合索引.</p><ul><li>业务上具有唯一性的字段，添加成唯一索引；</li></ul><p>遇到过几次字段在业务场景上要求唯一，但是该字段在数据库里的数据却出现了重复。因此在代码层考虑外，还需要在 MySQL 上的对应字段添加唯一索引。</p><ul><li>在 varchar 字段上建立索引时，建议根据实际文本区分度指定索引长度；</li></ul><p>原因：可以降低索引所占用的空间，并且很多时候，比如字符串基本是长度大于 20，但是只要建立长度为 20 的索引，就已经有很高的区分度了。可以使用 count(distinct left(列名, 索引长度))/count(*) 的区分度来确定。</p><ul><li><p>索引禁忌：</p><ul><li><p>不在低基数列上建立索引，例如：性别字段。</p></li><li><p>不在索引列进行数学运算和函数运算（原因，做函数操作可能会导致使用不了索引）</p></li></ul></li></ul><ol><li>不建议使用外键；</li></ol><p>原因：外键会导致表与表之间耦合，update 与 delete 操作都会涉及相关联的表，十分影响 sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能。</p><ol><li>禁止使用存储过程、视图、触发器、Event ；</li></ol><p>原因：高并发的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性。</p><ol><li><p>单表列数目建议小于 30；</p></li><li><p>表示例：</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_info (</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line"> stu_name <span class="built_in">VARCHAR</span> (<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line"> stu_class <span class="built_in">VARCHAR</span> (<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'班级'</span>,</span><br><span class="line"> stu_num <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'学号'</span>,</span><br><span class="line"> stu_score <span class="built_in">SMALLINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'总分'</span>,</span><br><span class="line"> tuition <span class="built_in">DECIMAL</span> (<span class="number">5</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'学费'</span>,</span><br><span class="line"> phone_number <span class="built_in">VARCHAR</span> (<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'电话号码'</span>,</span><br><span class="line"> create_time datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'记录创建时间'</span>,</span><br><span class="line"> update_time datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'记录更新时间'</span>,</span><br><span class="line"> <span class="keyword">status</span> <span class="built_in">TINYINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'1代表记录有效，0代表记录无效'</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line"> <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> uniq_stu_num (stu_num),</span><br><span class="line"> <span class="keyword">KEY</span> idx_stu_score (stu_score),</span><br><span class="line"> <span class="keyword">KEY</span> idx_update_time_tuition (update_time, tuition)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">charset</span> = utf8mb4 <span class="keyword">COMMENT</span> <span class="string">'学生信息表'</span>;</span><br></pre></td></tr></table></figure><h2 id="SQL语句规范"><a href="#SQL语句规范" class="headerlink" title="SQL语句规范"></a>SQL语句规范</h2><ol><li>避免隐式转换；</li></ol><p>具体原因可以看一下前文。</p><ol><li>尽量不使用select *,只 select 需要的字段 ；</li></ol><p>原因：读取不需要的列会增加 CPU、IO、NET 消耗，并且不能有效的利用覆盖索引。使用 SELECT * 容易在增加或者删除字段后导致程序报错。</p><ol><li>禁止使用 INSERT INTO t_xxx VALUES (xxx)，必须显示指定插入的列属性 ；</li></ol><p>原因：容易在增加或者删除字段后导致程序报错。</p><ol><li>尽量不使用负向查询；</li></ol><p>比如 not in/like。</p><ol><li>禁止以 % 开头的模糊查询。</li></ol><p>原因：使用不了索引</p><ol><li><p>禁止单条 SQL 语句同时更新多个表；</p></li><li><p>统计记录数使用 select count(*)，而不是 select count(primary_key)或者 select count(普通字段名)；</p></li></ol><p>原因：可能会导致走的索引不是最优的或者导致统计数字不准确。</p><ol><li><p>建议将子查询转换为关联查询；</p></li><li><p>建议应用程序捕获 SQL 异常，并有相应处理；</p></li><li><p>SQL 中不建议使用 sleep()，如特殊需求需要用到 sleep()，请提前告知 DBA；</p></li><li><p>避免大表的 join。</p></li></ol><h2 id="行为规范"><a href="#行为规范" class="headerlink" title="行为规范"></a>行为规范</h2><ol><li><p>批量导入、导出数据必须提前通知 DBA 协助观察；</p></li><li><p>有可能导致 MySQL QPS 上升的活动，提前告知DBA；</p></li><li><p>同一张表的多个 alter 合成一次操作；</p></li><li><p>不在业务高峰期批量更新、查询数据库；</p></li><li><p>删除表或者库要求尽量先 rename，观察几天，确定对业务没影响，再 drop。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了 MySQL 的一些操作规范，主要讲解了下面这些场景的规范：</p><ol><li>命名规范；</li><li>设计规范；</li><li>SQL 语句规范；</li><li>行为规范。</li></ol><p>当然，各个公司可能都有自己独有的 MySQL 使用规范，因此这篇文章仅供参考。</p><p>当制定出合理的 MySQL 使用规范，并严格按照规范操作，很多问题都可以在源头上避免掉。</p><blockquote><p>参考资料</p><p>《MySQL 工作笔记》第 4 章：SQL 开发规范和基础</p><p>《阿里巴巴Java开发手册》第五章：MySQL 数据库</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层的优化点总结</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E4%BC%98%E5%8C%96%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E4%BC%98%E5%8C%96%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    对于数据库的使用，我们不仅仅要考虑 MySQL 本身的优化，还需要考虑应用层的优化。因为有些线上问题，就是由于应用层设置不合理导致的。下面看一下常见的优化点。</p><h2 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h2><p>MySQL 如果频繁创建和断开连接，那 MySQL 的开销会比较大，可能会占用过多的服务器内存资源，甚至导致响应时间变慢。此时就可以考虑使用连接池来改进性能。</p><p>连接池可以理解为：创建一些持久连接的“池”，新的请求可以使用这些连接池，减少创建和断开连接的次数。</p><p>其大致原理是：</p><ol><li>当进程启动时，创建相应的数据库连接池对象；</li><li>如果程序需要请求数据库，则直接从连接池获取到一个连接；</li><li>数据库请求完成后，释放数据库连接池。</li></ol><p><strong>那么连接池会不会导致服务器连接过多呢？</strong></p><p>通常情况下，连接池不会导致服务器连接过多，因为它们会在进程间排队和共享连接。</p><blockquote><p>在《高性能 MySQL》第 14 章：应用层优化中就提到：当遇到连接池完全占满时，应该将连接请求进行排队，而不是扩展连接池。这样可以避免将压力都转到 MySQL 上而导致 MySQL 连接数过多。</p></blockquote><h2 id="减少对-MySQL-的访问"><a href="#减少对-MySQL-的访问" class="headerlink" title="减少对 MySQL 的访问"></a>减少对 MySQL 的访问</h2><p>避免对同一行数据做重复检索，比如查询某个用户信息。</p><p>首先查出这个用户的联系方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> phone <span class="keyword">from</span> user_info <span class="keyword">where</span> user_id=<span class="number">111</span>;</span><br></pre></td></tr></table></figure><p>然后再查出这个用户的姓名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> user_info <span class="keyword">where</span> user_id=<span class="number">111</span>;</span><br></pre></td></tr></table></figure><p>显然上面的方式并不是最优的，可以将两条 SQL 合并成一条：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> phone,<span class="keyword">name</span>  <span class="keyword">from</span> user_info <span class="keyword">where</span> user_id=<span class="number">111</span>;</span><br></pre></td></tr></table></figure><p>然后返回给客户端。这样跟数据库建立连接的次数从 2 次降低到 1 次，从而节省了部分建立连接所花费的内存和时间。</p><h2 id="增加-Redis-缓存层"><a href="#增加-Redis-缓存层" class="headerlink" title="增加 Redis 缓存层"></a>增加 Redis 缓存层</h2><p>在很多业务场景，Redis 充当着不可或缺的角色。这里介绍几种通过 Redis 环境 MySQL 压力的场景：</p><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>当统计数增加，则在 Redis 中执行下面的命令让计数器加 1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR t1_count</span><br></pre></td></tr></table></figure><p>通过这种方式缓解在 MySQL 中执行 update 的压力。</p><h3 id="K-V-数据缓存"><a href="#K-V-数据缓存" class="headerlink" title="K-V 数据缓存"></a>K-V 数据缓存</h3><p>在 MySQL 中，如果某个字段会被频繁查询，而该字段内容变化的概率又不是很大，就可以考虑使用 Redis 缓存。比如电商业务，查看上个季度某类型商品的销量排行，如果这一个功能放在主页，点击量可能会非常高，因此可以考虑放在 Redis 中。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Redis 中可以非常方便的使用消息队列。</p><p>生产者通过 lpush 将消息放在 list 中，消费者通过 rpop 取出该消息。</p><p>比如使用 Redis 实现短信消息队列。如果用户在 APP 上点击注册用户名密码，需要填下手机号验证，程序会将该用户的手机号放在 Redis 的 list 中，然后另外一个程序一直去消费 list 中的手机号，取出手机后，则调用第三方短信接口，发送手机短信息给到用户。</p><h2 id="单表过大及时归档"><a href="#单表过大及时归档" class="headerlink" title="单表过大及时归档"></a>单表过大及时归档</h2><p>比如单张表过大，可能有下面这些影响：</p><ol><li>在修改表结构时导致长时间主从延迟；</li><li>备份时间过久；</li><li>查询速度可能也会变慢。</li></ol><p>因此，可以考虑对历史数据归档（比如日志数据），控制单表的数据量。</p><h2 id="代码层读写分离"><a href="#代码层读写分离" class="headerlink" title="代码层读写分离"></a>代码层读写分离</h2><p>在配置了 MySQL 主从环境的情况下，可以考虑使用读写分离，通过程序配置的这种方式，在专栏<a href="https://www.imooc.com/read/43/article/707" target="_blank" rel="noopener">第 27 节</a>有提到过。更新走主库，查询走从库。</p><p>当然，主从同步可能因为大事务或者网络等原因导致同步延迟，在使用读写分离是也需要考虑到延迟这一点。</p><h2 id="表的索引提前规划"><a href="#表的索引提前规划" class="headerlink" title="表的索引提前规划"></a>表的索引提前规划</h2><p>当开发或者 DBA 在创建新表时，就应该考虑在表的条件字段添加合适索引。这样可以避免业务上线后，数据量一上来就出现大量慢查询而导致 MySQL 服务器高负载。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了使用 MySQL 时，应用层的一些优化。</p><p>提到了以下几点优化方案：</p><p>1、使用连接池；</p><p>2、减少对 MySQL 的访问；</p><p>3、增加 Redis 缓存层；</p><p>4、单表过大及时归档；</p><p>5、代码层读写分离；</p><p>6、表的索引提前规划；</p><p>······</p><p>实际工作中也是，不单单 DBA 要去优化 MySQL，开发也应该考虑在应用层去做一些优化，以保证业务稳定高效。</p><blockquote><p>参考资料</p><p>《深入浅出 MySQL》第 23 章：应用优化</p><p>《高性能 MySQL》第 14 章：应用层优化</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除大量数据的经验</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E5%88%A0%E9%99%A4%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E5%88%A0%E9%99%A4%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了防止单张表过大，很多情况下，我们需要对历史数据做归档或者删除操作。那么如何高效删除大量无用数据呢？今天就来总结一下。</p><p>在聊数据删除前，我们先来看看 MySQL 的共享表空间和独立表空间。</p><h2 id="共享表空间和独立表空间"><a href="#共享表空间和独立表空间" class="headerlink" title="共享表空间和独立表空间"></a>共享表空间和独立表空间</h2><p>InnoDB 数据是按照表空间进行存放的，其表空间分为共享表空间和独立表空间。</p><h3 id="共享表空间"><a href="#共享表空间" class="headerlink" title="共享表空间"></a>共享表空间</h3><p>共享表空间：表的数据放在系统共享表空间，也就是跟数据字典放一起。文件名为 ibdata1。可以通过参数 innodb_data_file_path 进行设置。在 my.cnf 中配置，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path = ibdata1:1G;ibdata2:1G:autoextend</span><br></pre></td></tr></table></figure><p>表示用两个文件（ibdata1 和 ibdata2）组成表空间，文件 ibdata1 的大小为 1G，文件 ibdata2 的大小为 1G，autoextend 表示用完 1G 可以自动增长。</p><h3 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h3><p>独立表空间：每个 InnoDB 表数据存储在一个以 .idb 为后缀的文件中。</p><p>由参数 innodb_file_per_table 控制。</p><p>设置为 on 表示使用独立表空间；</p><p>设置为 off 表示使用共享表空间。</p><blockquote><p><strong>经验分享</strong></p><p>一般情况下建议设置为独立表空间，原因是：如果某张表被 drop 掉，会直接删除该表对应的文件，如果放在共享表空间中，即使执行了 drop table 操作，空间还是不能回收。</p></blockquote><p>基于上面的经验分享，因此建议使用独立表空间，而本节后面提到的几种删除数据的情况，都是基于独立表空间的情况。</p><h2 id="几种数据删除形式"><a href="#几种数据删除形式" class="headerlink" title="几种数据删除形式"></a>几种数据删除形式</h2><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>如果是某张表（假如表名为 t29）的数据和表结构都不需要使用了，那么可以考虑 drop 掉。出于安全考虑，建议的步骤如下：</p><ul><li>1、首先将表名改为 t29_bak_20191011：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t29 <span class="keyword">rename</span> t29_bak_20191011;</span><br></pre></td></tr></table></figure><ul><li>2、然后等待半个月，观察是否有程序因为找不到表 t29 而报错；</li><li>3、如果没有跟表 t29 相关的报错，则半个月后直接 drop 掉 t29_bak_20191011：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t29_bak_20191011;</span><br></pre></td></tr></table></figure><h3 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h3><p>如果是某张表（假如表名为 t29）的历史数据不需要使用了，要做一次清空，则可以考虑使用 truncate。</p><p>建议的步骤如下：</p><p>1、创建一张与 t29 表结构相同的临时表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t29_bak_20191011 <span class="keyword">like</span> t29;</span><br></pre></td></tr></table></figure><p>2、并将数据拷贝到临时表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_bak_20191011  <span class="keyword">select</span> * <span class="keyword">from</span> t29;</span><br></pre></td></tr></table></figure><p>3、再清空该表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> t29;</span><br></pre></td></tr></table></figure><p>4、如果空间不够，观察半个月后，考虑转移 t29_bak_20191011 的数据到备份机器上。然后删除表 t29_bak_20191011：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t29_bak_20191011;</span><br></pre></td></tr></table></figure><blockquote><p><strong>经验分享</strong></p><p>我不止一次遇到类似的情况：需要清空表而使用 delete from table_name，导致主从延迟和磁盘 IO 跑满的情况。 原因是 binlog 为行模式的情况下，执行全表 delete 会生成每一行对应的删除操作，因此可能导致单个删除事务非常大。而 truncate 可以理解为 drop + create，在 binlog 为 row 模式的情况下，也只会产生一行 truncate 操作。所以，建议清空表时使用 truncate 而不使用 delete。</p></blockquote><h3 id="非分区表删除部分记录"><a href="#非分区表删除部分记录" class="headerlink" title="非分区表删除部分记录"></a>非分区表删除部分记录</h3><p>实际更多的情况，我们是需要删除表中一部分数据，在没有配置分区表的情况下，就只能用 delete 了。也许我们有时会发现，在 delete 很多数据后，实际表文件大小没变化。这是什么原因呢？</p><p>原因是，如果通过 delete 删除某条记录，InnoDB 引擎会把这条记录标记为删除，但是磁盘文件的大小并不会缩小。如果之后要在这中间插入一条数据，则可以复用这个位置，如果一直没有数据插入，就会形成一个 “空洞”。因此 delete 命令是不能回收空间的，这也是 delete 后表文件大小没变化的原因。</p><p>对于非分区表删除部分记录（比如删除 2017 年之前的数据，语句为：delete from table_name where date&lt;‘2017-01-01’;），建议的步骤是：</p><ul><li>1、首先备份全表；</li><li>2、确保 date 字段有索引，如果没有索引，则需要添加索引（目的是避免执行删除命令时，全表扫描）；</li><li>3、如果要删除的数据比较多，建议写一个循环，每次删除满足条件记录的 1000 条（目的是避免大事务），删完为止：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="built_in">date</span>&lt;<span class="string">'2017-01-01'</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><ul><li>4、最后重建表（目的是释放表空间，但是会锁表，建议在业务低峰执行）：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optimize</span> <span class="keyword">table</span> student;</span><br></pre></td></tr></table></figure><h3 id="分区表删除部分分区"><a href="#分区表删除部分分区" class="headerlink" title="分区表删除部分分区"></a>分区表删除部分分区</h3><p>从 MySQL 5.1 开始，支持分区。MySQL 分区是指将一张表按照某种规则（比如时间范围或者哈希等），划分为多个区块，各个区块所属的数据文件是相互独立的。</p><p>比如对于一些日志表，我们可以创建成分区表，建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t29_log ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t29_log (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">log_info <span class="built_in">VARCHAR</span> (<span class="number">100</span>),</span><br><span class="line"><span class="built_in">date</span> datetime</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(<span class="built_in">date</span>))(</span><br><span class="line"><span class="keyword">PARTITION</span> p2016</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line"><span class="keyword">less</span> <span class="keyword">THAN</span> (<span class="number">2017</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p2017</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line"><span class="keyword">less</span> <span class="keyword">THAN</span> (<span class="number">2018</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p2018</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line"><span class="keyword">less</span> <span class="keyword">THAN</span> (<span class="number">2019</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在上表的分区表中，表示：</p><ul><li>当日期的年份小于 2017 时，则数据存放在 p2016 分区；</li><li>当日期的年份大于等于 2017 小于 2018 时，则数据存放在 p2017 分区；</li><li>当日期的年份大于等于 2018 小于 2019 时，则数据存放在 p2018 分区。</li></ul><p>对于分区表，其物理文件是由建立分区时的各个分区 idb 文件组成，如下：</p><p><img src="1.png" alt="图片描述"></p><p>这里写入几条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_log <span class="keyword">select</span> <span class="number">1</span>,<span class="string">'aaa'</span>,<span class="string">'2016-01-01'</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_log <span class="keyword">select</span> <span class="number">2</span>,<span class="string">'bbb'</span>,<span class="string">'2016-06-01'</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_log <span class="keyword">select</span> <span class="number">3</span>,<span class="string">'ccc'</span>,<span class="string">'2017-01-01'</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_log <span class="keyword">select</span> <span class="number">4</span>,<span class="string">'ddd'</span>,<span class="string">'2018-01-01'</span>;</span><br></pre></td></tr></table></figure><p>因为表 t29_log 是根据 date 来分区的，因此数据是根据 date 值的范围存放在不同的物理文件中，可以通过 information_schema 库下的 partitions 表来查看各个分区的具体信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> TABLE_SCHEMA,TABLE_NAME,PARTITION_NAME,TABLE_ROWS <span class="keyword">from</span> information_schema.partitions <span class="keyword">where</span> table_schema=<span class="string">'muke'</span> <span class="keyword">and</span> table_name=<span class="string">'t29_log'</span>;</span><br></pre></td></tr></table></figure><p><img src="/2.png" alt="图片描述"><br>TABLE_ROWS 表示每个分区中的记录数。</p><p>我们查询下 t29_log 全表的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t29_log;</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="图片描述"><br>比如上面例子中 t29_log 需要删除 2016 年全年的数据，那么可以直接把 p2016 分区 drop 掉：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t29_log <span class="keyword">drop</span> <span class="keyword">partition</span> p2016;</span><br></pre></td></tr></table></figure><p><img src="4.png" alt="图片描述"></p><p>相对慢慢 delete，这种方式删除历史数据效率高很多。</p><p>因此，对于要经常删除历史数据的表，建议配置成分区表。以方便后续历史数据删除。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节首先提到了共享表空间和独立表空间，考虑到独立表空间的情况下，如果 drop 一张表，空间可以回收。因此一般建议设置为独立表空间。</p><p>如果要清空表，建议使用 truncate，而不使用 delete。</p><p>原因是 binlog 为行模式的情况下，执行全表 delete 会生成每一行对应的删除操作，因此可能导致单个删除事务非常大。而 truncate 可以理解为 drop + create，在 binlog 为 row 模式的情况下，也只会产生一行 truncate 操作。所以，建议清空表时使用 truncate 而不使用 delete。</p><p>本节提到了几种常见删除数据的情况，并提供了一些方法，其核心是删除前，需要备份数据。以防万一，另外就是尽可能的去避免删除数据时产生大事务。</p><p>考虑到非分区表删除部分记录会比较麻烦，因此如果知道某张表（比如日志类表）会进程删除几年前的数据，那么建议设置成分区表，删除历史数据将非常方便高效。</p><blockquote><p>参考资料</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-tablespaces.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-tablespaces.html</a></p><p>《MySQL 技术内幕：InnoDB 存储引擎》3.6.1 表空间文件、4.8 分区表</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的分库分表</title>
      <link href="/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>使用数据库时，我们经常会聊到分库分表，那么分库分表有哪些方式？什么情况应该考虑分库分表呢？这次我们来看下这些问题。</p><p>MySQL 分库分表是指：把 MySQL 数据库物理地拆分到多个实例或者机器上去。从而降低单台 MySQL 实例的负载。那么这里讲的拆分究竟以什么方式实现的呢？这里就先来看看 MySQL 分库分表的拆分方法：</p><h2 id="MySQL-分库分表拆分方法"><a href="#MySQL-分库分表拆分方法" class="headerlink" title="MySQL 分库分表拆分方法"></a>MySQL 分库分表拆分方法</h2><p>MySQL 分库分表拆分方法分为：垂直拆分和水平拆分。</p><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><p>垂直拆分一般是指下面几种情况：</p><ul><li>有多个业务，每个业务单独分到一个实例里面。</li><li>在一个实例中有多个库，把这些库分别放到单独的实例中。</li><li>在一个库中存在过多的表，把这些表拆分到多个库中。</li><li>把字段过多的表拆分成多个表，每张表包含一部分字段。</li></ul><p>比如一个电商网站，他的用户信息（userinfo）、商品信息（productinfo）、订单信息（orderinfo) 垂直拆分在三个实例中，如下图所示：</p><p><img src="1.png" alt="图片描述"></p><h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><p>如果通过垂直拆分，表数据量仍然很大，那就可以考虑使用水平拆分了。</p><p>所谓水平拆分，就是把同一张表分为多张表结构相同的表，每张表里存储一部分数据。而拆分的算法也比较多，常见的就是取模、范围、和全局表等。</p><p>还是拿上面电商网站的例子，比如业务会考虑做一次活动，预计注册用户会暴涨。那么就应该考虑对用户表进行水平拆分了，如下图：</p><p><img src="2.png" alt="图片描述"></p><p>这里使用的是取模分片，用户 ID 对 3 取模，如果余数是 0，则数据存放在 userinfo01 库的 user 表中；如果余数是 1，则数据存放在 userinfo02 库的 user 表中；如果余数是 2，则数据存放在 userinfo03 库的 user 表中。</p><h2 id="哪些情况需要考虑分库分表？"><a href="#哪些情况需要考虑分库分表？" class="headerlink" title="哪些情况需要考虑分库分表？"></a>哪些情况需要考虑分库分表？</h2><p>都在提分库分表，那么哪些情况应该考虑分库分表呢？这里总结了几个需要考虑分库分表的场景：</p><h3 id="数据量过大，影响了运维操作"><a href="#数据量过大，影响了运维操作" class="headerlink" title="数据量过大，影响了运维操作"></a>数据量过大，影响了运维操作</h3><p>如果数据量比较大，其对数据库影响也会比较大，最常见的比如：影响备份、大表 DDL 导致主从长时间延迟等。下面仔细讲讲这两种情况：</p><p>备份：如果单张表或者单个实例数据量太大，那备份可能需要占用大量的 IO 和磁盘空间，并且持续时间还会比较久。曾经听说过有公司的单个实例的备份从凌晨持续到当天下午的情况，这种场景下，尽管在从库备份，如果开启了读写分离，对业务的影响也是比较大的。</p><p>DDL 导致主从长时间延迟：大表执行 DDL 不但会产生 MDL 写锁（MDL 的风险可以看前文），并且还会导致主从延迟。</p><blockquote><p><strong>直接执行大表 DDL，为什么会导致主从延迟？</strong></p><p>原因是主库执行完 DDL 后，才会写入到 binlog 里，然后传输到从库执行，而又因为从库 SQL 线程是单线程的，因此，需要等到这条 DDL 在从库执行完成，其他事务才能继续执行，而从库执行 DDL 这段时间，主从都是延迟的。</p></blockquote><h3 id="把修改频繁的字段拆分出来"><a href="#把修改频繁的字段拆分出来" class="headerlink" title="把修改频繁的字段拆分出来"></a>把修改频繁的字段拆分出来</h3><p>比如电商业务场景的用户表，这张表可能包含了用户唯一标识 ID，用户名，昵称，联系方式，性别，出生日期，注册时间，积分等等。这些字段中，其实也只有积分会变更的比较频繁，因此可以把积分字段独立出来，然后加上用户唯一标识 ID。这样，用户表的更新次数就大大降低了。</p><h3 id="把大字段拆分出去"><a href="#把大字段拆分出去" class="headerlink" title="把大字段拆分出去"></a>把大字段拆分出去</h3><p>比如电商业务的商品表，表里可能包含了商品的价格，生产日期，产地，供应商，商品详情和使用说明等。我们会发现商品详情和使用说明的字段特别大，可能字段类型需要配置成 text 或 blob，类似的字段占用的磁盘空间也是比较大。维护起来会比较麻烦，因此这种情况下，建议把这类大字段水平拆分出来。</p><h3 id="增长比较快的"><a href="#增长比较快的" class="headerlink" title="增长比较快的"></a>增长比较快的</h3><p>还是拿电商业务举例，比如订单表，如果预估未来增长速度会比较快，那么可以考虑提前对订单表进行分库分表。防止单表增长过快。</p><h3 id="降低不同库或者表的相互影响"><a href="#降低不同库或者表的相互影响" class="headerlink" title="降低不同库或者表的相互影响"></a>降低不同库或者表的相互影响</h3><p>电商业务会涉及多个模块，比如会员，订单，库存等。比如搞了一个活动，扫码送会员积分，如果会员相关的表和订单相关的表在一个库中，那么很可能会员的活动会影响到订单业务。因此可以考虑将这些模块对应的表拆分到不同的库中。避免不同业务表或者库的相互影响。</p><h2 id="分库分表的实现"><a href="#分库分表的实现" class="headerlink" title="分库分表的实现"></a>分库分表的实现</h2><h3 id="通过程序"><a href="#通过程序" class="headerlink" title="通过程序"></a>通过程序</h3><p>如我已经通过垂直拆分，将不同业务表放在不同的业务库中。这种情况，程序只要每个业务配置不同的 database 即可。</p><p>如果是水平拆分，业务可以通过程序实现，比如按照用户名首字母分，讲不同首字母的名字过来的请求放在不同的库中。</p><h3 id="通过数据库中间件"><a href="#通过数据库中间件" class="headerlink" title="通过数据库中间件"></a>通过数据库中间件</h3><p>目前比较常见的就是通过数据库中间件，比如 MyCAT。这种对业务程序来说就比较友好了，某个业务库，程序端只要连逻辑库，而后端是通过 MyCAT，将这一个逻辑库指向多个物理库。然后通过分片字段，决定数据应该放在哪个分片里。如本节 1.2 所讲的水平分割的示意图。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了 MySQL 分库分表。</p><p>一般情况下，MySQL 分库分表可以分为：</p><ul><li>垂直拆分。</li><li>水平拆分。</li></ul><p>在本节总结了需要考虑分库分表的场景：</p><ul><li>数据量过大。</li><li>某个字段更新过于频繁。</li><li>存在大字段。</li><li>表数据增长比较快。</li><li>不同库表之间性能相互影响了。</li></ul><p>最后介绍了两种分库分表的实现方式：</p><ul><li>通过程序。</li><li>通过数据库。</li></ul><blockquote><p>参考资料</p><p>《MySQL 运维内参》第 24 节：MySQL 分库分表</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读写分离注意问题</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于高访问量的业务场景，MySQL 读写分离显得格外重要。</p><p>通常我们说的 MySQL 读写分离是指：对于修改操作在主库上执行，而对于查询操作，在从库上执行。主要目的是分担主库的压力。</p><p>但是读写分离有时也会存在问题，比如：主从延迟时，读取的从库数据不是最新的，对应的业务场景比如：</p><p>你网购的一个商品，付完款之后，因为主从延迟，第一时间还查询不到订单（查询的从库），即使等一段时间能看到订单，但是相信这种情况很多用户是不能接受的。</p><p>接下里就一起来讨论一下：读写分离需要注意哪些问题。</p><p>通常情况下，读写分离都是依赖主从复制，因此，我们先来看看主从复制的原理，也能方便我们理解为什么会出现主从延迟的现象。</p><h2 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h2><h3 id="MySQL-异步复制"><a href="#MySQL-异步复制" class="headerlink" title="MySQL 异步复制"></a>MySQL 异步复制</h3><p>传统的 MySQL 主从复制是异步的，因此也称为异步复制，MySQL 异步复制的原理如下：</p><ul><li>在主库开启 binlog 的情况下</li><li>如果主库有增删改的语句，会记录到 binlog 中</li><li>主库通过 IO 线程把 binlog 里面的内容传给从库的中继日志（relay log）中</li><li>主库给客户端返回 commit 成功（这里不会管从库是否已经收到了事务的 binlog）</li><li>从库的 SQL 线程负责读取它的 relay log 里的信息并应用到从库数据库中</li></ul><p>实现原理如下图：<br><img src="1.png" alt="图片描述"><br>在上图中，有一个地方不能忽视：</p><p><strong>在主库上并行运行的更新 SQL，由于从库只有单个 SQL 线程去消化 relay log，因此更新的 SQL 在从库只能串行执行。这也是很多情况下，会出现主从延迟的原因。</strong></p><p>当然，从 5.6 开始，MySQL 支持了每个库可以配置单独的 SQL 线程来消化 relay log，在 5.7 又增加了基于组提交的并行复制，大大改善了主从延迟的问题。</p><h3 id="MySQL-半同步复制"><a href="#MySQL-半同步复制" class="headerlink" title="MySQL 半同步复制"></a>MySQL 半同步复制</h3><p>在 MySQL 异步复制的基础上，又出现了一种改进的复制方式，称为：半同步复制。其原理如下：</p><ul><li>在主库开启 binlog 的情况下</li><li>如果主库有增删改的语句，会记录到 binlog 中</li><li>主库通过 IO 线程把 binlog 里面的内容传给从库的中继日志（relay log）中</li><li><strong>从库收到 binlog 后，发送给主库一个 ACK，表示收到了</strong></li><li><strong>主库收到这个 ACK 以后，才能给客户端返回 commit 成功</strong></li><li>从库的 SQL 线程负责读取它的 relay log 里的信息并应用到从库数据库中</li></ul><p>实现原理如下图：<br><img src="2.png" alt="图片描述">跟传统的异步复制相比，半同步复制保证了所有给客户端发送过确认提交的事务，从库都已经收到这个日志了。</p><h2 id="常见的读写分离方式"><a href="#常见的读写分离方式" class="headerlink" title="常见的读写分离方式"></a>常见的读写分离方式</h2><h3 id="通过程序"><a href="#通过程序" class="headerlink" title="通过程序"></a>通过程序</h3><p>开发通过配置程序来决定修改操作走主库，查询操作走从库。这种方式直连数据库，优点是性能会好点，缺点是配置麻烦。</p><p>但是需要注意的是：从库需要设置为 read_only，防止配置错误在从库写入了数据。</p><blockquote><p>这里提醒一点：</p><p>程序连接的用户建议不要给 super 权限，因为 super 权限的用户，即使整个库设置了 read_only ，也能写入数据。</p></blockquote><h3 id="2-2、通过中间件"><a href="#2-2、通过中间件" class="headerlink" title="2.2、通过中间件"></a>2.2、通过中间件</h3><p>通过中间件实现读写分离，目前算是一种主流的方式。拿 MyCAT 举例：</p><p>在 schema.xml 文件中，dataHost 标签 balance 属性的值，决定了是否启用读写分离。</p><p>balance 各个值及对应的读写方法如下：</p><ul><li>0：不开启读写分离，读操作发送到 writehost</li><li>1：全部的 readhost 与 stand by writehost 参与 select 语句的负载均衡</li><li>2：所有读操作都随机在 writehost、readhost上分发</li><li>3：所有读请求随机分发到 writerhost 对应的 readhost 执行，writehost 不负担读压力</li></ul><p>因此可以根据实际情况选择上面合适的读写分离策略。</p><h2 id="什么情况下会出现主从延迟"><a href="#什么情况下会出现主从延迟" class="headerlink" title="什么情况下会出现主从延迟"></a>什么情况下会出现主从延迟</h2><p>我们说到，对于读写分离场景，最大的问题就是：主从延迟。那么在哪些情况下会出现主从延迟呢？这里大致总结一下可能导致主从延迟的场景：</p><ul><li>大表 DDL</li><li>大事务</li><li>主库 DML 并发大</li><li>从库配置差</li><li>表上无主键</li><li>等等</li></ul><p>因此，如果存在读写分离的情况，应尽量避免上诉情况在业务高峰出现。</p><p>当然，我们不能完全杜绝主从延迟。因此再介绍几种读写分离场景下应对延迟的方法。</p><h2 id="读写分离怎样应对主从延迟"><a href="#读写分离怎样应对主从延迟" class="headerlink" title="读写分离怎样应对主从延迟"></a>读写分离怎样应对主从延迟</h2><p>读写分离场景应该怎样应对主从延迟呢？这里来讨论一下几种常见的应对主从延迟的方法：</p><h3 id="判断主从是否延迟"><a href="#判断主从是否延迟" class="headerlink" title="判断主从是否延迟"></a>判断主从是否延迟</h3><p>有些业务场景，如果所有请求都落在主库，主库压力会很大，但是在读写分离的情况，又不希望主从存在延迟的时候去读取从库。这种情况，就可以考虑查询时，先判断主从是否存在延迟，如果存在延迟，则查询落在主库，如果没延迟，则查询语句落在从库。</p><p>这里介绍几种判断主从延迟的方法：</p><p>第一种方法：判断 Seconds_Behind_Master 是否等于 0。</p><p>如果 Seconds_Behind_Master =0，则查询从库，如果大于 0，则查询主库。</p><blockquote><p>这里补充一下 Seconds_Behind_Master。</p><p>Seconds_Behind_Master 是在从库上执行 show slave status 时返回的其中一项，表示从库延迟的秒数。</p><p>其计算方法是：</p><p>从库服务器当前的时间戳与二进制日志中的事件的时间戳（在主库上的写入时间）相对比得到的。</p></blockquote><p>但是某些情况下，Seconds_Behind_Master 并不一定准确。比如网络中断时，Seconds_Behind_Master = 0 ，并不能代表主从无延迟。因此，有比这个更准确的一种方法：对比位点或 GTID。</p><p>第二种方法：对比位点或 GTID</p><p>如果 Master_Log_File 跟 Relay_Master_Log_File 相等，</p><p>并且 Read_Master_Log_Pos 跟 Exec_Master_Log_Pos 相等，</p><p>则可以把读请求放到从库，否则读请求放到主库。</p><blockquote><p><strong>补充一下上面几个参数的意义：</strong></p><p>几个参数均是通过 show slave status 返回的参数，用来查询主从复制的状态。</p><p>Master_Log_File：IO 线程正在读取的主库 binlog 文件名</p><p>Relay_Master_Log_File：SQL 线程最近执行的事务对应的主库 binlog 文件名</p><p>Read_Master_Log_Pos ：IO 线程正在读取的主库 binlog 文件中的位点</p><p>Exec_Master_Log_Pos ：SQL 线程最近读取和执行的事务对应的主库 binlog 文件中的位点</p></blockquote><p>如果开启了 GTID 复制，则可以对比 Retrieved_Gtid_Set 和 Executed_Gtid_Set 是否相等，相等则把读请求放到从库，有差异则读请求放到主库。</p><blockquote><p><strong>同样补充下两个参数的意义：</strong></p><p>前提是需要开启 GTID 两个参数才会有值，解释如下：</p><p>Retrieved_Gtid_Set：从库收到的所有日志的 GTID 集合</p><p>Executed_Gtid_Set：从库已经执行完的 GTID 集合</p></blockquote><h3 id="采用半同步复制"><a href="#采用半同步复制" class="headerlink" title="采用半同步复制"></a>采用半同步复制</h3><p>在本节的前面，我们讲解了半同步复制的原理，跟传统的异步复制相比，半同步复制保证了所有给客户端发送过确认提交的事务，从库都已经收到这个日志了。因此出现延迟的概率会小很多，当然实际生产应用时，建议结合上面讲的位点或 GTID 判断。</p><h3 id="等待同步完成"><a href="#等待同步完成" class="headerlink" title="等待同步完成"></a>等待同步完成</h3><p>依然采用 4.1 中介绍的几种判断是否有延迟的方法，只是应对方式不一样，比如存在延迟，则将情况反馈给程序，在前端页面提醒用户数据未完全同步，如果没有延迟，则查询从库。</p><p>有人可能会觉得：这种方式谁会用啊？实际可以应用在内部人员看的报表业务上。因为报表可能涉及的 SQL 都比较复杂，存在延迟就考虑去查询主库，可能会对其它线上业务有影响，因此可以等待从库同步完成，再查询从库。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲了读写分离，由于能分担主库的压力，很多情况会考虑读写分离。但是在使用时，就应该考虑到一些问题，其中最主要的就是主从延迟。</p><p>这个就看业务是否能接受延迟了。</p><p>如果不能接受延迟，建议采用半同步复制并且加上延迟判断。存在延迟则把读请求放到主库，没延迟就读从库。</p><p>如果业务能接受延迟，可以等数据同步完成，再去从库进行查询。</p><blockquote><p>参考资料</p><p>《MyCAT 权威指南》第 1 版：6.6.4 balance 属性</p><p>《MySQL 5.7 官方手册》 14.7.5.34 SHOW SLAVE STATUS Syntax</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的QC</title>
      <link href="/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84QC/"/>
      <url>/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84QC/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从 MySQL 4.1 开始，增加了查询缓存（Query Cache，简称 QC）的功能，它会存储 select 语句的文本以及发送到客户端的结果。如果下一次收到一个相同的查询，就会从查询缓存中获得查询结果。</p><blockquote><p>关于 QC 的详细定义，可以查询 <a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="noopener">MySQL 5.7 官方手册</a></p></blockquote><p>那么是不是只要开启查询缓存就能提升查询速度呢？今天就一起探讨这一话题。</p><h2 id="认识-QC"><a href="#认识-QC" class="headerlink" title="认识 QC"></a>认识 QC</h2><p>QC 需要缓存最新数据结果，因此表数据发生任何变化（insert、update、delete 等操作时），都会导致 QC 被刷新。</p><p>查询缓存相关的参数主要有：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">"%query_cache%"</span>;</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="图片描述"></p><blockquote><p><strong>这里解释一下上面几个参数</strong></p><p>have_query_cache：服务器在安装时是否已经配置了高速缓存<br>query_cache_limit：单条查询能够使用的缓存区大小<br>query_cache_min_res_unit：查询缓存分配内存块的最小单位<br>query_cache_size：缓存区的大小，单位为 MB<br>query_cache_type：缓存类型，有三个值可选：</p><ul><li>0 或者 off：关闭缓存</li><li>1 或者 on：打开缓存</li><li>2 或者 demand：只缓存带有 sql_cache 的 select 语句。</li></ul><p>query_cache_wlock_invalidate：如果某个数据表被其它的连接锁住，是否仍然从查询缓存中返回结果</p></blockquote><p>通过下面命令，可以监视查询缓存的使用情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">"qcache%"</span>;</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="图片描述"></p><blockquote><p><strong>这里解释一下各个参数的意义</strong></p><p>Qcache_free_blocks：查询缓存中的空闲内存块的数目</p><p>Qcache_free_memory：查询缓存的空闲内存总数</p><p>Qcache_hits：缓存命中次数</p><p>Qcache_inserts：被加入到缓存中的查询数目</p><p>Qcache_lowmem_prunes：因为缺少内存而从缓存中删除的查询数目</p><p>Qcache_not_cached：没有被缓存的查询数目</p><p>Qcache_queries_in_cache：在缓存中已注册的查询数目</p><p>Qcache_total_blocks：查询缓存中的块的总数目</p></blockquote><h2 id="QC-的优劣"><a href="#QC-的优劣" class="headerlink" title="QC 的优劣"></a>QC 的优劣</h2><p>在讲到底要不要开启 QC 之前，我们先聊聊 QC 的优劣。</p><p>QC 优势：</p><ul><li>提高查询速度：使用查询缓存在单行数据的表中搜索要比不使用查询缓存快 238%（数据来源：<a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="noopener">MySQL 5.7 官方手册</a>）。</li></ul><p>劣势：</p><ul><li>比如执行的 SQL 都很简单（比如从只有一行的表中查询数据），但每次查询都不一样的话，打开 QC 后，额外的开销为 13% 左右；</li><li>如果表数据发生了修改，使用该表的所有缓存查询都将实效，并且从缓存中删除；</li><li>QC 要求前后两次请求的 SQL 完全一样，不同数据库、不同协议版本或不同默认字符集的查询，都会被认为是不同的查询。甚至包括大小写，比如下面两条 SQL ，查询缓存就会认为是两个不同的查询：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> tbl_name</span><br></pre></td></tr></table></figure><ul><li>每次更新 QC 的内存块都需要进行锁定；</li><li>可能会导致 SQL 查询时间不稳定，比如<a href="https://www.percona.com/blog/2012/09/05/write-contentions-on-the-query-cache/" target="_blank" rel="noopener">这个例子</a>。</li></ul><h2 id="是否需要开启-QC"><a href="#是否需要开启-QC" class="headerlink" title="是否需要开启 QC"></a>是否需要开启 QC</h2><p>通过上面讲解的 QC 优劣，对于是否需要开启 QC 这个问题，我们大概能总结出：</p><p>如果线上环境中 99% 以上都是只读，很少更新，可以考虑全局开启 QC，也就是设置 query_cache_type 为 1。</p><p>很多时候，我们希望缓存的是几张更新频率很低的表，其它表不考虑使用查询缓存，就可以考虑将 query_cache_type 设置成 2 或者 DEMAND，这样就只缓存下面这类 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sql_cache</span> ......;</span><br></pre></td></tr></table></figure><p>结合前面讲的 QC 的劣势，其它情况就不建议开启 QC 了。</p><h2 id="4-怎样开启和关闭-QC"><a href="#4-怎样开启和关闭-QC" class="headerlink" title="4 怎样开启和关闭 QC"></a>4 怎样开启和关闭 QC</h2><p>全局开启 QC：</p><p>在配置文件 my.cnf 中设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type = 1</span><br><span class="line">query_cache_size = 50M</span><br></pre></td></tr></table></figure><p>只开启部分表的 QC：</p><p>在配置文件 my.cnf 中设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type = 2</span><br><span class="line">query_cache_size = 50M</span><br></pre></td></tr></table></figure><p>前面也提到了，这种情况，如果要使用 QC，查询语句需要加上 select sql_cache。</p><p>关闭 QC：</p><p>在配置文件 my.cnf 中设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type = 0</span><br><span class="line">query_cache_size = 0</span><br></pre></td></tr></table></figure><p>或者源码编译安装 MySQL 的话，编译时增加参数 —without-query-cache 即可。</p><h2 id="开启-QC-的注意事项"><a href="#开启-QC-的注意事项" class="headerlink" title="开启 QC 的注意事项"></a>开启 QC 的注意事项</h2><p>如果要开启 QC，建议不要设置过大，通常几十兆就好。如果设置过大，会增加维护缓存所需要的开销。</p><p>另外要注意一些即使开启 QC 也不能使用 QC 的场景（这里参考的是 MySQL 5.7 官方手册第 8.10.3.1 节： <a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-operation.html" target="_blank" rel="noopener">How the Query Cache Operates</a> ）：</p><ul><li>分区表不支持，如果涉及分区表的查询，将自动禁用查询缓存</li><li>子查询或者外层查询</li><li>存储过程、触发器中使用的 SQL</li><li>读取系统库时</li><li>类似下面 SQL 时：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><ul><li>用到临时表</li><li>产生了 warning 的查询</li><li>显示增加了 SQL_NO_CACHE 关键字的</li><li>如果没有全部库、表的 select 权限，则也不会使用 QC</li><li>使用了一些函数：比如 now ()，user ()，password () 等</li></ul><p>了解上面的场景，我们就能知道：开了查询缓存，前后 SQL 一模一样，为什么后面这一次执行也使用不了缓存的原因了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查询环境会存储 select 语句的文本以及发送到客户端的结果。</p><p>如果使用查询缓存在单行数据的表中搜索要比不使用查询缓存快 238%。</p><p>如果线上环境中 99% 以上都是只读，很少更新，可以考虑全局开启 QC。如果希望缓存的是几张更新频率很低的表，其它表不考虑使用查询缓存，就可以考虑将 query_cache_type 设置成 2，这些需要使用查询缓存的表，使用时加上 select sql_cache 即可。</p><p>但是考虑到 QC 存在下面这些缺点，因此，其它情况就不建议开启 QC 了。</p><ul><li>每次查询不一样，会额外增加开销</li><li>需要前后两条 SQL 完全一样才能使用</li><li>只要存在更新，就会清空这张表的查询缓存</li><li>等等</li></ul><p>当然开启 QC 的情况下，部分查询是无法走 QC 的，需要留意到这些场景。</p><blockquote><p>参考资料</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/query-cache.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-operation.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/query-cache-operation.html</a></p><p><a href="https://www.percona.com/blog/2012/09/05/write-contentions-on-the-query-cache/" target="_blank" rel="noopener">https://www.percona.com/blog/2012/09/05/write-contentions-on-the-query-cache/</a></p><p>《深入浅出 MySQL》第 2 版：23.2.2 使用查询缓存}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置自增主键的好处</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%A5%BD%E5%A4%84/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>mysql默认都带有一个id的自增主键，这么做的原因是神马，今天研究一下。</p><h2 id="关于自增主键"><a href="#关于自增主键" class="headerlink" title="关于自增主键"></a>关于自增主键</h2><p>当我们创建表时，可以定义主键为自增的，具体方法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t25`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`b`</span> <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>空表情况下，我们不指定 id 字段写入数据时，id 字段会自动获取到值 1，如下：</p><p>首先写入一条数据，没指定 id 的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t25(a,b) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'hi'</span>);</span><br></pre></td></tr></table></figure><p>再进行查询时，发现 id 字段自动获取到值 1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t25;</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="图片描述"><br>这里我们查询一下表 t25 的表结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t25;</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="图片描述"><br>发现表结构中包含 AUTO_INCREMENT=2，在下一次执行未指定 id 字段的 insert 语句时， 主键 id 会自动获取到这个值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t25(a,b) <span class="keyword">values</span> (<span class="number">2</span>,<span class="string">'ha'</span>);</span><br></pre></td></tr></table></figure><p>select * from t25;<br><img src="3.png" alt="图片描述"><br>发现新写入的数据 id 自动获取到 2 这个值。也就是，如果不指定，则会写入当前最大 ID 加 1 的值。</p><h2 id="主键和聚集索引的关系"><a href="#主键和聚集索引的关系" class="headerlink" title="主键和聚集索引的关系"></a>主键和聚集索引的关系</h2><p>很多同学会把主键和聚集索引弄混，这里先简单聊聊它们的区别：</p><ul><li>在 InnoDB 中，聚集索引不一定是主键，但是主键一定是聚集索引：原因是如果没有定义主键，聚集索引可能是第一个不允许为 null 的唯一索引，如果也没有这样的唯一索引，InnoDB 会选择内置 6 字节长的 ROWID 作为隐含的聚集索引。</li><li>我们知道 InnoDB 的数据是按照主键顺序存放的，而聚集索引就是按照每张表的主键构造一颗 B+ 树，它的叶子节点存放的是整行数据。</li><li>每张 InnoDB 表都有一个聚集索引，但是不一定有主键。</li></ul><h2 id="主键是否需要设置为自增"><a href="#主键是否需要设置为自增" class="headerlink" title="主键是否需要设置为自增"></a>主键是否需要设置为自增</h2><p>现在来讨论本节的重点：主键是否需要设置为自增？</p><p>通过上面的学习，我们知道了聚集索引是按照每张表的主键构造一颗 B+ 树的，而 B+ 树中，所有记录节点都是按键值的大小顺序存放在同一层叶子节点上。</p><p>如果每次插入的数据都是在聚集索引树的后面，聚集索引不需要分裂就可以存入数据。</p><p>但是如果插入的数据值在聚集索引树的中间部分，由于要保证插入后叶子节点中的记录依然排序，就可能需要聚集索引树分裂来保证键值的有序性。如下（这里省略了叶子节点之间的指针）：<br><img src="4.png" alt="图片描述"><br>如上图，Leaf Page（叶子节点数据页)已经满的情况下，如果写入的值是聚集索引树的中间部分，则会进行一次页分裂，以保证叶子节点上的记录有序和 B+ 树的平衡。并且分裂后，有些数据页没被用满，导致页空间浪费。</p><p><strong>因此如果业务输入的主键都是随机数字，那么写入数据时很可能会导致数据页频繁分裂，从而影响写入效率。</strong></p><p><strong>而如果设置主键是自增，那么每一次都是在聚集索引的最后增加，当一页写满，就会自动开辟一个新页，不会有聚集索引树分裂这一步，效率会比随机主键高很多。这也是很多建表规范要求主键自增的原因。</strong></p><blockquote><p>经验分享：</p><p>除了要求主键自增外，最好主键也要无业务意义，原因是防止主键更新而导致页分裂的情况。</p></blockquote><p>当然也不是所有的情况主键都需要设置为自增，比如可以用程序写入增长的主键值，保证了新写入数据的主键值比之前大，也可以避免聚集索引树频繁分裂。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讨论了自增主键的使用方式，并讲解了主键与聚集索引的关系。</p><p>通过本节学习，<strong>如果主键是随机的，那么写入数据时很可能会导致数据页频繁分裂，从而导致写入效率低和页空间浪费。</strong></p><p><strong>而如果设置主键是自增，那么每一次都是在聚集索引的最后增加，当一页写满，就会自动开辟一个新页，不会有聚集索引树分裂这一步，效率会比随机主键高很多。</strong></p><p>当然也不是所有的表都需要设置为自增，如果通过业务逻辑给到表主键的值是增长的（不一定连续），保证了新写入数据的主键值比之前大，也可以避免聚集索引树频繁分裂。这种方式也是可以选择的。</p><blockquote><p>参考资料</p><p>《MySQL 技术内幕：InnoDB 存储引擎》第 2 版 5.3.1 B+ 树的插入操作 和 5.4.3 B+ 树索引的分裂</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入攻击和预防</title>
      <link href="/2022/07/19/mysql-2022-07-19-sql%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%92%8C%E9%A2%84%E9%98%B2/"/>
      <url>/2022/07/19/mysql-2022-07-19-sql%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%92%8C%E9%A2%84%E9%98%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多时候，我们关心的是程序是否能实现我们的预期功能，而忽视了 SQL 安全，这就存在 SQL 注入的风险，本节就一起来聊聊 SQL 注入及防御。</p><h2 id="认识-SQL-注入"><a href="#认识-SQL-注入" class="headerlink" title="认识 SQL 注入"></a>认识 SQL 注入</h2><p>SQL 注入是利用某些数据库的外部接口将用户数据插入到实际的数据库操作语句中，从而达到入侵数据库乃至操作系统的目的。</p><p>SQL 注入产生的主要原因是：程序对用户输入的数据没有进行严格的过滤，导致非法数据库查询语句的执行。</p><p>SQL 注入具有很大的危害，可能会导致攻击者非法入侵系统，或者盗取数据，甚至清空数据等。</p><h2 id="如何进行-SQL-注入攻击"><a href="#如何进行-SQL-注入攻击" class="headerlink" title="如何进行 SQL 注入攻击"></a>如何进行 SQL 注入攻击</h2><p>为了方便理解 SQL 注入，我们来用实验模拟一下 SQL 注入攻击。</p><p>我们模拟一个用户登录验证的场景，首先创建用户表，并录入几个用户，语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists t24;</span><br><span class="line">CREATE TABLE &#96;t24&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;username&#96; varchar(20) DEFAULT NULL,</span><br><span class="line">  &#96;password&#96; varchar(20) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB CHARSET&#x3D;utf8mb4;</span><br><span class="line"></span><br><span class="line">insert into t24(username,password) values (&#39;mt&#39;,&#39;aaa&#39;),(&#39;gg&#39;,&#39;bbb&#39;),(&#39;mm&#39;,&#39;ccc&#39;);</span><br></pre></td></tr></table></figure><p>验证用户登录的 PHP 代码（PHP 版本：7.0.33）：</p><p>文件名：index.php</p><p>内容如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername=<span class="string">"127.0.0.1"</span>;</span><br><span class="line">$dbuser=<span class="string">"muke_user"</span>;</span><br><span class="line">$dbpassword=<span class="string">"9Gcag71Gaa"</span>;</span><br><span class="line">$dbname=<span class="string">"muke"</span>;</span><br><span class="line"></span><br><span class="line">$mysqli = <span class="keyword">new</span> mysqli($servername,$dbuser,$dbpassword,$dbname); <span class="comment">//配置MySQL连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($mysqli-&gt;connect_error)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'connect error:'</span>.$mysqli-&gt;connect_errno);</span><br><span class="line">&#125;</span><br><span class="line">$mysqli-&gt;set_charset(<span class="string">'UTF-8'</span>); <span class="comment">// 设置数据库字符集</span></span><br><span class="line">$username = <span class="keyword">isset</span>($_GET[<span class="string">'username'</span>]) ? $_GET[<span class="string">'username'</span>] : <span class="string">''</span>;</span><br><span class="line">$password = <span class="keyword">isset</span>($_GET[<span class="string">'password'</span>]) ? $_GET[<span class="string">'password'</span>] : <span class="string">''</span>;</span><br><span class="line">$sql = <span class="string">"select * from t24 where username='$username' and password= '$password'"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$sql&lt;br/&gt;"</span>;</span><br><span class="line">$result = $mysqli-&gt;query(<span class="string">"$sql"</span>);</span><br><span class="line"></span><br><span class="line">$data = $result-&gt;fetch_all(); <span class="comment">// 从结果集中获取所有数据</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($data))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"登录失败"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"登录成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">print_r($data);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>正常情况下，我们提交如下 URL，如果用户名密码正确的话，就可以使用 mt 这个用户登录系统了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=aaa</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887cb0001b39908610178.png" alt="图片描述"></p><p>如果不知道密码情况下乱输入一个密码，将无法登录通过验证：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=abc</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887be00014eb008600184.png" alt="图片描述"></p><p>但是可以通过 SQL 注入的方式，让攻击者不知道密码的情况也可以通过验证，如下：</p><p>把 URL 改成：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt' or '1=1</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887af0001c0c709390182.png" alt="图片描述"><br>显然我们不希望能通过这种方式登录系统，这就是一个 SQL 注入的例子。</p><p>这个例子中，甚至可以通过 SQL 注入捞取到所有用户信息，如下 URL：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=aaa' or username&lt;&gt;'mt</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d88879c0001313a17420198.png" alt="图片描述"><br>从上面截图中可以看到，URL 获取到表里所有用户的信息了。如果是生产环境，用户表有这种漏洞，可想而知他的危害有多大。</p><h2 id="如何预防-SQL-注入"><a href="#如何预防-SQL-注入" class="headerlink" title="如何预防 SQL 注入"></a>如何预防 SQL 注入</h2><h3 id="控制输入变量的格式"><a href="#控制输入变量的格式" class="headerlink" title="控制输入变量的格式"></a>控制输入变量的格式</h3><p>如上面例子中的 PHP 代码，可以优化成如下效果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername=<span class="string">"127.0.0.1"</span>;</span><br><span class="line">$dbuser=<span class="string">"muke_user"</span>;</span><br><span class="line">$dbpassword=<span class="string">"9Gcag71Gaa"</span>;</span><br><span class="line">$dbname=<span class="string">"muke"</span>;</span><br><span class="line"></span><br><span class="line">$mysqli = <span class="keyword">new</span> mysqli($servername,$dbuser,$dbpassword,$dbname); <span class="comment">//配置MySQL连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($mysqli-&gt;connect_error)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'connect error:'</span>.$mysqli-&gt;connect_errno);</span><br><span class="line">&#125;</span><br><span class="line">$mysqli-&gt;set_charset(<span class="string">'UTF-8'</span>); <span class="comment">// 设置数据库字符集</span></span><br><span class="line">$username = <span class="keyword">isset</span>($_GET[<span class="string">'username'</span>]) ? $_GET[<span class="string">'username'</span>] : <span class="string">''</span>;</span><br><span class="line">$password = <span class="keyword">isset</span>($_GET[<span class="string">'password'</span>]) ? $_GET[<span class="string">'password'</span>] : <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加对输入用户名密码的判断，如果不是字母或者数字，就直接提示格式错误而退出。</span></span><br><span class="line"><span class="keyword">if</span>( !preg_match(<span class="string">"/^[a-zA-Z0-9]&#123;1,&#125;$/"</span>,$username) || !preg_match(<span class="string">"/^[a-zA-Z0-9]&#123;1,&#125;$/"</span>,$password) ) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">"You input username and password  format error "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"select * from t24 where username='$username' and password= '$password'"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$sql&lt;br/&gt;"</span>;</span><br><span class="line">$result = $mysqli-&gt;query(<span class="string">"$sql"</span>);</span><br><span class="line"></span><br><span class="line">$data = $result-&gt;fetch_all(); <span class="comment">// 从结果集中获取所有数据</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($data))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"登录失败"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"登录成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">print_r($data);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>增加了对输入信息的判断，过滤掉一些带特殊字符的输入，我们再验证一下是否还会出现上面我们测试的 SQL 注入情况：</p><p>首先看这个 URL：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt' or '1=1</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d88876a0001d7f309240113.png" alt="图片描述"><br>发现会提示输入格式有问题，无法登录系统。</p><p>在看下上面能获取整张用户表数据的 SQL 注入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=aaa' or username&lt;&gt;'mt</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887590001e63712140133.png" alt="图片描述"></p><p>发现同样提示输入格式有问题，无法查询到任何数据。</p><h3 id="转义特殊字符"><a href="#转义特殊字符" class="headerlink" title="转义特殊字符"></a>转义特殊字符</h3><p>有时，我们程序是允许输入信息带特殊字符的，这种情况就可以使用转义的方式，防止 SQL 注入。</p><p>我们来实验下，在原始代码中，修改定义 sql 这一行为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql = <span class="string">"select * from t24 where username='"</span> . addslashes($username) . <span class="string">"' and password= '"</span> . addslashes($password) . <span class="string">"'"</span>;</span><br></pre></td></tr></table></figure><p>我们再输入前面会导致 SQL 注入的 URL：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt' or '1=1</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887420001ee7f09300195.png" alt="图片描述"></p><p>将传输的变量转义后，避免了 SQL 注入，发现登录失败。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=aaa' or username&lt;&gt;'mt</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d88872d0001a28912040188.png" alt="图片描述"><br>转义后，无法查询到整张用户表的信息了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了 SQL 注入。</p><p>产生的原因：程序对用户输入的数据没有进行严格的过滤，导致攻击者增加一些特殊字符，从而改变传输到 MySQL 中的 SQL。</p><p>SQL 注入危害：会导致攻击者非法入侵系统，或者盗取数据，甚至清空数据等。</p><p>本节讲解了 SQL 注入攻击的方法，目的是让我们能认识到会导致 SQL 注入的一些漏洞，从而优化我们的代码，比如控制输入变量的格式或者转义特殊字符，从而避免程序被 SQL 注入。</p><blockquote><p>参考资料</p><p>《深入浅出 MySQL》第 2 版 第 15 章 SQL 中的安全问题</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的分布式事务</title>
      <link href="/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天我们看一下mysql提供的分布式事务，有关分布式事务的更多详细解释以及更多的解决方案，可以看博客的其它文章。</p><h2 id="认识分布式事务"><a href="#认识分布式事务" class="headerlink" title="认识分布式事务"></a>认识分布式事务</h2><p>分布式事务是指一个大的事务由很多小操作组成，小操作分布在不同的服务器上或者不同的应用程序上。分布式事务需要保证这些小操作要么全部成功，要么全部失败。MySQL 从 5.0.3 开始支持分布式事务。</p><p>分布式事务使用两阶段提交协议：</p><ul><li>第一阶段：所有分支事务都开始准备，告诉事务管理器自己已经准备好了；</li><li>第二阶段：确定是 rollback 还是 commit，如果有一个节点不能提交，则所有节点都要回滚。</li></ul><p>与本地事务不同点在于：分布式事务需要多一次 prepare 操作，等收到所有节点的确定信息后，再进行 commit 或者 rollback。</p><p>上面买书的例子，就可以放到一个分布式事务里，保证增加订单和减库存操作有原子性，要么全部成功，要么全部失败。</p><p>MySQL 中分布式事务按实现方式可以分为两种：MySQL 自带的分布式事务和结合中间件实现分布式事务。下面来详细介绍一下这两种分布式事务。</p><h2 id="MySQL-自带的分布式事务"><a href="#MySQL-自带的分布式事务" class="headerlink" title="MySQL 自带的分布式事务"></a>MySQL 自带的分布式事务</h2><p>MySQL 有自带的分布式事务实现方法，具体语法如下：</p><p>启动分支事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">start</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>‘a’,‘a_1’ 表示 xid，</p><p>a 表示 gtrid，为分布式事务标识符，相同的分布式事务使用相同的 gtrid。</p><p>a_1 表示 bqual，为分支限定符，分布式事务中的每一个分支事务的 bqual 必须不同。</p></blockquote><p>结束分支事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">end</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><p>进入准备状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">prepare</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><p>提交分支事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">commit</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><p>回滚分支事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">rollback</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><p>返回当前数据库中处于 prepare 状态的分支事务的详细信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa recover;</span><br></pre></td></tr></table></figure><p>我们来看一个具体例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">use muke1;</td><td style="text-align:left">use muke2;</td></tr><tr><td style="text-align:left">create table t23_1(id int);</td><td style="text-align:left">create table t23_2(id int);</td></tr><tr><td style="text-align:left">xa start ‘test’,‘muke1’;</td><td style="text-align:left">xa start ‘test’,‘muke2’;</td></tr><tr><td style="text-align:left">insert into t23_1 select 1;</td><td style="text-align:left">insert into t23_2 select 1;</td></tr><tr><td style="text-align:left">xa end ‘test’,‘muke1’;</td><td style="text-align:left">xa end ‘test’,‘muke2’;</td></tr><tr><td style="text-align:left">xa prepare ‘test’,‘muke1’;</td><td style="text-align:left">xa prepare ‘test’,‘muke2’;</td></tr><tr><td style="text-align:left">xa recover \G</td><td style="text-align:left">xa recover \G</td></tr><tr><td style="text-align:left">xa commit ‘test’,‘muke1’;</td><td style="text-align:left">xa commit ‘test’,‘muke2’;</td></tr></tbody></table></div><p>上面的例子就演示了一个分布式事务，事务在 muke1 库中的 t23_1 表中插入一条记录，同时在 muke2 库中的 t23_2 表中插入一条记录，两个操作作为同一个事务提交。在进入准备状态之前，如果 session2 中某一步没执行成功而回滚了，则 session1 和 session2 整个分布式事务的操作都会回滚。</p><p>但是 MySQL 5.7 之前的版本，自带的分布式事务存在以下问题：</p><p>比如某个分支事务到达 prepare 状态时，此时数据库断电，重启后，可以继续对分支事务进行提交或者回滚，但是提交的事务不会写 binlog，如果有从库，会导致主从数据不一致的情况。</p><p>如果分支事务的客户端连接异常中止，那么数据库会自动回滚当前分支未完成的事务，如果此时分支事务已经到 prepare 状态，那么这个分布式事务的其他分支可能已经成功提交，如果这个分支回滚，可能导致分布式事务的不完整，丢失部分分支事务的内容。</p><p>还有一种情况，如果分支事务在执行到 prepare 状态时，数据库出现故障，并且无法启动，需要使用全备和 binlog 来恢复数据，那么这些在 prepare 状态的分支事务因为没有记录到 binlog，所以也不能通过binlog 进行恢复，在数据库恢复后，将丢失这部分数据。</p><p>所以，MySQL 5.7 之前的版本自带的分布式事务还存在比较严重的缺陷，在有些场景下，会导致数据丢失。如果业务对数据完整性要求不改，可以考虑使用，如果对数据完整性要求比较高，需要考虑先升级到 5.7 版本。</p><h2 id="结合中间件实现分布式"><a href="#结合中间件实现分布式" class="headerlink" title="结合中间件实现分布式"></a>结合中间件实现分布式</h2><p>上面说了 MySQL 自带的分布式事务，这里再介绍一下借助中间件实现分布式的情况。</p><p>具体实现方式可以拿上面网上购书的例子来说：</p><p>订单业务程序处理完增加订单的操作后，将减库存操作发送到消息队列中间件中（比如：Rocketmq），订单业务程序完成提交。然后库存业务程序检查到消息队列有减对应商品库存的信息，就开始执行减库存操作。库存业务执行完减库存操作，再发送一条消息给消息队列中间件：内容是已经减掉库存。具体步骤如下：<br><img src="/Users/james/blogs/blog/source/_posts/2022-07-19-mysql的分布式事务/1.png" alt="图片描述"><br>当然，为了确定最终已经完成减库存操作，还可以加一步对数据库中该商品库存的判断。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了分布式事务，所谓分布式事务，是指一个大的事务由很多小操作组成，小操作分布在不同的服务器上或者不同的应用程序上。分布式事务需要保证这些小操作要么全部成功，要么全部失败。</p><p>本节讲解了两种分布式方式：</p><ul><li>MySQL 自带的分布式事务</li><li>结合中间件实现分布式</li></ul><p>当然，目前主流的分布式实现还是结合中间件实现分布式处理的，本节也举例说明了使用 MQ 实现分布式的例子。</p><blockquote><p>参考资料</p><p>《高性能 MySQL》第 3 版 7.11 分布式（XA）事务</p><p>《深入浅出 MySQL》第 2 版 14.3 分布式事务的使用</p><p>《MySQL 技术内幕：InnoDB存储引擎》第 2 版 7.7 分布式事务)</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>有关事务的使用习惯</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E6%9C%89%E5%85%B3%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%A0%E6%83%AF/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E6%9C%89%E5%85%B3%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%A0%E6%83%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时好的事务习惯也影响着业务访问速度。接下来我们看一下事务的使用习惯。</p><p>我们先来看看一些不好的事务习惯：</p><h2 id="不好的事务习惯"><a href="#不好的事务习惯" class="headerlink" title="不好的事务习惯"></a>不好的事务习惯</h2><h3 id="在循环中提交"><a href="#在循环中提交" class="headerlink" title="在循环中提交"></a>在循环中提交</h3><p>在大多数情况下，MySQL 都是开启自动提交的，如果遇到循环执行 SQL，则相当于每个循环中都会进行一次提交，实际这算一个不好的事务习惯了。下面我创建一张测试表，并定义两个循环写入数据的存储过程：一个是自动提交，另一个是在循环前开启一个事务，在循环后一次性提交。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke; <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t22; <span class="comment">/* 如果表t22存在则删除表t22 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t22`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_a`</span> (<span class="string">`a`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_b`</span> (<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> <span class="keyword">if</span> <span class="keyword">exists</span> insert_t22_1; <span class="comment">/* 如果存在存储过程insert_t22_1，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t22_1() <span class="comment">/* 创建存储过程insert_t22_1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="built_in">int</span>; <span class="comment">/* 声明变量i */</span></span><br><span class="line"><span class="keyword">set</span> i=<span class="number">1</span>; <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">while(i&lt;=10000)do /* 对满足i&lt;=10000的值进行while循环 */</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t22(a,b,c,d) <span class="keyword">values</span>(i,i,i,i); <span class="comment">/* 写入表t22中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line"><span class="keyword">set</span> i=i+<span class="number">1</span>; <span class="comment">/* 将i加1 */</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ; <span class="comment">/* 创建批量写入10000条数据到表t22的存储过程insert_t22_1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> <span class="keyword">if</span> <span class="keyword">exists</span> insert_t22_2; <span class="comment">/* 如果存在存储过程insert_t22_2，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t22_2() <span class="comment">/* 创建存储过程insert_t22_2 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="built_in">int</span>; <span class="comment">/* 声明变量i */</span></span><br><span class="line"><span class="keyword">set</span> i=<span class="number">1</span>; <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">while(i&lt;=10000)do /* 对满足i&lt;=10000的值进行while循环 */</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t22(a,b,c,d) <span class="keyword">values</span>(i,i,i,i); <span class="comment">/* 写入表t22中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line"><span class="keyword">set</span> i=i+<span class="number">1</span>; <span class="comment">/* 将i加1 */</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ; <span class="comment">/* 创建批量写入10000条数据到表t22的存储过程insert_t22_2 */</span></span><br></pre></td></tr></table></figure><p>我们来对比两个存储过程的速度：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> insert_t22_1(); <span class="comment">/* 运行存储过程insert_t22_1 */</span></span><br></pre></td></tr></table></figure><p><img src="/Users/james/blogs/blog/source/_posts/2022-07-19-有关事务的使用习惯/1.png" alt="图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> insert_t22_2(); <span class="comment">/* 运行存储过程insert_t22_2 */</span></span><br></pre></td></tr></table></figure><p><img src="/Users/james/blogs/blog/source/_posts/2022-07-19-有关事务的使用习惯/2.png" alt="图片描述">明显第二种方式快的多。因为 insert_t22_1 每一次提交都要写一次重做日志，实际写了 10000 次重做日志，而存储过程 insert_t22_2 只写了 1 次重做日志。</p><p>因此，在类似这种循环写入的情况，如果循环次数不是太多，建议在循环前开启一个事务，循环结束后统一提交。</p><h3 id="不关注同一个事务里语句顺序"><a href="#不关注同一个事务里语句顺序" class="headerlink" title="不关注同一个事务里语句顺序"></a>不关注同一个事务里语句顺序</h3><p>比如 A 在超市购买 100 元的商品，付款操作可以简化为：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">操作</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">A 的账户中扣除 100</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">超市的账户增加 100</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">在超市系统中记录一条日志</td></tr></tbody></table></div><p>很多时候我们会按上面的 SQL 步骤放入一个事务里执行，不关注里面语句的顺序。实际可以优化的。</p><p>根据两阶段锁，整个事务里面涉及的锁，需要等到事务提交时才会释放。因此我们在<strong>同一个事务中，可以把没锁或者锁范围小的语句放在事务前面执行，而锁定范围大的语句放在后面执行。</strong></p><blockquote><p>这里来回顾一下第 16 节中提到的两阶段锁：锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。在执行语句的时候加上锁，但并不是语句执行完就立刻释放锁，而是要等到事务结束时才释放。</p></blockquote><p>因此上面 A 购买商品的例子中，可能很多人同时在超市付款，那么存在锁竞争的最可能是超市账户增加 100 元的操作。</p><p>那么付款操作可以这么优化：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">操作</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">在超市系统中记录一条日志</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">A 的账户中扣除 100</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">超市的账户增加 100</td></tr></tbody></table></div><p>把可能存在锁竞争的操作放在最后执行，从而优化整个事务。</p><p>因此在写程序时，应该去关注事务里的语句顺序。</p><h3 id="不关注不同事务访问资源的顺序"><a href="#不关注不同事务访问资源的顺序" class="headerlink" title="不关注不同事务访问资源的顺序"></a>不关注不同事务访问资源的顺序</h3><p>不同事务访问资源顺序也会导致产生死锁，我们来回顾一下：</p><ul><li>不同线程并发访问同一张表的多行数据，未按顺序访问导致死锁。</li><li>不同线程并发访问多个表时，未按顺序访问导致死锁。</li></ul><p>如果不关注并发访问的不同事务中访问资源的顺序，就会增大出现死锁的概率。</p><p>因此，为了降低死锁，我们需要去关注不同事务访问资源的顺序。</p><h3 id="不关注事务隔离级别"><a href="#不关注事务隔离级别" class="headerlink" title="不关注事务隔离级别"></a>不关注事务隔离级别</h3><p>不同事务隔离级别加锁的情况也是不同的。</p><p>如果完全不关注自己业务使用的 MySQL 是什么隔离级别，可能会降低程序的并发能力或者导致死锁。</p><p>比如业务场景完全能接受幻读，如果要求更高的 QPS，使用 RR 隔离级别显然不是最好的选择，因此可以改为 RC 隔离级别。</p><p>而如果业务使用的是 RR 隔离级别，可能由于间隙锁导致死锁，因此也应该在程序编写时关注 RR 隔离级别下是否会有间隙锁。</p><p>因此，为了更高的并发和降低死锁概率，在创建事务前，也应该去关注自己业务的数据库是什么事务隔离级别。</p><h3 id="在事务中混合使用存储引擎"><a href="#在事务中混合使用存储引擎" class="headerlink" title="在事务中混合使用存储引擎"></a>在事务中混合使用存储引擎</h3><p>在事务中混合使用事务型（比如 InnoDB）和非事务型（比如 MyISAM）表，如果是正常提交，到没什么问题。</p><p>但是，如果该事务回滚了，事务型的表可以正常回滚，而非事务型的表的变更就无法回滚了。这种情况就会导致数据不正常，并且事务最终的结果也难以确定。</p><p>因此，在事务中混合使用存储引擎也是一个不好的事务习惯。</p><blockquote><p>值得一提的是：如果开启 GTID，那么当同一个事务中使用不同存储引擎的表时，会出现如下报错：</p><p>ERROR 1785 (HY000): Statement violates GTID consistency: Updates to non-transactional tables can only be done in either autocommitted statements or single-statement transactions, and never in the same statement as updates to transactional tables.</p><p>因此，开启 GTID 的情况，可以避免同一个事务中混合使用存储引擎的情况。</p></blockquote><h2 id="总结一下好的事务习惯"><a href="#总结一下好的事务习惯" class="headerlink" title="总结一下好的事务习惯"></a>总结一下好的事务习惯</h2><p>在本节中，我们列举了几种不好的事务习惯，这里总结一下好的事务习惯：</p><ul><li>循环写入的情况，如果循环次数不是太多，建议在循环前开启一个事务，循环结束后统一提交。</li><li>优化事务里的语句顺序，减少锁时间。</li><li>关注不同事务访问资源的顺序。</li><li>创建事务之前，关注事务隔离级别。</li><li>在事务中不要混合使用存储引擎。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《MySQL 技术内幕》第 2 版 7.8 不好的事务习惯</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvcc实现</title>
      <link href="/2022/07/18/mysql-2022-07-18-mvcc%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/07/18/mysql-2022-07-18-mvcc%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    本节跟大家一起聊聊 MVCC。</p><h2 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a>什么是 MVCC？</h2><p>在说 MVCC 之前，大家先看看下面这个例子。</p><p>首先创建表并写入测试数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t20;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t20`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t20(a,b) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>进行实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">select * from t20; <img src="/Users/james/blogs/blog/source/_posts/mysql/2022-07-18-mvcc实现/1.png" alt="图片描述"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">begin;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">update t20 set b=666 where a=1;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"></td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"></td><td style="text-align:left">select * from t20; <img src="/Users/james/blogs/blog/source/_posts/mysql/2022-07-18-mvcc实现/2.png" alt="图片描述"></td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">commit;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"></td><td style="text-align:left">select * from t20; <img src="/Users/james/blogs/blog/source/_posts/mysql/2022-07-18-mvcc实现/3.png" alt="图片描述"></td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"></td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>在 session1 更新了 a=1 这行记录，但还没提交的情况下，在 session2 中，满足 a=1 这条记录，b 的值还是原始值 1，而不是 session 1 更新之后的 666，那么在数据库层面，这是怎么实现的呢？</p><p>其实 InnoDB 就是通过 MVCC 和 UNDO LOG 来实现的。</p><p>什么是 MVCC 呢？</p><p>MVCC， 即多版本并发控制。MVCC 的实现，是通过保存数据在某个时间点的快照来实现的，也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><p>也就是上面实验第 6 步中，为什么 session2 查询的结果还是 session1 修改之前的记录。</p><p>MCCC 只在 RC 和 RR 两个隔离级别下工作。因此在上面的实验中，改成 RR 隔离级别，第 6 步中，得到的结果还是 session1 修改之前的记录（但是在第 8 步，结果不一样哦，感兴趣的可以把上面操作放在 RR 隔离级别下实验一下）</p><p>上面提到了 undo log，那么什么是 undo log 呢？</p><h2 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h2><p>上节我们讲到了 redo log，它记录了事务操作变化。但是事务有时是需要回滚的，这时，undo log 就发挥了作用。undo log 是逻辑日志，将数据库逻辑地恢复到原来的样子，所有修改都被逻辑地取消了。</p><p>也就是如果是 insert 操作，其对应的回滚操作就是 delete；</p><p>如果是 delete，则对应的回滚操作是 insert；</p><p>如果是 update，则对应的回滚操作是一个反向的 update 操作。</p><p>除了回滚操作，undo log 的另一个作用是 MVCC，InnoDB 存储引擎中 MVCC 的实现是通过 undo 来完成的。当用户读取一行记录时，若该记录已经被其它事务占用，当前事务可以通过 undo log 读取之前的行版本信息，以此实现非锁定读取。</p><h2 id="MVCC-的实现原理"><a href="#MVCC-的实现原理" class="headerlink" title="MVCC 的实现原理"></a>MVCC 的实现原理</h2><p>InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本（存放在 UNDO LOG 中）。</p><p><img src="/Users/james/blogs/blog/source/_posts/mysql/2022-07-18-mvcc实现/4.png" alt="图片描述"><br>如图，执行 update t20 set b=666 where a=1; 时，会将原记录放到 undo 表空间中，并通过隐藏的回滚指针指向该记录。在本节开始的实验中的第 6 步中，session2 查询的结果是 session1 修改之前的记录，这个记录就是来自 undo log 中。</p><h2 id="MVCC-的优势"><a href="#MVCC-的优势" class="headerlink" title="MVCC 的优势"></a>MVCC 的优势</h2><p>MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。</p><p>通过 MVCC，保证了事务 ACID 中的 （隔离性）特性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 RC 和 RR 隔离级别下，如果需要查询一些被其它事务正在更新的行，看到的是这些记录被更新之前的值。而这就是用 MVCC 实现的。</p><p>MVCC 实现的原理大致是：</p><p><strong>InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。</strong></p><p>MVCC 最大的好处是读不加锁，读写不冲突，极大的增加了 MySQL 的并发性，通过 MVCC，也保证了事务 ACID 中的 (隔离性)特性。</p><blockquote><p>参考</p><p>《MySQL 技术内幕》第 2 版：7.2.2 undo</p><p>《高性能 MySQL》第 3 版：1.4 多版本并发控制</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务与事务持久化</title>
      <link href="/2022/07/18/mysql-2022-07-18-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2022/07/18/mysql-2022-07-18-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 思考两个问题，数据库突然断电会丢失数据吗？数据库中的事务是如何记录的？带着两个疑问，我们继续往下看。</p><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>根据《高性能 MySQL》第 3 版 1.3 事务一节中定义：</p><blockquote><p>事务就是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。</p></blockquote><p>看上面的文字可以稍微抽象了一点，可以结合生活中的一个例子：</p><p>比如你给朋友转账 100 元，其大致过程是：从你的账户扣除 100 元，然后再到你朋友的账户中增加 100 元，试想，如果在这中间，因为网络问题或者程序问题，导致在你的账户中扣除了，但是没有在你朋友的账户中增加，那岂不是乱套了。</p><p>所以，类似这种情况，就可以把这两个步骤放到一个事务里面。要么全部成功，也就是从你的账户扣除之后，然后在你朋友账户中新增；要么全部失败，比如在中间出现问题，会回滚这中间所有的变更。大致操作步骤如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">步骤</th><th style="text-align:left">对应的语句</th></tr></thead><tbody><tr><td style="text-align:left">开始一个事务</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">从你的账户扣除 100 元</td><td style="text-align:left">update money_info set balance = balance - 100 where user_id=1;</td></tr><tr><td style="text-align:left">在你朋友的账户中增加 100 元</td><td style="text-align:left">update money_info set balance = balance + 100 where user_id=2;</td></tr><tr><td style="text-align:left">事务结束</td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>一个良好的事务处理系统，必须具备 ACID 特性：</p><ul><li>atomicity（原子性） ：要么全执行，要么全都不执行；</li><li>consistency（一致性）：在事务开始和完成时，数据都必须保持一致状态；</li><li>isolation（隔离性） ：事务处理过程中的中间状态对外部是不可见的；</li><li>durability（持久性） ：事务完成之后，它对于数据的修改是永久性的。</li></ul><p>InnoDB 采用 redo log 机制来保证事务更新的一致性和持久性。什么是 redo log？下面来一起看下：</p><h2 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h2><p>Redo log 称为重做日志，用于记录事务操作变化，记录的是数据被修改之后的值。</p><p>Redo log 由两部分组成：</p><ul><li>内存中的重做日志缓冲（redo log buffer）</li><li>重做日志文件（redo log file）</li></ul><p>每次数据更新会先更新 redo log buffer，然后根据 innodb_flush_log_at_trx_commit 来控制 redo log buffer 更新到 redo log file 的时机。innodb_flush_log_at_trx_commit 有三个值可选：</p><ul><li><p>0：事务提交时，在事务提交时，每秒触发一次 redo log buffer 写磁盘操作，并调用操作系统 fsync 刷新 IO 缓存。</p></li><li><p>1：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，并调用操作系统 fsync 刷新 IO 缓存；</p></li><li><p>2：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，但不是马上调用 fsync 刷新 IO 缓存，而是每秒只做一次磁盘 IO 缓存刷新操作。</p></li></ul><p>innodb_flush_log_at_trx_commit 参数的默认值是 1，也就是每个事务提交的时候都会从 log buffer 写更新记录到日志文件，而且会刷新磁盘缓存，这完全满足事务持久化的要求，是最安全的，但是这样会有比较大的性能损失。</p><p>将参数设置为 0 时，如果数据库崩溃，最后 1秒钟的 redo log 可能会由于未及时写入磁盘文件而丢失，这种方式尽管效率最高，但是最不安全。</p><p>将参数设置为 2 时，如果数据库崩溃，由于已经执行了重做日志写入磁盘的操作，只是没有做磁盘 IO 刷新操作，因此，只要不发生操作系统奔溃，数据就不会丢失，这种方式是对性能和安全的一种折中处理。</p><h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><p>二进制日志（binlog）记录了所有的 DDL（数据定义语句）和 DML（数据操纵语句），但是不包括 select 和 show 这类操作。Binlog 有以下几个作用：</p><ul><li>恢复：数据恢复时可以使用二进制日志</li><li>复制：通过传输二进制日志到从库，然后进行恢复，以实现主从同步</li><li>审计：可以通过二进制日志进行审计数据的变更操作</li></ul><p>可以通过参数 sync_binlog 来控制累积多少个事务后才将二进制日志 fsync 到磁盘。</p><ul><li>sync_binlog=0，表示每次提交事务都只write，不fsync</li><li>sync_binlog=1，表示每次提交事务都会执行fsync</li><li>sync_binlog=N(N&gt;1)，表示每次提交事务都write，累积N个事务后才fsync</li></ul><p>比如要加快写入数据的速度或者机器磁盘 IO 瓶颈时，可以将 sync_binlog 设置成大于 1 的值，<strong>但是如果设置为 N(N&gt;1)时，如果数据库崩溃，可能会丢失最近 N 个事务的 binlog。</strong></p><h2 id="怎样确保数据库突然断电不丢数据？"><a href="#怎样确保数据库突然断电不丢数据？" class="headerlink" title="怎样确保数据库突然断电不丢数据？"></a>怎样确保数据库突然断电不丢数据？</h2><p>通过上面的讲解，只要 innodb_flush_log_at_trx_commit 和 sync_binlog 都为 1（通常称为：双一），就能确保 MySQL 机器断电重启后，数据不丢失。</p><p>因此建议在比较重要的库，比如涉及到钱的库，设置为双一，而你的测试环境或者正式业务不那么重要的库（比如日志库）可以将 innodb_flush_log_at_trx_commit 设置为0，sync_binlog 设置成大于100 的数值，提高更新效率。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了什么是事务？</p><p>所谓事务：是指一组原子性的 SQL 查询，事务里的 SQL 要么全部执行成功，要么全部执行失败。</p><p>一个良好的事务处理系统，必须具备 ACID 特性： atomicity（原子性）、consistency（一致性）、 isolation（隔离性）、 durability（持久性）。</p><p>另外讲解了 Redo log 和 Binlog：</p><ul><li>Redo log：称为重做日志，用于记录事务操作变化，记录的是数据被修改之后的值</li><li>Binlog：记录了所有变更操作，其作用有：恢复、复制、审计等</li></ul><p>如果想要数据库达到最安全的状态，可以将 innodb_flush_log_at_trx_commit 和 sync_binlog 都设置为 1。</p><blockquote><p>参考资料</p><p>《高性能 MySQL》第 3 版：1.3 事务</p><p>《MySQL 技术内幕》第 2 版：7.2 事务的实现</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql死锁的发生与解决</title>
      <link href="/2022/07/18/mysql-2022-07-18-mysql%E6%AD%BB%E9%94%81%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
      <url>/2022/07/18/mysql-2022-07-18-mysql%E6%AD%BB%E9%94%81%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有了锁的基础之后，我们来了解一下死锁的产生和解决。</p><h2 id="认识死锁"><a href="#认识死锁" class="headerlink" title="认识死锁"></a>认识死锁</h2><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</p><p>InnoDB 中解决死锁问题有两种方式：</p><ol><li>检测到死锁的循环依赖，立即返回一个错误（这个报错内容请看下面的实验），将参数 innodb_deadlock_detect 设置为 on 表示开启这个逻辑；</li><li>等查询的时间达到锁等待超时的设定后放弃锁请求。这个超时时间由 innodb_lock_wait_timeout 来控制。默认是 50 秒。</li></ol><blockquote><p>一般线上业务都建议使用的第 1 种策略，因为第 2 种策略锁等待时间是 50 秒，对于高并发的线上业务是不能接受的。</p><p>但是第 1 种策略，也会有死锁检测时的额外 CPU 开销的，比如电商中的秒杀场景。这种情况就可以根据业务开发商量优化程序，如果可以确保业务一定不会出现死锁，可以临时把死锁检测关掉，以提高并发效率。</p></blockquote><h2 id="为什么会产生死锁"><a href="#为什么会产生死锁" class="headerlink" title="为什么会产生死锁"></a>为什么会产生死锁</h2><p>我们通过几个实验来构造几种产生死锁的情况，首先创建测试表并写入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t18;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t18`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t18(a,b,c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t18_1;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t18_1  <span class="keyword">like</span> t18;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t18_1 <span class="keyword">select</span> * <span class="keyword">from</span> t18;</span><br></pre></td></tr></table></figure><h3 id="同一张表中"><a href="#同一张表中" class="headerlink" title="同一张表中"></a>同一张表中</h3><p>不同线程并发访问同一张表的多行数据，未按顺序访问导致死锁。</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">select * from t18 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left">select * from t18 where a=2 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left">select * from t18 where a=2 for update;/* SQL1 */ （等待）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>（session2 提示死锁回滚后，SQL1 成功返回结构）</strong></td><td style="text-align:left">select * from t18 where a=1 for update; <strong>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>session1 在等待 session2 释放 a=2 的行锁，而 session2 在等待 session1 释放 a=1 的行锁。两个 session 互相等待对方释放资源，就进入了死锁状态。</p><p>因此，在上面的例子中，如果 session1 中的事务提交之后，再执行 session2 中的事务，就可以避免这次死锁的发生了。</p><p><strong>所以对于程序多个并发访问同一张表时，如果事先确保每个线程按固定顺序来处理记录，可以降低死锁的概率。</strong></p><h3 id="不同表之间"><a href="#不同表之间" class="headerlink" title="不同表之间"></a>不同表之间</h3><p>不同线程并发访问多个表时，未按顺序访问导致死锁：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">select * from t18 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left">select * from t18_1 where a=1 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left">select * from t18_1 where a=1 for update;/* SQL2 */ 等待</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>（session2 提示死锁回滚后，SQL1 成功返回结构）</strong></td><td style="text-align:left">select * from t18 where a=1 for update; <strong>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>与 同一张表类似，但是这个例子涉及到两张表，如果上例中，之前就约定好 session1 中的事务执行完毕后，再执行 session2 的事务，则可以避免死锁的产生。</p><p>因此，<strong>不同程序并发访问多个表时，应尽量约定以相同的顺序来访问表，可大大降低并发操作不同表时死锁发生的概率</strong>。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>RR 隔离级别下，由于间隙锁导致死锁：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’; /* 设置会话隔离级别为 RR */</td><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’; /* 设置会话隔离级别为 RR */</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">select * from t18 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left">select * from t18 where a=2 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left">insert into t18(a,b,c) values (2,3,3);/* SQL3 */ 等待</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>（session2 提示死锁回滚后，SQL1 成功返回结构）</strong></td><td style="text-align:left">insert into t18(a,b,c) values (1,4,4);/* SQL4 */ ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>有之前的索引知识可以知道 SQL3 需要等待 a=2 获得的间隙锁，而 SQL4 需要等待 a=1 获得的间隙锁，两个 session 互相等待对方释放资源，就进入了死锁状态。</p><p>类似这种情况，可以考虑将隔离级别改成 RC（这里各位读者可以尝试在 RC 隔离级别下，做上面的实验），降低死锁的概率（当然RC 隔离级别可能会导致幻读，因此需要确定是否可以改成 RC。）</p><h2 id="如何降低死锁概率"><a href="#如何降低死锁概率" class="headerlink" title="如何降低死锁概率"></a>如何降低死锁概率</h2><p>那么应该怎样降低出现死锁的概率呢？这里总结了如下一些经验：</p><ol><li>更新 SQL 的 where 条件尽量用索引；</li><li>基于 primary 或 unique key 更新数据；</li><li>减少范围更新，尤其非主键、非唯一索引上的范围更新；</li><li>加锁顺序一致，尽可能一次性锁定所有需要行；</li><li>将 RR 隔离级别调整为 RC 隔离级别。</li></ol><h2 id="分析死锁的方法"><a href="#分析死锁的方法" class="headerlink" title="分析死锁的方法"></a>分析死锁的方法</h2><p>尽管在上面介绍了降低死锁概率的方法，但是在实际工作中，死锁很难完全避免。因此，捕获并处理死锁也是一个好的编程习惯。</p><p>InnoDB 中，可以使用 SHOW INNODB STATUS 命令来查看最后一个死锁的信息。我们可以尝试用下这个命令获取一些死锁信息，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span>\G</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="图片描述">如上面的图片，就是事务隔离级别例子中的死锁情况，在最后显示回滚了事务 2，也就是对应实验中的 session2。</p><p>另外设置 innodb_print_all_deadlocks = on 可以在 err log 中记录全部死锁信息。</p><p>因此我们可以通过上面两种方式捕获死锁信息，从而进行优化。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节聊了死锁相关的内容。通过具体实验列举了几种出现死锁的情况：</p><ul><li>不同线程并发访问同一张表的多行数据，未按顺序访问导致死锁；</li><li>不同线程并发访问多个表时，未按顺序访问导致死锁；</li><li>RR 隔离级别下，由于间隙锁导致死锁。</li></ul><p>后面提供了几种降低死锁概率的方法。</p><p>由于死锁不能完全杜绝，因此，在最后提供了捕获死锁信息的方法，在工作中我们可以把死锁信息记录下来，如果出现频率过高，就应该考虑去优化程序了。</p><blockquote><p>参考资料</p><p>《深入浅出 MySQL》第 2 版：20.3.9 关于死锁</p><p>《高性能 MySQL》第 3 版：1.3.2 死锁</p><p>《MySQL 技术内幕》第 2 版：6.7 死锁</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql锁机制-间隙锁</title>
      <link href="/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E9%97%B4%E9%9A%99%E9%94%81/"/>
      <url>/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E9%97%B4%E9%9A%99%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    上节我们聊到了 RC 隔离级别的各种情况的锁，这节我们就来一起看看 RR 隔离级别各种情况下的锁，同时揭晓间隙锁的意义。</p><h2 id="RC下的幻读"><a href="#RC下的幻读" class="headerlink" title="RC下的幻读"></a>RC下的幻读</h2><p>下面我们来做一个实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t16 where c=3 for update; <img src="6.png" alt="图片描述"></td></tr><tr><td style="text-align:left">use muke; insert into t16(a,b,c) values (5,5,3); Query OK, 1 row affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select * from t16 where c=3 for update; <img src="7.png" alt="图片描述"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>我们看一下上面的实验结果，在 session2 中，同一个事务中，按相同的查询条件重新读取以前检索过的数据，却发现了 session1 插入的满足查询条件的新数据，这也就是上一节讲到的幻读情况。</p><p>为什么上面的实验中会出现幻读呢？</p><p>我们来看看下面这张图：<br><img src="1.png" alt="图片描述">从图中可以看出，RC 隔离级别下，只锁住了满足 c=3 的当前行，而不会对后面的位置（或者说间隙)加锁，因此导致 session1 的写入语句能正常执行并提交。</p><p>那么应该怎样避免幻读呢？</p><p>从上面的分析我们可以知道，产生幻读的原因是：行锁只能锁住当前行，但是新插入的记录，是在被锁住记录之前的间隙。因此，为了解决幻读问题，InnoDB 在 RR 隔离级别下配置了间隙锁（Gap Lock）。</p><h2 id="RR-隔离级别下的非唯一索引查询"><a href="#RR-隔离级别下的非唯一索引查询" class="headerlink" title="RR 隔离级别下的非唯一索引查询"></a>RR 隔离级别下的非唯一索引查询</h2><p>我们继续看上面的实验，这里不同点是我们把隔离级别设置成 RR。</p><p>我们再单独建一张表，表结构与上节的表结构一致，为了方便后面分析，数据稍微有改动，语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t17;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t17`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uniq_a`</span> (<span class="string">`a`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t17(<span class="keyword">id</span>,a,b,c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>开始 RR 隔离级别下的实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t17 where c=4 for update; <img src="2.png" alt="图片描述"></td></tr><tr><td style="text-align:left">use muke; insert into t17(a,b,c) values (7,7,4); /* SQL1 */ <strong>（等待）</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select *\ from t17 where c=4 for update; <img src="3.png" alt="图片描述"></td></tr><tr><td style="text-align:left">insert into t17(a,b,c) values (7,7,4); /* SQL1 */ Query OK, 1 row affected (20.73 sec) <strong>（等 session2 执行 commit; 后，SQL1 马上返回结果）</strong></td><td style="text-align:left">commit;</td></tr><tr><td style="text-align:left">commit;</td></tr></tbody></table></div><p>根据实验情况，我们在 session2 中，对满足条件 c=4 的数据加上了排他锁，然后在 session1 写入一条 c=4 的记录，此时会出现等待，直到 session2 对事务进行提交后，session1 才会执行成功。这是为什么呢？我们来看下图：<br><img src="4.png" alt="图片描述">与 RC 隔离级别下的图相似，但是有个比较大的区别是：RR 隔离级别多了 GAP 锁。</p><p>如上图，首先需要考虑哪些位置可以插入新的满足条件 c=4 的项：</p><ul><li>由于 B+ 树索引是有序的，因此 [2,2]（代表 c 和 id 的值，后面就不一一说明了）前面的记录，不可能插入 c=4 的记录了；</li><li>[2,2] 与 [4,4] 之间可以插入 [4,3]；</li><li>[4,4] 与 [4,6] 之间可以插入 [4,5]；</li><li>[4,6] 之后，可以插入的值就很多了：<a href="其中 n&gt;6">4,n</a> ；</li></ul><p>为了保证这几个区间不会插入新的满足条件 c=4 的记录，MySQL RR 隔离级别选择了 GAP 锁，将这几个区间锁起来。</p><p>而上面实验中，语句 insert into t17 (a,b,c) values (7,7,4) 其对应插入 c 和 id 的值为 [4,7]，是在最后这个被 GAP Lock 锁住的区间，因此如上面实验，insert 操作会等待。</p><h2 id="RR-隔离级别下的非索引字段查询"><a href="#RR-隔离级别下的非索引字段查询" class="headerlink" title="RR 隔离级别下的非索引字段查询"></a>RR 隔离级别下的非索引字段查询</h2><p>上一节中，我们测试了 RC 隔离级别下，非索引字段做条件的当前读会对所有记录都加锁。</p><p>这一节，我们测试一下 RR 隔离级别下，非索引字段做条件的当前读加锁情况。</p><p>首先对 t17 表中的数据做初始化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t17;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t17`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uniq_a`</span> (<span class="string">`a`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t17(<span class="keyword">id</span>,a,b,c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; select * from t17 where b=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t17 where b=2 for update; <strong>（等待）</strong></td><td style="text-align:left">insert into t17(a,b,c) values (10,10,10); <strong>（等待）</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select * from t17 where b=2 for update; … 1 row in set (31.51 sec) <strong>（session1 提交后，马上返回结果）</strong></td><td style="text-align:left">insert into t17(a,b,c) values (10,10,10); Query OK, 1 row affected (8.08 sec) <strong>（session1 提交后，马上写入）</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></div><p>可能你会问？为什么 session3 的 insert 会出现等待？</p><p>我们看看下图：<br><img src="5.png" alt="图片描述"><br>如图，所有记录都有 X 锁，除此之外，每个 GAP 也被加上了 GAP 锁。因此这张表在执行完 select * from t17 where b=1 for update; 到 commit 之前，除了不加锁的快照读，其它任何加锁的 SQL，都会等待，如果这是线上业务表，那就是件非常恐怖的事情了。</p><p>总结：<strong>RR 隔离级别下，非索引字段做条件的当前读不但会把每条记录都加上 X 锁，还会把每个 GAP 加上 GAP 锁。再次说明，条件字段加索引的重要性。</strong></p><h2 id="RR-隔离级别下的唯一索引当前读是否会用到-GAP-锁"><a href="#RR-隔离级别下的唯一索引当前读是否会用到-GAP-锁" class="headerlink" title="RR 隔离级别下的唯一索引当前读是否会用到 GAP 锁"></a>RR 隔离级别下的唯一索引当前读是否会用到 GAP 锁</h2><p>GAP 锁的目的是：为了防止同一事务两次当前读，出现幻读的情况。如果能确保索引字段唯一，那其实一个等值查询，最多就返回一条记录，而且相同索引记录的值，一定不会再新增，因此不会出现 GAP 锁。</p><p>因此以唯一索引为条件的当前读，不会有 GAP 锁。所以 RR 隔离级别下的唯一索引当前读加锁情况与 RC 隔离级别下的唯一索引当前读加锁情况一致。这里就不再实验了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了 RC 隔离级别出现幻读的情况，而 RR 通过 GAP 锁解决了幻读，但是 RR 隔离级别相对于 RC，锁的范围可能更大了，特别是对没有索引的字段进行当前读（比如增、删、改或者 select … for update）时，会阻塞除快照读以外所有的并发 SQL。</p><p>而后面我们又聊了以唯一索引做为条件的当前读不会用到 GAP 锁，因为根据唯一索引查询最多就一条记录，而且相同索引记录的值，一定不会再新增。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql锁机制-行锁</title>
      <link href="/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E8%A1%8C%E9%94%81/"/>
      <url>/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E8%A1%8C%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>MySQL 5.5 之前的默认存储引擎是 MyISAM，5.5 之后改成了 InnoDB。InnoDB 后来居上最主要的原因就是：</p><ul><li>InnoDB 支持事务：适合在并发条件下要求数据一致的场景。</li><li>InnoDB 支持行锁：有效降低由于删除或者更新导致的锁定。</li></ul><p>本节就一起来探讨 InnoDB 的行锁。</p><p>在讲解行锁之前，我们首先来看一下两阶段锁协议。</p><h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><p>传统的关系型数据库加锁的一个原则是：两阶段锁原则。</p><p>两阶段锁：锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。</p><p>我们可以通过下面这张表理解两阶段锁：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">MySQL 操作</th><th style="text-align:left">解释</th><th style="text-align:left">锁阶段</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">begin;</td><td style="text-align:left">事务开始</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">insert into …;</td><td style="text-align:left">加 insert 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">update table …;</td><td style="text-align:left">加 update 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">delete from …;</td><td style="text-align:left">加 delete 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">commit;</td><td style="text-align:left">事务结束，同时释放 2、3、4 步骤中加的锁</td><td style="text-align:left">解锁阶段</td></tr></tbody></table></div><h2 id="InnoDB-行锁模式"><a href="#InnoDB-行锁模式" class="headerlink" title="InnoDB 行锁模式"></a>InnoDB 行锁模式</h2><p>InnoDB 实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁；</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>对于普通 select 语句，InnoDB 不会加任何锁，事务可以通过以下语句显式给记录集加共享锁或排他锁：</p><ul><li>共享锁（S）：select * from table_name where … lock in share mode;</li><li>排他锁（X）：select * from table_name where … for update。</li></ul><h2 id="InnoDB-行锁算法"><a href="#InnoDB-行锁算法" class="headerlink" title="InnoDB 行锁算法"></a>InnoDB 行锁算法</h2><p>InnoDB 行锁的三种算法：</p><ul><li>Record Lock：单个记录上的索引加锁。</li><li>Gap Lock：间隙锁，对索引项之间的间隙加锁，但不包括记录本身。</li><li>Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。</li></ul><p>InnoDB 行锁实现特点意味着：如果不通过索引条件检索数据，那么 InnoDB 将对表中所有记录加锁，实际效果跟表锁一样。</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>不同事务隔离级别对应的行锁也是不一样的，因此在讲解行锁的锁定范围之前，先简单聊聊事务隔离级别。事务隔离级别的详细介绍放在下一章。</p><p>MySQL 的 4 种隔离级别：</p><ul><li>Read uncommitted（读未提交）: 在该隔离级别，所有事务都可以看到其它未提交事务的执行结果。可能会出现脏读。</li><li>Read Committed（读已提交，简称： RC）：一个事务只能看见已经提交事务所做的改变。因为同一事务的其它实例在该实例处理期间可能会有新的 commit，所以可能出现幻读。</li><li>Repeatable Read（可重复读，简称：RR）：这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。消除了脏读、不可重复读，默认也不会出现幻读。</li><li>Serializable（串行）：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。</li></ul><blockquote><p>这里解释一下脏读和幻读：</p><ul><li>脏读：读取未提交的事务。</li><li>幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。</li></ul></blockquote><h2 id="RC-隔离级别下的行锁实验"><a href="#RC-隔离级别下的行锁实验" class="headerlink" title="RC 隔离级别下的行锁实验"></a>RC 隔离级别下的行锁实验</h2><p>有时我们可能会思考，某条语句（类似 select * from table_name where a=… for update;）是怎么加锁的？</p><p>要想分析某条 SQL 是怎么加锁的，如果其他信息都不知道，那就得分几种情况了，不同情况加锁的方式也各不一样，比较常见的一些情况如下：</p><ul><li>RC 隔离级别，a 字段没索引。</li><li>RC 隔离级别，a 字段有唯一索引。</li><li>RC 隔离级别，a 字段有非唯一索引。</li><li>RR 隔离级别，a 字段没索引。</li><li>RR 隔离级别，a 字段有唯一索引。</li><li>RR 隔离级别，a 字段有非唯一索引。</li><li>…</li></ul><blockquote><p>Read uncommitted 和 Serializable 这两种隔离级别在生产环境基本不用，就不做分析了。</p></blockquote><p>我们先验证 RC 隔离级别下的几种情况，RR 隔离级别的实验放在下节：</p><p>首先创建测试表及写入数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t16`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uniq_a`</span> (<span class="string">`a`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t16(a,b,c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>让我们开始实验吧！</p><h3 id="通过非索引字段查询"><a href="#通过非索引字段查询" class="headerlink" title="通过非索引字段查询"></a>通过非索引字段查询</h3><p>我们首先来看一下条件字段不使用索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/<em> 设置会话隔离级别为 RC\</em>/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; select * from t16 where b=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select <em> from t16 where b=2 for update; <em>*（等待）</em></em></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select * from t16 where b=2 for update; … 1 row in set (6.81 sec) <strong>（session1 执行 commit 后立马返回结果）</strong></td></tr></tbody></table></div><blockquote><p><strong>这里解释一下为什么要用 for update？</strong></p><p>我们常使用的查询语句，比如 select * from t16 where b=1 属于快照读，是不会看到别的事务插入的数据的。</p><p>而在查询语句后面加了 for update 显式给记录集加了排他锁，也就让查询变成了当前读。插入、更新、删除操作，都属于当前读。其实也就可以理解 select … for update 是为了让普通查询获得插入、更新、删除操作时所获得的锁。</p></blockquote><p>表面看起来 session1 只给了 b=1 这一行加了排他锁，但 session2 在请求其它行的排他锁时，却出现了锁等待。看下图：<br><img src="1.png" alt="图片描述">由于 b 字段没有索引，因此只能走聚簇索引，进行全表扫描。从上图中可以看到，满足条件的记录有一条，但是聚簇索引上的所有记录，都被加上了 X 锁。</p><p>为什么不是只在满足条件的记录上加锁呢？</p><p>这是因为在 MySQL 中，如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由 server 层进行过滤。因此也就把所有记录都锁上了。</p><blockquote><p>当然 MySQL 在这里有一些改进的，在 server 层过滤掉不满足条件的数据后，会把不满足条件的记录放锁。保证了最后只会持有满足条件的锁，但是每条记录的加锁操作还是不会省略。</p></blockquote><p>总结：<strong>没有索引的情况下，InnoDB 的当前读会对所有记录都加锁。所以在工作中应该特别注意 InnoDB 这一特性，否则可能会产生大量的锁冲突。</strong></p><h3 id="通过唯一索引查询"><a href="#通过唯一索引查询" class="headerlink" title="通过唯一索引查询"></a>通过唯一索引查询</h3><p>我们再来看一下条件字段有唯一索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td></tr><tr><td style="text-align:left">begin; use muke; select * from t16 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t16 where a=2 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select * from t16 where a=1 for update; <strong>（等待）</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select * from t16 where a=1 for update; … 1 row in set (4.70 sec) <strong>（session1 提交后，马上返回结果）</strong></td></tr></tbody></table></div><p>session1 给了 a=1 这一行加了排他锁，在 session2 中请求其他行的排他锁时，不会发生等待；但是在 session2 中请求 a=1 这一行的排他锁时，会发生等待。看下图：<br><img src="2.png" alt="图片描述"></p><p>由于 a 是唯一索引，因此 select * from t16 where a=1 for update；(后面称为 SQL2) 语句会选择走 a 列的索引进行条件过滤，在找到 a=1 的记录后，会将唯一索引上 a=1 索引记录上加 X 锁，同时，会根据读取到的 id 列，回到聚簇索引，然后将 id=1 对应的聚簇索引项加 X 锁。</p><p>为什么聚簇索引上的记录也要加锁呢？</p><p>比如，并发的一条 SQL，是通过主键索引来更新：update t16 set b=10 where id =1; 如果 SQL2 没有将主键索引上的记录加锁，那么并发的 update 并不知道 SQL2 在执行，所以如果 update 执行了，就违背了同一记录上的更新或者删除需要串行执行的约束。</p><p>总结：<strong>如果查询的条件是唯一索引，那么 SQL 需要在满足条件的唯一索引上加锁，并且会在对应的聚簇索引上加锁。</strong></p><h3 id="通过非唯一索引查询"><a href="#通过非唯一索引查询" class="headerlink" title="通过非唯一索引查询"></a>通过非唯一索引查询</h3><p>我们再来看一下条件字段有非唯一索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; select * from t16 where c=3 for update; … 2 rows in set (0.00 sec)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t16 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left">use muke; select * from t16 where a=2 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select * from t16 where a=3 for update; <strong>(等待)</strong></td><td style="text-align:left">select * from t16 where a=4 for update; <strong>(等待)</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select * from t16 where a=3 for update; … <strong>(session1 提交后，马上返回结果)</strong></td><td style="text-align:left">select * from t16 where a=4 for update; … <strong>(session1 提交后，马上返回结果)</strong></td></tr></tbody></table></div><p>我们在满足条件 c=3 的数据上加了排他锁，如上面结果，就是第 3、4 行。因此第 1、2 行的数据没被锁，而 3、4 行的数据被锁了。如下图：<br><img src="3.png" alt="图片描述">通过上图可以看到，在 a 字段的非唯一索引上，满足 c=3 的所有记录，都被加了锁。同时，对应的主键索引上的记录也都加上了锁。与通过唯一索引查询的情况相比，唯一索引查询最多有一行记录被锁，而非唯一索引将会把满足条件的所有记录都加上锁。</p><p>总结：<strong>如果查询的条件是非唯一索引，那么 SQL 需要在满足条件的非唯一索引上都加上锁，并且会在它们对应的聚簇索引上加锁。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们聊了一下 InnoDB 行锁，这是 InnoDB 替代 MyISAM（只支持表锁）的一个比较重要的原因。</p><p>在文稿的开始，跟大家讲解了两阶段锁、行锁模式、行锁算法以及事务隔离级别等。</p><p>我们做了 RC 隔离级别下不同场景的行锁实验，比较重要的一点是：在更新数据时，如果条件字段没索引，则表中所有记录都会被加上 X 锁。所以在工作中应该尽可能的让查询走索引。</p><blockquote><p>参考资料</p><p>何登成的 github：<a href="https://github.com/hedengcheng/tech/tree/master/database/MySQL。" target="_blank" rel="noopener">https://github.com/hedengcheng/tech/tree/master/database/MySQL。</a></p><p>《深入浅出 MySQL》（第 2 版）：20.3.4 InnoDB 行锁实现方式。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql锁机制-全局锁与表锁</title>
      <link href="/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E5%85%A8%E5%B1%80%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81/"/>
      <url>/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E5%85%A8%E5%B1%80%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>mysql有两大类内存一块是索引，主要是提高检索查询能力，另一大块就是锁，MySQL 中，锁就是协调多个用户或者客户端并发访问某一资源的机制，保证数据并发访问时的一致性和有效性。</p><p>本章就来介绍一下不同场景下的锁机制。</p><p>根据加锁的范围，MySQL 中的锁可分为三类：</p><ul><li>全局锁</li><li>表级锁</li><li>行锁</li></ul><p>本节来重点讲解一下全局锁和表锁。</p><h2 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1 全局锁"></a><strong>1 全局锁</strong></h2><p>MySQL 全局锁会关闭所有打开的表，并使用全局读锁锁定所有表。其命令为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">TABLES</span> <span class="keyword">WITH</span> <span class="keyword">READ</span> <span class="keyword">LOCK</span>;</span><br></pre></td></tr></table></figure><p>简称：FTWRL，可以使用下面命令解锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure><p>我们来通过实验理解一下全局锁：</p><p>首先创建测试表，并写入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t14;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t14`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t14(a,b) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>进行 FTWRL 实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">FLUSH TABLES WITH READ LOCK; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select * from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td><td style="text-align:left">select * from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td></tr><tr><td style="text-align:left">insert into t14(a,b) values(2,2); ERROR 1223 (HY000): Can’t execute the query because you have a conflicting read lock <strong>（报错）</strong></td><td style="text-align:left">insert into t14(a,b) values(2,2);/*sql1*/ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">UNLOCK TABLES;</td><td style="text-align:left">insert into t14(a,b) values(2,2);/* sql1 */ Query OK, 1 row affected (5.73 sec) <strong>（session1 解锁后，在等待的 sql1 马上执行成功）</strong></td></tr></tbody></table></div><p>上面的实验中，当 session1 执行 FTWRL 后，本线程 session1 和其它线程 session2 都可以查询，本线程和其它线程都不能更新。</p><p>原因是：<strong>当执行 FTWRL 后，所有的表都变成只读状态，数据更新或者字段更新将会被阻塞。</strong></p><p>那么全局锁一般什么时候会用到呢？</p><p>全局锁一般用在整个库（包含非事务引擎表）做备份（mysqldump 或者 xtrabackup）时。也就是说，在整个备份过程中，整个库都是只读的，其实这样风险挺大的。如果是在主库备份，会导致业务不能修改数据；而如果是在从库备份，就会导致主从延迟。</p><p>好在 mysqldump 包含一个参数 —single-transaction，可以在一个事务中创建一致性快照，然后进行所有表的备份。因此增加这个参数的情况下，备份期间可以进行数据修改。但是需要所有表都是事务引擎表。所以这也是建议使用 InnoDB 存储引擎的原因之一。</p><p>而对于 xtrabackup，可以分开备份 InnoDB 和 MyISAM，或者不执行 —master-data，可以避免使用全局锁。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁有两种：表锁和元数据锁。</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表锁使用场景：</p><ol><li>事务需要更新某张大表的大部分或全部数据。如果使用默认的行锁，不仅事务执行效率低，而且可能造成其它事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高事务执行速度；</li><li>事务涉及多个表，比较复杂，可能会引起死锁，导致大量事务回滚，可以考虑表锁避免死锁。</li></ol><p>其中表锁又分为表读锁和表写锁，命令分别是：</p><p>表读锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> t14 <span class="keyword">read</span>;</span><br></pre></td></tr></table></figure><p>表写锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> t14  write;</span><br></pre></td></tr></table></figure><p>下面我们分别用实验验证表读锁和表写锁。</p><p>表读锁实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">lock tables t14 read; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select id,a,b from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td></tr><tr><td style="text-align:left">insert into t14(a,b) values(3,3); ERROR 1099 (HY000): Table ‘t14’ was locked with a READ lock and can’t be updated <strong>（报错）</strong></td><td style="text-align:left">insert into t14(a,b) values(3,3);/* sql2 */ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left">insert into t14(a,b) values(3,3);/* sql2 */ Query OK, 1 row affected (10.97 sec) <strong>（session1 解锁后，sql2 立马写入成功）</strong></td></tr></tbody></table></div><p>从上面的实验我们可以看出，在 session1 中对表 t14 加表读锁，session1 和 session2 都可以查询表 t14 的数据；而 session1 执行更新会报错，session2 执行更新会等待（直到 session1 解锁后才更新成功）。</p><p>总结：<strong>对表执行 lock tables xxx read （表读锁）时，本线程和其它线程可以读，本线程写会报错，其它线程写会等待。</strong></p><p>我们再来看一下表写锁实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">lock tables t14 write; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select id,a,b from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/* sql3 */ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; Query OK, 0 rows affected (0.01 sec)</td><td style="text-align:left">select id,a,b from t14 limit 1;/* sql3 */ … 1 row in set (7.16 sec) <strong>（session1 解锁后，sql3 马上返回查询结果）</strong></td></tr><tr><td style="text-align:left">lock tables t14 write; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">delete from t14 limit 1; Query OK, 1 row affected, 1 warning (0.00 sec) <strong>（能正常执行删除语句）</strong></td><td style="text-align:left">delete from t14 limit 1;/<em> sql4 </em>/ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left">delete from t14 limit 1;/* sql4 */ Query OK, 1 row affected, 1 warning (14.94 sec) <strong>（session1 解锁后，sql4 立马执行成功）</strong></td></tr></tbody></table></div><p>总结：<strong>对表执行 lock tables xxx write （表写锁）时，本线程可以读写，其它线程读写都会阻塞。</strong></p><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>在 MySQL 中，DDL 是不属于事务范畴的。如果事务和 DDL 并行执行同一张表时，可能会出现事务特性被破坏、binlog 顺序错乱等 bug（比如 <a href="https://bugs.mysql.com/bug.php?id=989" target="_blank" rel="noopener">bug#989</a>）。为了解决这类问题，从 MySQL 5.5.3 开始，引入了元数据锁（Metadata Locking，简称：MDL 锁）（这段内容参考《淘宝数据库内核月报》<a href="http://mysql.taobao.org/monthly/2015/11/04/" target="_blank" rel="noopener">MySQL · 特性分析 · MDL 实现分析</a>）。</p><p>从上面我们知道，MDL 锁的出现解决了同一张表上事务和 DDL 并行执行时可能导致数据不一致的问题。</p><p>但是，我们在工作中，很多情况需要考虑 MDL 的存在，否则可能导致长时间锁等待甚至连接被打满的情况。如下例：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">select id,a,b,sleep(100) from t14 limit 1;/<em> sql5 </em>/</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">alter table t14 add column c int;/* sql6 */ <strong>（等待）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/* sql7 */ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">select id,a,b,sleep(100) from t14 limit 1;/* sql5 */ … 1 row in set (1 min 40.00 sec) <strong>（100秒后 sql5 返回结果）</strong></td><td style="text-align:left">alter table t14 add column c int;/* sql6 */ Query OK, 0 rows affected (1 min 33.98 sec) Records: 0 Duplicates: 0 Warnings: 0 <strong>（session1 的查询语句执行完成后，sql6 立马执行完毕）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/* sql7 */ … 1 row in set (1 min 26.65 sec) <strong>（session1 的查询语句执行完成后，sql7 立马执行完毕）</strong></td></tr></tbody></table></div><p>上面的实验中，我们在 session1 查询了表 t14 的数据，其中使用了 sleep(100) ，表示在 100 秒后才会返回结果；然后在 session2 执行 DDL 操作时会等待（原因是 session1 执行期间会对表 t14 加一个 MDL，而 session2 又会跟 session1 争抢 MDL）；而 session3 执行查询时也会继续等待。因此如果 session1 的语句一直没结束，其它所有的查询都会等待。这种情况下，如果这张表查询比较频繁，很可能短时间把数据库的连接数打满，导致新的连接无法建立而报错，如果是正式业务，影响是非常恐怖的。</p><p>当然如果出现这种情况，假如你还有 session 连着数据库，可以 kill 掉 session1 中的语句或者终止 session2 中的 DDL 操作，可以让业务恢复。但是出现这种情况的根源其实是：session1 中有长时间未提交的事务。<strong>因此对于开发来说，在工作中应该尽量避免慢查询、尽量保证事务及时提交、避免大事务等，当然对于 DBA 来说，也应该尽量避免在业务高峰执行 DDL 操作。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了全局锁和表锁。</p><p>其中<strong>全局锁会让所有的表变成只读状态，所有更新操作都会被阻塞。</strong></p><p>而表级锁分为表锁和元数据锁。</p><p>表锁又提到了表读锁和表写锁，并都进行了实验。两者的区别是：</p><p><strong>表读锁：本线程和其它线程可以读，本线程写会报错，其它线程写会等待。</strong></p><p><strong>表写锁：本线程可以读写，其它线程读写都会阻塞。</strong></p><p>为了保证事务和 DDl 并行执行数据一致，在 MySQL 5.5.3 引入了 MDL 锁。通过本节讲解的 MDL 锁机制，应该注意的几个点是：</p><ul><li>尽量避免慢查询</li><li>事务要及时提交</li><li>避免大事务</li><li>避免在业务高峰执行 DDL 操作</li></ul><blockquote><p>参考资料</p><p>《深入浅出 MySQL》第二版：20.3.8 什么时候使用表锁</p><p>《MySQL 5.7 参考手册》：<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables-with-read-lock" target="_blank" rel="noopener">13.7.6.3 FLUSH Syntax</a></p><p>《淘宝数据库内核月报》：<a href="http://mysql.taobao.org/monthly/2015/11/04/" target="_blank" rel="noopener">MySQL · 特性分析 · MDL 实现分析</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解红黑树性质与实现</title>
      <link href="/2022/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-16-%E8%AF%A6%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%A7%E8%B4%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-16-%E8%AF%A6%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%A7%E8%B4%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文将从2-3树与红黑树的联系入手，详细解释红黑树的性质与代码实现，让各位清楚红黑树为何如此定义以及性质是如何推导出来的。本文需要前章2-3树的知识</p><p>[红黑树等价树2-3树]: <a href="http://www.icanfly.tech/2022/07/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AD%89%E4%BB%B7%E6%A0%912-3%E6%A0%91/" target="_blank" rel="noopener">http://www.icanfly.tech/2022/07/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AD%89%E4%BB%B7%E6%A0%912-3%E6%A0%91/</a></p></blockquote><h3 id="初见红黑树"><a href="#初见红黑树" class="headerlink" title="初见红黑树"></a>初见红黑树</h3><p>引用&lt;&lt;算法导论&gt;&gt;一书，原文如下:</p><p>A red-black tree is a binary tree that satisfies the following red-black properties:</p><ol><li><strong>Every node is either red or black.</strong></li><li><strong>The root is black.</strong></li><li><strong>Every leaf (NIL) is black.</strong></li><li><strong>If a node is red, then both its children are black.</strong></li><li><strong>For each node, all simple paths from the node to descendant leaves contain the<br>same number of black nodes.</strong></li></ol><p>红黑树的性质网上一搜一堆，包括操作也是，但关键是 这性质是怎么推得呢？为什么有这样的性质呢？我可以先记下这些性质，耐心往下看。</p><h3 id="红黑树与2-3树的联系"><a href="#红黑树与2-3树的联系" class="headerlink" title="红黑树与2-3树的联系"></a>红黑树与2-3树的联系</h3><p>让我们先回顾一下 2-3树 添加新元素时要注意的地方:<br>    <strong>或者添加进2-节点，形成一个3-节点</strong><br>    <strong>或者添加进3-节点，暂时形成一个4-节点</strong>    </p><p>我们可以看到，插入的新元素一定要先插入到叶子节点上，如果超过了3节点，再去调整，红黑树也是一颗树，它本质上上实在模仿2-3树，因为2-3这种插入及调整能保证绝对的平衡，红黑树也想实现这种类似的平衡，我们假设红黑树插入的元素，每次也是要插入到一个元素身上，再去考虑调整。</p><p>​    我们将2-3树与红黑树做一下类比:</p><p>​    <img src="1.png" alt=""></p><p>​    我们观察此图，当在2-3树中插入第一个元素时，对应红黑树，也是插入一个元素，此元素默认颜色为黑色。当我们插入第二个元素时，我们说2-3树中，每插入一个元素，都是要插在一个元素身上的，对应红黑树，红黑树也想表达这种3节点的，但红黑树是用在内存的结构，也是基于BST的，一个节点只能有一个元素，那它怎么办，它只能拆分，并且这个地方定义，小的元素在下，拆在我的左孩子(这是定义，你要是不喜欢，可以定义一个红黑树2，让大的元素在小元素的右孩子身上)拆分之后，为了能表示 他们是处于在2-3树中同一个3节点的身份，可以让树枝是红色的来特殊标识一下，表示此节点与父亲节共同组成3节点，但实际上我们写过BST代码就知道了，其实树枝在代码里面就是那个next指针代替了，是没有具体实现类的，所以从实现的角度讲，从节点标识更容易实现，所以我们不妨将小元素节点来标识成红色，至此，一个简单的对应关系就出来了，我们看一下完整的一棵树</p><p><img src="2.png" alt=""></p><p>看完上图，是不是有一恍然大悟的感觉？我们再回过头来，看一下算法导论中提到的性质 ：</p><pre><code>1. 每个节点要么黑，要么红，显然，对应2-3树中的2节点以及3节点中的右面那个元素是黑，3节点中小的那个是红的。1. 跟元素是黑的，这个也简单，因为红元素的节点一定是有一个黑色节点的父亲，那根节点自然是父亲了。1. 叶节点是黑的，这个地方是定义的关系，它把null定义为叶节点，这个不影响理解。1. 如果一个节点是红色，则它的两个孩子是黑的。so easy，因为在2-3树中，一个3节点的孩子要么是2节点（一个元素，黑色代表）要么是3节点（父亲是黑，左孩子是红）。1. 其实说的是，从根节点到任意一个叶节点(我们还是习惯的将最后一个非空节点视为叶节点 )路径上黑色节点的个数是固定的。我们对比2-3树就知道了，把红黑树看成一颗假象的2-3树，2-3树绝对平衡的，层数是固定的，而黑色节点恰巧代表了层数，所以这个路径上黑色节点树固定也不难理解哦。</code></pre><h3 id="插入调整"><a href="#插入调整" class="headerlink" title="插入调整"></a>插入调整</h3><p>接下来我们考虑如何进行调整?，首先我们知道，插入的一个新元素，一定要先附着于一个叶子节点元素上，然后再去调整，因为相当于每个元素都要经过调整，我们可以先假设插入的新元素都是红色的节点，去调整。类似AVL的旋转操作，我们看一下红黑树的基本旋转操作，这些操作是红黑树的数据结构的基本操作。</p><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li><p>左旋转</p><p>左旋转要做的事情如下 ：</p></li></ul><p>​            <img src="3.png" alt="">    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node.right = x.left</span><br><span class="line">x.left = node</span><br><span class="line">x.color = node.color</span><br><span class="line">node.color = RED</span><br></pre></td></tr></table></figure><p><img src="4.png" alt=""></p><p>了解过AVL旋转实现的话，这个代码就很简单了。    </p><ul><li>颜色翻转</li></ul><p>左旋转实际是插入到一个2节点身上，下面我们重点看插入到3节点身上的形态及调整。</p><p>​    <img src="5.png" alt=""></p><p>在42、37插入完成之后，我们又插入了66，对应如图，插入的元素因为要和叶节点绑定，所以默认插入为红色。红色代表与父亲元素是同一个节点，但此时在2-3树中是一个临时的4节点的状态，2-3树中要分裂调整如图示的结构，同理红黑树，我们也对应的表示成2-3树分裂后的结构即可,也就是3个2节点。</p><p><img src="6.png" alt=""></p><p>但要注意一点，虽然都是2节点，但是分裂出来之后父亲是划到上层去了，也是一个结合的节点，所以要标识为红色。红色就代表要调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node.color = RED</span><br><span class="line">node.left.color = BLACK</span><br><span class="line">node.right.color = BLACK</span><br></pre></td></tr></table></figure><ul><li>右旋转</li></ul><p>右旋转也是插入到3节点中出现某种状态时需要调整的操作.</p><p>假设在插入42、37之后再插入一个12元素，显然这是一种临时的4节点状态，需要调整，目标是如图中的3节点状态，我们可先做一个右旋转操作（AVL中常规操作）</p><p><img src="7.png" alt=""></p><p>此时只是简单的右旋，还没到目标结构，但是注意看，这不正是颜色翻转要调整的状态吗？所以此时再调一次颜色翻转的操作即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node.left = x.right</span><br><span class="line">x.right = node</span><br><span class="line">x.color = node.color</span><br><span class="line">node.color = RED</span><br></pre></td></tr></table></figure><h4 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h4><p>我们取一种最麻烦的状态做示例，来回顾整个调整过程，假设向一个3节点中插入一个中间大小的元素</p><p><img src="8.png" alt=""></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            color = RED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点node的颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> BLACK;</span><br><span class="line">        <span class="keyword">return</span> node.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node x = node.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左旋转</span></span><br><span class="line">        node.right = x.left;</span><br><span class="line">        x.left = node;</span><br><span class="line"></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node x = node.left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右旋转</span></span><br><span class="line">        node.left = x.right;</span><br><span class="line">        x.right = node;</span><br><span class="line"></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 颜色翻转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        node.color = RED;</span><br><span class="line">        node.left.color = BLACK;</span><br><span class="line">        node.right.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向红黑树中添加新的元素(key, value)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">        root = add(root, key, value);</span><br><span class="line">        root.color = BLACK; <span class="comment">// 最终根节点为黑色节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向以node为根的红黑树中插入元素(key, value)，递归算法</span></span><br><span class="line">    <span class="comment">// 返回插入新节点后红黑树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            size ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value); <span class="comment">// 默认插入红色节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">            node.left = add(node.left, key, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span>)</span><br><span class="line">            node.right = add(node.right, key, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line">            node.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left))</span><br><span class="line">            node = leftRotate(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left))</span><br><span class="line">            node = rightRotate(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right))</span><br><span class="line">            flipColors(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根节点的二分搜索树中，key所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.equals(node.key))</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> getNode(node.left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// if(key.compareTo(node.key) &gt; 0)</span></span><br><span class="line">            <span class="keyword">return</span> getNode(node.right, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(root, key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span></span>&#123;</span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key + <span class="string">" doesn't exist!"</span>);</span><br><span class="line"></span><br><span class="line">        node.value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉以node为根的二分搜索树中的最小节点</span></span><br><span class="line">    <span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size --;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.left = removeMin(node.left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除键为key的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = remove(root, key);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">            node.left = remove(node.left , key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            node.right = remove(node.right, key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;   <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Node rightNode = node.right;</span><br><span class="line">                node.right = <span class="keyword">null</span>;</span><br><span class="line">                size --;</span><br><span class="line">                <span class="keyword">return</span> rightNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Node leftNode = node.left;</span><br><span class="line">                node.left = <span class="keyword">null</span>;</span><br><span class="line">                size --;</span><br><span class="line">                <span class="keyword">return</span> leftNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">            <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">            Node successor = minimum(node.right);</span><br><span class="line">            successor.right = removeMin(node.right);</span><br><span class="line">            successor.left = node.left;</span><br><span class="line"></span><br><span class="line">            node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树性质解释"><a href="#红黑树性质解释" class="headerlink" title="红黑树性质解释"></a>红黑树性质解释</h3><p> 前面已经解释性质来，这就不重复了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    我们通过插入操作讲解了红黑树的调整及性质的推导，删除操作其实也是在BST操作之上添加调整，可能要更复杂一些但大致原理类似，调整的基础操作也是上面讲到的，相信仔细读完本篇之后对红黑树有一定的感觉了，接下来我们将红黑树、BST、AVL综合对比一下：</p><ol><li>对于完全随机的数据，普通的二分搜索树很好用! 缺点:极端情况退化成链表(或者高度不平衡)</li><li>对于查询较多的使用情况，AVL树很好用!</li><li>红黑树牺牲了平衡性(21ogn的高度) 但是 统计性能更优(综合增删改查所有的操作)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 - 经典数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的回退操作</title>
      <link href="/2022/07/15/git-2022-07-14-git%E7%9A%84%E5%9B%9E%E9%80%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/07/15/git-2022-07-14-git%E7%9A%84%E5%9B%9E%E9%80%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="查看提交的log日志"><a href="#查看提交的log日志" class="headerlink" title="查看提交的log日志"></a>查看提交的log日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><h3 id="回退提交点"><a href="#回退提交点" class="headerlink" title="回退提交点"></a>回退提交点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commidId</span><br></pre></td></tr></table></figure><h3 id="显示所有提交点"><a href="#显示所有提交点" class="headerlink" title="显示所有提交点"></a>显示所有提交点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><blockquote><p>有时候回退回去，还想回退回来，这时候 git log 就已经删除了所有commit id了，只能用这个命令，这个日志 包括所有的 分之合并等提交点都会显示，但是注意，只是显示本地进行的操作，如果从git拉取下来后，不是在本地进行的提交，直接回退后，可能 git reflog 也不显示提交点，这时候直接用 git pull 拉取下来就行了，然后到你指定的位移.</p></blockquote><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自建项目上传github常用操作</title>
      <link href="/2022/07/15/git-2022-07-14-%E8%87%AA%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0github%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/07/15/git-2022-07-14-%E8%87%AA%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0github%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>在idea 初始化本地项目后</strong></p><ol><li><p>在github创建仓库</p></li><li><p>添加git远程仓库绑定:git remote add origin <a href="https://github.com/zzzzxd/xxxx" target="_blank" rel="noopener">https://github.com/zzzzxd/xxxx</a> 当前没有追踪远程分支,拉取时候绑定远程分支:git pull origin master </p></li></ol><p><strong>常见的其他操作</strong></p><ul><li><ul><li>删除项目当前分支对远程分支的关联</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></li><li><ul><li>项目以http方式重新关联</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin http://gitlab.xxxxxxxx.cn:xxxx/xxxxxx/mall.git</span><br></pre></td></tr></table></figure><ul><li><ul><li>项目中本地分支和远程分支关联</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull git branch --set-upstream-to=origin/de</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase 数据倾斜原因及解决方案</title>
      <link href="/2022/07/15/hbase-2022-07-15-Hbase-%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/07/15/hbase-2022-07-15-Hbase-%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近公司在做ip维度表，数据量比较大，上亿条数据了，拿hbase存储，进行实时关联。发现ip存到region上倾斜的比较严重，考虑到基数比较大，后期增量相对比较少，可以做一个预分区，使数据分布均衡，借此机会，从网上搜集了一下资料，总结一下常见的解决方案。</p></blockquote><h3 id="热点与数据倾斜"><a href="#热点与数据倾斜" class="headerlink" title="热点与数据倾斜"></a><strong>热点与数据倾斜</strong></h3><p><strong>热点：</strong></p><p>​    热点发生在大量的client直接访问集群的一个或极少数个节点（访问可能是读，写或者其他操作。</p><p>​    大量访问会使热点region所在的单个机器超出自身承受能力，引起性能下降甚至region不可用，这也会影响同一个RegionServer上的其他region，由于主机无法服务其他region的请求，造成资源浪费。设计良好的数据访问模式以使集群被充分，均衡的利用。</p><p><strong>数据倾斜：         </strong></p><p>​    Hbase可以被划分为多个Region，但是默认创建时只有一个Region分布在集群的一个节点上，数据一开始时都集中在这个Region，也就是集中在这一个节点上，就算region存储达到临界值时被划分，数据也是存储在少数节点上。这就是数据倾斜。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ul><li>HBase中的行是按照rowkey的字典顺序排序的，这种设计优化了scan操作，可以将相关的行以及会被一起读取的行存取在临近位置，便于scan。</li><li><strong>rowkey设计是热点的源头</strong>。</li><li><p>HBase中，表会被划分为1…n个Region，被托管在RegionServer中。Region有二个重要的属性: StartKey与EndKey</p><p>表示这个Region维护的rowKey范围，当我们要读/写数据时，如果rowKey落在某个start-end key范围内，那么就会定位到目标        region并且读/写到相关的数据。</p></li><li><p>默认的情况下，创建一张表是，只有1个region，</p><pre><code>  start-end key没有边界，所有数据都在这个region里装，然而，当数据越来越多，region的size越来越大时，大到一定的阀值，hbase认为再往这个region里塞数据已经不合适了，就会找到一个midKey将region一分为二，成为2个region,这个过程称为分裂(region-split)。而midKey则为这二个region的临界（这个中间值这里不作讨论是如何被选取的）。 此时，我们假设假设rowkey小于midKey则为阴被塞到1区，大于等于midKey则会被塞到2区，如果 rowkey还是顺序增大的，那数据就总会往2区里面写数据，而1区现在处于一个被冷落的状态，而且是半满的。2区的数据满了 会被再次分裂成2个区，如此不断产生被冷落而且不满的Region，当然，这些region有提供数据查询的功能。</code></pre><p>这种设计是分布式系统一个很大的弊端，而且这样导致数据倾斜和热点问题，从而导致集群的资源得不到很好的利用。</p></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="预分区"><a href="#预分区" class="headerlink" title="预分区"></a><strong>预分区</strong></h4><h5 id="预分区的必要性"><a href="#预分区的必要性" class="headerlink" title="预分区的必要性"></a><strong>预分区的必要性</strong></h5><p>HBase默认建表时有一个region，这个region的rowkey是没有边界的，即没有startkey和endkey，在数据写入时，所有数据都会写入这个默认的region，当一个region中数据超过阈值时（默认10G），此region已经不能承受不断增长的数据量，会进行split，分成2个region。在此过程中，会产生两个问题：</p><ul><li><ul><li><ol><li>我们的数据会不断的往一个region上写,会有写热点问题。</li></ol></li><li><ol><li>region split会消耗宝贵的集群I/O资源。如果在任务执行时region分裂，会导致任务失败</li></ol></li></ul></li></ul><p>基于此我们可以控制在建表的时候，创建多个空region，并确定每个region的起始和终止rowky，这样只要我们的rowkey设计能均匀的命中各个region，就不会存在写热点问题。自然split的几率也会大大降低。当然随着数据量的不断增长，该split的还是要进行split。像这样预先创建hbase表分区的方式，称之为预分区</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h5><p>首先看没有预分区的：</p><p>一个region里面就保存了7000w（虽然7000w对hbase来说是小case）的数据，读写压力全在这一个region上，会很容易造成热点问题</p><p>​    <img src="1.png" alt="0"></p><h5 id="使用Hbase-shell进行预分区"><a href="#使用Hbase-shell进行预分区" class="headerlink" title="使用Hbase shell进行预分区"></a><strong>使用Hbase shell进行预分区</strong></h5><p>前面说到了rowkey的排列是根据字典排序，所以rowkey寻址的时候是和startkey、endkey进行比较，在字典排序在哪个region的startkey、endkey之间，就落在哪个region</p><p>​                create ‘t1’,’f1’,SPLITS =&gt; [‘10’,’20’,’30’]              </p><p>​    <img src="2.png" alt="0"></p><p>四个分区，rowkey如果是‘0232534’，就落在第一个分区，‘13003424’落在第二个分区</p><p>​                 hbase&gt;create ‘t14’,’f’,SPLITS_FILE=&gt;’splits.txt’              </p><p>​    <img src="3.png" alt="0"></p><p>​    <img src="4.png" alt="0"></p><h4 id="rowkey设计避免热点"><a href="#rowkey设计避免热点" class="headerlink" title="rowkey设计避免热点"></a><strong>rowkey设计避免热点</strong></h4><h5 id="常用手段"><a href="#常用手段" class="headerlink" title="常用手段"></a><strong>常用手段</strong></h5><ul><li>⽣成随机数、hash、散列值</li></ul><p>​                ⽐如: 原本rowKey为1001的，SHA1后变成：dd01903921ea24941c26a48f2cec24e0bb0e8cc7       原本rowKey为3001的，SHA1后变成：49042c54de64a1e9bf0b33e00245660ef92dc7bd      原本rowKey为5001的，SHA1后变成：7b61dec07e02c188790670af43e717f0f46e8913      在做此操作之前，⼀般我们会选择从数据集中抽取样本，来决定什么样的rowKey来Hash后作为每个分区的临 界值。              </p><ul><li>字符串反转</li></ul><p>​                以手机号为rowkey，可以将手机号反转后的字符串作为rowkey，这样的就避免了以手机号那样比较固定开头导致热点问题    例如：20191124000001转成10000042119102           20191124000002转成20000042119102              </p><ul><li>加盐</li></ul><p>​                这里所说的加盐不是密码学中的加盐，而是在rowkey的前面增加随机数，具体就是给rowkey分配一个随机前缀以使得它和之前的rowkey的开头不同。 分配的前缀种类数量应该和你想使用数据分散到不同的region的数量一致。 加盐之后的rowkey就会根据随机生成的前缀分散到各个region上，以避免热点              </p><p>还有其他方案、具体情况具体分析。</p>]]></content>
      
      
      <categories>
          
          <category> Hbase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式AKF拆分原则</title>
      <link href="/2022/07/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-07-15-%E5%88%86%E5%B8%83%E5%BC%8FAKF%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99/"/>
      <url>/2022/07/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-07-15-%E5%88%86%E5%B8%83%E5%BC%8FAKF%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载 :<a href="https://blog.csdn.net/tomcosin/article/details/119332084" target="_blank" rel="noopener">https://blog.csdn.net/tomcosin/article/details/119332084</a></p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    当我们需要分布式系统提供更强的性能时，该怎样扩展系统呢？什么时候该加机器？什么时候该重构代码？扩容时，究竟该选择哈希算法还是最小连接数算法，才能有效提升性能？</p><p>在面对 Scalability 可伸缩性问题时，我们必须有一个系统的方法论，才能应对日益复杂的分布式系统。这一讲我将介绍 AKF 立方体理论，它定义了扩展系统的 3 个维度，我们可以综合使用它们来优化性能。</p><h3 id="什么是AKF"><a href="#什么是AKF" class="headerlink" title="什么是AKF"></a>什么是AKF</h3><p>AKF 立方体也叫做scala cube，它在《The Art of Scalability》一书中被首次提出，旨在提供一个系统化的扩展思路。AKF 把系统扩展分为以下三个维度：</p><ul><li>X 轴：直接水平复制应用进程来扩展系统。</li><li>Y 轴：将功能拆分出来扩展系统。</li><li>Z 轴：基于用户信息扩展系统。</li></ul><p>如下图所示：</p><p>​    <img src="1.png" alt="0"></p><h3 id="如何基于-AKF-X-轴扩展系统？"><a href="#如何基于-AKF-X-轴扩展系统？" class="headerlink" title="如何基于 AKF X 轴扩展系统？"></a><strong>如何基于 AKF X 轴扩展系统？</strong></h3><p>我们日常见到的各种系统扩展方案，都可以归结到 AKF 立方体的这三个维度上。而且，我们可以同时组合这 3 个方向上的扩展动作，使得系统可以近乎无限地提升性能。为了避免对 AKF 的介绍过于抽象，下面我用一个实际的例子，带你看看这 3 个方向的扩展到底该如何应用。</p><p>假定我们开发一个博客平台，用户可以申请自己的博客帐号，并在其上发布文章。最初的系统考虑了 MVC 架构，将数据状态及关系模型交给数据库实现，应用进程通过 SQL 语言操作数据模型，经由 HTTP 协议对浏览器客户端提供服务，如下图所示：</p><p>​    <img src="2.png" alt="0"></p><p>在这个架构中，处理业务的应用进程属于无状态服务，用户数据全部放在了关系数据库中。因此，当我们在应用进程前加 1 个负载均衡服务后，就可以通过部署更多的应用进程，提供更大的吞吐量。而且，初期增加应用进程，RPS 可以获得线性增长，很实用，如下图：</p><p>​    <img src="3.png" alt="0"></p><p>这就叫做沿 AKF X 轴扩展系统。这种扩展方式最大的优点，就是开发成本近乎为零，而且实施起来速度快！在搭建好负载均衡后，只需要在新的物理机、虚拟机或者微服务上复制程序，就可以让新进程分担请求流量，而且不会影响事务 Transaction 的处理。</p><p>当然，AKF X 轴扩展最大的问题是只能扩展无状态服务，当有状态的数据库出现性能瓶颈时，X 轴是无能为力的。例如，当用户数据量持续增长，关系数据库中的表就会达到百万、千万行数据，SQL 语句会越来越慢，这时可以沿着 AKF Z 轴去分库分表提升性能。又比如，当请求用户频率越来越高，那么可以把单实例数据库扩展为主备多实例，沿 Y 轴把读写功能分离提升性能。下面我们先来看 AKF Y 轴如何扩展系统。</p><h3 id="如何基于-AKF-Y-轴扩展系统？"><a href="#如何基于-AKF-Y-轴扩展系统？" class="headerlink" title="如何基于 AKF Y 轴扩展系统？"></a><strong>如何基于 AKF Y 轴扩展系统？</strong></h3><p>当数据库的 CPU、网络带宽、内存、磁盘 IO 等某个指标率先达到上限后，系统的吞吐量就达到了瓶颈，此时沿着 AKF X 轴扩展系统，是没有办法提升性能的。</p><p>在现代经济中，更细分、更专业的产业化、供应链分工，可以给社会带来更高的效率，而 AKF Y 轴与之相似，当遇到上述性能瓶颈后，拆分系统功能，使得各组件的职责、分工更细，也可以提升系统的效率。比如，当我们将应用进程对数据库的读写操作拆分后，就可以扩展单机数据库为主备分布式系统，使得主库支持读写两种 SQL，而备库只支持读 SQL。这样，主库可以轻松地支持事务操作，且它将数据同步到备库中也并不复杂，如下图所示：</p><p>​    <img src="4.png" alt="0"></p><p>当然，上图中如果读性能达到了瓶颈，我们可以继续沿着 AKF X 轴，用复制的方式扩展多个备库，提升读 SQL 的性能，可见，AKF 多个轴完全可以搭配着协同使用。</p><p>拆分功能是需要重构代码的，它的实施成本比沿 X 轴简单复制扩展要高得多。在上图中，通常关系数据库的客户端 SDK 已经支持读写分离，所以实施成本由中间件承担了，这对我们理解 Y 轴的实施代价意义不大，所以我们再来看从业务上拆分功能的例子。</p><p>当这个博客平台访问量越来越大时，一台主库是无法扛住所有写流量的。因此，基于业务特性拆分功能，就是必须要做的工作。比如，把用户的个人信息、身份验证等功能拆分出一个子系统，再把文章、留言发布等功能拆分到另一个子系统，由无状态的业务层代码分开调用，并通过事务组合在一起，如下图所示：</p><p>​    <img src="5.png" alt="0"></p><p>这样，每个后端的子应用更加聚焦于细分的功能，它的数据库规模会变小，也更容易优化性能。比如，针对用户登录功能，你可以再次基于 Y 轴将身份验证功能拆分，用 Redis 等服务搭建一个基于 LRU 算法淘汰的缓存系统，快速验证用户身份。</p><p>然而，沿 Y 轴做功能拆分，实施成本非常高，需要重构代码并做大量测试工作，上线部署也很复杂。比如上例中要对数据模型做拆分（如同一个库中的表拆分到多个库中，或者表中的字段拆到多张表中），设计组件之间的 API 交互协议，重构无状态应用进程中的代码，为了完成升级还要做数据迁移，等等。</p><p>解决数据增长引发的性能下降问题，除了成本较高的 AKF Y 轴扩展方式外，沿 Z 轴扩展系统也很有效，它的实施成本更低一些，下面我们具体看一下。</p><p><strong>如何基于 AKF Z 轴扩展系统？</strong></p><p>不同于站在服务角度扩展系统的 X 轴和 Y 轴，AKF Z 轴则从用户维度拆分系统，它不仅可以提升数据持续增长降低的性能，还能基于用户的地理位置获得额外收益。</p><p>仍然以上面虚拟的博客平台为例，当注册用户数量上亿后，无论你如何基于 Y 轴的功能去拆分表（即“垂直”地拆分表中的字段），都无法使得关系数据库单个表的行数在千万级以下，这样表字段的 B 树索引非常庞大，难以完全放在内存中，最后大量的磁盘 IO 操作会拖慢 SQL 语句的执行。</p><p>这个时候，关系数据库最常用的分库分表操作就登场了，它正是 AKF 沿 Z 轴拆分系统的实践。比如已经含有上亿行数据的 User 用户信息表，可以分成 10 个库，每个库再分成 10 张表，利用固定的哈希函数，就可以把每个用户的数据映射到某个库的某张表中。这样，单张表的数据量就可以降低到 1 百万行左右，如果每个库部署在不同的服务器上（具体的部署方式视访问吞吐量以及服务器的配置而定），它们处理的数据量减少了很多，却可以独占服务器的硬件资源，性能自然就有了提升。如下图所示：</p><p>​    <img src="6.png" alt="0"></p><p>分库分表是关系数据库中解决数据增长压力的最有效办法，但分库分表同时也导致跨表的查询语句复杂许多，而跨库的事务几乎难以实现，因此这种扩展的代价非常高。当然，如果你使用的是类似 MySQL 这些成熟的关系数据库，整个生态中会有厂商提供相应的中间件层，使用它们可以降低 Z 轴扩展的代价。</p><p>再比如，最开始我们采用 X 轴复制扩展的服务，它们的负载均衡策略很简单，只需要选择负载最小的上游服务器即可，比如 RoundRobin 或者最小连接算法都可以达到目的。但若上游服务器通过 Y 轴扩展，开启了缓存功能，那么考虑到缓存的命中率，就必须改用 Z 轴扩展的方式，基于用户信息做哈希规则下的新路由，尽量将同一个用户的请求命中相同的上游服务器，才能充分提高缓存命中率。</p><p>Z 轴扩展还有一个好处，就是可以充分利用 IDC 与用户间的网速差，选择更快的 IDC 为用户提供高性能服务。网络是基于光速传播的，当 IDC 跨城市、国家甚至大洲时，用户访问不同 IDC 的网速就会有很大差异。当然，同一地域内不同的网络运营商之间，也会有很大的网速差。</p><p>例如你在全球都有 IDC 或者公有云服务器时，就可以通过域名为当地用户就近提供服务，这样性能会高很多。事实上，CDN 技术就基于 IP 地址的位置信息，就近为用户提供静态资源的高速访问。</p><p>下图中，我使用了 2 种 Z 轴扩展系统的方式。首先是基于客户端的地理位置，选择不同的 IDC 就近提供服务。其次是将不同的用户分组，比如免费用户组与付费用户组，这样在业务上分离用户群体后，还可以有针对性地提供不同水准的服务。</p><p>​    <img src="7.png" alt="0"></p><p>沿 AKF Z 轴扩展系统可以解决数据增长带来的性能瓶颈，也可以基于数据的空间位置提升系统性能，然而它的实施成本比较高，尤其是在系统宕机、扩容时，一旦路由规则发生变化，会带来很大的数据迁移成本，[第 24 讲] 我将要介绍的一致性哈希算法，其实就是用来解决这一问题的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>这一讲我们介绍了如何基于 AKF 立方体的 X、Y、Z 三个轴扩展系统提升性能。</p><ul><li><p>X 轴扩展系统时实施成本最低，只需要将程序复制到不同的服务器上运行，再用下游的负载均衡分配流量即可。X 轴只能应用在无状态进程上，故无法解决数据增长引入的性能瓶颈。</p></li><li><p>Y 轴扩展系统时实施成本最高，通常涉及到部分代码的重构，但它通过拆分功能，使系统中的组件分工更细，因此可以解决数据增长带来的性能压力，也可以提升系统的总体效率。比如关系数据库的读写分离、表字段的垂直拆分，或者引入缓存，都属于沿 Y 轴扩展系统。</p></li><li><p>Z 轴扩展系统时实施成本也比较高，但它基于用户信息拆分数据后，可以在解决数据增长问题的同时，基于地理位置就近提供服务，进而大幅度降低请求的时延，比如常见的 CDN 就是这么提升用户体验的。但 Z 轴扩展系统后，一旦发生路由规则的变动导致数据迁移时，运维成本就会比较高。</p></li></ul><p>​    当然，X、Y、Z 轴的扩展并不是孤立的，我们可以同时应用这 3 个维度扩展系统。分布式系统非常复杂，AKF 给我们提供了一种自上而下的方法论，让我们能够针对不同场景下的性能瓶颈，以最低的成本提升性能。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解一致性哈希算法</title>
      <link href="/2022/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-2022-07-15-%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2022/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-2022-07-15-%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载:<a href="https://segmentfault.com/a/1190000021199728" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021199728</a></p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>要了解一致性哈希，首先我们必须了解传统的哈希及其在大规模分布式系统中的局限性。简单地说，哈希就是一个键值对存储，在给定键的情况下，可以非常高效地找到所关联的值。假设我们要根据其邮政编码查找城市中的街道名称。一种最简单的实现方式是将此信息以哈希字典的形式进行存储 <code>&lt;Zip Code，Street Name&gt;</code>。</p><p>当数据太大而无法存储在一个节点或机器上时，问题变得更加有趣，系统中需要多个这样的节点或机器来存储它。比如，使用多个 Web 缓存中间件的系统。<strong>那如何确定哪个 key 存储在哪个节点上？针对该问题，最简单的解决方案是使用哈希取模来确定。</strong> 给定一个 key，先对 key 进行哈希运算，将其除以系统中的节点数，然后将该 key 放入该节点。同样，在获取 key 时，对 key 进行哈希运算，再除以节点数，然后转到该节点并获取值。上述过程对应的哈希算法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_number &#x3D; hash(key) % N # 其中 N 为节点数。</span><br></pre></td></tr></table></figure><p>下图描绘了多节点系统中的传统的哈希取模算法，基于该算法可以实现简单的负载均衡。</p><p><img src="traditional-hashing.png" alt="traditional-hashing"></p><h3 id="一、传统哈希取模算法的局限性"><a href="#一、传统哈希取模算法的局限性" class="headerlink" title="一、传统哈希取模算法的局限性"></a>一、传统哈希取模算法的局限性</h3><p>下面我们来分析一下传统的哈希及其在大规模分布式系统中的局限性。这里我们直接使用我之前所写文章 <a href="https://segmentfault.com/a/1190000021136424" target="_blank" rel="noopener">布隆过滤器你值得拥有的开发利器</a> 中定义的 SimpleHash 类，然后分别对 <strong>semlinker、kakuqo 和 test</strong> 3 个键进行哈希运算并取余，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleHash &#123;</span><br><span class="line">    private int cap;</span><br><span class="line">    private int seed;</span><br><span class="line"></span><br><span class="line">    public SimpleHash(int cap, int seed) &#123;</span><br><span class="line">        this.cap &#x3D; cap;</span><br><span class="line">        this.seed &#x3D; seed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int hash(String value) &#123;</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        int len &#x3D; value.length();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            result &#x3D; seed * result + value.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return (cap - 1) &amp; result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SimpleHash simpleHash &#x3D; new SimpleHash(2 &lt;&lt; 12, 8);</span><br><span class="line">        System.out.println(&quot;node_number&#x3D;hash(\&quot;semlinker\&quot;) % 3 -&gt; &quot; + </span><br><span class="line">          simpleHash.hash(&quot;semlinker&quot;) % 3);</span><br><span class="line">        System.out.println(&quot;node_number&#x3D;hash(\&quot;kakuqo\&quot;) % 3 -&gt; &quot; + </span><br><span class="line">          simpleHash.hash(&quot;kakuqo&quot;) % 3);</span><br><span class="line">        System.out.println(&quot;node_number&#x3D;hash(\&quot;test\&quot;) % 3 -&gt; &quot; + </span><br><span class="line">          simpleHash.hash(&quot;test&quot;) % 3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码成功运行后，在控制台会输出以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node_number&#x3D;hash(&quot;semlinker&quot;) % 3 -&gt; 1</span><br><span class="line">node_number&#x3D;hash(&quot;kakuqo&quot;) % 3 -&gt; 2</span><br><span class="line">node_number&#x3D;hash(&quot;test&quot;) % 3 -&gt; 0</span><br></pre></td></tr></table></figure><p>基于以上的输出结果，我们可以创建以下表格：</p><p><img src="ch-three-nodes-hash.png" alt="ch-three-nodes-hash"></p><h4 id="1-1-节点减少的场景"><a href="#1-1-节点减少的场景" class="headerlink" title="1.1 节点减少的场景"></a>1.1 节点减少的场景</h4><p><strong>在分布式多节点系统中，出现故障很常见。任何节点都可能在没有任何事先通知的情况下挂掉，针对这种情况我们期望系统只是出现性能降低，正常的功能不会受到影响。</strong> 对于原始示例，当节点出现故障时会发生什么？原始示例中有的 3 个节点，假设其中 1 个节点出现故障，这时节点数发生了变化，节点个数从 3 减少为 2，此时表格的状态发生了变化：</p><p><img src="ch-two-nodes-hash.png" alt="ch-two-nodes-hash"></p><p>很明显节点的减少会导致键与节点的映射关系发生变化，这个变化对于新的键来说并不会产生任何影响，但对于已有的键来说，将导致节点映射错误，以 “semlinker” 为例，变化前系统有 3 个节点，该键对应的节点编号为 1，当出现故障时，节点数减少为 2 个，此时该键对应的节点编号为 0。</p><h4 id="1-2-节点增加的场景"><a href="#1-2-节点增加的场景" class="headerlink" title="1.2 节点增加的场景"></a>1.2 节点增加的场景</h4><p><strong>在分布式多节点系统中，对于某些场景比如节日大促，就需要对服务节点进行扩容，以应对突发的流量。</strong> 对于原始示例，当增加节点会发生什么？原始示例中有的 3 个节点，假设进行扩容临时增加了 1 个节点，这时节点数发生了变化，节点个数从 3 增加为 4 个，此时表格的状态发生了变化：</p><p><img src="ch-four-nodes-hash.png" alt="ch-four-nodes-hash"></p><p>很明显节点的增加也会导致键与节点的映射关系发生变化，这个变化对于新的键来说并不会产生任何影响，但对于已有的键来说，将导致节点映射错误，同样以 “semlinker” 为例，变化前系统有 3 个节点，该键对应的节点编号为 1，当增加节点时，节点数增加为 4 个，此时该键对应的节点编号为 2。</p><p>当集群中节点的数量发生变化时，之前的映射规则就可能发生变化。如果集群中每个机器提供的服务没有差别，这不会有什么影响。<strong>但对于分布式缓存这种的系统而言，映射规则失效就意味着之前缓存的失效，若同一时刻出现大量的缓存失效，则可能会出现 “缓存雪崩”，这将会造成灾难性的后果。</strong></p><p><strong>要解决此问题，我们必须在其余节点上重新分配所有现有键，这可能是非常昂贵的操作，并且可能对正在运行的系统产生不利影响。当然除了重新分配所有现有键的方案之外，还有另一种更好的方案即使用一致性哈希算法。</strong></p><h3 id="二、一致性哈希算法"><a href="#二、一致性哈希算法" class="headerlink" title="二、一致性哈希算法"></a>二、一致性哈希算法</h3><p>一致性哈希算法在 1997 年由麻省理工学院提出，是一种特殊的哈希算法，在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式<a href="https://baike.baidu.com/item/哈希表/5981869" target="_blank" rel="noopener">哈希表</a>（Distributed Hash Table，DHT）中存在的动态伸缩等问题 。</p><h4 id="2-1-一致性哈希算法优点"><a href="#2-1-一致性哈希算法优点" class="headerlink" title="2.1 一致性哈希算法优点"></a>2.1 一致性哈希算法优点</h4><ul><li><p>可扩展性。一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少，相比传统哈希算法大大节省了数据移动的开销 。</p></li><li><p>更好地适应数据的快速增长。采用一致性哈希算法分布数据，当数据不断增长时，部分虚拟节点中可能包含很多数据、造成数据在虚拟节点上分布不均衡，此时可以将包含数据多的虚拟节点分裂，这种分裂仅仅是将原有的虚拟节点一分为二、不需要对全部的数据进行重新哈希和划分。</p><p>虚拟节点分裂后，如果物理服务器的负载仍然不均衡，只需在服务器之间调整部分虚拟节点的存储分布。这样可以随数据的增长而动态的扩展物理服务器的数量，且代价远比传统哈希算法重新分布所有数据要小很多。</p></li></ul><h4 id="2-2-一致性哈希算法与哈希算法的关系"><a href="#2-2-一致性哈希算法与哈希算法的关系" class="headerlink" title="2.2 一致性哈希算法与哈希算法的关系"></a>2.2 一致性哈希算法与哈希算法的关系</h4><p>一致性哈希算法是在哈希算法基础上提出的，在动态变化的分布式环境中，哈希算法应该满足的几个条件：平衡性、单调性和分散性。</p><ul><li>平衡性：是指 hash 的结果应该平均分配到各个节点，这样从算法上解决了负载均衡问题。</li><li>单调性：是指在新增或者删减节点时，不影响系统正常运行。</li><li>分散性：是指数据应该分散地存放在分布式集群中的各个节点（节点自己可以有备份），不必每个节点都存储所有的数据。</li></ul><h3 id="三、一致性哈希算法原理"><a href="#三、一致性哈希算法原理" class="headerlink" title="三、一致性哈希算法原理"></a>三、一致性哈希算法原理</h3><p>一致性哈希算法通过一个叫作一致性哈希环的数据结构实现。这个环的起点是 0，终点是 2^32 - 1，并且起点与终点连接，故这个环的整数分布范围是 [0, 2^32-1]，如下图所示：</p><p><img src="hash-ring.png" alt="hash-ring"></p><h4 id="3-1-将对象放置到哈希环"><a href="#3-1-将对象放置到哈希环" class="headerlink" title="3.1 将对象放置到哈希环"></a>3.1 将对象放置到哈希环</h4><p>假设我们有 “semlinker”、”kakuqo”、”lolo”、”fer” 四个对象，分别简写为 o1、o2、o3 和 o4，然后使用哈希函数计算这个对象的 hash 值，值的范围是 [0, 2^32-1]：</p><p><img src="hash-ring-hash-objects.png" alt="hash-ring-hash-objects"></p><p>图中对象的映射关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash(o1) &#x3D; k1; hash(o2) &#x3D; k2;</span><br><span class="line">hash(o3) &#x3D; k3; hash(o4) &#x3D; k4;</span><br></pre></td></tr></table></figure><h4 id="3-2-将服务器放置到哈希环"><a href="#3-2-将服务器放置到哈希环" class="headerlink" title="3.2 将服务器放置到哈希环"></a>3.2 将服务器放置到哈希环</h4><p>接着使用同样的哈希函数，我们将服务器也放置到哈希环上，可以选择服务器的 IP 或主机名作为键进行哈希，这样每台服务器就能确定其在哈希环上的位置。这里假设我们有 3 台缓存服务器，分别为 cs1、cs2 和 cs3：</p><p><img src="/hash-ring-hash-servers.png" alt="hash-ring-hash-servers"></p><p>图中服务器的映射关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(cs1) &#x3D; t1; hash(cs2) &#x3D; t2; hash(cs3) &#x3D; t3; # Cache Server</span><br></pre></td></tr></table></figure><h4 id="3-3-为对象选择服务器"><a href="#3-3-为对象选择服务器" class="headerlink" title="3.3 为对象选择服务器"></a>3.3 为对象选择服务器</h4><p>将对象和服务器都放置到同一个哈希环后，在哈希环上顺时针查找距离这个对象的 hash 值最近的机器，即是这个对象所属的机器。以 o2 对象为例，顺序针找到最近的机器是 cs2，故服务器 cs2 会缓存 o2 对象。而服务器 cs1 则缓存 o1，o3 对象，服务器 cs3 则缓存 o4 对象。</p><p><img src="hash-ring-objects-servers.png" alt="hash-ring-objects-servers"></p><h4 id="3-4-服务器增加的情况"><a href="#3-4-服务器增加的情况" class="headerlink" title="3.4 服务器增加的情况"></a>3.4 服务器增加的情况</h4><p>假设由于业务需要，我们需要增加一台服务器 cs4，经过同样的 hash 运算，该服务器最终落于 t1 和 t2 服务器之间，具体如下图所示：</p><p><img src="http://cdn.semlinker.com/hash-ring-add-server.jpg" alt="hash-ring-add-server"></p><p>对于上述的情况，只有 t1 和 t2 服务器之间的对象需要重新分配。在以上示例中只有 o3 对象需要重新分配，即它被重新到 cs4 服务器。在前面我们已经分析过，如果使用简单的取模方法，当新添加服务器时可能会导致大部分缓存失效，而使用一致性哈希算法后，这种情况得到了较大的改善，因为只有少部分对象需要重新分配。</p><h4 id="3-5-服务器减少的情况"><a href="#3-5-服务器减少的情况" class="headerlink" title="3.5 服务器减少的情况"></a>3.5 服务器减少的情况</h4><p>假设 cs3 服务器出现故障导致服务下线，这时原本存储于 cs3 服务器的对象 o4，需要被重新分配至 cs2 服务器，其它对象仍存储在原有的机器上。</p><p><img src="hash-ring-remove-server.png" alt="hash-ring-remove-server"></p><h4 id="3-6-虚拟节点"><a href="#3-6-虚拟节点" class="headerlink" title="3.6 虚拟节点"></a>3.6 虚拟节点</h4><p>到这里一致性哈希的基本原理已经介绍完了，但对于新增服务器的情况还存在一些问题。新增的服务器 cs4 只分担了 cs1 服务器的负载，服务器 cs2 和 cs3 并没有因为 cs4 服务器的加入而减少负载压力。如果 cs4 服务器的性能与原有服务器的性能一致甚至可能更高，那么这种结果并不是我们所期望的。</p><p><strong>针对这个问题，我们可以通过引入虚拟节点来解决负载不均衡的问题。即将每台物理服务器虚拟为一组虚拟服务器，将虚拟服务器放置到哈希环上，如果要确定对象的服务器，需先确定对象的虚拟服务器，再由虚拟服务器确定物理服务器。</strong></p><p><img src="ch-virtual-nodes.png" alt="ch-virtual-nodes"></p><p>图中 o1 和 o2 表示对象，v1 ~ v6 表示虚拟服务器，s1 ~ s3 表示物理服务器。</p><h3 id="四、一致性哈希算法实现"><a href="#四、一致性哈希算法实现" class="headerlink" title="四、一致性哈希算法实现"></a>四、一致性哈希算法实现</h3><p>这里我们只介绍不带虚拟节点的一致性哈希算法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import java.util.SortedMap;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class ConsistentHashingWithoutVirtualNode &#123;</span><br><span class="line">    &#x2F;&#x2F;待添加入Hash环的服务器列表</span><br><span class="line">    private static String[] servers &#x3D; &#123;&quot;192.168.0.1:8888&quot;, &quot;192.168.0.2:8888&quot;, </span><br><span class="line">      &quot;192.168.0.3:8888&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;key表示服务器的hash值，value表示服务器</span><br><span class="line">    private static SortedMap&lt;Integer, String&gt; sortedMap &#x3D; new TreeMap&lt;Integer, String&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;程序初始化，将所有的服务器放入sortedMap中</span><br><span class="line">    static &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; servers.length; i++) &#123;</span><br><span class="line">            int hash &#x3D; getHash(servers[i]);</span><br><span class="line">            System.out.println(&quot;[&quot; + servers[i] + &quot;]加入集合中, 其Hash值为&quot; + hash);</span><br><span class="line">            sortedMap.put(hash, servers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;得到应当路由到的结点</span><br><span class="line">    private static String getServer(String key) &#123;</span><br><span class="line">        &#x2F;&#x2F;得到该key的hash值</span><br><span class="line">        int hash &#x3D; getHash(key);</span><br><span class="line">        &#x2F;&#x2F;得到大于该Hash值的所有Map</span><br><span class="line">        SortedMap&lt;Integer, String&gt; subMap &#x3D; sortedMap.tailMap(hash);</span><br><span class="line">        if (subMap.isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果没有比该key的hash值大的，则从第一个node开始</span><br><span class="line">            Integer i &#x3D; sortedMap.firstKey();</span><br><span class="line">            &#x2F;&#x2F;返回对应的服务器</span><br><span class="line">            return sortedMap.get(i);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;第一个Key就是顺时针过去离node最近的那个结点</span><br><span class="line">            Integer i &#x3D; subMap.firstKey();</span><br><span class="line">            &#x2F;&#x2F;返回对应的服务器</span><br><span class="line">            return subMap.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用FNV1_32_HASH算法计算服务器的Hash值</span><br><span class="line">    private static int getHash(String str) &#123;</span><br><span class="line">        final int p &#x3D; 16777619;</span><br><span class="line">        int hash &#x3D; (int) 2166136261L;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length(); i++)</span><br><span class="line">            hash &#x3D; (hash ^ str.charAt(i)) * p;</span><br><span class="line">        hash +&#x3D; hash &lt;&lt; 13;</span><br><span class="line">        hash ^&#x3D; hash &gt;&gt; 7;</span><br><span class="line">        hash +&#x3D; hash &lt;&lt; 3;</span><br><span class="line">        hash ^&#x3D; hash &gt;&gt; 17;</span><br><span class="line">        hash +&#x3D; hash &lt;&lt; 5;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果算出来的值为负数则取其绝对值</span><br><span class="line">        if (hash &lt; 0)</span><br><span class="line">            hash &#x3D; Math.abs(hash);</span><br><span class="line">        return hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] keys &#x3D; &#123;&quot;semlinker&quot;, &quot;kakuqo&quot;, &quot;fer&quot;&#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; keys.length; i++)</span><br><span class="line">            System.out.println(&quot;[&quot; + keys[i] + &quot;]的hash值为&quot; + getHash(keys[i])</span><br><span class="line">                    + &quot;, 被路由到结点[&quot; + getServer(keys[i]) + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码成功运行后，在控制台会输出以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[192.168.0.1:8888]加入集合中, 其Hash值为1326271016</span><br><span class="line">[192.168.0.2:8888]加入集合中, 其Hash值为1132535844</span><br><span class="line">[192.168.0.3:8888]加入集合中, 其Hash值为115798597</span><br><span class="line"></span><br><span class="line">[semlinker]的hash值为1549041406, 被路由到结点[192.168.0.3:8888]</span><br><span class="line">[kakuqo]的hash值为463104755, 被路由到结点[192.168.0.2:8888]</span><br><span class="line">[fer]的hash值为1677150790, 被路由到结点[192.168.0.3:8888]</span><br></pre></td></tr></table></figure><p>上面我们只介绍了不带虚拟节点的一致性哈希算法实现，如果有的小伙伴对带虚拟节点的一致性哈希算法感兴趣，可以参考 <a href="https://blog.csdn.net/suifeng629/article/details/81567777" target="_blank" rel="noopener">一致性Hash(Consistent Hashing)原理剖析及Java实现</a> 这篇文章。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>​    本文通过示例介绍了传统的哈希取模算法在分布式系统中的局限性，进而在针对该问题的解决方案中引出了一致性哈希算法。一致性哈希算法在 1997 年由麻省理工学院提出，是一种特殊的哈希算法，在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。在介绍完一致性哈希算法的作用和优点等相关知识后，我们以图解的形式生动介绍了一致性哈希算法的原理，最后给出了不带虚拟节点的一致性哈希算法的 Java 实现。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一 致性Hash </tag>
            
            <tag> 分布式算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树等价树2-3树</title>
      <link href="/2022/07/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-14-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AD%89%E4%BB%B7%E6%A0%912-3%E6%A0%91/"/>
      <url>/2022/07/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-14-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AD%89%E4%BB%B7%E6%A0%912-3%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote><p>一提到红黑树大家应该都不陌生，jdk集合容器底层大量应用红黑树来实现，是一种高性能应用广泛的数据结构。可是，对于它的性质原理很多人理解起来都比较困难，在&lt;&lt;算法&gt;&gt;本书中，作者也是红黑树的作者，采用2-3树来引入的方式介绍红黑树的原理，所以我们接下来要聊的2-3树是理解红黑树很重要的数据结构，可以这么说，看懂了本篇，再了解红黑树和2-3树的等价关系，就很容易理解红黑树的性质了。</p></blockquote><h3 id="2-3树基本性质"><a href="#2-3树基本性质" class="headerlink" title="2-3树基本性质"></a>2-3树基本性质</h3><ul><li>2-3树是一种绝对平衡的树 即平衡因子为0；</li><li>2-3树也是一种BST，满足二分搜索树的基本性质</li><li>2-3树，只有两种节点，2节点（节点有两个孩子）和3节点（节点有3个孩子）</li><li>2-3树 每插入一个元素，一定是插在叶子节点上，再去进行调整。</li></ul><h3 id="2-3树插入过程"><a href="#2-3树插入过程" class="headerlink" title="2-3树插入过程"></a>2-3树插入过程</h3><p>​    假设你已经具备BST、AVL平衡树的基础，那么基本性质了解以后，我们再看一下插入过程，基本上就搞定2-3树了</p><p>​    以 42、37、12、18、6、11、5 元素插入为例，详细的插入过程如下图:    <img src="1.png" alt=""></p><p>  详细解释一下:</p><pre><code>1. 第一次插入元素42时，整树为空，形成根节点1. 接着插入37，要和根节点先合并，检查是不是形成4节点，没有则无需调整。1. 插入12，此时只有根节点这个叶节点，先合并，检查形成4节点，需要拆分，37成根1. 插入18，和BST一样的插入顺序，来到12点叶节点位置，合并，检查无需拆分。1. 插入6，又来到12点叶节点，形成4节点，拆分。1. 插入11，来到6节点的位置，无需拆分。1. 插入5，此时引起了连锁的拆分反应，最终12成根。</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>可以发现，2-3 树由于这种插入调整的规则，使得它在任何时刻都是绝对平衡，2-3树可能是我们见到的唯一绝对平衡的数据结构。</li><li>2-3树 每次插入一定是插入在叶节点上，再去考虑调整。</li><li>2-3树不难，它的绝对平衡的特性，使得它查找迅速，并且插入速度并不是特别慢</li><li>先牢记插入合并以及拆分的过程，等理解红黑树性质时会有大用。</li></ol><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 算法 - 经典数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化Mysql数据导入的几种方法</title>
      <link href="/2022/07/14/mysql-2022-07-14-%E4%BC%98%E5%8C%96Mysql%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/14/mysql-2022-07-14-%E4%BC%98%E5%8C%96Mysql%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析sql执行效率的方法</title>
      <link href="/2022/07/14/mysql-2022-07-14-%E5%88%86%E6%9E%90sql%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/14/mysql-2022-07-14-%E5%88%86%E6%9E%90sql%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql ONLY_FULL_BY_GROUP_MODE模式</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql-ONLY-FULL-BY-GROUP-MODE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql-ONLY-FULL-BY-GROUP-MODE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>ONLY_FULL_BY_GROUP_MODE</strong></p><p>​    如果此模式不开启，则对mysql的扩展生效 此时与标准sql 有两个明显的区别：</p><p>​    <strong>允许在select list，having condition 和 order by 中使用没有出现在group by 中的字段，此时mysql会随机选择没有出现在group by字段中的值，其效果和使用ANY—VALUE效果是一样的</strong></p><p><strong>允许在having condition 中使用select list 中的alias</strong></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql DateTime与Timestamp区别</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql-DateTime%E4%B8%8ETimestamp%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql-DateTime%E4%B8%8ETimestamp%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 创建用户相关操作常用命令</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>创建用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#39;username&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39;;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#39;dog&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;192.168.1.101_&#39; IDENDIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;&#39;;CREATE USER &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure><p><strong>赋予权限</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON test.user TO &#39;pig&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON *.* TO &#39;pig&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON maindataplus.* TO &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure><p><strong>刷新权限</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><strong>删除用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql dump 命令</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql-dump-%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql-dump-%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="命令及解释"><a href="#命令及解释" class="headerlink" title="命令及解释"></a>命令及解释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -ubackup -p123456 -h 192.168.1.2 backup_test &gt; D:\bak\bakcup.sql </span><br><span class="line">在这段命令中：mysqldump 是myqldump的程序名了；</span><br><span class="line">  -u 是数据库的用户名，后面紧跟着用户名backup；</span><br><span class="line">  -p 是数据库的密码，后面同样紧跟着密码，注意是-p和密码之间不能有空格；</span><br><span class="line">  -h 是数据库的地址，如果没有此项表明是备份本地的数据库；</span><br><span class="line">(对我们用的阿里云，就是rds暴露在外的公网地址  xxxx.mysql.rds.aliyuncs.com)</span><br><span class="line">backup_test 要备份的数据库名称；</span><br><span class="line">表明该数据库备份到后面的文件，紧跟当然是备份文件的地址了，注意要用绝对文件路径，文件的后缀也可以用.txt。</span><br><span class="line">一旦执行该命令后，mysqldump立即执行备份操作。远程备份数据库要似乎网络的情况，一般远程备份需要一定的时间的。</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>实际mysql dump记住两条命令就够了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">导入：</span><br><span class="line">mysql -u root -p database &lt; data.sql</span><br><span class="line">导出：</span><br><span class="line">（整个数据库）</span><br><span class="line">mysqldump -u 账户 -p密码 数据库名字 &gt; data.sql</span><br><span class="line">（单个表）</span><br><span class="line">mysqldump  -u 账户 -p密码 数据库名字 表名字 &gt; data.sql</span><br></pre></td></tr></table></figure><blockquote><p>补充：</p><p>导出一个表，只有表结构</p><p>mysqldump -u用户名 -p 密码 -d数据库名 表名&gt; 导出的文件名</p><p>C:\Users\jack&gt; mysqldump -uroot -pmysql -d sva_rec date_rec_drv&gt; e:\date_rec_drv.sql</p><p>导出一个数据库结构</p><p>C:\Users\jack&gt; mysqldump -uroot -pmysql -d sva_rec &gt; e:\sva_rec.sql</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 停止启动mysql常用命令</title>
      <link href="/2022/07/14/mysql-2022-07-14-linux-%E5%81%9C%E6%AD%A2%E5%90%AF%E5%8A%A8mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/14/mysql-2022-07-14-linux-%E5%81%9C%E6%AD%A2%E5%90%AF%E5%8A%A8mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="查看mysql版本"><a href="#查看mysql版本" class="headerlink" title="查看mysql版本"></a>查看mysql版本</h3><p>方法一：status;</p><p>方法二：select version();</p><h3 id="Mysql启动、停止、重启常用命令"><a href="#Mysql启动、停止、重启常用命令" class="headerlink" title="Mysql启动、停止、重启常用命令"></a>Mysql启动、停止、重启常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a、启动方式</span><br><span class="line">1、使用 service 启动：</span><br><span class="line">    [root@localhost &#x2F;]# service mysqld start (5.0版本是mysqld)</span><br><span class="line">    [root@szxdb etc]# service mysql start (5.5.7版本是mysql)</span><br><span class="line">2、使用 mysqld 脚本启动：</span><br><span class="line">    &#x2F;etc&#x2F;inint.d&#x2F;mysqld start</span><br><span class="line">3、使用 safe_mysqld 启动：</span><br><span class="line">    safe_mysqld&amp;</span><br><span class="line">b、停止</span><br><span class="line">    1、使用 service 启动：</span><br><span class="line">    service mysqld stop</span><br><span class="line">    2、使用 mysqld 脚本启动：</span><br><span class="line">    &#x2F;etc&#x2F;inint.d&#x2F;mysqld stop</span><br><span class="line">    3、mysqladmin shutdown</span><br><span class="line">c、重启</span><br><span class="line">    1、使用 service 启动：</span><br><span class="line">    service mysqld restart</span><br><span class="line">    service mysql restart (5.5.7版本命令)</span><br><span class="line">    2、使用 mysqld 脚本启动：</span><br><span class="line">    &#x2F;etc&#x2F;init.d&#x2F;mysqld restart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql中Binlog常用命令</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql%E4%B8%ADBinlog%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql%E4%B8%ADBinlog%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Binlog使用场景"><a href="#Binlog使用场景" class="headerlink" title="Binlog使用场景"></a>Binlog使用场景</h3><ul><li>主从数据库复制： Mysql Replication在Master端开启Binlog，Master把日志传递给Slavers，以达到    Master-slavers主从数据同步。</li><li>数据恢复： 使用mysqlbinlog工具来恢复数据</li></ul><h3 id="Binlog常用命令"><a href="#Binlog常用命令" class="headerlink" title="Binlog常用命令"></a>Binlog常用命令</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 查看是否启用Binlog日志</span><br><span class="line">show variables like &#39;log_bin&#39;;</span><br><span class="line"></span><br><span class="line"># 查看详细的日志配置信息</span><br><span class="line">show global variables like &#39;%log%&#39;;</span><br><span class="line"></span><br><span class="line"># Mysql数据存储目录</span><br><span class="line">show variables like &#39;%dir%&#39;;</span><br><span class="line"></span><br><span class="line"># 查看binlog数据目录</span><br><span class="line">show global variables like &#39;%log_bin%&#39;;</span><br><span class="line"></span><br><span class="line">##以下命令需要super权限</span><br><span class="line"># 查看当前服务器binlog文件及大小</span><br><span class="line">show binary logs;</span><br><span class="line"></span><br><span class="line"># 查看 binlog 内容</span><br><span class="line">show binlog events;</span><br><span class="line"></span><br><span class="line"># 查看具体一个binlog文件的内容 （in 后面为binlog的文件名）</span><br><span class="line">show binlog events in &#39;master.000003&#39;;</span><br><span class="line"></span><br><span class="line"># 设置binlog文件保存事件，过期删除，单位天</span><br><span class="line">set global expire_log_days&#x3D;3; </span><br><span class="line"></span><br><span class="line"># 删除当前的binlog文件</span><br><span class="line">reset master; </span><br><span class="line"></span><br><span class="line"># 删除slave的中继日志</span><br><span class="line">reset slave;</span><br><span class="line"></span><br><span class="line"># 删除指定日期前的日志索引中binlog日志文件</span><br><span class="line">purge master logs before &#39;2019-03-12 21:54:00&#39;;</span><br><span class="line"></span><br><span class="line"># 删除指定日志文件</span><br><span class="line">purge master logs to &#39;master.000001&#39;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda、pip、virtualenv的几点区别</title>
      <link href="/2022/07/14/python-2022-07-14-conda%E3%80%81pip%E3%80%81virtualenv%E7%9A%84%E5%87%A0%E7%82%B9%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/07/14/python-2022-07-14-conda%E3%80%81pip%E3%80%81virtualenv%E7%9A%84%E5%87%A0%E7%82%B9%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="conda"><a href="#conda" class="headerlink" title="conda"></a><strong>conda</strong></h3><p>首先，<strong>conda是一个通用的包管理器</strong>，意思是什么语言的包都可以用其进行管理，自然也就包括Python了。在安装Anaconda或者Miniconda时，会对conda进行一同安装。其中Anaconda作为Python的发行版，相当于在Python的基础上自带了常用第三方库，而Miniconda则相当于是一个conda环境的安装程序，只包含了conda及其依赖项，这样就可以减少一些不需要的第三方库的安装，所以Miniconda所占用的空间很小。</p><h3 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h3><p>Pip同conda一样，也是一个包管理器，并且是Python官方认可的包管理器。其中pip的含义是Pip Installs Packages。最常用于安装在Python包索引（PyPI, Python Package Index <a href="https://pypi.python.org/pypi）上发布的包。因此，在通过conda" target="_blank" rel="noopener">https://pypi.python.org/pypi）上发布的包。因此，在通过conda</a> list命令查看当前环境下已安装的包时，通过pip的源是pypi。</p><p>​    <img src="1.png" alt="在这里插入图片描述"></p><h3 id="conda和pip安装库的区别"><a href="#conda和pip安装库的区别" class="headerlink" title="conda和pip安装库的区别"></a>conda和pip安装库的区别</h3><p>在Anaconda中，<strong>无论在哪个环境下</strong>，只要通过conda install xxx的方式安装的库都会放在Anaconda的pkgs目录下，如:E:\python\anaconda\pkgs\numpy-1.18.1-py36h48dd78f_1。这样的好处就是，当在某个环境下已经下载好了某个库，再在另一个环境中还需要这个库时，就可以直接从pkgs目录下将该库复制至新环境（将这个库的Lib\site-packages中的文件复制到当前新环境下Lib中的第三方库中，也即Lib\site-packages中，这个过程相当于通过pip install xxx进行了安装）而不用重复下载。</p><h3 id="conda和pip卸载库的区别"><a href="#conda和pip卸载库的区别" class="headerlink" title="conda和pip卸载库的区别"></a>conda和pip卸载库的区别</h3><p>pip是在<strong>特定的环境</strong>中进行库的安装，所以卸载库也是一样的道理，通过pip uninstall xxx就可以将该环境下Lib\site-packages中对应的库进行卸载了。</p><p>如果通过conda uninstall xxx删除当前环境下某个库时，删除的只是当前环境下site-packages目录中该库的内容，它的效果和通过pip uninstall xxx是一样的。如果再到另一个环境中通过conda install xxx下载这个库，则还是通过将pkgs目录下的库复制到当前环境。若要清空这个pkgs下的已下载库，可以通过命令conda clean -h进行实现。</p><h3 id="conda和virtualenv的区别"><a href="#conda和virtualenv的区别" class="headerlink" title="conda和virtualenv的区别"></a>conda和virtualenv的区别</h3><p>virtualenv和conda都可以做包隔离，类似java中的maven管理，实现一个项目一个独立的环境，简单的包隔离，用virtualenv就可以实现，它本质就是创建一个文件夹，作为一个独立的环境，运行文件夹bin下的激活脚本就进入这个独立的环境，在这个环境中，所有运行的python命令，安装的脚本都是在这个目录下的，是独立全局的python环境的。但有一个缺点就是virtualenv使用哪个版本的pip命令就会安装到当前目录的bin下，那么用virtualenv创建的虚拟环境就是这个版本的环境，是不能实现版本切换的，换句话说创建出的所有环境都是同一个python版本，要想实现多版本的环境就得用conda，很好的工具，可以详细学习一下。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>454. 4Sum II</title>
      <link href="/2022/07/14/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-14-454-4Sum-II/"/>
      <url>/2022/07/14/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-14-454-4Sum-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/4sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/4sum-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The two tuples are:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>n == nums3.length</code></li><li><code>n == nums4.length</code></li><li><code>1 &lt;= n &lt;= 200</code></li><li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题告诉我们 还是要学会变通，4个数和为0的组合数几种，先前两个数组组合，后两个数组组合，注意sum的种数，最后再两两组合。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.length; j++) &#123;</span><br><span class="line">sum = A[i] + B[j];</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(sum)) &#123;</span><br><span class="line">map.put(sum, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(sum, map.get(sum) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D.length; j++) &#123;</span><br><span class="line">sum = C[i] + D[j];</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(-sum)) &#123;</span><br><span class="line">ans += map.get(-sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>412. Fizz Buzz </title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-412-Fizz-Buzz/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-412-Fizz-Buzz/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/fizz-buzz/" target="_blank" rel="noopener">https://leetcode.com/problems/fizz-buzz/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em>a string array</em> <code>answer</code> <em>(<strong>1-indexed</strong>) where</em>:</p><ul><li><code>answer[i] == &quot;FizzBuzz&quot;</code> if <code>i</code> is divisible by <code>3</code> and <code>5</code>.</li><li><code>answer[i] == &quot;Fizz&quot;</code> if <code>i</code> is divisible by <code>3</code>.</li><li><code>answer[i] == &quot;Buzz&quot;</code> if <code>i</code> is divisible by <code>5</code>.</li><li><code>answer[i] == i</code> (as a string) if none of the above conditions are true.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 5</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 15</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;7&quot;,&quot;8&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;11&quot;,&quot;Fizz&quot;,&quot;13&quot;,&quot;14&quot;,&quot;FizzBuzz&quot;]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>考察会不会编程</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">3</span>==<span class="number">0</span> &amp;&amp; (i+<span class="number">1</span>) %<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(<span class="string">"Fizz"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(<span class="string">"Buzz"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                list.add((i+<span class="number">1</span>)+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>395. Longest Substring with At Least K Repeating Characters</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-395-Longest-Substring-with-At-Least-K-Repeating-Characters/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-395-Longest-Substring-with-At-Least-K-Repeating-Characters/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> and an integer <code>k</code>, return <em>the length of the longest substring of</em> <code>s</code> <em>such that the frequency of each character in this substring is greater than or equal to</em> <code>k</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aaabb&quot;, k &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest substring is &quot;aaa&quot;, as &#39;a&#39; is repeated 3 times.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ababbc&quot;, k &#x3D; 2</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest substring is &quot;ababb&quot;, as &#39;a&#39; is repeated 2 times and &#39;b&#39; is repeated 3 times.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> consists of only lowercase English letters.</li><li><code>1 &lt;= k &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>乍一看 特像滑动窗口对吧，直接用，一会发现，窗口结束不了，比如说，L =  0，R取扫描，对于abbbcccdefg    k =2的情况，明明只要L=1，R = 6位置就能得到答案的，结果R = 6，不满足条件啊，因为a还不够2啊，所以R 继续扫，又引入了新的字符，永远满足不了条件！</li><li>这个窗口不能直接用，就是因为你会不断的引入新字符，你得给认为的中断！比如讲，每次用窗口，认为的规定字符种类就必须是2种，那么遇到c的时候 L必须前移！</li><li>好好体会这道 窗口不能直接用的题目！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">//<span class="doctag">TODO:</span>做的还是慢</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">26</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">           <span class="keyword">int</span> kind = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (p1 &lt; chars.length)&#123;</span><br><span class="line">               <span class="keyword">while</span> (p2 &lt; chars.length)&#123;</span><br><span class="line">                   <span class="keyword">int</span> expect = chars[p2]-<span class="string">'a'</span>;</span><br><span class="line">                   <span class="keyword">if</span>(visited[expect] == <span class="number">0</span>)&#123;</span><br><span class="line">                       <span class="keyword">if</span>(kind+<span class="number">1</span> &gt; i)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                       kind++;</span><br><span class="line">                       set.add(expect);</span><br><span class="line">                   &#125;</span><br><span class="line">                   visited[expect]++;</span><br><span class="line">                   p2++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(kind == i)&#123;</span><br><span class="line">                   <span class="keyword">final</span> Iterator&lt;Integer&gt; iterator = set.iterator();</span><br><span class="line">                   <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                       <span class="keyword">final</span> Integer next = iterator.next();</span><br><span class="line">                       <span class="keyword">if</span>(visited[next] &lt; k)&#123;</span><br><span class="line">                           flag = <span class="keyword">false</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                       res = Math.max(res,p2-p1);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(--visited[chars[p1]-<span class="string">'a'</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                   kind--;</span><br><span class="line">                   set.remove(chars[p1]-<span class="string">'a'</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               p1++;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>387. First Unique Character in a String</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-387-First-Unique-Character-in-a-String/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-387-First-Unique-Character-in-a-String/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">https://leetcode.com/problems/first-unique-character-in-a-string/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code>, <em>find the first non-repeating character in it and return its index</em>. If it does not exist, return <code>-1</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcode&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;loveleetcode&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aabb&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s</code> consists of only lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>无</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            map[chars[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[chars[i]] == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>384. Shuffle an Array</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-384-Shuffle-an-Array/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-384-Shuffle-an-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/shuffle-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/shuffle-an-array/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, design an algorithm to randomly shuffle the array. All permutations of the array should be <strong>equally likely</strong> as a result of the shuffling.</p><p>Implement the <code>Solution</code> class:</p><ul><li><code>Solution(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li><li><code>int[] reset()</code> Resets the array to its original configuration and returns it.</li><li><code>int[] shuffle()</code> Returns a random shuffling of the array.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;, &quot;shuffle&quot;, &quot;reset&quot;, &quot;shuffle&quot;]</span><br><span class="line">[[[1, 2, 3]], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Solution solution &#x3D; new Solution([1, 2, 3]);</span><br><span class="line">solution.shuffle();    &#x2F;&#x2F; Shuffle the array [1,2,3] and return its result.</span><br><span class="line">                       &#x2F;&#x2F; Any permutation of [1,2,3] must be equally likely to be returned.</span><br><span class="line">                       &#x2F;&#x2F; Example: return [3, 1, 2]</span><br><span class="line">solution.reset();      &#x2F;&#x2F; Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]</span><br><span class="line">solution.shuffle();    &#x2F;&#x2F; Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 50</code></li><li><code>-106 &lt;= nums[i] &lt;= 106</code></li><li>All the elements of <code>nums</code> are <strong>unique</strong>.</li><li>At most <code>104</code> calls <strong>in total</strong> will be made to <code>reset</code> and <code>shuffle</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>利用随机交换就可以，注意踩坑.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cap;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        cap = Arrays.copyOf(nums, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(cap,cap.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] t = Arrays.copyOf(cap, cap.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t.length-<span class="number">1</span>; i&gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> loc = random.nextInt(i+<span class="number">1</span>);<span class="comment">//  踩坑</span></span><br><span class="line">            swap(t,i,loc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * int[] param_1 = obj.reset();</span></span><br><span class="line"><span class="comment"> * int[] param_2 = obj.shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>380. Insert Delete GetRandom O(1)</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-380-Insert-Delete-GetRandom-O-1/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-380-Insert-Delete-GetRandom-O-1/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="noopener">https://leetcode.com/problems/insert-delete-getrandom-o1/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement the <code>RandomizedSet</code> class:</p><ul><li><code>RandomizedSet()</code> Initializes the <code>RandomizedSet</code> object.</li><li><code>bool insert(int val)</code> Inserts an item <code>val</code> into the set if not present. Returns <code>true</code> if the item was not present, <code>false</code> otherwise.</li><li><code>bool remove(int val)</code> Removes an item <code>val</code> from the set if present. Returns <code>true</code> if the item was present, <code>false</code> otherwise.</li><li><code>int getRandom()</code> Returns a random element from the current set of elements (it’s guaranteed that at least one element exists when this method is called). Each element must have the <strong>same probability</strong> of being returned.</li></ul><p>You must implement the functions of the class such that each function works in <strong>average</strong> <code>O(1)</code> time complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">Output</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">RandomizedSet randomizedSet &#x3D; new RandomizedSet();</span><br><span class="line">randomizedSet.insert(1); &#x2F;&#x2F; Inserts 1 to the set. Returns true as 1 was inserted successfully.</span><br><span class="line">randomizedSet.remove(2); &#x2F;&#x2F; Returns false as 2 does not exist in the set.</span><br><span class="line">randomizedSet.insert(2); &#x2F;&#x2F; Inserts 2 to the set, returns true. Set now contains [1,2].</span><br><span class="line">randomizedSet.getRandom(); &#x2F;&#x2F; getRandom() should return either 1 or 2 randomly.</span><br><span class="line">randomizedSet.remove(1); &#x2F;&#x2F; Removes 1 from the set, returns true. Set now contains [2].</span><br><span class="line">randomizedSet.insert(2); &#x2F;&#x2F; 2 was already in the set, so return false.</span><br><span class="line">randomizedSet.getRandom(); &#x2F;&#x2F; Since 2 is the only number in the set, getRandom() will always return 2.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li>At most <code>2 * ``105</code> calls will be made to <code>insert</code>, <code>remove</code>, and <code>getRandom</code>.</li><li>There will be <strong>at least one</strong> element in the data structure when <code>getRandom</code> is called.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>数据结构题目，要求每个操作都是O(1)的，主要是删除操作，删掉之后就不连续了呀，那取随机值的时候，取到空就麻烦了，可以做一个映射表，记录索引，这时候就可以用交换操作代替直接删除，注意更新映射表，很有用的小技巧。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*<span class="number">100005</span>];</span><br><span class="line">     Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(val) != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        num[size++] = val;</span><br><span class="line">        map.put(val,size-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Integer loc = map.get(val);</span><br><span class="line">        <span class="keyword">if</span>(loc == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        map.remove(val);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (loc == size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(num,loc,size);</span><br><span class="line">        map.put(num[loc],loc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i = random.nextInt(size);</span><br><span class="line">        <span class="keyword">return</span> num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>378. Kth Smallest Element in a Sorted Matrix</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-378-Kth-Smallest-Element-in-a-Sorted-Matrix/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-378-Kth-Smallest-Element-in-a-Sorted-Matrix/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>371. Sum of Two Integers</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-371-Sum-of-Two-Integers/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-371-Sum-of-Two-Integers/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-of-two-integers/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integers <code>a</code> and <code>b</code>, return <em>the sum of the two integers without using the operators</em> <code>+</code> <em>and</em> <code>-</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 1, b &#x3D; 2</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 2, b &#x3D; 3</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-1000 &lt;= a, b &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>利用位运算做加法，其实很简单，你只要利用好真值表，表示出对应和的位运算操作，进位的位元算操作，就有了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>,elem1 = <span class="number">0</span>,elem2 = <span class="number">0</span>,jie = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">            elem1 = (a &gt;&gt; i)&amp;<span class="number">1</span>;</span><br><span class="line">            elem2 = (b &gt;&gt; i)&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = elem1 ^ elem2 ^ jie; <span class="comment">//当前位</span></span><br><span class="line">            jie =jie&amp;(elem1^elem2)|elem1&amp;elem2;</span><br><span class="line">            res |= (t&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>350. Intersection of Two Arrays II</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-350-Intersection-of-Two-Arrays-II/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-350-Intersection-of-Two-Arrays-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-arrays-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must appear as many times as it shows in both arrays and you may return the result in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">Output: [2,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">Output: [4,9]</span><br><span class="line">Explanation: [9,4] is also accepted.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目简单，但是可以学到东西，看下数值范围，拿数组存下，再次遍历只要数组元素大于0，就统计，统计完记得减掉一个 。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1005</span>];</span><br><span class="line">            <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> elem : nums1) &#123;</span><br><span class="line">              map[elem]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> elem : nums2) &#123;</span><br><span class="line">               <span class="keyword">if</span>(map[elem]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                   res[cnt++] = elem;</span><br><span class="line">                   map[elem]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(res,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>347. Top K Frequent Elements</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-347-Top-K-Frequent-Elements/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-347-Top-K-Frequent-Elements/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">https://leetcode.com/problems/top-k-frequent-elements/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li><li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>主要考察堆的典型Top K应用</li><li>先统计词频（小知识点），然后维护一个K的最小堆。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">num = k;</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1.count - o2.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">HashMap&lt;Integer, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(num)) &#123;</span><br><span class="line">map.put(num, <span class="keyword">new</span> Node(num));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.get(num).count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> CountComparator());</span><br><span class="line"><span class="keyword">for</span> (Node node : map.values()) &#123;</span><br><span class="line"><span class="keyword">if</span> (heap.size() &lt; k || (heap.size() == k &amp;&amp; node.count &gt; heap.peek().count)) &#123;</span><br><span class="line">heap.add(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">heap.poll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">ans[index++] = heap.poll().num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Heap </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>344. Reverse String</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-344-Reverse-String/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-344-Reverse-String/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/reverse-string/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-string/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p><p>You must do this by modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a> with <code>O(1)</code> extra memory.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>无</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = s[i];</span><br><span class="line">            s[i] = s[s.length-<span class="number">1</span>-i];</span><br><span class="line">            s[s.length-<span class="number">1</span>-i] = (<span class="keyword">char</span>)t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>341. Flatten Nested List Iterator</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-341-Flatten-Nested-List-Iterator/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-341-Flatten-Nested-List-Iterator/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>334. Increasing Triplet Subsequence</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-334-Increasing-Triplet-Subsequence/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-334-Increasing-Triplet-Subsequence/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>329. Longest Increasing Path in a Matrix</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-329-Longest-Increasing-Path-in-a-Matrix/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-329-Longest-Increasing-Path-in-a-Matrix/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>328. Odd Even Linked List</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-328-Odd-Even-Linked-List/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-328-Odd-Even-Linked-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/odd-even-linked-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return <em>the reordered list</em>.</p><p>The <strong>first</strong> node is considered <strong>odd</strong>, and the <strong>second</strong> node is <strong>even</strong>, and so on.</p><p>Note that the relative order inside both the even and odd groups should remain as it was in the input.</p><p>You must solve the problem in <code>O(1)</code> extra space complexity and <code>O(n)</code> time complexity.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: [1,3,5,2,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [2,1,3,5,6,4,7]</span><br><span class="line">Output: [2,3,6,7,1,5,4]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the linked list is in the range <code>[0, 104]</code>.</li><li><code>-106 &lt;= Node.val &lt;= 106</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是遍历一趟把奇数的节点和偶数的节点分成两个链表</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next == <span class="keyword">null</span> || head.next.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode odd = head;</span><br><span class="line">        ListNode even_head = head.next;</span><br><span class="line">        ListNode even = head.next;</span><br><span class="line">        ListNode cur = even.next;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((step&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                odd.next = cur;</span><br><span class="line">                odd = odd.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                even.next = cur;</span><br><span class="line">                even = even.next;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">            cur= cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">       odd.next = even_head;</span><br><span class="line">        even.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>326. Power of Three</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-326-Power-of-Three/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-326-Power-of-Three/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/power-of-three/" target="_blank" rel="noopener">https://leetcode.com/problems/power-of-three/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em><code>true</code> if it is a power of three. Otherwise, return <code>false</code></em>.</p><p>An integer <code>n</code> is a power of three, if there exists an integer <code>x</code> such that <code>n == 3x</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 27</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 0</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 9</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= n &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>可以简单的模拟，也可以用打表法，打出在int范围内，3^x的最大值，那么只要被n整除，n就是3的某次方</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>324. Wiggle Sort II</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-324-Wiggle-Sort-II/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-324-Wiggle-Sort-II/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>322. Coin Change</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-322-Coin-Change/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-322-Coin-Change/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">https://leetcode.com/problems/coin-change/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p><p>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p><p>You may assume that you have an infinite number of each kind of coin.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [1,2,5], amount &#x3D; 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [1], amount &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>典型的DP。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = coins.length;</span><br><span class="line">        <span class="keyword">int</span> N = amount;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[M+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i++) dp[M][i] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = M-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= N;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span>(j-coins[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i][j-coins[i]] != Integer.MAX_VALUE)&#123;</span><br><span class="line">                    p1 =  dp[i][j-coins[i]]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> p2 = dp[i+<span class="number">1</span>][j];</span><br><span class="line">                dp[i][j] = Math.min(p1,p2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][N]==Integer.MAX_VALUE ? -<span class="number">1</span>:dp[<span class="number">0</span>][N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>315. Count of Smaller Numbers After Self</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-315-Count-of-Smaller-Numbers-After-Self/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-315-Count-of-Smaller-Numbers-After-Self/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>300. Longest Increasing Subsequence</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-300-Longest-Increasing-Subsequence/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-300-Longest-Increasing-Subsequence/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>297. Serialize and Deserialize Binary Tree</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-297-Serialize-and-Deserialize-Binary-Tree/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-297-Serialize-and-Deserialize-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/serialize-and-deserialize-binary-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p><strong>Clarification:</strong> The input/output format is the same as <a href="https://leetcode.com/faq/#binary-tree" target="_blank" rel="noopener">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,null,null,4,5]</span><br><span class="line">Output: [1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 104]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题目解"><a href="#题目解" class="headerlink" title="题目解"></a>题目解</h3><ul><li>树的序列化与反序列化，把null值用一个特殊符号代替即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        process(root,builder);</span><br><span class="line">        <span class="keyword">final</span> String str = builder.toString();</span><br><span class="line">        <span class="keyword">return</span> str.substring(<span class="number">0</span>,str.length()-<span class="number">1</span>); <span class="comment">//去掉最后一个#</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(TreeNode root,StringBuilder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            builder.append(<span class="string">"*#"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(root.val+<span class="string">"#"</span>);</span><br><span class="line">        process(root.left,builder);</span><br><span class="line">        process(root.right,builder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">""</span>.equals(data)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> String[] split = data.split(<span class="string">"#"</span>);</span><br><span class="line">        step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> unprocess(split);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">unprocess</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs[step].equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = Integer.parseInt(strs[step++]);</span><br><span class="line">            <span class="keyword">final</span> TreeNode cur = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">            cur.left = unprocess(strs);</span><br><span class="line">            cur.right = unprocess(strs);</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>295. Find Median from Data Stream</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-295-Find-Median-from-Data-Stream/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-295-Find-Median-from-Data-Stream/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">https://leetcode.com/problems/find-median-from-data-stream/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.</p><ul><li>For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.</li><li>For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li></ul><p>Implement the MedianFinder class:</p><ul><li><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.</li><li><code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.</li><li><code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10-5</code> of the actual answer will be accepted.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 1.5, null, 2.0]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MedianFinder medianFinder &#x3D; new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    &#x2F;&#x2F; arr &#x3D; [1]</span><br><span class="line">medianFinder.addNum(2);    &#x2F;&#x2F; arr &#x3D; [1, 2]</span><br><span class="line">medianFinder.findMedian(); &#x2F;&#x2F; return 1.5 (i.e., (1 + 2) &#x2F; 2)</span><br><span class="line">medianFinder.addNum(3);    &#x2F;&#x2F; arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); &#x2F;&#x2F; return 2.0</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-105 &lt;= num &lt;= 105</code></li><li>There will be at least one element in the data structure before calling <code>findMedian</code>.</li><li>At most <code>5 * 104</code> calls will be made to <code>addNum</code> and <code>findMedian</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>要求没输入一个数输出此前所有元素中的中位数，如果是偶数个元素，输出中间两个元素的平均值。</li><li>可以用BST，存下元素以及元素的个数、左子树的个数、右子树的个数，这样我们每次log级别的插入元素时候，是可以顺表数出来中位数的，But，BST最差会成链，所以还得改成AVL这种动态平衡的，那这个题就比较麻烦了，实际上我们只要最中间的两个数。</li><li>可以用堆，一个最大堆，保留前一半的数，一个最小堆保留后面的数。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span>  Queue&lt;Integer&gt; pre = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((a,b)-&gt;b-a);</span><br><span class="line">    <span class="keyword">public</span> Queue&lt;Integer&gt; post = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.isEmpty())&#123;</span><br><span class="line">            pre.add(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; pre.peek())&#123;</span><br><span class="line">            post.add(num);</span><br><span class="line">            <span class="keyword">if</span> (post.size() - pre.size() &gt; <span class="number">1</span>)</span><br><span class="line">                pre.add(post.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.add(num);</span><br><span class="line">            <span class="keyword">if</span> (pre.size() - post.size() &gt; <span class="number">1</span>)</span><br><span class="line">                post.add(pre.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.size() == post.size()) <span class="keyword">return</span> (pre.peek() + post.peek())*<span class="number">1.0</span>/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pre.size() &gt; post.size() ? pre.peek() : post.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Heap </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>289. Game of Life</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-289-Game-of-Life/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-289-Game-of-Life/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener">https://leetcode.com/problems/game-of-life/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    According to <a href="https://en.wikipedia.org/wiki/Conway&#39;s_Game_of_Life" target="_blank" rel="noopener">Wikipedia’s article</a>: “The <strong>Game of Life</strong>, also known simply as <strong>Life</strong>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p><p>The board is made up of an <code>m x n</code> grid of cells, where each cell has an initial state: <strong>live</strong> (represented by a <code>1</code>) or <strong>dead</strong> (represented by a <code>0</code>). Each cell interacts with its <a href="https://en.wikipedia.org/wiki/Moore_neighborhood" target="_blank" rel="noopener">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p><ol><li>Any live cell with fewer than two live neighbors dies as if caused by under-population.</li><li>Any live cell with two or three live neighbors lives on to the next generation.</li><li>Any live cell with more than three live neighbors dies, as if by over-population.</li><li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li></ol><p>The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the <code>m x n</code> grid <code>board</code>, return <em>the next state</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]</span><br><span class="line">Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[1,1],[1,0]]</span><br><span class="line">Output: [[1,1],[1,1]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 25</code></li><li><code>board[i][j]</code> is <code>0</code> or <code>1</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题，把题目读懂就不难，通过周围元素1的个数判断此元素的生死。</li><li>判断出此元素的生死，你还不能立即修改，因为，你该来会影响周围元素的判断呀，因为其实就是0和1代表生死，所以我们利用位元算，在权重为2的位置通过0和1来表示新状态。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        M = board.length;</span><br><span class="line">        N = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>,expect = <span class="number">0</span>; <span class="comment">//0不变，1取反</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">8</span>;d++)&#123;</span><br><span class="line">                    res +=getState(board,i+dir_x[d],j+dir_y[d]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; (res &lt;<span class="number">2</span> || res &gt; <span class="number">3</span>)) expect = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">0</span> &amp;&amp;res ==<span class="number">3</span>) expect = <span class="number">1</span>;</span><br><span class="line">                expect= (expect ^ board[i][j]);</span><br><span class="line">                board[i][j] = (expect&lt;&lt;<span class="number">1</span>)|board[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                board[i][j] &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">(<span class="keyword">int</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= M || j &lt;<span class="number">0</span> || j &gt;= N ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> board[i][j]&amp;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>287. Find the Duplicate Number</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-287-Find-the-Duplicate-Number/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-287-Find-the-Duplicate-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">https://leetcode.com/problems/find-the-duplicate-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.</p><p>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this repeated number</em>.</p><p>You must solve the problem <strong>without</strong> modifying the array <code>nums</code> and uses only constant extra space.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 105</code></li><li><code>nums.length == n + 1</code></li><li><code>1 &lt;= nums[i] &lt;= n</code></li><li>All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>利用数组的特性，让每个元素归位，就会找到重复元素。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[nums[i]-<span class="number">1</span>] == nums[i])</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                swap(nums,i,nums[i]-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>283. Move Zeroes</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-283-Move-Zeroes/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-283-Move-Zeroes/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/move-zeroes/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p><p><strong>Note</strong> that you must do this in-place without making a copy of the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>双指针交换即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p2 = <span class="number">0</span>; p2 &lt; nums.length; p2++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p2] != <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,p1++,p2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>279. Perfect Squares</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-279-Perfect-Squares/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-279-Perfect-Squares/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">https://leetcode.com/problems/perfect-squares/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em>the least number of perfect square numbers that sum to</em> <code>n</code>.</p><p>A <strong>perfect square</strong> is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, <code>1</code>, <code>4</code>, <code>9</code>, and <code>16</code> are perfect squares while <code>3</code> and <code>11</code> are not.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 12</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>首先得知道 四数定理。一个数由平方数组合，不会超过4个。</li><li>结合打表，把，1和2的打出来，判断3的，3的没有就是4个，也挺快。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashSet&lt;Integer&gt; d_set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (set.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">                set.add(i*i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i;j++)&#123;</span><br><span class="line">                    d_set.add(i*i + j*j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单个平方数</span></span><br><span class="line">        <span class="keyword">if</span>(set.contains(n)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(d_set.contains(n)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">final</span> Iterator&lt;Integer&gt; iterator = set.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                <span class="keyword">int</span> t = n - iterator.next();</span><br><span class="line">                <span class="keyword">if</span>(d_set.contains(t)) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>268. Missing Number</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-268-Missing-Number/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-268-Missing-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/missing-number/" target="_blank" rel="noopener">https://leetcode.com/problems/missing-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: n &#x3D; 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: n &#x3D; 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: n &#x3D; 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= n</code></li><li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>因为数据大小是有范围的，这种就可以利用桶排的思想。遍历两次即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length; <span class="comment">//期望的是0-N-1满，这样返回就是N</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            ints[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ints[i] == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>242. Valid Anagram</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-242-Valid-Anagram/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-242-Valid-Anagram/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-anagram/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code> <em>otherwise</em>.</p><p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s</code> and <code>t</code> consist of lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>比较简单了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] chars = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars2 = t.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(chars1.length != chars2.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars1.length; i++) &#123;</span><br><span class="line">            chars[chars1[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(--chars[chars2[i]-<span class="string">'a'</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>240. Search a 2D Matrix II</title>
      <link href="/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-240-Search-a-2D-Matrix-II/"/>
      <url>/2022/07/13/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-13-240-Search-a-2D-Matrix-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/search-a-2d-matrix-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= n, m &lt;= 300</code></li><li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li><li>All the integers in each row are <strong>sorted</strong> in ascending order.</li><li>All the integers in each column are <strong>sorted</strong> in ascending order.</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>两个方向都是递增的，明显提示二分了，我们可以一个方向遍历，再另一个方向用二分</li><li>法一不好，没有充分利用二分特性！其实想清楚，只要在右上角，则可以不断的二分！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[M-<span class="number">1</span>][N-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == matrix[<span class="number">0</span>][<span class="number">0</span>] || target == matrix[M-<span class="number">1</span>][N-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = M-<span class="number">1</span> ;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(binarySearch(matrix[i],target))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = num.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r- l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(num[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num[mid] &lt; target) l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num[l] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length,N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = N-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (inEdge(l,r,M,N))&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[l][r] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[l][r] &gt; target)&#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">inEdge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &gt;= <span class="number">0</span> &amp;&amp; l &lt; m &amp;&amp; r &gt;= <span class="number">0</span> &amp;&amp; r &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>239. Sliding Window Maximum</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-239-Sliding-Window-Maximum/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-239-Sliding-Window-Maximum/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>238. Product of Array Except Self</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-238-Product-of-Array-Except-Self/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-238-Product-of-Array-Except-Self/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">https://leetcode.com/problems/product-of-array-except-self/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.</p><p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p><p>You must write an algorithm that runs in <code>O(n)</code> time and without using the division operation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4]</span><br><span class="line">Output: [24,12,8,6]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,1,0,-3,3]</span><br><span class="line">Output: [0,0,9,0,0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目不难，我觉得这种小题就是好题，培养分析问题的思维。</li><li>提前构造一个辅助数组表示从右面的累成，然后从左遍历，保留左边的累成，这样就可以求出每个元素两边的累乘。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        suffix[nums.length-<span class="number">2</span>] = nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        suffix[nums.length-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = suffix.length-<span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            suffix[i] = suffix[i+<span class="number">1</span>] * nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            suffix[i] = suffix[i] * pre;</span><br><span class="line">            pre *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>237. Delete Node in a Linked List</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-237-Delete-Node-in-a-Linked-List/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-237-Delete-Node-in-a-Linked-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/delete-node-in-a-linked-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write a function to <strong>delete a node</strong> in a singly-linked list. You will <strong>not</strong> be given access to the <code>head</code> of the list, instead you will be given access to <strong>the node to be deleted</strong> directly.</p><p>It is <strong>guaranteed</strong> that the node to be deleted is <strong>not a tail node</strong> in the list.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/01/node1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [4,5,1,9], node &#x3D; 5</span><br><span class="line">Output: [4,1,9]</span><br><span class="line">Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/01/node2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [4,5,1,9], node &#x3D; 1</span><br><span class="line">Output: [4,5,9]</span><br><span class="line">Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of the nodes in the given list is in the range <code>[2, 1000]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li>The value of each node in the list is <strong>unique</strong>.</li><li>The <code>node</code> to be deleted is <strong>in the list</strong> and is <strong>not a tail</strong> node</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题确实有点取巧，耍小聪明来。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">          ListNode next = node.next;</span><br><span class="line">          node.val = next.val;</span><br><span class="line">          node.next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>236. Lowest Common Ancestor of a Binary Tree</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-236-Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-236-Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[2, 105]</code>.</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>All <code>Node.val</code> are <strong>unique</strong>.</li><li><code>p != q</code></li><li><code>p</code> and <code>q</code> will exist in the tree.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>最近公共祖先问题 LCA问题，也是经典的问题，简单的做法就是 求出跟几点到这个节点的路径，两条路径拿出来，再找第一个相交节点即可</li><li>高级的做法是树链剖分，这个数据结构比较复杂，专门出一章来解释，现在先用简单的做法。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> ArrayList&lt;TreeNode&gt; path1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="keyword">final</span> ArrayList&lt;TreeNode&gt; path2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          findX(path1,root,p.val);</span><br><span class="line">          findX(path2,root,q.val);</span><br><span class="line">          <span class="keyword">int</span> i = path1.size()-<span class="number">1</span>,j = path2.size() -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; path1.size() - path2.size();k++) i--;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; path2.size() - path1.size();k++) j--;</span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (;i &gt;=<span class="number">0</span>;i--,j--) <span class="keyword">if</span> (path1.get(i) == path2.get(j)) <span class="keyword">return</span> path1.get(i);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Integer <span class="title">findX</span><span class="params">(List&lt;TreeNode&gt; path,TreeNode root,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          path.add(root);</span><br><span class="line">          <span class="keyword">if</span> (root.val == t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(findX(path,root.left,t)==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(findX(path,root.right,t) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>234. Palindrome Linked List</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-234-Palindrome-Linked-List/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-234-Palindrome-Linked-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-linked-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a singly linked list, return <code>true</code> if it is a palindrome.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is in the range <code>[1, 105]</code>.</li><li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目就是判断链表是不是回文，你当然可以用容器存下来去判断，那这样肯定是不好的。经典的做法就是 ，找到中点或者上中点，下半段反转，两端进行遍历对比，判断完之后，给人家翻回来。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.val == head.next.val;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next; <span class="comment">//目的是上中点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode mid = slow; <span class="comment">//slow 为 mid or up mid</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        slow = mid.next;</span><br><span class="line">        mid.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = slow.next;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        slow = pre;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( slow!= <span class="keyword">null</span> &amp;&amp; fast.val == slow.val)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> res = slow == <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//修正</span></span><br><span class="line">        slow = pre; <span class="comment">//pre在最后一个节点</span></span><br><span class="line">        pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre =slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        mid.next = pre;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>230. Kth Smallest Element in a BST</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-230-Kth-Smallest-Element-in-a-BST/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-230-Kth-Smallest-Element-in-a-BST/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-smallest-element-in-a-bst/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>kth</code> <em>smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is <code>n</code>.</li><li><code>1 &lt;= k &lt;= n &lt;= 104</code></li><li><code>0 &lt;= Node.val &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>BST中寻找第K小，其实就是中序遍历的第K个节点,直接递归时候找出来就行</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(root,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">process</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root== <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> l = process(root.left, k);</span><br><span class="line">        <span class="keyword">if</span> (l != -<span class="number">1</span>) <span class="keyword">return</span> l;</span><br><span class="line">        c++;</span><br><span class="line">        <span class="keyword">if</span>(c == k) <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> r = process(root.right, k);</span><br><span class="line">        <span class="keyword">if</span> (r != -<span class="number">1</span>) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>227. Basic Calculator II</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-227-Basic-Calculator-II/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-227-Basic-Calculator-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/basic-calculator-ii/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/basic-calculator-ii/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> which represents an expression, <em>evaluate this expression and return its value</em>. </p><p>The integer division should truncate toward zero.</p><p>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-231, 231 - 1]</code>.</p><p><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot; 3&#x2F;2 &quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot; 3+5 &#x2F; 2 &quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> consists of integers and operators <code>(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)</code> separated by some number of spaces.</li><li><code>s</code> represents <strong>a valid expression</strong>.</li><li>All the integers in the expression are non-negative integers in the range <code>[0, 231 - 1]</code>.</li><li>The answer is <strong>guaranteed</strong> to fit in a <strong>32-bit integer</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这道题目是一种常见的思路，乘除的时候先算，在队列里存放加减的序列,然后遍历计算一下可以。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Deque&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (chars[i] == <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] &lt;= <span class="string">'9'</span> &amp;&amp; chars[i] &gt;= <span class="string">'0'</span>) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (chars[i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addNum(queue,num);</span><br><span class="line">                queue.addLast(String.valueOf(chars[i]));</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addNum(queue,num);</span><br><span class="line">        <span class="keyword">return</span>  getRes(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(Deque&lt;String&gt; queue,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!queue.isEmpty() &amp;&amp; (queue.peekLast().equals(<span class="string">"*"</span>) || queue.peekLast().equals(<span class="string">"/"</span>))) &#123;</span><br><span class="line">            String exp = queue.removeLast();</span><br><span class="line">            Integer a = Integer.valueOf(queue.removeLast());</span><br><span class="line">            <span class="keyword">if</span> (exp.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">                num = a * num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num = a / num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.addLast(String.valueOf(num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRes</span><span class="params">(Deque&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.valueOf(queue.removeFirst());</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            String exp = queue.removeFirst();</span><br><span class="line">            String num = queue.removeFirst();</span><br><span class="line">            <span class="keyword">if</span>(exp.equals(<span class="string">"+"</span>))&#123;</span><br><span class="line">                res += Integer.valueOf(num);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                res -= Integer.valueOf(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>218. The Skyline Problem</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-218-The-Skyline-Problem/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-218-The-Skyline-Problem/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>217. Contains Duplicate</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-217-Contains-Duplicate/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-217-Contains-Duplicate/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/contains-duplicate/" target="_blank" rel="noopener">https://leetcode.com/problems/contains-duplicate/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, return <code>true</code> if any value appears <strong>at least twice</strong> in the array, and return <code>false</code> if every element is distinct.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>考察会不会编程。</li><li>发现 用for each 循环 比普通的循环要快！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; nums.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            if (set.contains(nums[i])) return true;</span></span><br><span class="line"><span class="comment">//            set.add(nums[i]);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(i)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>215. Kth Largest Element in an Array</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-215-Kth-Largest-Element-in-an-Array/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-215-Kth-Largest-Element-in-an-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-largest-element-in-an-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>kth</code> <em>largest element in the array</em>.</p><p>Note that it is the <code>kth</code> largest element in the sorted order, not the <code>kth</code> distinct element.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,5,6,4], k &#x3D; 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,3,1,2,4,5,5,6], k &#x3D; 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>利用快排枢轴的方法，寻找第K大元素，经典题目.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span>  nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> process(nums,k,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> kth,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line"><span class="comment">//            System.out.println("i:"+i +" j:"+j +" kth:"+kth);</span></span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp =  nums[i];</span><br><span class="line">        <span class="keyword">int</span> p1 = i,p2 = j;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; p2)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p2 &gt; p1 &amp;&amp; nums[p2] &lt; tmp)&#123;</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p1 &lt; p2)&#123;</span><br><span class="line">                nums[p1] = nums[p2];</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; p2 &amp;&amp; nums[p1] &gt;= tmp)&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p1 &lt; p2)&#123;</span><br><span class="line">                nums[p2] = nums[p1];</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[p1] = tmp; <span class="comment">//p1位置确定</span></span><br><span class="line">        <span class="keyword">int</span> cur_k = p1 - i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur_k == kth) <span class="keyword">return</span> nums[p1];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur_k &gt; kth) <span class="keyword">return</span> process(nums,kth,i,p1-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> process(nums,kth-cur_k,p1+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Quick Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>212. Word Search II</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-212-Word-Search-II/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-212-Word-Search-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/word-search-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> <code>board</code> of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.</p><p>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words &#x3D; [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class="line">Output: [&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words &#x3D; [&quot;abcb&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 12</code></li><li><code>board[i][j]</code> is a lowercase English letter.</li><li><code>1 &lt;= words.length &lt;= 3 * 104</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>words[i]</code> consists of lowercase English letters.</li><li>All the strings of <code>words</code> are unique.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个和word Search 一的区别是，一只是给了一个单词，去判定存不存在，直接暴力搜就行，现在是判断一堆单词 看看拿个存在，也就是暴力搜的时候，你这个字符不仅仅是和一个单词的字符去比了，你要看，当前路径形成的单词有没有这个单词啊？是不是某个单词的前缀啊？要是直接比那就麻烦了，需要用有序表遍历挨个比，所以应该想到什么，Trie！它去组织单词，给组织起来，当前位置是单词就是，如果是路径也可以继续走，如果不是则直接返回。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        Node root;</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            Node[] nodes;</span><br><span class="line">            <span class="keyword">boolean</span> isWord;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = chars[i]-<span class="string">'a'</span>;</span><br><span class="line">                cur.nodes[index] = cur.nodes[index] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node():cur.nodes[index];</span><br><span class="line">                cur = cur.nodes[index];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] path = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            prefixTree.insert(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                process(res,path,<span class="number">0</span>,i,j,prefixTree.root,board);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; res,<span class="keyword">char</span>[] path,<span class="keyword">int</span> k,<span class="keyword">int</span> i,<span class="keyword">int</span> j,PrefixTree.Node cur,<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index = board[i][j] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.nodes[index] == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">         path[k] = board[i][j];</span><br><span class="line">         board[i][j] = <span class="string">'-'</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur.nodes[index].isWord) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(path,<span class="number">0</span>,k+<span class="number">1</span>));</span><br><span class="line">            cur.nodes[index].isWord = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续以感染的方式 继续检测单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">4</span>;d++)&#123;</span><br><span class="line">            process(res,path,k+<span class="number">1</span>,i+dir_x[d],j+dir_y[d],cur.nodes[index],board);</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = path[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>210. Course Schedule II</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-210-Course-Schedule-II/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-210-Course-Schedule-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/course-schedule-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/course-schedule-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you <strong>must</strong> take course <code>bi</code> first if you want to take course <code>ai</code>.</p><ul><li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li></ul><p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 4, prerequisites &#x3D; [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">Output: [0,2,1,3]</span><br><span class="line">Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.</span><br><span class="line">So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 1, prerequisites &#x3D; []</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>ai != bi</code></li><li>All the pairs <code>[ai, bi]</code> are <strong>distinct</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>和课程安排一 没啥区别。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numCourses == <span class="number">1</span> ) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] v_edge = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, List&gt; adjacent = getAdjacent(prerequisites,v_edge);</span><br><span class="line">        <span class="keyword">return</span> judge(v_edge,adjacent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, List&gt; <span class="title">getAdjacent</span><span class="params">(<span class="keyword">int</span>[][] prerequisites, <span class="keyword">int</span>[] v_edge)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, List&gt; adject = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> from = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            v_edge[to]++;</span><br><span class="line">            <span class="keyword">if</span>(adject.containsKey(from))&#123;</span><br><span class="line">                adject.get(from).add(to);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(to);</span><br><span class="line">                adject.put(from,list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] judge(<span class="keyword">int</span>[] v_edge,Map&lt;Integer, List&gt; map)&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] collect = <span class="keyword">new</span> <span class="keyword">int</span>[v_edge.length];</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v_edge.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v_edge[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">final</span> Integer v = queue.poll();</span><br><span class="line">            collect[res++] = v;</span><br><span class="line">            <span class="keyword">final</span> List&lt;Integer&gt; list = map.get(v);</span><br><span class="line">            <span class="keyword">if</span>(list != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                    Integer t = list.get(i);</span><br><span class="line">                    <span class="keyword">if</span>(--v_edge[t] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res == v_edge.length) <span class="keyword">return</span> collect;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Topological Sorting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>208. Implement Trie (Prefix Tree)</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-208-Implement-Trie-Prefix-Tree/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-208-Implement-Trie-Prefix-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-trie-prefix-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A <a href="https://en.wikipedia.org/wiki/Trie" target="_blank" rel="noopener"><strong>trie</strong></a> (pronounced as “try”) or <strong>prefix tree</strong> is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p><p>Implement the Trie class:</p><ul><li><code>Trie()</code> Initializes the trie object.</li><li><code>void insert(String word)</code> Inserts the string <code>word</code> into the trie.</li><li><code>boolean search(String word)</code> Returns <code>true</code> if the string <code>word</code> is in the trie (i.e., was inserted before), and <code>false</code> otherwise.</li><li><code>boolean startsWith(String prefix)</code> Returns <code>true</code> if there is a previously inserted string <code>word</code> that has the prefix <code>prefix</code>, and <code>false</code> otherwise.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">Output</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; return True</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; return False</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; return True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; return True</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code> and <code>prefix</code> consist only of lowercase English letters.</li><li>At most <code>3 * 104</code> calls <strong>in total</strong> will be made to <code>insert</code>, <code>search</code>, and <code>startsWith</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个没什么难度，让实现一个Trie，只要学过这个东西，不难的。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Node[] nodes;</span><br><span class="line">        <span class="keyword">boolean</span> isWord;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = chars[i]-<span class="string">'a'</span>;</span><br><span class="line">            cur.nodes[index] = cur.nodes[index] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node():cur.nodes[index];</span><br><span class="line">            cur = cur.nodes[index];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = chars[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.nodes[index] != <span class="keyword">null</span>)</span><br><span class="line">                cur = cur.nodes[index];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = prefix.toCharArray();</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = chars[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.nodes[index] != <span class="keyword">null</span>)</span><br><span class="line">                cur = cur.nodes[index];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trie </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>207. Course Schedule</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-207-Course-Schedule/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-207-Course-Schedule/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">https://leetcode.com/problems/course-schedule/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you <strong>must</strong> take course <code>bi</code> first if you want to take course <code>ai</code>.</p><ul><li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li></ul><p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li>All the pairs prerequisites[i] are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>课程安排。典型的拓扑排序。图论的算法，有机会单独总结一次。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numCourses == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span>[] v_edge = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, List&gt; adjacent = getAdjacent(prerequisites,v_edge);</span><br><span class="line">        <span class="keyword">return</span> judge(v_edge,adjacent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, List&gt; <span class="title">getAdjacent</span><span class="params">(<span class="keyword">int</span>[][] prerequisites,<span class="keyword">int</span>[] v_edge)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, List&gt; adject = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> from = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            v_edge[to]++;</span><br><span class="line">            <span class="keyword">if</span>(adject.containsKey(from))&#123;</span><br><span class="line">                adject.get(from).add(to);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(to);</span><br><span class="line">                adject.put(from,list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span>[] v_edge,Map&lt;Integer, List&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v_edge.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v_edge[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">final</span> Integer v = queue.poll();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">final</span> List&lt;Integer&gt; list = map.get(v);</span><br><span class="line">            <span class="keyword">if</span>(list != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                    Integer t = list.get(i);</span><br><span class="line">                    <span class="keyword">if</span>(--v_edge[t] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == v_edge.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Algorithm -Topological Sorting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206. Reverse Linked List</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-206-Reverse-Linked-List/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-206-Reverse-Linked-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: [5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2]</span><br><span class="line">Output: [2,1]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个就是遍历一趟，把扫过的指针反向即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode cur = head,pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>204. Count Primes</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-204-Count-Primes/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-204-Count-Primes/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/count-primes/" target="_blank" rel="noopener">https://leetcode.com/problems/count-primes/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em>the number of prime numbers that are strictly less than</em> <code>n</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 10</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= n &lt;= 5 * 106</code></li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>数数素数，利用打表法，开数组，把素数打出来，再数就可以了。我们这里说的数素数指的是 埃及素数筛选法，时间复杂度是loglog(N)。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">boolean</span>[] primer = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9000000</span>]; <span class="comment">//false代表是</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; <span class="number">9000000</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!primer[i])&#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                    set.add(i);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>;j &lt; <span class="number">9000000</span>;j += i)&#123;</span><br><span class="line">                        primer[j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Integer primer_floor = set.floor(n);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> loc = list.indexOf(primer_floor);</span><br><span class="line">        <span class="keyword">if</span> (set.contains(n))&#123;</span><br><span class="line">            <span class="keyword">return</span> loc;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> loc +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>202. Happy Number</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-202-Happy-Number/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-202-Happy-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="noopener">https://leetcode.com/problems/happy-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write an algorithm to determine if a number <code>n</code> is happy.</p><p>A <strong>happy number</strong> is a number defined by the following process:</p><ul><li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li><li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li><li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li></ul><p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 19</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>看着是数学题，可是也不需要找规律，就是模拟实现一下就过了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!(set.contains(n) || n == <span class="number">1</span>))&#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            <span class="keyword">int</span> c = n;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (c != <span class="number">0</span>)&#123;</span><br><span class="line">                res += (c%<span class="number">10</span>)*(c%<span class="number">10</span>);</span><br><span class="line">                c /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !set.contains(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>200. Number of Islands</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-200-Number-of-Islands/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-200-Number-of-Islands/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-islands/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p><p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典的岛屿问题，数有多少个岛屿，一般两种做法，一个是感染的思路，遍历矩阵，对每个没遍历过的，从它开始进行BFS感染，把整个联通块串起来，并且标记好访问过，那么 循环矩阵时，进行过几次BFS，就是几个块。</li><li>典型的并查集，并查集的作用就是来判断两个元素是不是在同一个集合，进行集合的合并，同时可以记录有多少个集合，每个集合有多少个元素等。我们对矩阵中的元素，对每一个都看它的右面和下面，进行集合的合并。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span>[] parents;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">boolean</span>[] root; <span class="comment">//是不是根</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parent = c;</span><br><span class="line">        <span class="keyword">while</span> (parents[parent] != parent)&#123;</span><br><span class="line">            parent = parents[parent];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//路经压缩</span></span><br><span class="line">        parents[c] = parent;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root_a = find(a);</span><br><span class="line">        <span class="keyword">int</span> root_b = find(b);</span><br><span class="line">        <span class="keyword">if</span>(root_a != root_b)&#123;</span><br><span class="line">            parents[root_a] = root_b;</span><br><span class="line">            root[root_a] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        parents = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length*grid[<span class="number">0</span>].length];</span><br><span class="line">        root = <span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length*grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parents.length; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  =<span class="number">0</span> ;i &lt; grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    root[i*grid[<span class="number">0</span>].length+j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; grid[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[<span class="number">0</span>][i] == <span class="string">'1'</span> &amp;&amp; grid[<span class="number">0</span>][i-<span class="number">1</span>] ==<span class="string">'1'</span>)&#123;</span><br><span class="line">                union(i-<span class="number">1</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="comment">//看左面</span></span><br><span class="line">                    <span class="keyword">if</span>(j != <span class="number">0</span> &amp;&amp; grid[i][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                        union(i*grid[<span class="number">0</span>].length+j-<span class="number">1</span>,i*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(grid[i-<span class="number">1</span>][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                        union((i-<span class="number">1</span>)*grid[<span class="number">0</span>].length+j,i*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root[i]) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>198. House Robber</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-198-House-Robber/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-198-House-Robber/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">https://leetcode.com/problems/house-robber/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).</span><br><span class="line">Total amount you can rob &#x3D; 1 + 3 &#x3D; 4.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 2), rob house 3 (money &#x3D; 9) and rob house 5 (money &#x3D; 1).</span><br><span class="line">Total amount you can rob &#x3D; 2 + 9 + 1 &#x3D; 12.</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>打家劫舍 经典题目啊，像打家劫舍、循环的打家劫舍、点灯问题、循环的点灯问题 其实都差不多。</li><li>我们定义dp[i],代表 [i,len-1] 能拿到的最大值，那么此时有<script type="math/tex">dp[i] = max(dp[i+1],num[i]+dp[i+2])</script>,其实只跟后面两个元素有关，改成变量迭代的方式，省掉空间。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = nums[N-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = pre;</span><br><span class="line">            pre = Math.max(nums[i] + pre2,pre);</span><br><span class="line">            pre2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>191. Number of 1 Bits</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-191-Number-of-1-Bits/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-191-Number-of-1-Bits/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-1-bits/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">Hamming weight</a>).</p><p><strong>Note:</strong></p><ul><li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</li><li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two&#39;s_complement" target="_blank" rel="noopener">2’s complement notation</a>. Therefore, in <strong>Example 3</strong>, the input represents the signed integer. <code>-3</code>.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 00000000000000000000000000001011</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The input binary string 00000000000000000000000000001011 has a total of three &#39;1&#39; bits.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 00000000000000000000000010000000</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The input binary string 00000000000000000000000010000000 has a total of one &#39;1&#39; bit.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 11111111111111111111111111111101</span><br><span class="line">Output: 31</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &#39;1&#39; bits.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The input must be a <strong>binary string</strong> of length <code>32</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>遍历数一下就行，只不过这里，咱们通过取最右侧第一个1的方式，而不是一位一位无脑的遍历，这样就更快点。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( n!= <span class="number">0</span>)&#123;</span><br><span class="line">            n -= (n &amp; (-n));</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>190. Reverse Bits</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-190-Reverse-Bits/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-190-Reverse-Bits/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/reverse-bits/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-bits/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Reverse bits of a given 32 bits unsigned integer.</p><p><strong>Note:</strong></p><ul><li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</li><li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two&#39;s_complement" target="_blank" rel="noopener">2’s complement notation</a>. Therefore, in <strong>Example 2</strong> above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 00000010100101000001111010011100</span><br><span class="line">Output:    964176192 (00111001011110000010100101000000)</span><br><span class="line">Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 11111111111111111111111111111101</span><br><span class="line">Output:   3221225471 (10111111111111111111111111111111)</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The input must be a <strong>binary string</strong> of length <code>32</code></li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>我们就用一个比较简单的操作交换即可，就不借鉴各路大神的操作了。</li><li>对bit位交换，如果一样那就不用交换，如果不一样，各自位取反即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">16</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> M = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">            <span class="keyword">int</span> left = (M &amp; n);</span><br><span class="line">            <span class="keyword">int</span> right = (N &amp; n);</span><br><span class="line">            <span class="keyword">if</span>(left != <span class="number">0</span>&amp;&amp; right==<span class="number">0</span> || left==<span class="number">0</span> &amp;&amp; right!= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left == <span class="number">0</span>)&#123;</span><br><span class="line">                    n |= M;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    n &amp;= ~(M);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(right == <span class="number">0</span>)&#123;</span><br><span class="line">                    n |= N;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    n &amp;= ~(N);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>189. Rotate Array</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-189-Rotate-Array/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-189-Rotate-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-array/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,-100,3,99], k &#x3D; 2</span><br><span class="line">Output: [3,99,-1,-100]</span><br><span class="line">Explanation: </span><br><span class="line">rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class="line">rotate 2 steps to the right: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= k &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典的交换题目，三次交换即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; nums.length) k = k % nums.length;</span><br><span class="line">        swap(nums,nums.length-k,nums.length-<span class="number">1</span>);</span><br><span class="line">        swap(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>-k);</span><br><span class="line">        swap(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = l,p2 = r;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; p2)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[p1];</span><br><span class="line">            nums[p1] = nums[p2];</span><br><span class="line">            nums[p2] = temp;</span><br><span class="line">            p1++;</span><br><span class="line">            p2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>179. Largest Number</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-179-Largest-Number/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-179-Largest-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/largest-number/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a list of non-negative integers <code>nums</code>, arrange them such that they form the largest number and return it.</p><p>Since the result may be very large, so you need to return a string instead of an integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [10,2]</span><br><span class="line">Output: &quot;210&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,30,34,5,9]</span><br><span class="line">Output: &quot;9534330&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题是贪心，我们排序一下，排序时候，要不要交换，要看当前两个元素的是不交换拼接的值大，还是交换之后拼接的值大！</li><li>这就是贪心策略，应该多积累，见过就会，没见过就难想.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            list.add(String.valueOf(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        list.sort((a,b)-&gt;-(a+b).compareTo(b+a));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.length() != <span class="number">0</span> || !list.get(i).equals(<span class="string">"0"</span>) || i == list.size()-<span class="number">1</span>)</span><br><span class="line">                res.append(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Greed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>172. Factorial Trailing Zeroes</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-172-Factorial-Trailing-Zeroes/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-172-Factorial-Trailing-Zeroes/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/factorial-trailing-zeroes/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em>the number of trailing zeroes in</em> <code>n!</code>.</p><p>Note that <code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: 3! &#x3D; 6, no trailing zero.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 5</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 5! &#x3D; 120, one trailing zero.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= n &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这道题是与质数有关的题目，一个数的介乘分解质因数后有多少个质数a？这个是典型的题目</li><li>此题就是问，分解后有多少个5，因为2 * 5 = 10，而2的质数远比5多啊，所以取决于5</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">            res += n/<span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>171. Excel Sheet Column Number</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-171-Excel-Sheet-Column-Number/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-171-Excel-Sheet-Column-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">https://leetcode.com/problems/excel-sheet-column-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>columnTitle</code> that represents the column title as appears in an Excel sheet, return <em>its corresponding column number</em>.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: columnTitle &#x3D; &quot;A&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: columnTitle &#x3D; &quot;AB&quot;</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: columnTitle &#x3D; &quot;ZY&quot;</span><br><span class="line">Output: 701</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= columnTitle.length &lt;= 7</code></li><li><code>columnTitle</code> consists only of uppercase English letters.</li><li><code>columnTitle</code> is in the range <code>[&quot;A&quot;, &quot;FXSHRXW&quot;]</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是简单的映射</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String columnTitle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = columnTitle.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            res = res * <span class="number">26</span> + (chars[i] - <span class="string">'A'</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>169. Majority Element</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-169-Majority-Element/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-169-Majority-Element/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">https://leetcode.com/problems/majority-element/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array <code>nums</code> of size <code>n</code>, return <em>the majority element</em>.</p><p>The majority element is the element that appears more than <code>⌊n / 2⌋</code> times. You may assume that the majority element always exists in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>水王问题、摩尔投票问题都是一类，这个考察的是，如果存在大于一半的元素，至多是一个，同理推导，对于N个元素中，要求个数大于 N/k的元素，这样元素至多是k-1个，不可能是k个。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>,elem = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == elem)&#123;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(--c &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    c = <span class="number">1</span>;</span><br><span class="line">                    elem = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>166. Fraction to Recurring Decimal</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-166-Fraction-to-Recurring-Decimal/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-166-Fraction-to-Recurring-Decimal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/fraction-to-recurring-decimal/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/fraction-to-recurring-decimal/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.</p><p>If the fractional part is repeating, enclose the repeating part in parentheses.</p><p>If multiple answers are possible, return <strong>any of them</strong>.</p><p>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>104</code> for all the given inputs.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numerator &#x3D; 1, denominator &#x3D; 2</span><br><span class="line">Output: &quot;0.5&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numerator &#x3D; 2, denominator &#x3D; 1</span><br><span class="line">Output: &quot;2&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numerator &#x3D; 4, denominator &#x3D; 333</span><br><span class="line">Output: &quot;0.(012)&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= numerator, denominator &lt;= 231 - 1</code></li><li><code>denominator != 0</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>做这道题 关键是寻找循环节，可以通过余数去判断。</li><li>用map去记录位置，找到循环节然后插入括号。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numerator == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">&#125;</span><br><span class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// "+" or "-"</span></span><br><span class="line">res.append(((numerator &gt; <span class="number">0</span>) ^ (denominator &gt; <span class="number">0</span>)) ? <span class="string">"-"</span> : <span class="string">""</span>);</span><br><span class="line"><span class="keyword">long</span> num = Math.abs((<span class="keyword">long</span>) numerator);</span><br><span class="line"><span class="keyword">long</span> den = Math.abs((<span class="keyword">long</span>) denominator);</span><br><span class="line"><span class="comment">// integral part</span></span><br><span class="line">res.append(num / den);</span><br><span class="line">num %= den;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fractional part</span></span><br><span class="line">res.append(<span class="string">"."</span>);</span><br><span class="line">HashMap&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Long, Integer&gt;();</span><br><span class="line">map.put(num, res.length());</span><br><span class="line"><span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">num *= <span class="number">10</span>;</span><br><span class="line">res.append(num / den);</span><br><span class="line">num %= den;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(num)) &#123;</span><br><span class="line"><span class="keyword">int</span> index = map.get(num);</span><br><span class="line">res.insert(index, <span class="string">"("</span>);</span><br><span class="line">res.append(<span class="string">")"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(num, res.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>162. Find Peak Element</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-162-Find-Peak-Element/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-162-Find-Peak-Element/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="noopener">https://leetcode.com/problems/find-peak-element/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A peak element is an element that is strictly greater than its neighbors.</p><p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <strong>any of the peaks</strong>.</p><p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</p><p>You must write an algorithm that runs in <code>O(log n)</code> time.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>nums[i] != nums[i + 1]</code> for all valid <code>i</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>要求log(N)，提示很明确了二分。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> res = isPeek(nums, mid);</span><br><span class="line">            <span class="keyword">if</span>(res == <span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(res &lt; <span class="number">0</span>) r = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isPeek</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mid == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[mid+<span class="number">1</span>] &lt; nums[mid] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (mid == nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[mid] &gt; nums[mid-<span class="number">1</span>] ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid-<span class="number">1</span>] &lt; nums[mid] &amp;&amp; nums[mid] &lt; nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//往右走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid-<span class="number">1</span>] &gt; nums[mid] &amp;&amp; nums[mid] &gt; nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//往左走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid-<span class="number">1</span>] &gt; nums[mid] &amp;&amp; nums[mid] &lt; nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160. Intersection of Two Linked Lists</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-160-Intersection-of-Two-Linked-Lists/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-160-Intersection-of-Two-Linked-Lists/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-linked-lists/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p><p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_statement.png" alt="img"></p><p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p><p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p><p><strong>Custom Judge:</strong></p><p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p><ul><li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li><li><code>listA</code> - The first linked list.</li><li><code>listB</code> - The second linked list.</li><li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li><li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li></ul><p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">Output: Intersected at &#39;8&#39;</span><br><span class="line">Explanation: The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect).</span><br><span class="line">From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">Output: Intersected at &#39;2&#39;</span><br><span class="line">Explanation: The intersected node&#39;s value is 2 (note that this must not be 0 if the two lists intersect).</span><br><span class="line">From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">Output: No intersection</span><br><span class="line">Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.</span><br><span class="line">Explanation: The two lists do not intersect, so return null.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes of <code>listA</code> is in the <code>m</code>.</li><li>The number of nodes of <code>listB</code> is in the <code>n</code>.</li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt; m</code></li><li><code>0 &lt;= skipB &lt; n</code></li><li><code>intersectVal</code> is <code>0</code> if <code>listA</code> and <code>listB</code> do not intersect.</li><li><code>intersectVal == listA[skipA] == listB[skipB]</code> if <code>listA</code> and <code>listB</code> intersect.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个就是找第一个公共结点，只需要让长度长的链表提前跑，使两个链表指针，在从后面开始数长度相同的位置开始，一块遍历即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> &amp;&amp; headB != <span class="keyword">null</span> || headB == <span class="keyword">null</span> &amp;&amp; headA != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cntA = <span class="number">0</span>,cntB = <span class="number">0</span>;</span><br><span class="line">        ListNode p1 = headA,p2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cntA++;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cntB++;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = headA;</span><br><span class="line">        p2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (cntA - cntB &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            cntA--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cntB - cntA &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            cntB--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span> &amp;&amp; p1 != p2)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>155. Min Stack</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-155-Min-Stack/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-155-Min-Stack/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">https://leetcode.com/problems/min-stack/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><p>Implement the <code>MinStack</code> class:</p><ul><li><code>MinStack()</code> initializes the stack object.</li><li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li><li><code>void pop()</code> removes the element on the top of the stack.</li><li><code>int top()</code> gets the top element of the stack.</li><li><code>int getMin()</code> retrieves the minimum element in the stack.</li></ul><p>You must implement a solution with <code>O(1)</code> time complexity for each function.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin(); &#x2F;&#x2F; return -3</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();    &#x2F;&#x2F; return 0</span><br><span class="line">minStack.getMin(); &#x2F;&#x2F; return -2</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.</li><li>At most <code>3 * 104</code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此类题目就是要求你重做数据结构，实现某种功能    </li><li>此题考查的是栈</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     Stack&lt;Integer&gt; stack;</span><br><span class="line">    Stack&lt;Integer&gt; min_stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        min_stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       stack.push(val);</span><br><span class="line">        <span class="keyword">if</span> (min_stack.isEmpty())&#123;</span><br><span class="line">            min_stack.push(val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            min_stack.push(val &lt; min_stack.peek()?val:min_stack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        min_stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>152. Maximum Product Subarray</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-152-Maximum-Product-Subarray/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-152-Maximum-Product-Subarray/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-product-subarray/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, find a contiguous non-empty subarray within the array that has the largest product, and return <em>the product</em>.</p><p>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p><p>A <strong>subarray</strong> is a contiguous subsequence of the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,-2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [2,3] has the largest product 6.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,0,-1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>最大乘积子数组，dp_max[i]表示 以i结尾的最大乘积子数组，dp_min[i]表示以i结尾的最小乘积子数组,主要是数值可能是负的，可能会出现负负得正的情况，那我们可以避开这种详细的讨论，因为答案一定在与dp_min数组或者dp_max数组乘积中可以得出。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min_pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max_pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = max_pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = Math.min(Math.min(nums[i],min_pre*nums[i]),nums[i]*max_pre);</span><br><span class="line">            max_pre = Math.max(Math.max(nums[i],max_pre*nums[i]),nums[i]*min_pre);</span><br><span class="line">            min_pre = tmp;</span><br><span class="line">            res = Math.max(res,max_pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>150. Evaluate Reverse Polish Notation</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-150-Evaluate-Reverse-Polish-Notation/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-150-Evaluate-Reverse-Polish-Notation/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">https://leetcode.com/problems/evaluate-reverse-polish-notation/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank" rel="noopener">Reverse Polish Notation</a>.</p><p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. Each operand may be an integer or another expression.</p><p><strong>Note</strong> that division between two integers should truncate toward zero.</p><p>It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: ((2 + 1) * 3) &#x3D; 9</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;&#x2F;&quot;,&quot;+&quot;]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: (4 + (13 &#x2F; 5)) &#x3D; 6</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;&#x2F;&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">Output: 22</span><br><span class="line">Explanation: ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> is either an operator: <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, <code>&quot;*&quot;</code>, or <code>&quot;/&quot;</code>, or an integer in the range <code>[-200, 200]</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是计算后缀表达式</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> [] stack = <span class="keyword">new</span> <span class="keyword">int</span>[tokens.length];</span><br><span class="line">        <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">            String c = tokens[i];</span><br><span class="line">            <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"+"</span>:&#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> a = stack[top--];</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> b = stack[top--];</span><br><span class="line">                    stack[++top] = a + b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"-"</span>:&#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> a = stack[top--];</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> b = stack[top--];</span><br><span class="line">                    stack[++top] = b-a;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"*"</span>:&#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> a = stack[top--];</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> b = stack[top--];</span><br><span class="line">                    stack[++top] = a * b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"/"</span> : &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> a = stack[top--];</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> b = stack[top--];</span><br><span class="line">                    stack[++top] = b /a ;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:&#123;</span><br><span class="line">                    <span class="comment">//操作数</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> v = Integer.parseInt(c);</span><br><span class="line">                    stack[++top] = v;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)stack[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>149. Max Points on a Line</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-149-Max-Points-on-a-Line/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-149-Max-Points-on-a-Line/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">https://leetcode.com/problems/max-points-on-a-line/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of <code>points</code> where <code>points[i] = [xi, yi]</code> represents a point on the <strong>X-Y</strong> plane, return <em>the maximum number of points that lie on the same straight line</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[1,1],[2,2],[3,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= points.length &lt;= 300</code></li><li><code>points[i].length == 2</code></li><li><code>-104 &lt;= xi, yi &lt;= 104</code></li><li>All the <code>points</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个看规模 长度最大 300，300个点，就for循环遍历一点问题没有</li><li>分析题目，其实就查 和你在一条直线上的点，用两个点计算出表达式，计算后面点是不是在表达式上，统计个数，拿出最大值即可。</li><li>注意！做差和0比的时候，double 这种浮点数容易出现精度问题，导致结果不是0，拿精度比。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line">        <span class="keyword">int</span> N = points.length;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p1 = <span class="number">0</span>; p1 &lt; N - <span class="number">1</span>; p1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = p1 + <span class="number">1</span>; t &lt; N; t++) &#123;</span><br><span class="line">                <span class="comment">//计算斜率及直线表达式</span></span><br><span class="line">                <span class="keyword">double</span> k = points[t][<span class="number">0</span>] - points[p1][<span class="number">0</span>] == <span class="number">0</span> ? Integer.MAX_VALUE : (<span class="keyword">double</span>)(points[t][<span class="number">1</span>] - points[p1][<span class="number">1</span>]) / (points[t][<span class="number">0</span>] - points[p1][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">double</span> b = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (k != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    b = points[p1][<span class="number">1</span>] - k * points[p1][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> tmp_max = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> p2 = t + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 扫描共线点</span></span><br><span class="line">                <span class="keyword">if</span> (k == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (p2 &lt; N) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (points[p2][<span class="number">0</span>] == points[p1][<span class="number">0</span>]) &#123;</span><br><span class="line">                            tmp_max++;</span><br><span class="line">                            res = Math.max(tmp_max, res);</span><br><span class="line">                        &#125;</span><br><span class="line">                        p2++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (p2 &lt; N) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (Math.abs(points[p2][<span class="number">1</span>]-(k * points[p2][<span class="number">0</span>] + b)) &lt; eps) &#123;</span><br><span class="line">                            tmp_max++;</span><br><span class="line">                            res = Math.max(tmp_max, res);</span><br><span class="line">                        &#125;</span><br><span class="line">                        p2++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>148. Sort List</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-148-Sort-List/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-148-Sort-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/sort-list/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [4,2,1,3]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [-1,5,3,4,0]</span><br><span class="line">Output: [-1,0,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is in the range <code>[0, 5 * 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目难度中等。首先题目是对链表排序，首先想到什么？大声喊出来，没错，我听到了你的回答，归并排序，一个简单而又神奇的算法！</li><li>归并排序，二路归并需要中间分开，可以用快慢指针的方法找到上中点，这些小技巧啊 平时都要用起来才行。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//链表的归并,时间复杂度是N*logN</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> process(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">process</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next ==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">       ListNode fast = head.next,slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode right = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode left = process(head);</span><br><span class="line">        right = process(right);</span><br><span class="line">        <span class="keyword">return</span>  merge(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">merge</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right!= <span class="keyword">null</span>)&#123;</span><br><span class="line">              ListNode cur =<span class="keyword">null</span>,head = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                  ListNode tmp;</span><br><span class="line">                  <span class="keyword">if</span>(left.val &lt; right.val)&#123;</span><br><span class="line">                      tmp = left;</span><br><span class="line">                      left = left.next;</span><br><span class="line">                  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                      tmp = right;</span><br><span class="line">                      right = right.next;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span>(cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      cur = tmp;</span><br><span class="line">                      head = cur;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      cur.next = tmp;</span><br><span class="line">                      cur = cur.next;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">while</span> (left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                  cur.next = left;</span><br><span class="line">                  left = left.next;</span><br><span class="line">                  cur = cur.next;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">while</span> (right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                  cur.next = right;</span><br><span class="line">                  right = right.next;</span><br><span class="line">                  cur = cur.next;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> head;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>146. LRU Cache</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-146-LRU-Cache/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-146-LRU-Cache/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>141. Linked List Cycle</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-141-Linked-List-Cycle/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-141-Linked-List-Cycle/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p><p>Return <code>true</code> <em>if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of the nodes in the list is in the range <code>[0, 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>掌握一个技巧，使用快慢指针，如果成环，他们相遇的第一个节点就是入环节点，很有用的这个技巧，原理证明不用管。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode slow = head,fast = head.next.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>&amp;&amp;fast.next != <span class="keyword">null</span> &amp;&amp; slow != fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow == fast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>140. Word Break II</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-140-Word-Break-II/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-140-Word-Break-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/word-break-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p><p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsanddog&quot;, wordDict &#x3D; [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]</span><br><span class="line">Output: [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;pineapplepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]</span><br><span class="line">Output: [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]</span><br><span class="line">Explanation: Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li><li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li><li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题难度为Hard，但其实和单词分解一差不多，这个要求的不仅仅判断能不能分解，而且把所有的情况都找出来，那这肯定得递归来收集答案了。</li><li>问题是，我们收集时候，即使当前单词能被拆分，那怎么判断这种情况要不要递归下去，因为递归下去目的就是收集答案，我们可以在单词分解一的基础上，利用DP数组，来进行判断是否选择递归。</li><li>一个一个单元点组合起来，就成了一道难题了，要是没有单词分解一的铺垫，你能不能想到，提前打一个dp出来来收集答案呢？其实之前有遇到过类似，比如：回文串分解。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            <span class="keyword">public</span> Node[] nodes; <span class="comment">//26个字母</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">            <span class="keyword">public</span>  String word;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">                isWord = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Node root;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="keyword">null</span> || <span class="string">""</span>.equals(word)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                cur.nodes[chars[i]-<span class="string">'a'</span>] = cur.nodes[chars[i]-<span class="string">'a'</span>] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node(): cur.nodes[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">                cur = cur.nodes[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">            cur.word = word;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordDict.size(); i++) &#123;</span><br><span class="line">            prefixTree.addWord(wordDict.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[N+<span class="number">1</span>];</span><br><span class="line">        dp[N] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] word = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            PrefixTree.Node cur = prefixTree.root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.nodes[word[j]-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur.nodes[word[j]-<span class="string">'a'</span>].isWord&amp;&amp;dp[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur = cur.nodes[word[j]-<span class="string">'a'</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        process(word,<span class="number">0</span>,prefixTree,<span class="keyword">new</span> StringBuilder(),res,dp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] word, <span class="keyword">int</span> index, PrefixTree ptree, StringBuilder builder, List&lt;String&gt; res,<span class="keyword">boolean</span>[] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index  == word.length) &#123;</span><br><span class="line">            builder.deleteCharAt(builder.length() - <span class="number">1</span>);</span><br><span class="line">            res.add(builder.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PrefixTree.Node cur = ptree.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index;i &lt; word.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.nodes[word[i]-<span class="string">'a'</span>] != <span class="keyword">null</span> &amp;&amp; cur.nodes[word[i]-<span class="string">'a'</span>].isWord &amp;&amp; dp[i+<span class="number">1</span>])&#123;</span><br><span class="line">                builder.append(cur.nodes[word[i]-<span class="string">'a'</span>].word+<span class="string">" "</span>);</span><br><span class="line">                process(word,i+<span class="number">1</span>,ptree,builder,res,dp);</span><br><span class="line">                builder.delete(builder.lastIndexOf(cur.nodes[word[i]-<span class="string">'a'</span>].word),builder.length());</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.nodes[word[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>139. Word Break</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-139-Word-Break/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-139-Word-Break/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-break/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/word-break/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;,&quot;code&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.</span><br><span class="line">Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 300</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li><li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li><li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>不难想，无非就是递归来切这个字符串，每切的时候还得判断，当前切的这一下是在单词表中的吗？把单词表用有序表存起来，查找时间仍和这个查找的字符串长度有关。我们可以用Trie，把单词表组织起来，有路代表能组成单词，可以加快查找过程。</li><li>此外，我们定义dp[i]，代表[i,len-1]的字符串能否被单词表分解？dp[0]则是答案。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            <span class="keyword">public</span> Node[] nodes; <span class="comment">//26个字母</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">            <span class="keyword">public</span>  String word;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">                isWord = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Node root;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="keyword">null</span> || <span class="string">""</span>.equals(word)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                cur.nodes[chars[i]-<span class="string">'a'</span>] = cur.nodes[chars[i]-<span class="string">'a'</span>] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node(): cur.nodes[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">                cur = cur.nodes[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">            cur.word = word;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordDict.size(); i++) &#123;</span><br><span class="line">            prefixTree.addWord(wordDict.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[N+<span class="number">1</span>];</span><br><span class="line">        dp[N] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] word = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            PrefixTree.Node cur = prefixTree.root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.nodes[word[j]-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur.nodes[word[j]-<span class="string">'a'</span>].isWord&amp;&amp;dp[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur = cur.nodes[word[j]-<span class="string">'a'</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>138. Copy List with Random Pointer</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-138-Copy-List-with-Random-Pointer/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-138-Copy-List-with-Random-Pointer/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">https://leetcode.com/problems/copy-list-with-random-pointer/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p><p>Construct a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="noopener"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p><p>For example, if there are two nodes <code>X</code> and <code>Y</code> in the original list, where <code>X.random --&gt; Y</code>, then for the corresponding two nodes <code>x</code> and <code>y</code> in the copied list, <code>x.random --&gt; y</code>.</p><p>Return <em>the head of the copied linked list</em>.</p><p>The linked list is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p><ul><li><code>val</code>: an integer representing <code>Node.val</code></li><li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</li></ul><p>Your code will <strong>only</strong> be given the <code>head</code> of the original linked list.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/12/18/e1.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/12/18/e2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [[1,1],[2,1]]</span><br><span class="line">Output: [[1,1],[2,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2019/12/18/e3.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [[3,null],[3,0],[3,null]]</span><br><span class="line">Output: [[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>-104 &lt;= Node.val &lt;= 104</code></li><li><code>Node.random</code> is <code>null</code> or is pointing to some node in the linked list.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目难度中等，看你会不会灵活处理。对已有的链表，模仿着创造出一条新的来，random也要指向对应新的节点才可以。</li><li>遍历3次，第一次再节点后面插入一个新的节点，第二次将对应的random指向好，第三次，将对应的新节点串联起来。 </li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node new_node = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">            new_node.next = cur.next;</span><br><span class="line">            cur.next = new_node;</span><br><span class="line">            cur = new_node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        Node new_head  = <span class="keyword">null</span>;</span><br><span class="line">        Node new_last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node random = cur.random;</span><br><span class="line">            <span class="keyword">if</span> (random != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> Node new_random = random.next;</span><br><span class="line">                cur.next.random = new_random;</span><br><span class="line">            &#125;</span><br><span class="line">             cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (new_head == <span class="keyword">null</span>)&#123;</span><br><span class="line">                new_head = cur.next;</span><br><span class="line">                new_last = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                new_last.next = cur.next;</span><br><span class="line">                new_last = new_last.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136. Single Number</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-136-Single-Number/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-136-Single-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a <strong>non-empty</strong> array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p><p>You must implement a solution with a linear runtime complexity and use only constant extra space.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-3 * 104 &lt;= nums[i] &lt;= 3 * 104</code></li><li>Each element in the array appears twice except for one element which appears only once.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，考察位运算，我们知道异或运算是不同为1，相同为0，而0与任何数异或都是数字本身，所以 异或一遍就能得到答案</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            n ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>134. Gas Station</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-134-Gas-Station/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-134-Gas-Station/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">https://leetcode.com/problems/gas-station/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>ith</code> station is <code>gas[i]</code>.</p><p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>ith</code> station to its next <code>(i + 1)th</code> station. You begin the journey with an empty tank at one of the gas stations.</p><p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4</span><br><span class="line">Travel to station 4. Your tank &#x3D; 4 - 1 + 5 &#x3D; 8</span><br><span class="line">Travel to station 0. Your tank &#x3D; 8 - 2 + 1 &#x3D; 7</span><br><span class="line">Travel to station 1. Your tank &#x3D; 7 - 3 + 2 &#x3D; 6</span><br><span class="line">Travel to station 2. Your tank &#x3D; 6 - 4 + 3 &#x3D; 5</span><br><span class="line">Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.</span><br><span class="line">Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: gas &#x3D; [2,3,4], cost &#x3D; [3,4,3]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">You can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class="line">Let&#39;s start at station 2 and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4</span><br><span class="line">Travel to station 0. Your tank &#x3D; 4 - 3 + 2 &#x3D; 3</span><br><span class="line">Travel to station 1. Your tank &#x3D; 3 - 3 + 3 &#x3D; 3</span><br><span class="line">You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.</span><br><span class="line">Therefore, you can&#39;t travel around the circuit once no matter where you start.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == gas.length == cost.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= gas[i], cost[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>加油站问题，经典题目！我们这个地方用滑动窗口解</li><li>我们首先用cost数组减掉gas数组，存回cost数组，这样&gt;=0表示从这出发能到达下个点，我们从L位置遍历过程中，进行累加cost数组前缀和preSum，如果出现负数肯定是到达不了下个位置了。</li><li>滑动窗口要找单调性，不能回退，比如说 [L,R]，此时不满足情况即preSum &lt; 0，那么[L+1,R] 的位置一定也不满足，因为当初你有可能携带汽油到达L位置，结果从L都到不了R，现在从L+1的位置 怎么可能到达了R! </li><li>为了节省空间，在cost数组本身进行环形增长，达到长度N，其实完全可以再开辟个数组，复制一遍不用这么麻烦</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = cost.length;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> gas[<span class="number">0</span>]-cost[<span class="number">0</span>] &gt;= <span class="number">0</span>?<span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            cost[i] = gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; N)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; N &amp;&amp;cost[p1] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p1 &lt; N)&#123;</span><br><span class="line">                <span class="keyword">int</span> p2 = p1,preSum = cost[p1];</span><br><span class="line">                <span class="comment">//窗口增长</span></span><br><span class="line">                <span class="keyword">while</span> ((p2-p1+N)%N+<span class="number">1</span>&lt;N &amp;&amp; preSum &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    p2 = (p2+<span class="number">1</span>)%N;</span><br><span class="line">                    preSum += cost[p2];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(preSum &gt;= <span class="number">0</span> ) <span class="keyword">return</span> p1;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p2 &gt; p1) p1 = p2;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>131. Palindrome Partitioning</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-131-Palindrome-Partitioning/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-131-Palindrome-Partitioning/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-partitioning/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a <strong>palindrome</strong>. Return all possible palindrome partitioning of <code>s</code>.</p><p>A <strong>palindrome</strong> string is a string that reads the same backward as forward.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aab&quot;</span><br><span class="line">Output: [[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;</span><br><span class="line">Output: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s</code> contains only lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>中等难度。要求我们输出所有的切分之后每一块都是回文串的可能性，要枚举第一刀切在哪，要保证切出来的是回文串，切完第一刀之后，我们可以递归去收集答案，第一刀切出来的这个部分是不是回文串还要判断</li><li>为了加速判断，可以事先用DP把回文串的下标求出来，加速判断过程，但怪异的事，这种做法竟然不如现判断的效果好，八成leetcode的测试用例不行。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事先dp 求解回文串下标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            dp[i][i]  = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; N)</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = chars[i] == chars[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">3</span>;i &gt;=<span class="number">0</span> ;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">2</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(chars[i] != chars[j]) dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        process(res,list,<span class="number">0</span>,s,dp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;List&lt;String&gt;&gt; res,List&lt;String&gt; path,<span class="keyword">int</span> index,String str,<span class="keyword">boolean</span>[][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = str.length();</span><br><span class="line">        <span class="keyword">if</span>(index == N)&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">            res.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index;i &lt; N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[index][i])&#123;</span><br><span class="line">                path.add(str.substring(index,i+<span class="number">1</span>));</span><br><span class="line">                process(res,path,i+<span class="number">1</span>,str,dp);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现判断</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        partitioning(<span class="number">0</span>, s, result, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">partitioning</span><span class="params">(<span class="keyword">int</span> index, String s, List&lt;List&lt;String&gt;&gt; result, List&lt;String&gt; ds)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (index == s.length())&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(ds));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s, index, i))&#123;</span><br><span class="line">                ds.add(s.substring(index, i+<span class="number">1</span>));</span><br><span class="line">                partitioning(i+<span class="number">1</span>, s, result, ds);</span><br><span class="line">                ds.remove(ds.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(start) != s.charAt(end))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>130. Surrounded Regions</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-130-Surrounded-Regions/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-130-Surrounded-Regions/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">https://leetcode.com/problems/surrounded-regions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> matrix <code>board</code> containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>, <em>capture all regions that are 4-directionally surrounded by</em> <code>&#39;X&#39;</code>.</p><p>A region is <strong>captured</strong> by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">Output: [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">Explanation: Notice that an &#39;O&#39; should not be flipped if:</span><br><span class="line">- It is on the border, or</span><br><span class="line">- It is adjacent to an &#39;O&#39; that should not be flipped.</span><br><span class="line">The bottom &#39;O&#39; is on the border, so it is not flipped.</span><br><span class="line">The other three &#39;O&#39; form a surrounded region, so they are flipped.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;X&quot;]]</span><br><span class="line">Output: [[&quot;X&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>board[i][j]</code> is <code>&#39;X&#39;</code> or <code>&#39;O&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题说的是，把完全包起来的区域里的O-&gt;X,边界上能联通的O不要变，这个还是挺好的，要求你转换思路，我们先把O存成另一个字符C，然后从边界出发去进行BFS 也就是 感染操作，上下左右的去联通，联通了就置成另一个字符K，那么我们再进行遍历，所有的C变成X，所有的K变回O即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> M,N;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        M = board.length;</span><br><span class="line">        N = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            <span class="comment">//统一表示成'C'</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> ( board[i][j] == <span class="string">'O'</span>)</span><br><span class="line">                         board[i][j] = <span class="string">'C'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始从边界进行扫描</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++) &#123;</span><br><span class="line">            infect(board,<span class="number">0</span>,i);</span><br><span class="line">            infect(board,M-<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            infect(board,i,<span class="number">0</span>);</span><br><span class="line">            infect(board,i,N-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            <span class="comment">//统一表示成'C'</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> ( board[i][j] == <span class="string">'C'</span>)</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">if</span> ( board[i][j] == <span class="string">'K'</span>)</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isJudge(i,j) &amp;&amp; board[i][j] == <span class="string">'C'</span>)&#123;</span><br><span class="line">            board[i][j] = <span class="string">'K'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">4</span>;d++)&#123;</span><br><span class="line">                infect(board,i+dir_x[d],j + dir_y[d]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">isJudge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; M &amp;&amp; j &gt;= <span class="number">0</span>&amp;&amp; j&lt;N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>128. Longest Consecutive Sequence</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-128-Longest-Consecutive-Sequence/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-128-Longest-Consecutive-Sequence/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-consecutive-sequence/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence.</em></p><p>You must write an algorithm that runs in <code>O(n)</code> time.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [100,4,200,1,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求最长连续序列，需要两个容器，一个装头，一个装尾，每个元素来了，要看看它前面的元素在尾里面？在的话把自己添加进去，同时存储对应前面的值，接下来再看它后面的 是头吗？如果是，需要重新更正之前的头对应后面的个数，与信息流的题目类似。head容器、tail容器。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>)<span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, Integer&gt; head = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, Integer&gt; tail = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(head.containsKey(nums[i]) || tail.containsKey(nums[i]))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                head.put(nums[i],<span class="number">1</span>);</span><br><span class="line">                tail.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//和前面连一块</span></span><br><span class="line">            <span class="keyword">if</span> (tail.containsKey(nums[i] - <span class="number">1</span>)) &#123;</span><br><span class="line">                head.remove(nums[i]);</span><br><span class="line">                <span class="keyword">final</span> Integer preLen = tail.get(nums[i] - <span class="number">1</span>);</span><br><span class="line">                head.put(nums[i] - preLen, head.get(nums[i] - preLen) + <span class="number">1</span>);</span><br><span class="line">                tail.put(nums[i], preLen + <span class="number">1</span>);</span><br><span class="line">                res = Math.max(res,preLen+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//和后面连上，注意同时更新前面的连续序列</span></span><br><span class="line">            <span class="keyword">if</span> (head.containsKey(nums[i] + <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Integer posLen = head.get(nums[i] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">final</span> Integer preLen = tail.get(nums[i]);</span><br><span class="line">                head.put(nums[i]-preLen+<span class="number">1</span>,preLen+posLen);</span><br><span class="line">                tail.put(nums[i]+posLen,preLen+posLen);</span><br><span class="line">                res = Math.max(res,preLen+posLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>127. Word Ladder</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-127-Word-Ladder/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-127-Word-Ladder/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">https://leetcode.com/problems/word-ladder/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code> such that:</p><ul><li>Every adjacent pair of words differs by a single letter.</li><li>Every <code>si</code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li><li><code>sk == endWord</code></li></ul><p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or</em> <code>0</code> <em>if no such sequence exists.</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= beginWord.length &lt;= 10</code></li><li><code>endWord.length == beginWord.length</code></li><li><code>1 &lt;= wordList.length &lt;= 5000</code></li><li><code>wordList[i].length == beginWord.length</code></li><li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li><li><code>beginWord != endWord</code></li><li>All the words in <code>wordList</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题其实就是图，以每个单词为顶点，相邻的顶点是差一个字母的单词，构造出邻接表之后，把起点也加到图中，那么就是求起点到终点的最短路径问题，单源最短路径有迪杰斯特拉算法 或者更简单的BFS即可。</li><li>再构造邻接表的时候注意，对这个单词寻找邻居时候，不要直接遍历单词表，而是对这个单词的每个字母去调整出新单词，判断单词表中是否存在，这样会更快.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] vToStr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String,Integer&gt; strToMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = wordList.size()+<span class="number">1</span>;</span><br><span class="line">        vToStr = <span class="keyword">new</span> String[N];</span><br><span class="line">        strToMap =  <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        wordList.add(beginWord);</span><br><span class="line">        <span class="comment">// 处理映射</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            vToStr[i] = wordList.get(i);</span><br><span class="line">            strToMap.put(vToStr[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Integer end = strToMap.get(endWord);</span><br><span class="line">        <span class="keyword">if</span>(end == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; adjectTb = getAdjectTb();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bfs = bfs(adjectTb,N,strToMap.get(beginWord),end);</span><br><span class="line">        <span class="keyword">return</span> bfs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; getAdjectTb()&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vToStr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> String str = vToStr[i];</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; chars.length; i1++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">'a'</span>;k &lt;= <span class="string">'z'</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(chars[i1] == k)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">char</span> tmp = chars[i1];</span><br><span class="line">                    chars[i1] = k;</span><br><span class="line">                    <span class="keyword">final</span> String s = <span class="keyword">new</span> String(chars);</span><br><span class="line">                    <span class="keyword">final</span> Integer con = strToMap.get(s);</span><br><span class="line">                    <span class="keyword">if</span>(con != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        list.add(con);</span><br><span class="line">                    &#125;</span><br><span class="line">                    chars[i1] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; adjectTb ,<span class="keyword">int</span> N,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] queue = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>,rear = <span class="number">0</span>;</span><br><span class="line">        queue[rear++] = begin;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        visited[begin] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (front != rear)&#123;</span><br><span class="line">            <span class="keyword">int</span> next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; batchSize;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = queue[front++];</span><br><span class="line">                <span class="keyword">if</span>(tmp == end)</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">final</span> List&lt;Integer&gt; adjents = adjectTb.get(tmp);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adjents.size(); j++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Integer t = adjents.get(j);</span><br><span class="line">                    <span class="keyword">if</span>(!visited[t])&#123;</span><br><span class="line">                        queue[rear++] = t;</span><br><span class="line">                        visited[t] = <span class="keyword">true</span>;</span><br><span class="line">                        next_batch++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">            batchSize = next_batch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125. Valid Palindrome</title>
      <link href="/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-125-Valid-Palindrome/"/>
      <url>/2022/07/12/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-12-125-Valid-Palindrome/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-palindrome/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p><p>Given a string <code>s</code>, return <code>true</code> <em>if it is a <strong>palindrome</strong>, or</em> <code>false</code> <em>otherwise</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;amanaplanacanalpanama&quot; is a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;race a car&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;raceacar&quot; is not a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot; &quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: s is an empty string &quot;&quot; after removing non-alphanumeric characters.</span><br><span class="line">Since an empty string reads the same forward and backward, it is a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 2 * 105</code></li><li><code>s</code> consists only of printable ASCII characters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目不难，就是注意字符类型，判断好就行</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R = str.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line"><span class="comment">// 英文（大小写） + 数字</span></span><br><span class="line"><span class="keyword">if</span> (validChar(str[L]) &amp;&amp; validChar(str[R])) &#123;</span><br><span class="line"><span class="keyword">if</span> (!equal(str[L], str[R])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">L++;</span><br><span class="line">R--;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">L += validChar(str[L]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">R -= validChar(str[R]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validChar</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isLetter(c) || isNumber(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equal</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isNumber(c1) || isNumber(c2)) &#123;</span><br><span class="line"><span class="keyword">return</span> c1 == c2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a  A   32</span></span><br><span class="line"><span class="comment">// b  B   32</span></span><br><span class="line"><span class="comment">// c  C   32</span></span><br><span class="line"><span class="keyword">return</span> (c1 == c2) || (Math.max(c1, c2) - Math.min(c1, c2) == <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLetter</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>124. Binary Tree Maximum Path Sum</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-124-Binary-Tree-Maximum-Path-Sum/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-124-Binary-Tree-Maximum-Path-Sum/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-maximum-path-sum/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p><p>The <strong>path sum</strong> of a path is the sum of the node’s values in the path.</p><p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 &#x3D; 6.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">Output: 42</span><br><span class="line">Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 &#x3D; 42.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 3 * 104]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>二叉树的递归套路，主要靠一点区分就是，这个最大路径要么经过我root，要么不经过，如果经过的话，一定要和子树经过头的最大路径连起来才可以。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeInfo</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSum;</span><br><span class="line">        <span class="keyword">int</span> fromHeadMaxSum;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeInfo</span><span class="params">(<span class="keyword">int</span> maxSum, <span class="keyword">int</span> fromHeadMaxSum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.maxSum = maxSum;</span><br><span class="line">            <span class="keyword">this</span>.fromHeadMaxSum = fromHeadMaxSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxPathSumProcess(root).maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NodeInfo <span class="title">maxPathSumProcess</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSum = root.val;</span><br><span class="line">        <span class="keyword">int</span> fromHeadMaxSum = root.val;</span><br><span class="line">        <span class="keyword">final</span> NodeInfo leftInfo = maxPathSumProcess(root.left);</span><br><span class="line">        <span class="keyword">final</span> NodeInfo rightInfo = maxPathSumProcess(root.right);</span><br><span class="line">        <span class="comment">//第一种情况，不经过root</span></span><br><span class="line">        <span class="keyword">if</span>(leftInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">            maxSum = Math.max(leftInfo.maxSum,maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">            maxSum = Math.max(rightInfo.maxSum,maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二种，经过root了</span></span><br><span class="line">        <span class="keyword">if</span> (leftInfo!=<span class="keyword">null</span> &amp;&amp; leftInfo.fromHeadMaxSum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            maxSum = Math.max(maxSum, leftInfo.fromHeadMaxSum + root.val);</span><br><span class="line">            fromHeadMaxSum = Math.max(leftInfo.fromHeadMaxSum + root.val,fromHeadMaxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightInfo!=<span class="keyword">null</span> &amp;&amp; rightInfo.fromHeadMaxSum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            maxSum = Math.max(maxSum, rightInfo.fromHeadMaxSum + root.val);</span><br><span class="line">            fromHeadMaxSum = Math.max(rightInfo.fromHeadMaxSum + root.val,fromHeadMaxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span> &amp;&amp; rightInfo != <span class="keyword">null</span> &amp;&amp; leftInfo.fromHeadMaxSum &gt; <span class="number">0</span> &amp;&amp; rightInfo.fromHeadMaxSum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            maxSum = Math.max(maxSum, leftInfo.fromHeadMaxSum + root.val + rightInfo.fromHeadMaxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NodeInfo(maxSum,fromHeadMaxSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>122. Best Time to Buy and Sell Stock II</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-122-Best-Time-to-Buy-and-Sell-Stock-II/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-122-Best-Time-to-Buy-and-Sell-Stock-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p><p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.</span><br><span class="line">Total profit is 4 + 3 &#x3D; 7.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Total profit is 4.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>股票系列问题 第二问，是说 同时可以持有一份股票，可以当天买，当天卖，交易次数不限，求最大利润，问题其实可以转换成，再上坡，下坡中，求所有上坡的和</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; prices.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            res  += Math.max(<span class="number">0</span>,prices[i+<span class="number">1</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>121. Best Time to Buy and Sell Stock</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-121-Best-Time-to-Buy-and-Sell-Stock/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-121-Best-Time-to-Buy-and-Sell-Stock/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p><p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-1 &#x3D; 5.</span><br><span class="line">Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transactions are done and the max profit &#x3D; 0.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>股票系列问题可是经典题目，这是股票一，买一次，卖一次求最大利润，题目转化成，对当前i位置，减去我左边的最小值，即为当前位置卖出的最大利润，遍历一趟得结果</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            min = Math.min(prices[i],min);</span><br><span class="line">            res = Math.max(res,prices[i]-min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>118. Pascal&#39;s Triangle</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-118-Pascal-s-Triangle/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-118-Pascal-s-Triangle/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/pascals-triangle/" target="_blank" rel="noopener">https://leetcode.com/problems/pascals-triangle/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>numRows</code>, return the first numRows of <strong>Pascal’s triangle</strong>.</p><p>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numRows &#x3D; 5</span><br><span class="line">Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numRows &#x3D; 1</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>杨辉三角，普通循环就搞定了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tmp.add(<span class="number">1</span>);</span><br><span class="line">        res.add(tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; numRows;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;Integer&gt; last = res.get(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            cur.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i;j++)&#123;</span><br><span class="line">                cur.add(last.get(j-<span class="number">1</span>) + (j &gt;= last.size()? <span class="number">0</span>:last.get(j)));</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>116. Populating Next Right Pointers in Each Node</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-116-Populating-Next-Right-Pointers-in-Each-Node/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-116-Populating-Next-Right-Pointers-in-Each-Node/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">https://leetcode.com/problems/populating-next-right-pointers-in-each-node/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 212 - 1]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>Follow-up:</strong></p><ul><li>You may only use constant extra space.</li><li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>T103 提到了层次遍历一次取一批的技巧，这个题就用的上了，一次取出来一批，设置好右节点即可 。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> bathSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            Node pre = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bathSize; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre = cur;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre.next = cur;</span><br><span class="line">                     pre = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(cur.left);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(cur.right);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bathSize = next_batch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>108. Convert Sorted Array to Binary Search Tree</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-108-Convert-Sorted-Array-to-Binary-Search-Tree/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-108-Convert-Sorted-Array-to-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a <strong>height-balanced</strong> binary search tree</em>.</p><p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line">Explanation: [0,-10,5,null,-3,null,9] is also accepted:</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3]</span><br><span class="line">Output: [3,1]</span><br><span class="line">Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> is sorted in a <strong>strictly increasing</strong> order.</li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这是个简单题，主要要求的很明确了，要是高度是平衡的，那么就用二分，中点当根，然后递归下去即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r -l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> TreeNode left = process(num, l, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> TreeNode right = process(num, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">final</span> TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        root.left = left;</span><br><span class="line">        root.right = right;</span><br><span class="line">        root.val = num[mid];</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary Search </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder &#x3D; [-1], inorder &#x3D; [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> and <code>inorder</code> consist of <strong>unique</strong> values.</li><li>Each value of <code>inorder</code> also appears in <code>preorder</code>.</li><li><code>preorder</code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.</li><li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>前序遍历与中序遍历，前序与层序，加上保证值不同，便可以唯一确定一棵树，先序确定出跟，然后另一个数组确定出对应的左右子树。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constuctTree(preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constuctTree</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,<span class="keyword">int</span> l2,<span class="keyword">int</span> r2,HashMap&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 &gt; r1) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(preorder[l1]);</span><br><span class="line">            <span class="keyword">final</span> Integer loc = map.get(root.val);</span><br><span class="line">            <span class="keyword">final</span> TreeNode left = constuctTree(preorder, l1 + <span class="number">1</span>, l1 + loc -l2, l2, loc - <span class="number">1</span>, map);</span><br><span class="line">            <span class="keyword">final</span> TreeNode right = constuctTree(preorder, l1 + loc - l2 + <span class="number">1</span>, l1 - l2 + r2, loc + <span class="number">1</span>, r2, map);</span><br><span class="line">            root.left = left;</span><br><span class="line">            root.right = right;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104. Maximum Depth of Binary Tree</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-104-Maximum-Depth-of-Binary-Tree/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-104-Maximum-Depth-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p><p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 104]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>很简单的递归套路</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> l = getHeight(root.left);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> r = getHeight(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l,r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>103. Binary Tree Zigzag Level Order Traversal</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-103-Binary-Tree-Zigzag-Level-Order-Traversal/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-103-Binary-Tree-Zigzag-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes’ values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[20,9],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是让你一层是从左到右，下一层又是从右到左</li><li>这里介绍一个特别重要的技巧，好多题目可以这么解，就是用队列层序遍历时候，每次从队列里拿元素，一次性拿一批，把这一层的都是拿出来，拿出来你想正着就正着，想倒着就倒着 再折腾一次就可以！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; batchSize;i++)&#123;</span><br><span class="line">                <span class="keyword">final</span> TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(node.left);</span><br><span class="line">                        next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(node.right);</span><br><span class="line">                        next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                c.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">                    reverse(c);</span><br><span class="line">                &#125;</span><br><span class="line">            batchSize = next_batch;</span><br><span class="line">            flag ^= <span class="number">1</span>;</span><br><span class="line">            list.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ArrayList&lt;Integer&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = c.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size()/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = c.get(i);</span><br><span class="line">            c.set(i,c.get(len-<span class="number">1</span>-i));</span><br><span class="line">            c.set(len-<span class="number">1</span>-i,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>102. Binary Tree Level Order Traversal</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-102-Binary-Tree-Level-Order-Traversal/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-102-Binary-Tree-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>二叉树的层序遍历，常规操作.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> batch = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> next_batch=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; batch;i++)&#123;</span><br><span class="line">                <span class="keyword">final</span> TreeNode tmp = queue.poll();</span><br><span class="line">                list.add(tmp.val);</span><br><span class="line">                <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(tmp.left);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(tmp.right);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">            batch = next_batch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>101. Symmetric Tree</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-101-Symmetric-Tree/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-101-Symmetric-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/symmetric-tree/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>好题啊好题，虽说是简单题，还蛮考验小聪明的，其实就是说你得始终验证每个节点的左树是不是和右树一样，对每个节点都得验证这是递归，进行验证的时候，你得拿到对应的兄弟节点，所以可以 直接传两次！把树直接传两次！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode leftRoot,TreeNode rightRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftRoot != <span class="keyword">null</span> &amp;&amp; rightRoot != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftRoot.val != rightRoot.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> isMirror(leftRoot.left,rightRoot.right) &amp;&amp; isMirror(leftRoot.right,rightRoot.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(leftRoot == <span class="keyword">null</span> &amp;&amp; rightRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>98. Validate Binary Search Tree</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-98-Validate-Binary-Search-Tree/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-98-Validate-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/validate-binary-search-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p><p>A <strong>valid BST</strong> is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&#39;s value is 5 but its right child&#39;s value is 4.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 104]</code>.</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>BST的中序遍历一定是递增的，验证这个条件即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root,list);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i) &lt;= list.get(i-<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left,list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inOrder(root.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>94. Binary Tree Inorder Traversal</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-94-Binary-Tree-Inorder-Traversal/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-94-Binary-Tree-Inorder-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-inorder-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes’ values</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2,3]</span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>普通的中序遍历</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        process(res,root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; res,TreeNode root)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">          process(res,root.left);</span><br><span class="line">          res.add(root.val);</span><br><span class="line">          process(res,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>91. Decode Ways</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-91-Decode-Ways/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-91-Decode-Ways/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">https://leetcode.com/problems/decode-ways/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A message containing letters from <code>A-Z</code> can be <strong>encoded</strong> into numbers using the following mapping:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; &quot;1&quot;</span><br><span class="line">&#39;B&#39; -&gt; &quot;2&quot;</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; &quot;26&quot;</span><br></pre></td></tr></table></figure><p>To <strong>decode</strong> an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, <code>&quot;11106&quot;</code> can be mapped into:</p><ul><li><code>&quot;AAJF&quot;</code> with the grouping <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> with the grouping <code>(11 10 6)</code></li></ul><p>Note that the grouping <code>(1 11 06)</code> is invalid because <code>&quot;06&quot;</code> cannot be mapped into <code>&#39;F&#39;</code> since <code>&quot;6&quot;</code> is different from <code>&quot;06&quot;</code>.</p><p>Given a string <code>s</code> containing only digits, return <em>the <strong>number</strong> of ways to <strong>decode</strong> it</em>.</p><p>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: &quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: &quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;06&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: &quot;06&quot; cannot be mapped to &quot;F&quot; because of the leading zero (&quot;6&quot; is different from &quot;06&quot;).</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> contains only digits and may contain leading zero(s).</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求解码的字符串种数，这种求种数、求最优解的都可以考虑dp，主要是思路来的快</li><li>定义dp[i]  表示 [i~len-1]区间上 解码字符串的种数</li><li>考虑当前 chars[i],字符单独解码的情况，考虑它与后面字符共同解码的情况，进行枚举即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">//明显的dp,dp[i]，表示i~s.lengtn-1有多少种解码方式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = chars.length;</span><br><span class="line">        <span class="keyword">int</span> pre1 = chars[N-<span class="number">1</span>] == <span class="string">'0'</span> ?  <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(chars[i] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//一位数的时候</span></span><br><span class="line">                <span class="keyword">if</span>(chars[i+<span class="number">1</span>] != <span class="string">'0'</span>)&#123;</span><br><span class="line">                    p1 = pre1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//两位数计算</span></span><br><span class="line">                <span class="keyword">int</span> num = (chars[i]-<span class="string">'0'</span>)*<span class="number">10</span>+(chars[i+<span class="number">1</span>]-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                    p2 = pre2;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = p1 + p2;</span><br><span class="line">            &#125;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>88. Merge Sorted Array</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-88-Merge-Sorted-Array/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-88-Merge-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p><p><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.</p><p>The final sorted array should not be returned by the function, but instead be <em>stored inside the array</em> <code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3</span><br><span class="line">Output: [1,2,2,3,5,6]</span><br><span class="line">Explanation: The arrays we are merging are [1,2,3] and [2,5,6].</span><br><span class="line">The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The arrays we are merging are [1] and [].</span><br><span class="line">The result of the merge is [1].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The arrays we are merging are [] and [1].</span><br><span class="line">The result of the merge is [1].</span><br><span class="line">Note that because m &#x3D; 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-109 &lt;= nums1[i], nums2[j] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>小小的考察，从后遍历，往后放置即可，还是从题目本身出发，好好分析！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m-<span class="number">1</span>,j = n-<span class="number">1</span>,k = nums1.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                    nums1[k--] = nums1[i--];</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k != -<span class="number">1</span> &amp;&amp; i == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (k &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> Merge Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>84. Largest Rectangle in Histogram</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-84-Largest-Rectangle-in-Histogram/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-84-Largest-Rectangle-in-Histogram/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-rectangle-in-histogram/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of integers <code>heights</code> representing the histogram’s bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: heights &#x3D; [2,1,5,6,2,3]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: The above is a histogram where width of each bar is 1.</span><br><span class="line">The largest rectangle is shown in the red area, which has an area &#x3D; 10 units.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: heights &#x3D; [2,4]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= heights.length &lt;= 105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个是单调栈的应用，单调栈求的是，以当前值为最小值的最大区间。</li><li>还是从题目本身出发，先分析，分析出哪个知识点，用哪个知识点，最大的矩形面积，这个矩形一定是以某个高度为高，然后以这个高度尽可能向两边扩形成一个最大矩形。此外，这个高度一定是在所有的高度里面的，所以我们就可以遍历这些高度，对这些高度，找每个高度形成的最大区间，所有里面的最大面积就是答案。所以说，我们一定要通过分析，找到一个突破点，可以通过枚举去找到所有可能性，进而找到答案。</li><li>有关单调栈的实现这一块，看其它文章的总结。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> N = heights.length,top = -<span class="number">1</span>,res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (top != -<span class="number">1</span> &amp;&amp; heights[stack[top]] &gt;= heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> elem = stack[top--];</span><br><span class="line">                <span class="keyword">int</span> leftMin = top == -<span class="number">1</span> ? -<span class="number">1</span> : stack[top];</span><br><span class="line">                <span class="keyword">int</span> rightMin = i;</span><br><span class="line">                <span class="keyword">int</span> num = (rightMin - <span class="number">1</span> - leftMin) * heights[elem];</span><br><span class="line">                res =  Math.max(res,num);</span><br><span class="line">            &#125;</span><br><span class="line">            stack[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (top!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> elem = stack[top--];</span><br><span class="line">            <span class="keyword">int</span> leftMin = top == -<span class="number">1</span> ? -<span class="number">1</span> : stack[top];</span><br><span class="line">            <span class="keyword">int</span> rightMin = N;</span><br><span class="line">            <span class="keyword">int</span> num = (rightMin - <span class="number">1</span> - leftMin) * heights[elem];</span><br><span class="line">            res = Math.max(res,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Monotonic Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>79. Word Search</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-79-Word-Search/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-79-Word-Search/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">https://leetcode.com/problems/word-search/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</p><p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;SEE&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCB&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是简单的暴力搜索即可。</li><li>下面两个方法，其实思路时一模一样，但是 方法二，就是省掉了数组标记，而是在自身上做标记，用回溯的方法，判断也少点，就这它的时间比方法一快了一倍。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board[<span class="number">0</span>].length * board.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] arr = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(i,j,<span class="number">0</span>,arr,board,visited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法一，暴力搜索，dfs，对每个位置去搜索单词即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> index,<span class="keyword">char</span>[] arr,<span class="keyword">char</span>[][] board,<span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> loc = i*board[<span class="number">0</span>].length + j;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span>|| j &gt;= board[<span class="number">0</span>].length || visited[loc])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[index] == board[i][j];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == arr[index])&#123;</span><br><span class="line">                visited[loc] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">4</span>;d++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(i+dir_x[d],j+dir_y[d],index+<span class="number">1</span>,arr,board,visited))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[loc] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] w = word.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (f(board, i, j, w, <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前到达了b[i][j]，word[k....]</span></span><br><span class="line"><span class="comment">// 从b[i][j]出发，能不能搞定word[k....] true false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>[][] b, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] w, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k == w.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// word[k.....] 有字符</span></span><br><span class="line"><span class="comment">// 如果(i,j)越界，返回false</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == b.length || j &lt; <span class="number">0</span> || j == b[<span class="number">0</span>].length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b[i][j] != w[k]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> tmp = b[i][j];</span><br><span class="line">b[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> ans = f(b, i - <span class="number">1</span>, j, w, k + <span class="number">1</span>) </span><br><span class="line">|| f(b, i + <span class="number">1</span>, j, w, k + <span class="number">1</span>) </span><br><span class="line">|| f(b, i, j - <span class="number">1</span>, w, k + <span class="number">1</span>)</span><br><span class="line">|| f(b, i, j + <span class="number">1</span>, w, k + <span class="number">1</span>);</span><br><span class="line">b[i][j] = tmp;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>78. Subsets</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-78-Subsets/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-78-Subsets/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode.com/problems/subsets/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible subsets (the power set)</em>.</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: [[],[0]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求子集，从左到右递归枚举，加上回溯，收集起来即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; fin = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fin.add(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            fin.add(nums[i]);</span><br><span class="line">            process(res,path,nums,<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        res.add(fin);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; path,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index,<span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lim == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">            res.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index==nums.length || nums.length-index &lt; lim)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(nums[index]);</span><br><span class="line">        process(res,path,nums,index+<span class="number">1</span>,lim-<span class="number">1</span>);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        process(res,path,nums,index+<span class="number">1</span>,lim);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>76. Minimum Window Substring</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-76-Minimum-Window-Substring/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-76-Minimum-Window-Substring/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-window-substring/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window substring</strong> of</em> <code>s</code> <em>such that every character in</em> <code>t</code> <em>(<strong>including duplicates</strong>) is included in the window. If there is no such substring**, return the empty string</em> <code>&quot;&quot;</code><em>.</em></p><p>The testcases will be generated such that the answer is <strong>unique</strong>.</p><p>A <strong>substring</strong> is a contiguous sequence of characters within the string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot;</span><br><span class="line">Output: &quot;BANC&quot;</span><br><span class="line">Explanation: The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;, t &#x3D; &quot;a&quot;</span><br><span class="line">Output: &quot;a&quot;</span><br><span class="line">Explanation: The entire string s is the minimum window.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;, t &#x3D; &quot;aa&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: Both &#39;a&#39;s from t must be included in the window.</span><br><span class="line">Since the largest window of s only has one &#39;a&#39;, return empty string.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == s.length</code></li><li><code>n == t.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><p>尝试考虑滑动窗口，滑动窗口能使用，一定要具有单调性，能保证求解的时候，R可以不回退！比如说</p><p>L=2，R=6，此时满足条件了，记录下来，继续考量L = 3，R= 6是否是更优的，来逼近答案，那为什么不考虑 L = 3，R = 4，5 这两个窗口呢？这两个窗口不是被跳过去了吗？因为L = 2,R = 5的时候 都不满足条件，那L=3，R= 5这个更小的窗口 怎么可能满足条件呢！所以这叫R 不回退！</p></li><li><p>第二点，如何判断此时窗口是满足条件的窗口，窗口内的元素是包含制定字符串元素，种类以及对应的个数。我们引入一种“欠债表”的思想，这个表内，初始化时，是我们要还的字符，也就是指定的字符串对应字符及个数，此外维护一个变量是代表 我们还欠着多少，当变量为0时，表明此窗口如何符合条件。具体看代码来理解。</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] tb = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>]; <span class="comment">//欠债表</span></span><br><span class="line">        <span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] p_str = t.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p_str.length; i++) &#123;</span><br><span class="line">            tb[p_str[i]]++;</span><br><span class="line">            in++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_n = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sloc = <span class="number">0</span>,eloc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;p1 &lt; str.length;p1++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p2 &lt; str.length &amp;&amp; in &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (--tb[str[p2++]] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    in--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(in == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p2 - p1 &lt; min_n)&#123;</span><br><span class="line">                    min_n = p2-p1;</span><br><span class="line">                    sloc = p1;</span><br><span class="line">                    eloc = p2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++tb[str[p1]] &gt; <span class="number">0</span>)&#123; in++; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(sloc,eloc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75. Sort Colors</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-75-Sort-Colors/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-75-Sort-Colors/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-colors/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p><p>We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.</p><p>You must solve this problem without using the library’s sort function.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,0,1]</span><br><span class="line">Output: [0,1,2]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>nums[i]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这就是经典的三色旗问题呢，高频题里还是主要以经典题目为主。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>,p3 = nums.length-<span class="number">1</span>,p2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= p3)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[p2] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,p1,p2);</span><br><span class="line">                p2++;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[p2] == <span class="number">2</span>)&#123;</span><br><span class="line">                swap(nums,p2,p3);</span><br><span class="line">                p3--;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                p2++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>73. Set Matrix Zeroes</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-73-Set-Matrix-Zeroes/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-73-Set-Matrix-Zeroes/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/set-matrix-zeroes/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>‘s.</p><p>You must do it <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in place</a>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: [[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[0].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>-231 &lt;= matrix[i][j] &lt;= 231 - 1</code></li></ul><p><strong>Follow up:</strong></p><ul><li>A straightforward solution using <code>O(mn)</code> space is probably a bad idea.</li><li>A simple improvement uses <code>O(m + n)</code> space, but still not the best solution.</li><li>Could you devise a constant space solution?</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题有点像炸弹人游戏，我们遍历一趟就可以，简单的做法就是利用数组标记下哪一行，哪一列需要置0</li><li>Follow Up中，提示 能不能用常量空间做标记，这种优化，在面试中也常问。我们想的就是怎么节省空间？自然想办法就是在给的空间上想办法利用，</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>​    方法一:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length];</span><br><span class="line">        <span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    row[i] = <span class="number">1</span>;</span><br><span class="line">                    col[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] == <span class="number">1</span> || col[j]==<span class="number">1</span>)&#123;</span><br><span class="line">                   matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    优化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> col0 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">col0 = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = matrix.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (col0) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>70. Climbing Stairs</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-70-Climbing-Stairs/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-70-Climbing-Stairs/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">https://leetcode.com/problems/climbing-stairs/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p><p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>比较经典的递归问题了，现在回过头来看，用动归的递推，还是挺简单的。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">2</span>,pre2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = pre1 + pre2;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>69. Sqrt(x)</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-69-Sqrt-x/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-69-Sqrt-x/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">https://leetcode.com/problems/sqrtx/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a non-negative integer <code>x</code>, compute and return <em>the square root of</em> <code>x</code>.</p><p>Since the return type is an integer, the decimal digits are <strong>truncated</strong>, and only <strong>the integer part</strong> of the result is returned.</p><p><strong>Note:</strong> You are not allowed to use any built-in exponent function or operator, such as <code>pow(x, 0.5)</code> or <code>x ** 0.5</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= x &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这就是经典的二分求根号，不过这个题更简单，求的就是第一个满足((long)mid * mid) &lt;= x的整数。用res保留下解，不断的去推进这个值，这种写法简单好用，推荐！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = x;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(((<span class="keyword">long</span>)mid * mid) &lt;= x)&#123;</span><br><span class="line">               res = mid;</span><br><span class="line">               l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66. Plus One</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-66-Plus-One/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-66-Plus-One/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">https://leetcode.com/problems/plus-one/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given a <strong>large integer</strong> represented as an integer array <code>digits</code>, where each <code>digits[i]</code> is the <code>ith</code> digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading <code>0</code>‘s.</p><p>Increment the large integer by one and return <em>the resulting array of digits</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br><span class="line">Incrementing by one gives 123 + 1 &#x3D; 124.</span><br><span class="line">Thus, the result should be [1,2,4].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br><span class="line">Incrementing by one gives 4321 + 1 &#x3D; 4322.</span><br><span class="line">Thus, the result should be [4,3,2,2].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; [9]</span><br><span class="line">Output: [1,0]</span><br><span class="line">Explanation: The array represents the integer 9.</span><br><span class="line">Incrementing by one gives 9 + 1 &#x3D; 10.</span><br><span class="line">Thus, the result should be [1,0].</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li><li><code>digits</code> does not contain any leading <code>0</code>‘s.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>其实就是用数组进行大数运算，这个比较简单，只是简单的加法，累加时候注意加入进位，最后要判断是不是仍有进位，如果还有，要注意扩容数组</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有点类似大数运算，需要考虑进位情况，这个是比较简答的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> jie = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(jie == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> mod = (digits[i] + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (digits[i] + jie)/<span class="number">10</span>;</span><br><span class="line">            digits[i] = mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jie == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[]  new_digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; digits.length;i++) new_digits[i] = digits[i];</span><br><span class="line">            new_digits[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> new_digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>62. Unique Paths</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-62-Unique-Paths/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-62-Unique-Paths/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">https://leetcode.com/problems/unique-paths/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p><p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p>The test cases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: m &#x3D; 3, n &#x3D; 7</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Down</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题实际就是求排列组合，能想到这就简单，不然就吃力了，因为是矩型，而且只能左到右，上到下的走，所以从开始点到结束点，从左到右，从上到下 一定都是固定的步数。</li><li>排列组合的计算，方法数有很多，主要是用到简化公式的方法，不然直接计算 很容易就溢出了，至于计算方法，待我其它文章详细总结。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)C2(m+n-<span class="number">2</span>,m-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">C2</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            res =res*(n-m+i)/i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. Merge Intervals</title>
      <link href="/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-56-Merge-Intervals/"/>
      <url>/2022/07/11/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-11-56-Merge-Intervals/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-intervals/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目比较简单，就是输出有多少个覆盖的区间，遍历一趟，记录下来即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = intervals.length;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= end)&#123;</span><br><span class="line">                end = Math.max(intervals[i][<span class="number">1</span>],end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                intervals[t][<span class="number">0</span>] = start;</span><br><span class="line">                intervals[t++][<span class="number">1</span>] = end;</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals[t][<span class="number">0</span>] = start;</span><br><span class="line">        intervals[t++][<span class="number">1</span>] = end;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[t][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t;i++)&#123;</span><br><span class="line">            res[i][<span class="number">0</span>] = intervals[i][<span class="number">0</span>];</span><br><span class="line">            res[i][<span class="number">1</span>] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55. Jump Game</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-55-Jump-Game/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-55-Jump-Game/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/jump-game/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game/submissions/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>nums</code>. You are initially positioned at the array’s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p><p>Return <code>true</code> <em>if you can reach the last index, or</em> <code>false</code> <em>otherwise</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典题目。这个题就是考察“不回退”的技巧，用一个变量去扩展可以走到的路。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; max_pos) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                max_pos = Math.max(i + nums[i],max_pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>54. Spiral Matrix</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-54-Spiral-Matrix/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-54-Spiral-Matrix/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/spiral-matrix/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题不难，也没什么特殊的知识点，就是一个技巧，用几个变量控制好 从左到右，从右到左，从上到下，从下到上的范围，循环进行即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> d_left=<span class="number">0</span>,d_right=N-<span class="number">1</span>,d_up=<span class="number">0</span>,d_down = M-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>,cur_row = -<span class="number">1</span>,cur_col = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (c &lt; M*N)&#123;</span><br><span class="line">            <span class="comment">//往右</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d_left;i &lt;= d_right;i++)&#123;</span><br><span class="line">                list.add(matrix[d_up][i]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_up++;</span><br><span class="line">            <span class="comment">//往下</span></span><br><span class="line">            <span class="keyword">if</span>(c &gt;= M * N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = d_up;i &lt;= d_down;i++)&#123;</span><br><span class="line">                list.add(matrix[i][d_right]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_right--;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= M * N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//往左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = d_right;i &gt;= d_left;i--)&#123;</span><br><span class="line">                list.add(matrix[d_down][i]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_down--;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= M * N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//往上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d_down;i &gt;= d_up;i--)&#123;</span><br><span class="line">                list.add(matrix[i][d_left]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>53. Maximum Subarray</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-53-Maximum-Subarray/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-53-Maximum-Subarray/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.</p><p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,4,-1,7,8]</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution using the <strong>divide and conquer</strong> approach, which is more subtle.</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>比较常见的dp模型，从左到右,dp[i] 表示以i结尾的最大字数组的和</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = arr.length;</span><br><span class="line">        <span class="keyword">int</span> pre = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            pre = Math.max(arr[i],arr[i]+pre);</span><br><span class="line">            res = Math.max(res,pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50. Pow(x, n)</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-50-Pow-x-n/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-50-Pow-x-n/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">https://leetcode.com/problems/powx-n/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(x, n)</a>, which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>xn</code>).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li><code>-231 &lt;= n &lt;= 231-1</code></li><li><code>-104 &lt;= xn &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求m^n，可以对n用二分，加快累乘的速度</li><li>m^ (-n) = 1/m^n,这容易，所以，如果是负的，我们统一成正的处理，最后看是不是用1除即可。</li><li>注意边界，(-n)可能是Integer的最小值，所以如果直接转成绝对值就出错了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> raw = n;</span><br><span class="line">        n = n &gt; <span class="number">0</span> ? n : (n == Integer.MIN_VALUE ? Integer.MAX_VALUE : -n);</span><br><span class="line">        <span class="keyword">double</span> power = x;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                res *= power;</span><br><span class="line">            &#125;</span><br><span class="line">            power *= power;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> raw &gt; <span class="number">0</span> ? res : <span class="number">1</span>/res/(raw == Integer.MIN_VALUE ? x:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49. Group Anagrams</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-49-Group-Anagrams/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-49-Group-Anagrams/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener">https://leetcode.com/problems/group-anagrams/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p><p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]</span><br><span class="line">Output: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;&quot;]</span><br><span class="line">Output: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;a&quot;]</span><br><span class="line">Output: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> consists of lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>与字母种数有关，与字母顺序无关，这种题目出现的很高，也不难，做一个词频映射表表，能表示出来哪个字符出现的次数即可</li><li>是26个字符，所以char[26], 即可，注意这个地方就是要用char类型数组，因为不同的频次对应不同的字符。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        HashMap&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = strs[i].toCharArray();</span><br><span class="line">            <span class="keyword">char</span>[] dic = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; chars.length; i1++) &#123;</span><br><span class="line">                dic[chars[i1]-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> String dic_key = <span class="keyword">new</span> String(dic);</span><br><span class="line">            <span class="keyword">if</span>(map.get(dic_key) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(strs[i]);</span><br><span class="line">                map.put(dic_key,list);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.get(dic_key).add(strs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        map.forEach((k,v)-&gt;lists.add(v));</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48. Rotate Image</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-48-Rotate-Image/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-48-Rotate-Image/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/rotate-image/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-image/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <strong>90</strong> degrees (clockwise).</p><p>You have to rotate the image <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>第一次做还没反应过来怎么做。其实就注意一个点，是矩阵，90度旋转，它同一圈的不会转出去，所以就又一个对焦，一圈一圈转就行。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">0</span>,c = matrix.length-<span class="number">1</span>,d = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &lt; c)&#123;</span><br><span class="line">            rotateSwap(matrix,a++,b++,c--,d--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotateSwap</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d-b;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = matrix[a][b+i];</span><br><span class="line">            matrix[a][b+i] = matrix[c-i][b];</span><br><span class="line">            matrix[c-i][b] = matrix[c][d-i];</span><br><span class="line">            matrix[c][d-i] = matrix[a+i][d];</span><br><span class="line">            matrix[a+i][d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>46. Permutations</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-46-Permutations/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-46-Permutations/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1]</span><br><span class="line">Output: [[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>All the integers of <code>nums</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>全排列，基础的递归题目。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        process(list,nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回[index,len-1]位置的全排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length)&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                tmp.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            swap(nums,index,i);</span><br><span class="line">            process(list,nums,index+<span class="number">1</span>);</span><br><span class="line">            swap(nums,index,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = num[i];</span><br><span class="line">        num[i] = num[j];</span><br><span class="line">        num[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>44. Wildcard Matching</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-44-Wildcard-Matching/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-44-Wildcard-Matching/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/wildcard-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/wildcard-matching/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code> where:</p><ul><li><code>&#39;?&#39;</code> Matches any single character.</li><li><code>&#39;*&#39;</code> Matches any sequence of characters (including the empty sequence).</li></ul><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; matches any sequence.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cb&quot;, p &#x3D; &quot;?a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length, p.length &lt;= 2000</code></li><li><code>s</code> contains only lowercase English letters.</li><li><code>p</code> contains only lowercase English letters, <code>&#39;?&#39;</code> or <code>&#39;*&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目是通配符匹配，用动态规划会简单点, i,j的含义是s的前0~i字符能否与p的0~j字符匹配,然后根据p[j]是什么样的字符进行可能性的枚举即可。</li><li></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"**"</span>.equals(p) || <span class="string">"*"</span>.equals(p))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] p_str = p.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str.length + <span class="number">1</span>][p_str.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process(str,p_str,s.length()-<span class="number">1</span>,p.length()-<span class="number">1</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">char</span>[] p,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j+<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span>)&#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = i==-<span class="number">1</span>?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j;k &gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[k] != <span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p[j] == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i;k &gt;= -<span class="number">1</span>;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(process(str,p,k,j-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p[j] == <span class="string">'?'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (process(str,p,i-<span class="number">1</span>,j-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==p[j]&amp;&amp;process(str,p,i-<span class="number">1</span>,j-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. Trapping Rain Water</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-42-Trapping-Rain-Water/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-42-Trapping-Rain-Water/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">https://leetcode.com/problems/trapping-rain-water/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [4,2,0,3,2,5]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>乍一看，以为是单调栈，单调栈最大的特点就是，能求以当前元素为最小值的最长区间，这个题实际上并不适合，所以说上来先不要急着套模型，先从题目本身出发，去思考如何解决。</li><li>每个柱子都有可能接住雨水，接的大小实际就是它能“涨”多高，不就是取决于它左边最高高度和右面最高高度的最小值么。想明白这个地方，这个题就有了。</li><li>构造出辅助数组left[i],表示从0~i中的最大值，right[i]，表示i~lenth-1中的最大值，其中left可以再第二次遍历求每个柱子接水的时候一并算出，这样两个循环就搞定了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        <span class="keyword">int</span> max_n = height[height.length-<span class="number">1</span>];</span><br><span class="line">        right[height.length-<span class="number">1</span>] = max_n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = height.length-<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            max_n = Math.max(height[i],max_n);</span><br><span class="line">            right[i] = max_n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        max_n = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; height.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> expect = Math.min(max_n,right[i+<span class="number">1</span>]);</span><br><span class="line">            res += expect &lt; height[i] ? <span class="number">0</span> : expect-height[i];</span><br><span class="line">            max_n = Math.max(max_n,height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>41. First Missing Positive</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-41-First-Missing-Positive/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-41-First-Missing-Positive/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">https://leetcode.com/problems/first-missing-positive/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an unsorted integer array <code>nums</code>, return the smallest missing positive integer.</p><p>You must implement an algorithm that runs in <code>O(n)</code> time and uses constant extra space.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,0]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,4,-1,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题为hard 难度,不过确实不错！理解好题目，要求O(N),那肯定不能排序。</li><li>假设数组长度为N，最理想的情况就是return N+1，说明1～N 全部出现了，那如果，在我们遍历过程中，出现了一个 不在[1,N]区间的元素或者重复出现[1,N]中的元素 意味着，我们期待的N+1不可能实现了，因为有其他元素 “占位”了，此时最理想的情况是 [1,N-1]仍然满足条件，return N,所以，当扫描到异常元素时，会导致我们期望的值缩小。</li><li>有一点，我们怎么保证我们扫描过的元素是连续的，并且是不重复的，因为重复的会占位，所以我们用双指针，L代表扫描过有效的元素。R代表我们期望的，利用下表与值的关系来重新排列，让元素在对应的下表位置(O(N)),</li><li>特别注意<code>nums[L] == nums[nums[L]-1]</code>,当要置位的元素已经存在时候，说明也是垃圾值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>; <span class="comment">//L,R为虚指,所谓的有效区得保证有效，关键是连续，也就是扫描过去的元素得是连续的才行,L位置必须是放L+1的值</span></span><br><span class="line">        <span class="keyword">int</span> R = nums.length-<span class="number">1</span>; <span class="comment">//R+1代表可连续增长的最大值</span></span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[L]==L+<span class="number">1</span>)&#123;</span><br><span class="line">               L++;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[L] &lt;= L||nums[L] &gt; R+<span class="number">1</span> ||nums[L] == nums[nums[L]-<span class="number">1</span>])&#123;</span><br><span class="line">               swap(nums,L,R);</span><br><span class="line">               R--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               swap(nums,L,nums[L]-<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> loc1,<span class="keyword">int</span> loc2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num[loc1];</span><br><span class="line">        num[loc1] = num[loc2];</span><br><span class="line">        num[loc2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>38. Count and Say</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-38-Count-and-Say/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-38-Count-and-Say/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">https://leetcode.com/problems/count-and-say/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    The <strong>count-and-say</strong> sequence is a sequence of digit strings defined by the recursive formula:</p><ul><li><code>countAndSay(1) = &quot;1&quot;</code></li><li><code>countAndSay(n)</code> is the way you would “say” the digit string from <code>countAndSay(n-1)</code>, which is then converted into a different digit string.</li></ul><p>To determine how you “say” a digit string, split it into the <strong>minimal</strong> number of substrings such that each substring contains exactly <strong>one</strong> unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.</p><p>For example, the saying and conversion for digit string <code>&quot;3322251&quot;</code>:</p><p><img src="https://assets.leetcode.com/uploads/2020/10/23/countandsay.jpg" alt="img"></p><p>Given a positive integer <code>n</code>, return <em>the</em> <code>nth</code> <em>term of the <strong>count-and-say</strong> sequence</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: &quot;1&quot;</span><br><span class="line">Explanation: This is the base case.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 4</span><br><span class="line">Output: &quot;1211&quot;</span><br><span class="line">Explanation:</span><br><span class="line">countAndSay(1) &#x3D; &quot;1&quot;</span><br><span class="line">countAndSay(2) &#x3D; say &quot;1&quot; &#x3D; one 1 &#x3D; &quot;11&quot;</span><br><span class="line">countAndSay(3) &#x3D; say &quot;11&quot; &#x3D; two 1&#39;s &#x3D; &quot;21&quot;</span><br><span class="line">countAndSay(4) &#x3D; say &quot;21&quot; &#x3D; one 2 + one 1 &#x3D; &quot;12&quot; + &quot;11&quot; &#x3D; &quot;1211&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 30</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>很多题目只是表面花里胡哨，读懂了，把题目简化一下，就发现时一个很普通的模型，此题就属于这类，写好递归即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] last = countAndSay(n - <span class="number">1</span>).toCharArray();</span><br><span class="line">StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; last.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (last[i - <span class="number">1</span>] == last[i]) &#123;</span><br><span class="line">times++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans.append(times);</span><br><span class="line">ans.append(last[i - <span class="number">1</span>]);</span><br><span class="line">times = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.append(times);</span><br><span class="line">ans.append(last[last.length - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36. Valid Sudoku</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-36-Valid-Sudoku/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-36-Valid-Sudoku/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode.com/problems/valid-sudoku/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-sudoku/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Determine if a <code>9 x 9</code> Sudoku board is valid. Only the filled cells need to be validated <strong>according to the following rules</strong>:</p><ol><li>Each row must contain the digits <code>1-9</code> without repetition.</li><li>Each column must contain the digits <code>1-9</code> without repetition.</li><li>Each of the nine <code>3 x 3</code> sub-boxes of the grid must contain the digits <code>1-9</code> without repetition.</li></ol><p><strong>Note:</strong></p><ul><li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li><li>Only the filled cells need to be validated according to the mentioned rules.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; </span><br><span class="line">[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> is a digit <code>1-9</code> or <code>&#39;.&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>其实就是遍历，判断一下此时在列方向、行方向是不是不满足条件，遍历过程中标记好条件即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//主要是存当前行、当前列、当前子块</span></span><br><span class="line">        <span class="keyword">int</span>[][] rowVisited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">10</span>]; <span class="comment">// 第二维是数字</span></span><br><span class="line">        <span class="keyword">int</span>[][] colVisited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">10</span>]; <span class="comment">//第二维是数字</span></span><br><span class="line">        <span class="keyword">int</span>[][] subMatrixVisited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> subId =<span class="number">3</span> * (i/<span class="number">3</span>) + j/<span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">char</span> t = board[i][j]; </span><br><span class="line">                    <span class="keyword">if</span>(t == <span class="string">'.'</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> num = t - <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(rowVisited[i][num] == <span class="number">1</span> || colVisited[j][num] == <span class="number">1</span> || subMatrixVisited[subId][num]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rowVisited[i][num] = <span class="number">1</span>;</span><br><span class="line">                    colVisited[j][num] = <span class="number">1</span>;</span><br><span class="line">                    subMatrixVisited[subId][num]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> Find First and Last Position of Element in Sorted Array</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-Find-First-and-Last-Position-of-Element-in-Sorted-Array/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p><p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [], target &#x3D; 0</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>nums</code> is a non-decreasing array.</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>二分的典型应用，查找第一个满足条件的值，其实 二分在求某个函数的解时，威力无穷，有机会专门总结一下。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.length==<span class="number">0</span>?<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125; : (nums[<span class="number">0</span>]==target ? <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125; : <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = binarySearch(nums, target );</span><br><span class="line">        <span class="keyword">if</span>(left == Integer.MAX_VALUE||nums[left] &gt; target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> right = binarySearch(nums, target + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right == Integer.MAX_VALUE ? nums.length-<span class="number">1</span>:right-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找 查找第一个一个大于等于target的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r =nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                res = Math.min(res,mid);</span><br><span class="line">                r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                l = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>33. Search in Rotated Sorted Array</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-33-Search-in-Rotated-Sorted-Array/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-33-Search-in-Rotated-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/search-in-rotated-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p><p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p><p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of</em> <code>target</code> <em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li>All values of <code>nums</code> are <strong>unique</strong>.</li><li><code>nums</code> is an ascending array that is possibly rotated.</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目不错，已经要求你log(n)的时间复杂度，那只能往二分上去想了，这是很明确的吧。</li><li>既然二分，关键在于根据题目的特点，找到能每次二分的点，每次能砍掉近一半的数据，此题的特点是原先是上升的，如果出现了下降的元素，那么就是发生了旋转,我们可以先通过比较l和r位置元素判断出此时是否是旋转区间，如果不是，直接二分查找，如果是可以通过l、mid、r三个位置的元素来确定哪个区间出现了旋转区间，对于无旋转区间的 可以直接判断出target是否存在此区间。</li><li>利用好，无旋转区间，即上升区间的特点，可以减少很多复杂的判断，最终目的就是缩小解空间，最终逼近答案</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[r])&#123; <span class="comment">//l 到 r内 是递增区间，无旋转点，直接二分查找</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//l 到 r内 含有旋转点 ,进一步通过mid 来定位旋转点</span></span><br><span class="line">                <span class="keyword">if</span>(nums[l] &lt;= nums[mid])&#123; <span class="comment">//左边无旋转点,从[l,mid]是升区间</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[l] &lt;= target &amp;&amp; nums[mid] &gt;= target)&#123;</span><br><span class="line">                        <span class="comment">//来此区间找</span></span><br><span class="line">                        r = mid -<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        l = mid +<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  <span class="comment">//从mid+1到r才是正常区间</span></span><br><span class="line">                        <span class="comment">//左边有旋转区间,右边无旋转点，即问题变成了，此时如何判断target是在左变还是右边?通过右区间判断</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[mid] &lt;= target &amp;&amp; nums[r] &gt;=target)&#123; <span class="comment">//来右边</span></span><br><span class="line">                        l = mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                        r = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>29. Divide Two Integers</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-29-Divide-Two-Integers/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-29-Divide-Two-Integers/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/divide-two-integers/" target="_blank" rel="noopener">https://leetcode.com/problems/divide-two-integers/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers <strong>without</strong> using multiplication, division, and mod operator.</p><p>The integer division should truncate toward zero, which means losing its fractional part. For example, <code>8.345</code> would be truncated to <code>8</code>, and <code>-2.7335</code> would be truncated to <code>-2</code>.</p><p>Return <em>the <strong>quotient</strong> after dividing</em> <code>dividend</code> <em>by</em> <code>divisor</code>.</p><p><strong>Note:</strong> Assume we are dealing with an environment that could only store integers within the <strong>32-bit</strong> signed integer range: <code>[−231, 231 − 1]</code>. For this problem, if the quotient is <strong>strictly greater than</strong> <code>231 - 1</code>, then return <code>231 - 1</code>, and if the quotient is <strong>strictly less than</strong> <code>-231</code>, then return <code>-231</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend &#x3D; 10, divisor &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 10&#x2F;3 &#x3D; 3.33333.. which is truncated to 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend &#x3D; 7, divisor &#x3D; -3</span><br><span class="line">Output: -2</span><br><span class="line">Explanation: 7&#x2F;-3 &#x3D; -2.33333.. which is truncated to -2.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= dividend, divisor &lt;= 231 - 1</code></li><li><code>divisor != 0</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这题leetcode标注为中等难度，点踩的人特别多， 我也比较晕 不知道考察什么，可能还没领会到精髓。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//溢出的情况判断</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> dividend/divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28. Implement strStr()</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-28-Implement-strStr/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-28-Implement-strStr/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-strstr/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strStr()</a>.</p><p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p><p><strong>Clarification:</strong></p><p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p><p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C’s <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strstr()</a> and Java’s <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String" target="_blank" rel="noopener">indexOf()</a>).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> and <code>needle</code> consist of only lowercase English characters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题leetcode是标注是easy,其实考察的是kmp字符串匹配算法，疑问java的indexOf方法底层实际就是kmp的实现，所以这个地方就偷个懒了，有关Kmp方法以及它的改进，有机会我会详细讲解。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26. Remove Duplicates from Sorted Array</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-26-Remove-Duplicates-from-Sorted-Array/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-26-Remove-Duplicates-from-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>.</p><p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code> should hold the final result. It does not matter what you leave beyond the first <code>k</code> elements.</p><p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p><p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p><p><strong>Custom Judge:</strong></p><p>The judge will test your solution with the following code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums &#x3D; [...]; &#x2F;&#x2F; Input array</span><br><span class="line">int[] expectedNums &#x3D; [...]; &#x2F;&#x2F; The expected answer with correct length</span><br><span class="line"></span><br><span class="line">int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; Calls your implementation</span><br><span class="line"></span><br><span class="line">assert k &#x3D;&#x3D; expectedNums.length;</span><br><span class="line">for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] &#x3D;&#x3D; expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,2]</span><br><span class="line">Output: 2, nums &#x3D; [1,2,_]</span><br><span class="line">Explanation: Your function should return k &#x3D; 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">Output: 5, nums &#x3D; [0,1,2,3,4,_,_,_,_,_]</span><br><span class="line">Explanation: Your function should return k &#x3D; 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li><li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，双指针，通过一次遍历把重复元素去除掉，简答题目第一次能做出来也挺不错的，不知道为什么那么多人点踩。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>; <span class="comment">//p1实指，p1以及之后都是留下来的了</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> p2 = <span class="number">0</span>;p2 &lt; nums.length;p2++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p1] != nums[p2])&#123;</span><br><span class="line">                nums[++p1] = nums[p2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23. Merge k Sorted Lists</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-23-Merge-k-Sorted-Lists/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-23-Merge-k-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-k-sorted-lists/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p><p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">Output: [1,1,2,3,4,4,5,6]</span><br><span class="line">Explanation: The linked-lists are:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">merging them into one sorted list:</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; [[]]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 104</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-104 &lt;= lists[i][j] &lt;= 104</code></li><li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li><li>The sum of <code>lists[i].length</code> will not exceed <code>10^4</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>难度不大，主要考察堆，属于堆的典型题目，再配合链表，算是常考题目了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        ListNode last = <span class="keyword">null</span>;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;((a,b)-&gt;a.val - b.val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                heap.add(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">final</span> ListNode t = heap.poll();</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">                head = t;</span><br><span class="line">                last = t;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                last.next = t;</span><br><span class="line">                last = last.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                heap.add(t.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22. Generate Parentheses</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-22-Generate-Parentheses/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-22-Generate-Parentheses/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/generate-parentheses/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: [&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: [&quot;()&quot;]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>普通题，考察写递归的能力。</li><li>要的是全部解，这种全部可能性的肯定是递归来收集答案了，注意递归的写法，确定递归函数中需要哪些信息来确定参数，要尽可能的减少参数</li><li>递归中，假设到[0,index-1]的已经正确的填完了，现在来填index的位置，每次填，用条件保证填对，这样到length的位置，递归结束，此时的填写的path是正确的一种，不用再进行判断。如何判断此时填什么符合？<ul><li>首先，leftSize表示还能填左括号的个数，开始默认是n个,那么leftSize &gt; 0，此时可以填 左括号,填完leftSize 需要减1</li><li>右括号填写的条件是，已经填的右括号的个数: $index-(N-leftSize)$  仍然小于左括号个数：$N-leftSize$,整理可得$index &lt; 2 *(N-leftSize)$</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        process(n,<span class="number">0</span>,res,path,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> leftRest,<span class="keyword">int</span> index,List&lt;String&gt; res,StringBuilder path,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">2</span>*N)&#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftRest &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            process(leftRest-<span class="number">1</span>,index+<span class="number">1</span>,res,path.append(<span class="string">"("</span>),N);</span><br><span class="line">            path.deleteCharAt(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">2</span> *(N-leftRest))&#123;</span><br><span class="line">            process(leftRest,index+<span class="number">1</span>,res,path.append(<span class="string">")"</span>),N);</span><br><span class="line">            path.deleteCharAt(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21. Merge Two Sorted Lists</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-21-Merge-Two-Sorted-Lists/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-21-Merge-Two-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p> <a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p><p>Merge the two lists in a one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p><p>Return <em>the head of the merged linked list</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: list1 &#x3D; [1,2,4], list2 &#x3D; [1,3,4]</span><br><span class="line">Output: [1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: list1 &#x3D; [], list2 &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: list1 &#x3D; [], list2 &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>Both <code>list1</code> and <code>list2</code> are sorted in <strong>non-decreasing</strong> order.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，细心点就可以了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">        ListNode head = list1;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">                pre = pre ==<span class="keyword">null</span>?list1:pre.next;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode tmp = list2.next;</span><br><span class="line">                list2.next = list1;</span><br><span class="line">                <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre = list2;</span><br><span class="line">                    head = list2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre.next = list2;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                list2 = tmp;</span><br><span class="line">                list1 = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list2 != <span class="keyword">null</span>)</span><br><span class="line">            pre.next = list2;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20. Valid Parentheses</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-20-Valid-Parentheses/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-20-Valid-Parentheses/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-parentheses/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> consists of parentheses only <code>&#39;()[]{}&#39;</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>很简单，栈的最基本应用</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> N = str.length;</span><br><span class="line"><span class="keyword">char</span>[] stack = <span class="keyword">new</span> <span class="keyword">char</span>[N];</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> cha = str[i];</span><br><span class="line"><span class="keyword">if</span> (cha == <span class="string">'('</span> || cha == <span class="string">'['</span> || cha == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">stack[size++] = cha == <span class="string">'('</span> ? <span class="string">')'</span> : (cha == <span class="string">'['</span> ? <span class="string">']'</span> : <span class="string">'&#125;'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> last = stack[--size];</span><br><span class="line"><span class="keyword">if</span> (cha != last) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19. Remove Nth Node From End of List</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-19-Remove-Nth-Node-From-End-of-List/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-19-Remove-Nth-Node-From-End-of-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-nth-node-from-end-of-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">Output: [1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1], n &#x3D; 1</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], n &#x3D; 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is <code>sz</code>.</li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，考察数据结构基本功，写的时候耐心点，细节点即可。</li><li>小技巧，保留一个pre和cur遍历指针相隔K个，这样等cur==null时，pre指向的就是要的元素。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          ListNode cur = head,pre = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(step &gt;= n)&#123;</span><br><span class="line">                  pre = pre == <span class="keyword">null</span> ? head : pre.next;</span><br><span class="line">              &#125;</span><br><span class="line">              cur = cur.next;</span><br><span class="line">              step++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> head.next;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              pre.next = pre.next.next;</span><br><span class="line">              <span class="keyword">return</span> head;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> Letter Combinations of a Phone Number</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-Letter-Combinations-of-a-Phone-Number/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-Letter-Combinations-of-a-Phone-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">https://leetcode.com/problems/letter-combinations-of-a-phone-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p><p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><img src="https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png" alt="img"></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; &quot;&quot;</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; &quot;2&quot;</span><br><span class="line">Output: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> is a digit in the range <code>[&#39;2&#39;, &#39;9&#39;]</code>.</li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>不难，主要是考察会不会写递归，在递归中收集组合</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[][] phone = &#123; </span><br><span class="line">&#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> &#125;, <span class="comment">// 2    0</span></span><br><span class="line">&#123; <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span> &#125;, <span class="comment">// 3    1</span></span><br><span class="line">&#123; <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span> &#125;, <span class="comment">// 4    2</span></span><br><span class="line">&#123; <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span> &#125;, <span class="comment">// 5    3</span></span><br><span class="line">&#123; <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span> &#125;, <span class="comment">// 6    </span></span><br><span class="line">&#123; <span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span> &#125;, <span class="comment">// 7 </span></span><br><span class="line">&#123; <span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span> &#125;,   <span class="comment">// 8</span></span><br><span class="line">&#123; <span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span> &#125;, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "23"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = digits.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] path = <span class="keyword">new</span> <span class="keyword">char</span>[str.length];</span><br><span class="line">process(str, <span class="number">0</span>, path, ans);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> index, <span class="keyword">char</span>[] path, List&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == str.length) &#123;</span><br><span class="line">ans.add(String.valueOf(path));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">char</span>[] cands = phone[str[index] - <span class="string">'2'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> cur : cands) &#123;</span><br><span class="line">path[index] = cur;</span><br><span class="line">process(str, index + <span class="number">1</span>, path, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 3Sum</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-15-3Sum/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-15-3Sum/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p><p>Notice that the solution set must not contain duplicate triplets.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,0,1,2,-1,-4]</span><br><span class="line">Output: [[-1,-1,2],[-1,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">nums[0] + nums[1] + nums[1] &#x3D; (-1) + 0 + 1 &#x3D; 0.</span><br><span class="line">nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0.</span><br><span class="line">nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0.</span><br><span class="line">The distinct triplets are [-1,0,1] and [-1,-1,2].</span><br><span class="line">Notice that the order of the output and the order of the triplets does not matter.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,1]</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The only possible triplet does not sum up to 0.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,0,0]</span><br><span class="line">Output: [[0,0,0]]</span><br><span class="line">Explanation: The only possible triplet sums up to 0.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>中等难度，不错的题目。先理解题目，要求输出的三元组 是元素的值，并且list里面的3元组不能重复</li><li>可以这样想3元组和为0，3个元素一定是小中大的关系，可以枚举小的元素，再去找中和大的元素。可以将元素排序，这样依次枚举，枚举的一定是小的元素，巧妙的避免重复。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> p1 = i+<span class="number">1</span>,p2 = nums.length-<span class="number">1</span>,target = <span class="number">0</span>-nums[i];</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; p2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[p1]+nums[p2] == target)&#123;</span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    tmp.add(nums[i]);</span><br><span class="line">                    tmp.add(nums[p1++]);</span><br><span class="line">                    tmp.add(nums[p2--]);</span><br><span class="line">                    list.add(tmp);</span><br><span class="line">                    <span class="keyword">while</span> (p2 &gt; p1 &amp;&amp; nums[p2] == nums[p2+<span class="number">1</span>]) p2--;</span><br><span class="line">                    <span class="keyword">while</span> (p1 &lt; p2 &amp;&amp; nums[p1] == nums[p1-<span class="number">1</span>]) p1++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[p1]+nums[p2] &lt; target)&#123;</span><br><span class="line">                    p1++;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14. Longest Common Prefix</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-14-Longest-Common-Prefix/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-14-Longest-Common-Prefix/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-common-prefix/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> consists of only lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>遍历，不断缩短前缀即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String commonPrefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[i].indexOf(commonPrefix) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> length = commonPrefix.length();</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> ( j = length-<span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(strs[i].indexOf(commonPrefix.substring(<span class="number">0</span>,j)) == <span class="number">0</span>)&#123;</span><br><span class="line">                        commonPrefix = commonPrefix.substring(<span class="number">0</span>,j);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    commonPrefix = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> commonPrefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13. Roman to Integer</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-13-Roman-to-Integer/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-13-Roman-to-Integer/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/roman-to-integer/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>For example, <code>2</code> is written as <code>II</code> in Roman numeral, just two ones added together. <code>12</code> is written as <code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;III&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: III &#x3D; 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 15</code></li><li><code>s</code> contains only the characters <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code>.</li><li>It is <strong>guaranteed</strong> that <code>s</code> is a valid roman numeral in the range <code>[1, 3999]</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>水题，比较简单，看懂题意就能做.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">// C     M     X   C     I   X</span></span><br><span class="line"><span class="comment">// 100  1000  10   100   1   10</span></span><br><span class="line"><span class="keyword">int</span> nums[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">switch</span> (s.charAt(i)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">nums[i] = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">nums[i] = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">nums[i] = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">nums[i] = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">nums[i] = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">nums[i] = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">nums[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">sum -= nums[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum + nums[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Container With Most Water</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-11-Container-With-Most-Water/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-11-Container-With-Most-Water/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode.com/problems/container-with-most-water/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>ith</code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p><p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p><p>Return <em>the maximum amount of water a container can store</em>.</p><p><strong>Notice</strong> that you may not slant the container.</p><p><strong>Example 1:</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br><span class="line">Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [1,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>绝对的经典问题，通过双指针，不断的推高答案，不是一下找到答案，而是尽可能的寻找到最接近答案的值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[p1] &lt; height[p2])&#123;</span><br><span class="line">               res = Math.max((p2-p1)*height[p1],res);</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max((p2-p1)*height[p2],res);</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two pointer </tag>
            
            <tag> greed </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10. Regular Expression Matching</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-10-Regular-Expression-Matching/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-10-Regular-Expression-Matching/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an input string <code>s</code> and a pattern <code>p</code>, implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code> where:</p><ul><li><code>&#39;.&#39;</code> Matches any single character.</li><li><code>&#39;*&#39;</code> Matches zero or more of the preceding element.</li></ul><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ab&quot;, p &#x3D; &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= p.length &lt;= 30</code></li><li><code>s</code> contains only lowercase English letters.</li><li><code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and <code>&#39;*&#39;</code>.</li><li>It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题，第一次做的的话 会比较麻烦。用i代表字符串的当前字符，j代表正则表达式的当前字符，主要分区，后面的字符是不是<em>这种情况，如果是\</em>，说明当前i未必非得让j来匹配，i和j不同要继续看i和j+2可不可能匹配，如果i后面是一串连续相同的字符，要考虑j是匹配几个着同样的字符呢？</li><li>进行斜率优化，其实，递归是从左到右进行的，循环是可以通过观察替换出来的。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(s.toCharArray(),<span class="number">0</span>,p.toCharArray(),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> i,<span class="keyword">char</span>[] exp,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==exp.length) <span class="keyword">return</span> i ==str.length;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span> != exp.length &amp;&amp; exp[j+<span class="number">1</span>] != <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i != str.length &amp;&amp; (str[i]==exp[j] || exp[j]==<span class="string">'.'</span>) &amp;&amp; process(str,i+<span class="number">1</span>,exp,j+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> == exp.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span> == str.length &amp;&amp; (str[i]==exp[j] || exp[j]==<span class="string">'.'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> c = i;</span><br><span class="line">                <span class="keyword">while</span> (c &lt; str.length &amp;&amp; (str[c]==exp[j]||exp[j]==<span class="string">'.'</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (process(str,c+<span class="number">1</span>,exp,j+<span class="number">2</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    c++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  process(str,i,exp,j+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process(s.toCharArray(),<span class="number">0</span>,p.toCharArray(),<span class="number">0</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> i,<span class="keyword">char</span>[] exp,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>) <span class="keyword">return</span> dp[i][j]==<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == exp.length) &#123;</span><br><span class="line">           res = i == str.length;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> != exp.length &amp;&amp; exp[j + <span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != str.length &amp;&amp; (str[i] == exp[j] || exp[j] == <span class="string">'.'</span>) &amp;&amp; process2(str, i + <span class="number">1</span>, exp, j + <span class="number">1</span>,dp))&#123;</span><br><span class="line">                    res = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> == exp.length) &#123;</span><br><span class="line">                    res =  i + <span class="number">1</span> == str.length &amp;&amp; (str[i] == exp[j] || exp[j] == <span class="string">'.'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">                        res = process2(str, i, exp, j + <span class="number">2</span>,dp);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(str[i] != exp[j] &amp;&amp; exp[j] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                            res =  process2(str, i, exp, j + <span class="number">2</span>,dp);</span><br><span class="line">                        &#125;<span class="keyword">else</span></span><br><span class="line">                            res = process2(str, i, exp, j + <span class="number">2</span>,dp) || process2(str, i+<span class="number">1</span>, exp, j,dp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = res?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8. String to Integer (atoi)</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-8-String-to-Integer-atoi/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-8-String-to-Integer-atoi/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode.com/problems/string-to-integer-atoi/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer (similar to C/C++’s <code>atoi</code> function).</p><p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p><ol><li>Read in and ignore any leading whitespace.</li><li>Check if the next character (if not already at the end of the string) is <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code>. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.</li><li>Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.</li><li>Convert these digits into an integer (i.e. <code>&quot;123&quot; -&gt; 123</code>, <code>&quot;0032&quot; -&gt; 32</code>). If no digits were read, then the integer is <code>0</code>. Change the sign as necessary (from step 2).</li><li>If the integer is out of the 32-bit signed integer range <code>[-231, 231 - 1]</code>, then clamp the integer so that it remains in the range. Specifically, integers less than <code>-231</code> should be clamped to <code>-231</code>, and integers greater than <code>231 - 1</code> should be clamped to <code>231 - 1</code>.</li><li>Return the integer as the final result.</li></ol><p><strong>Note:</strong></p><ul><li>Only the space character <code>&#39; &#39;</code> is considered a whitespace character.</li><li><strong>Do not ignore</strong> any characters other than the leading whitespace or the rest of the string after the digits.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;42&quot;</span><br><span class="line">Output: 42</span><br><span class="line">Explanation: The underlined characters are what is read in, the caret is the current reader position.</span><br><span class="line">Step 1: &quot;42&quot; (no characters read because there is no leading whitespace)</span><br><span class="line">         ^</span><br><span class="line">Step 2: &quot;42&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)</span><br><span class="line">         ^</span><br><span class="line">Step 3: &quot;42&quot; (&quot;42&quot; is read in)</span><br><span class="line">           ^</span><br><span class="line">The parsed integer is 42.</span><br><span class="line">Since 42 is in the range [-231, 231 - 1], the final result is 42.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation:</span><br><span class="line">Step 1: &quot;   -42&quot; (leading whitespace is read and ignored)</span><br><span class="line">            ^</span><br><span class="line">Step 2: &quot;   -42&quot; (&#39;-&#39; is read, so the result should be negative)</span><br><span class="line">             ^</span><br><span class="line">Step 3: &quot;   -42&quot; (&quot;42&quot; is read in)</span><br><span class="line">               ^</span><br><span class="line">The parsed integer is -42.</span><br><span class="line">Since -42 is in the range [-231, 231 - 1], the final result is -42.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation:</span><br><span class="line">Step 1: &quot;4193 with words&quot; (no characters read because there is no leading whitespace)</span><br><span class="line">         ^</span><br><span class="line">Step 2: &quot;4193 with words&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)</span><br><span class="line">         ^</span><br><span class="line">Step 3: &quot;4193 with words&quot; (&quot;4193&quot; is read in; reading stops because the next character is a non-digit)</span><br><span class="line">             ^</span><br><span class="line">The parsed integer is 4193.</span><br><span class="line">Since 4193 is in the range [-231, 231 - 1], the final result is 4193.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length &lt;= 200</code></li><li><code>s</code> consists of English letters (lower-case and upper-case), digits (<code>0-9</code>), <code>&#39; &#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;.&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这题点踩的人有点多，个人也感觉这个题不是很漂亮，主要条件描述不清楚，各种异常的情况 报错了才知道，而且也考察不出什么东西。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="keyword">if</span>(s.length() ==<span class="number">0</span> || s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span> c = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(c&lt;=<span class="string">'z'</span> &amp;&amp; c &gt;= <span class="string">'a'</span> || c == <span class="string">'.'</span> || c &lt;= <span class="string">'Z'</span>&amp;&amp; c &gt;= <span class="string">'A'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//一定是以数字或者字符或者空白开头</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span> || s.charAt(i) == <span class="string">'-'</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">if</span>(!(s.charAt(<span class="number">0</span>) &lt;= <span class="string">'9'</span> &amp;&amp; s.charAt(<span class="number">0</span>) &gt;= <span class="string">'0'</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.length() &amp;&amp; !(s.charAt(i+<span class="number">1</span>) &gt;=<span class="string">'0'</span> &amp;&amp; s.charAt(i+<span class="number">1</span>) &lt;=<span class="string">'9'</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String regex = <span class="string">"[-+]?\\d+"</span>;</span><br><span class="line">        <span class="keyword">final</span> Pattern pattern = Pattern.compile(regex);</span><br><span class="line">        <span class="keyword">final</span> Matcher matcher = pattern.matcher(s);</span><br><span class="line">        <span class="keyword">if</span>(matcher.find())&#123;</span><br><span class="line">            <span class="keyword">final</span> String int_str = matcher.group();</span><br><span class="line">            <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                l = Integer.parseInt(int_str);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">if</span>(int_str.charAt(<span class="number">0</span>) == <span class="string">'-'</span>)</span><br><span class="line">                    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7. Reverse Integer</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-7-Reverse-Integer/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-7-Reverse-Integer/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-integer/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a signed 32-bit integer <code>x</code>, return <code>x</code> <em>with its digits reversed</em>. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range <code>[-2^31, 2^31 - 1]</code>, then return <code>0</code>.</p><p><strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</strong></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= x &lt;= 23^1 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ol><li>此题偏简单，不能使用Long来存，反转之后，我们需要一位一位的进行计算存值，肯定会有溢出的情况，所以，我们要学会“提前处理”，<code>res==m &amp;&amp; x%10 &lt; o</code>  否则很有可能到最后是溢出的情况而我们又判断不出此时的情况。</li><li>可以将传入的整数以负数形式存储，这样存的值对于反转之后Integer.MIN来说正好存下，当然此题不会传入这种值，但若是以字符串形式传入，这个技巧就生效了。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> neg = x &lt; <span class="number">0</span>;</span><br><span class="line">        x = neg ? x : -x;   <span class="comment">//溢出是两个方向的，统一变负数处理，可以换成一个方向上 </span></span><br><span class="line">        <span class="keyword">int</span> m = Integer.MIN_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> o = Integer.MIN_VALUE % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res &lt; m || res==m &amp;&amp; x%<span class="number">10</span> &lt; o) <span class="comment">//提前进行整数溢出的判断</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neg ? res : Math.abs(res);  <span class="comment">//理论会有 负数没溢出，转绝对值溢出的情况，所以应该特殊处理，但这个题输入是一个整数，不会出现反转是-2147483647</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. Longest Palindromic Substring</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-5-Longest-Palindromic-Substring/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-5-Longest-Palindromic-Substring/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-palindromic-substring/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code>, return <em>the longest palindromic substring</em> in <code>s</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Explanation: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> consist of only digits and English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题是比较经典的DP问题，可以先对边界进行单独处理，转移方程如下:<script type="math/tex; mode=display">dp[i][j] = \begin{cases} true & i = j\\equal(chars[i],chars[j]) & j=i+1,j < N  \end{cases}</script>然后，再对非边界内元素进行递推即可:<script type="math/tex; mode=display">dp[i][j] = \begin{cases}  if (chars[i]=chars[j])  & dp[i+1][j-1]\\ else & false \end{cases}</script></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sd=<span class="number">0</span>,ed=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; N)&#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = chars[i]==chars[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][i+<span class="number">1</span>])&#123;</span><br><span class="line">                        res = <span class="number">2</span>;</span><br><span class="line">                        sd = i;</span><br><span class="line">                        ed = i+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">3</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">2</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[i] == chars[j])&#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i+<span class="number">1</span> &gt; res)&#123;</span><br><span class="line">                        res = j-i+<span class="number">1</span>;</span><br><span class="line">                        sd = i;</span><br><span class="line">                        ed = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(sd,ed+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. Median of Two Sorted Arrays</title>
      <link href="/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-4-Median-of-Two-Sorted-Arrays/"/>
      <url>/2022/07/10/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-10-4-Median-of-Two-Sorted-Arrays/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH协议原理及最佳实践</title>
      <link href="/2022/07/07/network-2022-07-07-SSH%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2022/07/07/network-2022-07-07-SSH%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="初识SSH"><a href="#初识SSH" class="headerlink" title="初识SSH"></a>初识SSH</h3><p>​    维基百科是这样描述ssh协议的 ：</p><blockquote><p><strong>Secure Shell</strong>（安全外壳协议，简称<strong>SSH</strong>）是一种加密的<a href="https://zh.m.wikipedia.org/wiki/网络传输协议" target="_blank" rel="noopener">网络传输协议</a>，可在不安全的网络中为网络服务提供安全的传输环境<a href="https://zh.m.wikipedia.org/zh-cn/Secure_Shell#cite_note-rfc4251-1" target="_blank" rel="noopener">[1]</a>。SSH通过在网络中创建<a href="https://zh.m.wikipedia.org/w/index.php?title=安全隧道&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">安全隧道</a>（英语：<a href="https://en.wikipedia.org/wiki/secure_channel" target="_blank" rel="noopener">secure channel</a>）来实现SSH客户端与服务器之间的连接<a href="https://zh.m.wikipedia.org/zh-cn/Secure_Shell#cite_note-rfc4252-2" target="_blank" rel="noopener">[2]</a>。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输<a href="https://zh.m.wikipedia.org/wiki/命令行界面" target="_blank" rel="noopener">命令行界面</a>和远程执行命令。</p></blockquote><p>通常是用来建立一条相对安全的连接，而不是明文传输。</p><h3 id="SSH原理"><a href="#SSH原理" class="headerlink" title="SSH原理"></a>SSH原理</h3><p>同样，SSH协议也要解决三个问题，即</p><ul><li>如何保证信息的保密性？</li><li>如和保证信息的完整性？</li><li>如何识别对方身份？</li></ul><p>其中前两个问题，通过使用对称加密与非对称加密、数字签名可以解决，在之前的HTTPS相关的文章中都有详细的解释，现在我们重点讨论第三个问题，如何识别对方身份？我们知道HTTPS是通过CA机构颁发证书的方式来确认对方的身份，而SSH的公钥和私钥是客户端自己生成，所以没有CA机构认证。SSH协议有两种识别对方身份的方式</p><ul><li>基于口令的认证</li><li>基于公钥认证</li></ul><h4 id="口令认证"><a href="#口令认证" class="headerlink" title="口令认证"></a>口令认证</h4><p>基于口令的认证，我个人认为，实际上基于口令的认证是第一次的时候需要与 “正确的对方”建立连接,次此连接之后给主机生成一个唯一的host_key，相当于”认识“了这台主机，下次建立链接时，如果与一台错误的主机建立链接时，通过host_key便可以识别出来！</p><p> 如下图，第一登陆的时候:</p><p><img src="1.png" alt=""></p><p>图中显是的是，先通过RSA算法对域名+ip这个key结合公钥对应的唯一信息生成加密串,然后做一个hash提取一个比较短的摘要作为指纹（实际上这只是通俗的解释，指纹的生成用到ECDSA算法，这个算法比较复杂，本人也没详细了解就不做过多的介绍了）,询问你是否继续连接</p><p><img src="2.png" alt=""></p><p>其中know hosts用来存放已经接受识别的身份。</p><p>再下一步就是输入密码进行登录了，其实验证是双向的，指纹验证是验证服务器，用户密码就是服务器再验证客户端了。</p><h4 id="公钥认证"><a href="#公钥认证" class="headerlink" title="公钥认证"></a>公钥认证</h4><p>第一种验证方式，再服务器验证客户端的时候，每次都得使用密码来进行验证，所以通过有了第二种方式来进行免密登录。</p><p>具体流程如下:</p><ol><li>Client将自己的公钥存放在Server上，追加在文件authorized_keys中。</li><li>Server端接收到Client的连接请求后，会在authorized_keys中匹配到Client的公钥pubKey，并生成随机数R，用Client的公钥对该随机数进行加密得到pubKey(R)<br> ，然后将加密后信息发送给Client。</li><li>Client端通过私钥进行解密得到随机数R，然后对随机数R和本次会话的SessionKey利用MD5生成摘要Digest1，发送给Server端。</li><li>Server端会也会对R和SessionKey利用同样摘要算法生成Digest2。</li><li>Server端会最后比较Digest1和Digest2是否相同，完成认证过程。</li></ol><p><img src="3.png" alt="img"></p><blockquote><p>在步骤1中，Client将自己的公钥存放在Server上。需要用户手动将公钥copy到server上。这就是在配置ssh的时候进程进行的操作。下图是GitHub上SSH keys设置视图：</p></blockquote><p><img src="4.png" alt=""></p><h3 id="SSH的最佳实践"><a href="#SSH的最佳实践" class="headerlink" title="SSH的最佳实践"></a>SSH的最佳实践</h3><h4 id="SSH生成的文件"><a href="#SSH生成的文件" class="headerlink" title="SSH生成的文件"></a>SSH生成的文件</h4><p><img src="5.png" alt=""></p><ol><li>d_rsa：保存私钥</li><li>id_rsa.pub：保存公钥</li><li>authorized_keys：保存已授权的客户端公钥</li><li>known_hosts：保存已认证的远程主机ID</li></ol><p><img src="6.png" alt=""></p><blockquote><p>需要注意的是：一台主机可能既是Client，也是Server。所以会同时拥有authorized_keys和known_hosts。</p></blockquote><h4 id="有关文件的常见疑问"><a href="#有关文件的常见疑问" class="headerlink" title="有关文件的常见疑问"></a>有关文件的常见疑问</h4><ol><li>known_hosts中存储的内容是什么？</li></ol><p>​    known_hosts中存储是已认证的远程主机host key，每个SSH Server都有一个<strong>secret, unique ID, called a host key</strong>。    </p><ol><li>host key何时加入known_hosts的？</li></ol><p>​    当我们第一次通过SSH登录远程主机的时候</p><ol><li>为什么需要known_hosts？</li></ol><p>​    最后探讨下为什么需要known_hosts，这个文件主要是通过Client和Server的双向认证，从而避免中间人（<strong>man-in-the-middle attack</strong>）攻击，每次Client向Server发起连接的时候，不仅仅Server要验证Client的合法性，Client同样也需要验证Server的身份，SSH client就是通过known_hosts中的host key来验证Server的身份的。</p><blockquote><p>这中方案足够安全吗？当然不，比如第一次连接一个未知Server的时候，known_hosts还没有该Server的host key，这不也可能遭到<strong>中间人</strong>攻击吗？这可能只是安全性和可操作性之间的折中吧。</p></blockquote><h4 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h4><p>记住三步走:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.客户端生成公钥私钥 </span><br><span class="line">ssh-keygen</span><br><span class="line">2.上传公钥到服务器</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.100</span><br><span class="line">3.免密登录</span><br><span class="line">ssh root@192.168.1.100</span><br></pre></td></tr></table></figure><blockquote><p>参考:<a href="https://www.jianshu.com/p/33461b619d53" target="_blank" rel="noopener">https://www.jianshu.com/p/33461b619d53</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> ssh </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS与&quot;中间人攻击&quot;</title>
      <link href="/2022/07/07/network-2022-07-07-HTTPS%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
      <url>/2022/07/07/network-2022-07-07-HTTPS%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="引导问题"><a href="#引导问题" class="headerlink" title="引导问题"></a>引导问题</h3><ol><li><p>为什么使用Https是安全的？</p></li><li><p>Https的底层原理如何实现？</p></li><li><p>使用Https是绝对安全的吗？</p></li></ol><h3 id="Https实现原理"><a href="#Https实现原理" class="headerlink" title="Https实现原理"></a>Https实现原理</h3><p>Https协议在内容传输上使用的加密是“对称加密”，而“非对称加密”只作用于证书验证阶段。Https的整体实现过程分为“证书验证”和“数据传输”两个阶段，过程如下所示：</p><ul><li>Https协议在内容传输上使用的加密是“对称加密”，而“非对称加密”只作用于证书验证阶段。</li><li>Https的整体实现过程分为“证书验证”和“数据传输”两个阶段，过程如下所示：</li></ul><p>​    <img src="1.png" alt="0"></p><p><strong>证书验证阶段</strong></p><ol><li><p>浏览器发起Https请求；</p></li><li><p>服务器端返回Https证书；</p></li><li><p>浏览器客户端验证证书是否合法，若不合法则提示警告</p></li></ol><p><strong>数据传输阶段</strong></p><ol><li><p>当证书验证合法后，在客户端本地生成随机数；</p></li><li><p>通过公钥加密随机数，并将加密后的随机数传输到服务端；</p></li><li><p>服务端通过私钥对接收到的加密随机数进行解密操作；</p></li><li><p>服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密操作后再进行内容传输。</p></li></ol><h3 id="为什么数据传输是用对称加密？"><a href="#为什么数据传输是用对称加密？" class="headerlink" title="为什么数据传输是用对称加密？"></a>为什么数据传输是用对称加密？</h3><p>首先，非对称加密的加密效率是非常低的，而http的应用场景通常存在着端与端之间的大量数据交互，从效率来说是无法接受的；</p><p>其次，在Https场景中只有服务端保存了私钥，而一对公私钥只能实现单向的加解密（即服务端无法使用私钥对传回浏览器客户端的数据进行加密，只能用于解密），所以Https中内容传输加密采取的是对称加密，而不是非对称加密（此处随机数则是对称加密的介体，即客户端和服务器端所拥有的随机数都是一致的，能够进行双向加解密）。</p><h3 id="为什么需要CA认证机构颁发证书？"><a href="#为什么需要CA认证机构颁发证书？" class="headerlink" title="为什么需要CA认证机构颁发证书？"></a>为什么需要CA认证机构颁发证书？</h3><p>Http协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而Https协议主要就是解决网络传输的安全性问题。</p><p>首先，我们假设不存在认证机构，任何人都可以制作证书，这存在的风险便是经典的“中间人攻击”问题。具体过程如下：</p><p>​    <img src="2.png" alt="0"></p><h3 id="“中间人攻击”原理"><a href="#“中间人攻击”原理" class="headerlink" title="“中间人攻击”原理"></a>“中间人攻击”原理</h3><ol><li><p>客户端请求被劫持（如DNS劫持等），所有的客户端请求均被转发至中间人的服务器；</p></li><li><p>中间人服务器返回中间人伪造的“伪证书”（包含伪公钥）；</p></li><li><p>客户端创建随机数，通过中间人证书的伪公钥对随机数进行加密后传输给中间人，然后凭随机数构造对称加密算法对要进行传输的数据内容进行对称加密后传输；</p></li><li><p>中间人因为拥有客户端生成的随机数，从而能够通过对称加密算法进行数据内容解密；</p></li><li><p>中间人再以“伪客户端”的身份向正规的服务端发起请求；</p></li><li><p>因为中间人与服务器之间的通信过程是合法的，正规服务端通过建立的安全通道返回加密后的数据内容；</p></li><li><p>中间人凭借与正规服务器建立的对称加密算法进行数据内容解密；</p></li><li><p>中间人再通过与客户端建立的对称加密算法对正规服务器返回的数据内容进行加密传输；</p></li><li><p>客户端通过中间人建立的对称加密算法对返回的数据内容进行解密；</p></li></ol><p>由于缺少对证书的真伪性验证，所有客户端即使发起了Https请求，但客户端完全不知道自己发送的请求已经被第三方拦截，导致其中传输的数据内容被中间人窃取。</p><h3 id="浏览器如何确保CA证书的合法性？"><a href="#浏览器如何确保CA证书的合法性？" class="headerlink" title="浏览器如何确保CA证书的合法性？"></a>浏览器如何确保CA证书的合法性？</h3><ol><li>证书包含的主要信息：</li></ol><ul><li>颁发机构信息</li><li>公钥</li><li>公司信息</li><li>域名</li><li>有效期</li><li>指纹</li><li>等等</li></ul><ol><li>证书的合法性依据</li></ol><p>首先，权威机构是需要通过认证的。其次证书的可信性基于信任制，CA认证机构需要对其颁发的证书进行信用担保，只要是CA认证机构颁发的证书，我们就认为是合法的。CA认证机构会对证书申请人的信息进行审核的。</p><ol><li><p>浏览器如何验证证书的合法性？</p><p>浏览器发起https请求时，服务器会返回网站的SSL证书，浏览器需要对证书做以下验证：</p></li></ol><ul><li>验证域名、有效期等信息是否正确；</li><li>判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发的证书进行来源验证；</li><li>判断证书是否被篡改。需要与CA服务器进行对比校验；</li><li>判断证书是否已被吊销。通过CRL(Certificate Revocation List 证书注销列表) 和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中OCSP可用于第3步中以减少与CA服务器的交互，提高验证效率。</li></ul><p>以上任意一步都同时满足的情况下，浏览器才认为证书是合法的。</p><h3 id="只有认证机构可以生产证书吗？"><a href="#只有认证机构可以生产证书吗？" class="headerlink" title="只有认证机构可以生产证书吗？"></a>只有认证机构可以生产证书吗？</h3><p>如果需要浏览器不提示安全风险，那只能通过认证机构签发的证书。但浏览器通常只是会提示安全风险，并不会限制网站的访问，所有从技术上来说，谁都可以生产证书，只要有证书就能够完成网站的https传输。</p><h3 id="客户端的本地随机数被窃取了怎么办？"><a href="#客户端的本地随机数被窃取了怎么办？" class="headerlink" title="客户端的本地随机数被窃取了怎么办？"></a>客户端的本地随机数被窃取了怎么办？</h3><p>其实https并不包含对随机数的安全保证，https保证的只是数据传输过程安全，而随机数存储于本地，本地的安全属于另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。（这也反映了Https协议并不是绝对的安全的）</p><h3 id="使用Https被抓包了会怎样？"><a href="#使用Https被抓包了会怎样？" class="headerlink" title="使用Https被抓包了会怎样？"></a>使用Https被抓包了会怎样？</h3><p>由于Https的数据是加密，常规下抓包工具代理请求后抓到的包内容是加密状态的，无法直接查看。</p><p>但是，浏览器只会提示安全风险，如果用户授权仍然继续访问网站，完成请求。那么，只有客户端是我们自己的终端，我们授权的情况下，便能够建立中间人网络，而抓包工具作为中间人的代理。</p><p>通常， HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。</p><p>即是，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。</p><blockquote><p>引用:<a href="https://blog.csdn.net/Jop_qq/article/details/104362064" target="_blank" rel="noopener">https://blog.csdn.net/Jop_qq/article/details/104362064</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashSet与TreeSet源码解析</title>
      <link href="/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-HashSet%E4%B8%8ETreeSet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-HashSet%E4%B8%8ETreeSet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TreeMap源码解析</title>
      <link href="/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-TreeMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-TreeMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>TreeMap是一种常用的key有序的数据结构,底层原理主要是用到动态平衡树，之前研究过了HashMap，解决冲突时链表会转化红黑树，同样这里平衡树依然是红黑树,可见这个数据结构的重要性了。如果红黑树原理不熟悉，那么涉及到具体的操作源码 可先跳过，有关红黑树只需要记住一点，红黑树和AVL都是动态平衡树的一种，都是在BST的基础上改进而来，基础的查询操作和BST一模一样，插入元素与删除元素，都是在元素插入或删除之后根据自己的特性取调整节点-“打补丁”以维持平衡。</p></blockquote><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li>结构图</li><li><p>类注释信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较器，如果外部有传进来 Comparator 比较器，首先用外部的</span></span><br><span class="line"><span class="comment">//如果外部比较器为空，则使用 key 自己的 Comparable 的 compareTo 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"><span class="comment">//红黑树的根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">//树节点的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//树的版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ol><p>看一下这棵红黑树的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> keyHash = (key==<span class="keyword">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> valueHash = (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">"="</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><ol><li>常用属性</li></ol><h3 id="常用操作源码解析"><a href="#常用操作源码解析" class="headerlink" title="常用操作源码解析"></a>常用操作源码解析</h3><ol><li>添加元素</li><li>查找</li><li>删除</li><li>迭代</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList源码解析</title>
      <link href="/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-LinkList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-LinkList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li><p>整体结构</p><p>LinkedList也是常用的一种数据结构,它和ArrayList在逻辑上都是线性结构，而在物理存储上ArrayList是连续存储，LinkedList是非连续存储。LinkedList实现是一个双向链表。Node节点源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     E item;</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line">   </span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">         <span class="keyword">this</span>.item = element;</span><br><span class="line">         <span class="keyword">this</span>.next = next;</span><br><span class="line">         <span class="keyword">this</span>.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>只要稍微熟悉点数据结构对这种实现就不陌生，典型的链表结构，整体的图示如下:</p></li></ol><ol><li><p>类注释信息</p><pre><code>    1. 没有实现线程同步，多线程的时候需要外部来做同步。</code></pre><ol><li>ListIterator也是有“fail-fast”机制的。</li></ol></li><li><p>常见属性</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">transient int size &#x3D; 0;</span><br><span class="line">&#x2F;**</span><br><span class="line">     * Pointer to first node.</span><br><span class="line">     * Invariant: (first &#x3D;&#x3D; null &amp;&amp; last &#x3D;&#x3D; null) ||</span><br><span class="line">     *            (first.prev &#x3D;&#x3D; null &amp;&amp; first.item !&#x3D; null)</span><br><span class="line">     *&#x2F;</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">     * Pointer to last node.</span><br><span class="line">     * Invariant: (first &#x3D;&#x3D; null &amp;&amp; last &#x3D;&#x3D; null) ||</span><br><span class="line">     *            (last.next &#x3D;&#x3D; null &amp;&amp; last.item !&#x3D; null)</span><br><span class="line">     *&#x2F;</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h3 id="常用操作解析"><a href="#常用操作解析" class="headerlink" title="常用操作解析"></a>常用操作解析</h3><ol><li><p>添加</p><ol><li><p>从头插入</p><p>因为比较简单，都是最基础的数据结构，就不过多解释了，源码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从头部追加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//头节点赋值给临时变量</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="comment">//新建节点，前一个节点指向null，e是新建节点的值，f 是新建节点的下一个节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">        <span class="comment">//新建节点成为头节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="comment">//头节点为空，就是链表唯恐，头尾节点是一个节点。</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="comment">//上一个头节点的前一个节点就是当前节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>从尾巴插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从尾部开始追加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把尾节点数据暂存</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="comment">//新建新的节点，l 是前一个节点，e 是当前节点的值，后一个节点是 null</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//新建的节点放在尾部</span></span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="comment">//如果链表为空，头部和尾部是同一个节点，都是新建的节点</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="comment">//否则把前尾节点的下一个节点，指向当前尾节点。</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        <span class="comment">//大小和版本更改</span></span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>删除</p><ol><li>从头删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从头删除节点 f 是链表头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拿出头节点的值，作为方法的返回值</span></span><br><span class="line">        <span class="keyword">final</span> E element = f.item;</span><br><span class="line">        <span class="comment">// 拿出头节点的下一个节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        <span class="comment">//帮助 GC 回收头节点</span></span><br><span class="line">        f.item = <span class="keyword">null</span>;</span><br><span class="line">        f.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 头节点的下一个节点成为头节点</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="comment">//如果 next 为空，表明链表为空</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//链表不为空，头节点的前一个节点指向 null</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//修改链表大小和版本</span></span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>从尾巴删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> l == last &amp;&amp; l != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> E element = l.item;</span><br><span class="line">        <span class="comment">//删除之前先保留前一个节点，last前移做准备</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = <span class="keyword">null</span>;</span><br><span class="line">        l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">            first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//修改版本</span></span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代</p><p>有关迭代器相关的知识，在ArrayList文章中已经解释的比较详细了，这里就重点看下源码好了，比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>LinkedList是双向链表，所以实现的接口也是双向迭代器,继承关系如下:</p><p><img src="2.png" alt=""></p><p>接下来我们看下，它的向前，向后的迭代方法</p><ol><li>　向后迭代</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断还有没有下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextIndex &lt; size;<span class="comment">//下一个节点的索引小于链表的大小，就有</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//检查期望版本号有无发生变化</span></span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="keyword">if</span> (!hasNext())<span class="comment">//再次检查</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="comment">// next 是当前节点</span></span><br><span class="line">  lastReturned = next;</span><br><span class="line">  <span class="comment">// next 是下一个节点了，为下次迭代做准备</span></span><br><span class="line">  next = next.next;</span><br><span class="line">  nextIndex++;</span><br><span class="line">  <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>向前</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果上次节点索引位置大于 0，就还有节点可以迭代</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取前一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="comment">// next 为空场景：说明是第一次迭代，取尾节点(last)</span></span><br><span class="line">  <span class="comment">// next 不为空场景：说明已经发生过迭代了，直接取前一个节点即可(next.prev)</span></span><br><span class="line">  lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">  <span class="comment">// 索引位置变化</span></span><br><span class="line">  nextIndex--;</span><br><span class="line">  <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>迭代器删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="comment">// lastReturned 为空，说明没有执行 next 或者 previos，直接报错</span></span><br><span class="line">  <span class="comment">// lastReturned = next() 方法执行的结果</span></span><br><span class="line">  <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">  <span class="comment">//删除当前节点</span></span><br><span class="line">  unlink(lastReturned);</span><br><span class="line">  <span class="comment">// 从尾到头递归顺序，并且是第一次迭代，并且要删除最后一个元素的情况下</span></span><br><span class="line">  <span class="comment">// 这种情况下，previous 方法里面设置了 lastReturned = next = last。</span></span><br><span class="line">  <span class="comment">// 我们必须把 next 设置成 null，这样在下次递归时，previous 方法才会让队尾最后一个节点赋值给 next</span></span><br><span class="line">  <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">    next = lastNext;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    nextIndex--;</span><br><span class="line">  lastReturned = <span class="keyword">null</span>;</span><br><span class="line">  expectedModCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    LinkedList无非是链表的封装，使用起来也很简单，它的插入与删除都是O(1) 的复杂度，虽然ArrayList也是O(1)的，但那是在均摊分析下的，LinkedList是真正的O (1)操作，主要是它不需要考虑动态的扩容缩容操作。</p><p>此外，LinkedList也常用来作为DeQueue的实现。Queue接口，我觉得它主要就是拿来做并发用的，有关它的知识点，有机会来介绍一下。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList源码解析</title>
      <link href="/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ArrayList几乎是最常用的一种数据结构,本篇就研究一下ArrayList的常用操作的底层实现。通过学习底层实现的细节，帮助自己写出更优秀的代码 。</p></blockquote><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li>结构图</li></ol><p>​    ArrayList实际上就是封装了一个数组 ,代码体现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装的数组</span></span><br><span class="line"><span class="keyword">transient</span>  Object[] elementData;</span><br></pre></td></tr></table></figure><p><img src="1.jpg" alt=""></p><ol><li>类注释信息        </li></ol><ul><li>允许 put null 值，会自动扩容；</li><li>size、isEmpty、get、set、add 等方法时间复杂度都是 O (1)；</li></ul><ol><li>常见属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认数组大小10</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"> <span class="comment">//数组使用的大小</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">transient</span>  Object[] elementData;</span><br></pre></td></tr></table></figure><ul><li>DEFAULT_CAPACITY 表示数组的初始大小，默认是 10，这个数字要记住；</li><li>size 表示当前数组的大小，类型 int，没有使用 volatile 修饰，非线程安全的；</li><li>还有一个特别重要的变量,继承自AbstractList </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>​        这个变量与ArrayList源码注释中提到的”fail-fast”有关，这个变量源码中有详细的解释，翻译过来大致如下 ：</p><blockquote><p>此列表在结构上被修改的次数。结构修改是指改变列表的大小，或以某种方式干扰列表，使正在进行的迭代可能产生不正确的结果。</p><p>该字段由迭代器和列表迭代器方法返回的迭代器和列表迭代器实现使用。如果此字段的值意外更改，迭代器（或列表迭代器）将抛出ConcurrentModificationException，以响应下一个、删除、上一个、设置或添加操作。这提供了快速失效行为，而不是在迭代过程中面对并发修改时的不确定性行为。</p><p>子类使用此字段是可选的。如果子类希望提供故障快速迭代器（和列表迭代器），那么它只需在其add（int，E）和remove（int）方法（以及它覆盖的任何其他导致列表结构修改的方法）中增加该字段。对add（int，E）或remove（int）的单个调用只能向该字段添加一个，否则迭代器（和列表迭代器）将抛出虚假的ConcurrentModificationException。如果实现不希望提供故障快速迭代器，则可以忽略此字段。</p></blockquote><p>什么意思呢，所谓的”fail-fast”就是指如果在迭代时，容器发生结构性的改变，元素减少或者增多（注意更新不算）,那么遍历时会立刻抛出异常结束迭代，而这个”fail-fast”机制就是通过检查modCount变量来实现的，下文在源码中我会再详细解释。 算法导论中 也曾提过 “循环不变性”,是指如果在循环的某一次迭代开始之前是正确的，那么在下一次迭代开始之前，也是正确的，感觉是有一丢丢的联系。在很多框架的实现中也见过类似的操作，对List中的元素，会先copy一份出来，再去迭代，目的就是避免迭代过程中容器发生变更而必须加锁的操作。</p><h3 id="常用操作的源码解析"><a href="#常用操作的源码解析" class="headerlink" title="常用操作的源码解析"></a>常用操作的源码解析</h3><ol><li>初始化</li></ol><p>​        初始化代码有3种:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                         initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  无参数构造器，默认是空数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//指定初始数据初始化</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//elementData 是保存数组的容器，默认为 null</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">//如果给定的集合（c）数据有值，则进行拷贝赋值操作</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">      <span class="comment">//如果集合元素类型不是 Object 类型，才开始拷贝，否则不执行</span></span><br><span class="line">      <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 给定集合（c）无值，则默认空数组</span></span><br><span class="line">      <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意: ArrayList 无参构造器初始化时，默认大小是空数组，并不是10，10 是在第一次 add 的时候扩容的数组值。</p><ol><li>新增与扩容</li></ol><p>​    添加元素的逻辑很简单，首先判断是不是需要扩容，保证容量够用，然后添加元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确保数组大小足够，不够需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//直接赋值，线程不安全的</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>继续看 ensureCapacityInternal()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是空数组，就从最小容量和默认容量10之间取最大值</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">      minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保容积足够</span></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录数组被修改</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果我们希望的最小容量大于目前数组的长度，那么就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">      grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最终实际是在grow方法中进行了扩容，并且做了旧值的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老的数组大小2倍，最后把现有数据拷贝到新的数组里面去</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// oldCapacity &gt;&gt; 1 是把 oldCapacity / 2 的意思</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就去 Integer 的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// 通过复制进行扩容</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>添加以及扩容操作也比较简单，有两个细节，需要注意一下</p><ul><li><p>扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是 原来容量的 1.5 倍；</p></li><li><p>ArrayList 中的数组的最大值是 Integer.MAX_VALUE，超过这个值， JVM 就不会给数组 分配内存空间了。</p></li></ul><ol><li>扩容的具体实现</li></ol><p>​    实际上，我们看到最终调用的扩容，不过是用工具类新生成了一个数组，而这个工具类的底层实际调用的也是系统类，进行数组的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Params:</span><br><span class="line">  src – the source array.</span><br><span class="line">  srcPos – starting position in the source array.</span><br><span class="line">  dest – the destination array.</span><br><span class="line">  destPos – starting position in the destination data.</span><br><span class="line">  length – the number of array elements to be copied</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>删除</li></ol><p>​    删除元素有两种，一种是根据下标删除，一种是根据值删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据数组下标去删除</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">      System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                       numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据值去删除</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果值是空的，找到第一个值是空的删除</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">        <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">          fastRemove(index);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 值不为空，找到第一个和入参相等的删除</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">        <span class="comment">// 这里是根据  equals 来判断值相等的</span></span><br><span class="line">        <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">          fastRemove(index);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>迭代器遍历</li></ol><p>​    Iterator我们来详细解释一下，这种遍历的思想在国外的很多企业算法面试题中都有涉及，并且它还是一种设计模式，同时我们再看下上文中提到的modCount是如何来实现“fail-fast”机制的。</p><p>首先看一下ArrayList的iterator方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//源码带注释 * &lt;p&gt;The returned iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际就是返回来一个Iterator接口的实现<code>private class Itr implements Iterator&lt;E&gt;</code></p><p>我们先看一下Iterator接口，再看一下在ArrayList中的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中就这几个方法，其中<code>hasNext()</code>、<code>next()</code>、<code>remove()</code>方法通常是迭代器重点使用的方法,而<code>forEachRemaining()</code>方法我们也看到实际调用的也是迭代器，它是传入的是一个函数式接口, 接下来我们重点关注前三种方法的实现，先看下Iterator在ArrayList中的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 迭代过程中，下一个元素的位置，从 0 开始，用来控制拿下一个元素</span></span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="comment">// 新增时表示上一次迭代过程中，索引的位置，删除成功时为 -1</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="comment">// 迭代过程中期望数组修改版本号</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasNext()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> cursor != size;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>next()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span></span><br><span class="line">      checkForComodification();</span><br><span class="line">      <span class="comment">//本次迭代过程中，元素的索引位置</span></span><br><span class="line">      <span class="keyword">int</span> i = cursor;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      <span class="comment">// 下一次迭代时，元素的位置</span></span><br><span class="line">      cursor = i + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 返回元素值</span></span><br><span class="line">      <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有关这个”fail-fast”,我们看下checkForComodification()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>迭代器一创建出来，就会赋值expectedModCount，然后每次操作前会比较modCount与它的值，用来做检查，而迭代器删除的时候，会重新赋值<code>expectedModCount = modCount</code>,保证可以通过检查，下面我们也会看到。</p><p>remove()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果上一次操作时，数组的位置已经小于 0 了，说明数组已经被删除完了</span></span><br><span class="line">      <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">      <span class="comment">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span></span><br><span class="line">      checkForComodification();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        <span class="comment">// -1 表示元素已经被删除，这里也防止重复删除</span></span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 删除元素时 modCount 的值已经发生变化，再此赋值给 expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>​    ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多 个线程对这些变量进行操作时，可能会有值被覆盖的情况。</p><p>类注释中推荐我们使用 Collections#synchronizedList 来保证线程安全，SynchronizedList 是 通过在每个方法上面加上锁来实现，虽然实现了线程安全，但是性能大大降低，具体实现源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">synchronized</span> (mutex) &#123;<span class="comment">// synchronized 是一种 重量级锁，但具有锁升级的概念，mutex 表示一把互斥锁 </span></span><br><span class="line">    <span class="keyword">return</span> c.add(e); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    本文从 ArrayList 整体架构出发，落地到初始化、新增、扩容、删除、迭代等核心源码实现，我 们发现 ArrayList 其实就是围绕底层数组结构，各个 API 都是对数组的操作进行封装，让使用者 无需感知底层实现，只需关注如何使用即可。</p>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS对称与非对称加密协议</title>
      <link href="/2022/07/06/network-2022-07-06-Httptps%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/07/06/network-2022-07-06-Httptps%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>众所周知，WEB服务存在http和https两种通信方式，http默认采用80作为通讯端口，对于传输采用不加密的方式，https默认采用443，对于传输的数据进行加密传输。本文重点介绍https涉及到的对称加密和非对称加密协议原理。</p></blockquote><p>首先我们先不谈https，先从一个简单的通讯原理图讲起：</p><p>​    <img src="1.png" alt="0"></p><h4 id="http通信原理"><a href="#http通信原理" class="headerlink" title="http通信原理"></a>http通信原理</h4><p>客户端发送一句client hello给服务器端，服务器端返回一句serverhello给客户端，鉴于本文讨论是https的加密主题，我们只讨论信息传输的加密问题实现客户端和服务端发送的信息client hello 和server hello，即使中间的包被窃取了，也无法解密传输的内容</p><p>http：client hello和server hello在通讯的过程中，以明文的形式进行传输，采用wireshark抓包的效果如下图：</p><p>​    <img src="2.png" alt="0"></p><p>有没有感觉这个的信息传输是完全暴露在互联网上面，你请求的所有信息都可以被窥测到，是不是感觉心一凉，不过不用担心，我们的安全信息现在都是采用https的传输，后面讲到https的时候大家心里会顿时轻松。但这不是最关键的，http的传输最大的隐患是信息劫持和篡改，如下图：</p><p>​    <img src="3.png" alt="0"></p><p>可以看到，http的信息传输中，信息很容易被×××给劫持，更有甚者，×××可以伪装服务器将篡改后的信息返回给用户，试想一下，如果×××劫持的是你的银行信息，是不是很可怕。所以对于http传出存在的问题可以总结如下：</p><p>（1）信息篡改：修改通信的内容</p><p>（2）信息劫持：拦截到信息通信的内容</p><p>这些是http不安全的体现，说完http，我们回到本文的主题https，看下人家是怎么保护信息的，所有的请求信息都采用了TLS加密，如果没有秘钥是无法解析传输的是什么信息</p><p>​    <img src="4.png" alt="0"></p><h4 id="对于加密传输存在对称加密和非对称加密"><a href="#对于加密传输存在对称加密和非对称加密" class="headerlink" title="对于加密传输存在对称加密和非对称加密"></a>对于加密传输存在对称加密和非对称加密</h4><h5 id="对称加密-——对称加密传输"><a href="#对称加密-——对称加密传输" class="headerlink" title="对称加密 ——对称加密传输"></a>对称加密 ——对称加密传输</h5><p>​    <img src="5.png" alt="0"></p><p>当客户端发送Hello字符串的时候，在进行信息传输前，采用加密算法（上图中的秘钥S）将hello加密程JDuEW8&amp;*21!@#进行传输，即使中间被×××劫持了，如果没有对应的秘钥S也无法知道传出的信息为何物，在上图中信息的加密和解密都是通过同一个秘钥进行的，对于这种加密我们称之为对称加密，只要A和B之间知道加解密的秘钥，任何第三方都无法获取秘钥S，则在一定条件下，基本上解决了信息通信的安全问题。但在现实的情况下（www），实际的通讯模型远比上图复杂，下图为实际的通信模型</p><p>​    <img src="6.png" alt="0"></p><p>server和所有的client都采用同一个秘钥S进行加解密，但大家思考下，如果这样的话，无异于没有加密，请做下思考</p><p>由于server和所有的client都采用同一个秘钥S，则×××们作为一个client也可以获取到秘钥S，此地无银三百两。所以在实际的通讯中，一般不会采用同一个秘钥，而是采用不同的秘钥加解密，如下图——通过协商的方式获取不同的秘钥</p><p>​    <img src="7.png" alt="0"></p><p>如上图，A和server通信采用对称加密A算法，B和server通信采用对称秘钥B算法，因此可以很好的解决了不同的客户端采用相同的秘钥进行通讯的问题</p><p>那现在又存在问题了，A通过明文传输和server协商采用了加密算法A，但这条信息本身是没有加密的，因此×××们还是可以窃取到秘钥的，整个的通讯仍然存在风险。那该如何处理呢？有人说，把这条信息（协调秘钥的过程）再次加密，那是不是还要协商加密秘钥，如此反复，永无止境。从根本上无法解决信息通讯的安全问题</p><h5 id="如何对协商过程进行加密-（-非对称加密原理图）"><a href="#如何对协商过程进行加密-（-非对称加密原理图）" class="headerlink" title="如何对协商过程进行加密 （ 非对称加密原理图）"></a>如何对协商过程进行加密 （ 非对称加密原理图）</h5><p>​    <img src="8.png" alt="0"></p><p>在密码学跟对称加密一起出现的，应用最广的加密机制“非对称加密”，如上图，特点是私钥加密后的密文，只要是公钥，都可以解密，但是反过来公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。</p><p>基于上述的特点，我们可以得出如下结论：</p><p>（1）公钥是开放给所有人的，但私钥是需要保密的，存在于服务端</p><p>（2）服务器端server向client端（A、B…）的信息传输是不安全的：因为所有人都可以获取公钥</p><p>（3）但client端（A、B…）向server端的信息传输确实安全的：因为私钥只有server端存在</p><p>因此，如何协商加密算法的问题，我们解决了，非对称加密算法进行对称加密算法协商过程。</p><p>​    <img src="9.png" alt="0"></p><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>信息通信采用http是不安全的，存在信息劫持、篡改的风险，https是加密传输，是安全的通信，对于https加密的过程，我们首先介绍的对称加密，采用对称加密进行通信存在秘钥协商过程的不安全性，因此我们采用了非对称加密算法解决了对协商过程的加密，因此https是集对称加密和非对称加密为一体的加密过程</p><p><strong>安全的获取公钥</strong></p><p>细心的人可能已经注意到了如果使用非对称加密算法，我们的客户端A，B需要一开始就持有公钥，要不没法开展加密行为啊。</p><p>这下，我们又遇到新问题了，如何让A、B客户端安全地得到公钥？</p><p>​    <img src="10.png" alt="0"></p><p>client获取公钥最最直接的方法是服务器端server将公钥发送给每一个client用户，但这个时候就出现了公钥被劫持的问题，如上图，client请求公钥，在请求返回的过程中被×××劫持，那么我们将采用劫持后的假秘钥进行通信，则后续的通讯过程都是采用假秘钥进行，数据库的风险仍然存在。在获取公钥的过程中，我们又引出了一个新的话题：如何安全的获取公钥，并确保公钥的获取是安全的， 那就需要用到终极武器了：SSL 证书（需要购买）和CA机构</p><p>​    <img src="11.png" alt="0"></p><p>如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有证书的颁发机构、有效期、公钥、证书持有者、签名，通过第三方的校验保证了身份的合法，解决了公钥获取的安全性</p><p>以浏览器为例说明如下整个的校验过程：</p><p>（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验</p><p>（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发</p><p>（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。</p><p>（4）如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密</p><p>（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比</p><p>（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充</p><p>（7）此时浏览器就可以读取证书中的公钥，用于后续加密了</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​        HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。</p><blockquote><p>引用：<a href="https://blog.csdn.net/weixin_42504145/article/details/85207103/" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42504145/article/details/85207103/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> 加密算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS、证书机构（CA）、证书、数字签名、私钥、公钥</title>
      <link href="/2022/07/06/network-2022-07-06-HTTPS%E3%80%81%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84%EF%BC%88CA%EF%BC%89%E3%80%81%E8%AF%81%E4%B9%A6%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E3%80%81%E7%A7%81%E9%92%A5%E3%80%81%E5%85%AC%E9%92%A5/"/>
      <url>/2022/07/06/network-2022-07-06-HTTPS%E3%80%81%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84%EF%BC%88CA%EF%BC%89%E3%80%81%E8%AF%81%E4%B9%A6%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E3%80%81%E7%A7%81%E9%92%A5%E3%80%81%E5%85%AC%E9%92%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文内容主要来自简书博主olaH的文章，作者对概念之间的联系解释的非常清楚，熟悉这些概念可以对理解SSH协议、Https协议以及证书颁发等打下基础</p><p>原文链接:<a href="https://www.jianshu.com/u/ab311efd67d7" target="_blank" rel="noopener">olaH</a></p></blockquote><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密是指双方持有相同的密钥进行通信，加密速度快，但是有一个安全问题，双方怎样获得相同的密钥？你总不能总是拿着U盘把密钥拷贝给对方吧。</p><p>常见的对称加密算法有DES、3DES、AES等</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密，又称为公开密钥加密，是为了解决对称加密中的安全问题而诞生，一个称为公开密钥(public key)，即公钥，另一个称为私钥(private key)，即私钥。但是它的加密速度相对于对称加密来说很慢。</p><ul><li>公钥(public key)是对外开放的，私钥(private key)是自己拥有的。</li><li>公钥(public key)加密的数据，只能用私钥(private key)解密。</li><li>私钥(private key)加密的数据，只能用公钥(public key)解密。</li></ul><h3 id="信息安全问题"><a href="#信息安全问题" class="headerlink" title="信息安全问题"></a>信息安全问题</h3><p>在信息安全性问题中，我们常常要做到三点才能保证信息的安全：</p><ol><li>信息的保密性</li><li>信息的完整性</li><li>身份识别</li></ol><h4 id="信息的保密性（加密算法）"><a href="#信息的保密性（加密算法）" class="headerlink" title="信息的保密性（加密算法）"></a>信息的保密性（加密算法）</h4><p>信息的保密性我们可以使用对称加密和非对称加密来完成，使用对称加密来完成，速度相对非对称加密很快，但是存在一个安全问题，密钥如何传递？由此通用的方法是使用非对称加密+对称加密来完成。客户端使用公钥对对称加密的密钥进行加密，然后传递给服务端，服务端使用私钥进行解密确认密钥，开始传输数据。</p><p>​    <img src="1.png" alt="0"></p><h4 id="信息的完整性（数字签名）"><a href="#信息的完整性（数字签名）" class="headerlink" title="信息的完整性（数字签名）"></a>信息的完整性（数字签名）</h4><p>信息传输的途中，我们的信息很有可能被第三方劫持篡改，所以我们需要保证信息的完整性，通用方法是使用散列算法如SHA1，MD5将传输内容hash一次获得hash值，即摘要。客户端使用服务端的公钥对摘要和信息内容进行加密，然后传输给服务端，服务端使用私钥进行解密获得原始内容和摘要值，这时服务端使用相同的hash算法对原始内容进行hash，然后与摘要值比对，如果一致，说明信息是完整的。</p><p>​    <img src="2.png" alt="0"></p><p>image.png</p><h4 id="身份识别（数字证书）"><a href="#身份识别（数字证书）" class="headerlink" title="身份识别（数字证书）"></a>身份识别（数字证书）</h4><p>在信息传输的过程中，我们通常需要验证信息的发送方的身份，这时我们转化一下思路就可以完成，把发送端的公钥发送给接收端，发送端通过把自己的内容使用私钥加密然后发送给接收端，接收端只能用发送端的公钥解密，自然就验证了发送端的身份。</p><p>​    <img src="3.png" alt="0"></p><p>image.png</p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>在传输的过程中，客户端如何获得服务器端的公钥呢？当时是服务器分发给客户端，如果一开始服务端发送的公钥到客户端的过程中有可能被第三方劫持，然后第三方自己伪造一对密钥，将公钥发送给客户端，当服务器发送数据给客户端的时候，中间人将信息进行劫持，用一开始劫持的公钥进行解密后，然后使用自己的私钥将数据加密发送给客户端，而客户端收到后使用公钥解密，反过来亦是如此，整个过程中间人是透明的，但信息泄露却不得而知。</p><p>​    <img src="4.png" alt="0"></p><p>image.png</p><p>为了防止这种情况，数字证书就出现了，它其实就是基于上上面所说的私钥加密数据，公钥解密来验证其身份。</p><p>数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，最重要的是公钥在数字证书中。</p><p>数字证书是如何保证公钥来自请求的服务器呢？数字证书上由持有人的相关信息，通过这点可以确定其不是一个中间人；但是证书也是可以伪造的，如何保证证书为真呢？</p><p>一个证书中含有三个部分:”证书内容，散列算法，加密密文”，证书内容会被散列算法hash计算出hash值，然后使用CA机构提供的私钥进行RSA加密。</p><p>​    <img src="5.png" alt="0"></p><p>image.png</p><p>当客户端发起请求时，服务器将该数字证书发送给客户端，客户端通过CA机构提供的公钥对加密密文进行解密获得散列值（数字签名），同时将证书内容使用相同的散列算法进行Hash得到另一个散列值，比对两个散列值，如果两者相等则说明证书没问题。</p><p>​    <img src="6.png" alt="0"></p><p>image.png</p><p>一些常见的证书文件类型如下：</p><p>X.509#DER 二进制格式证书，常用后缀.cer .crt</p><p>X.509#PEM 文本格式证书，常用后缀.pem</p><p>有的证书内容是只包含公钥（服务器的公钥），如.crt、.cer、.pem</p><p>有的证书既包含公钥又包含私钥（服务器的私钥），如.pfx、.p12</p><h3 id="HTTPS，TLS-SSL"><a href="#HTTPS，TLS-SSL" class="headerlink" title="HTTPS，TLS/SSL"></a>HTTPS，TLS/SSL</h3><p>Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。</p><p>使用TCP端口默认为443</p><p>TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。</p><p>SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。</p><p>SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。</p><h4 id="对称加密-1"><a href="#对称加密-1" class="headerlink" title="对称加密"></a>对称加密</h4><p>速度高，可加密内容较大，用来加密会话过程中的消息</p><h4 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h4><p>加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</p><p>​    <img src="7.png" alt="0"></p><p>image.png</p><h4 id="HTTPS单向认证"><a href="#HTTPS单向认证" class="headerlink" title="HTTPS单向认证"></a>HTTPS单向认证</h4><p>Https在建立Socket连接之前，需要进行握手，具体过程如下：</p><p>​    <img src="8.png" alt="0"></p><p>image.png</p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息;</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书;</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：</li></ol><ul><li><ul><li>证书是否过期;</li><li>发行服务器证书的CA是否可靠;(通过查询浏览器或本机内的CA证书)</li><li>返回的公钥是否能正确解开返回证书中的数字签名;（通过使用本机或浏览器内置的CA公钥进行解密）</li><li>服务器证书上的域名是否和服务器的实际域名相匹配;</li><li>验证通过后，将继续进行通信，否则，终止通信;</li></ul></li></ul><ol><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择;</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式;</li><li>服务器将选择好的加密方案通过明文方式返回给客户端;</li><li>客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器;</li><li>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥;</li></ol><p>在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全;</p><h4 id="HTTPS双向认证"><a href="#HTTPS双向认证" class="headerlink" title="HTTPS双向认证"></a>HTTPS双向认证</h4><p>双向认证和单向认证类似，它额外增加了服务端对客户端的认证：</p><p>​    <img src="9.png" alt="0"></p><p>image.png</p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息;</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书;</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：</li></ol><ul><li><ul><li>证书是否过期;</li><li>发行服务器证书的CA是否可靠;(通过查询浏览器或本机内的CA证书)</li><li>返回的公钥是否能正确解开返回证书中的数字签名;（通过使用本机或浏览器内置的CA公钥进行解密）</li><li>服务器证书上的域名是否和服务器的实际域名相匹配;</li><li>验证通过后，将继续进行通信，否则，终止通信;</li></ul></li></ul><ol><li>服务端要求客户端发送客户端的证书即客户端证书公钥，客户端会将自己的证书发送至服务端；</li><li>验证客户端的证书，通过验证后，会获得客户端的公钥；</li><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式;</li><li>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</li><li>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端；</li><li>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全；</li></ol>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码解析</title>
      <link href="/2018/10/05/%E6%BA%90%E7%A0%81-jdk-2022-07-05-HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/10/05/%E6%BA%90%E7%A0%81-jdk-2022-07-05-HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>HashMap是特别常用的数据结构，源码很长,但底层原理并不复杂，本篇主要介绍hashmap的存储原理以及底层用到的数据结构，并对核心代码进行分析。</p></blockquote><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li><p>结构图</p><p>HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。其中当链表的长度大于等于 8 时， 链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表，整体的数据结构 如下：</p><p><img src="1.jpg" alt="结构图"></p></li><li><p>类注释信息</p><ul><li>允许 null 值，不同于 HashTable ，是线程不安全的;</li><li>load factor（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值，较高的 值会减少空间开销（扩容减少，数组大小增长速度变慢），但增加了查找成本（hash 冲突增加，链表长度变长），不扩容的条件：数组容量 &gt; 需要的数组大小 /load factor;</li><li>如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的 大小，这样可以防止在其过程中不断的扩容，影响性能；</li><li>HashMap 是非线程安全的，我们可以自己在外部加锁，或者通过Collections#synchronizedMap 来实现线程安全，Collections#synchronizedMap 的实 现是在每个方法上加上了 synchronized 锁；</li><li>在迭代过程中，如果 HashMap 的结构被修改，会快速失败。</li></ul></li><li><p>常见属性</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">   <span class="comment">//最大容量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">  <span class="comment">//负载因子默认值</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">   <span class="comment">//bin(桶)容量大于等于8时，链表转化成红黑树</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//bin(桶)容量小于等于6时，红黑树转化成链表</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//容量最小64时才会转会成红黑树</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于fail-fast的，记录HashMap结构发生变化(数量变化或rehash)的数目</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//HashMap 的实际大小，可能不准(因为当你拿到这个值的时候，可能又发生了变化)</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 扩容的门槛，如果初始化时，给定数组大小的话，通过tableSizeFor 方法计算，永远接近于 2 的幂次方</span></span><br><span class="line">   <span class="comment">// 如果是通过 resize 方法进行扩容后，大小 = 数组容量 * 0.75</span></span><br><span class="line">   <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//存放数据的数组</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ol><li><p>整体流程</p><p>新增 key，value 大概的步骤如下：</p><ol><li>空数组有无初始化，没有的话初始化；</li><li>如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；</li><li>如果 hash 冲突，两种解决方案：链表 or 红黑树；</li><li>如果是链表，递归循环，把新元素追加到队尾；</li><li>如果是红黑树，调用红黑树新增的方法；</li><li>通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；</li><li>判断是否需要扩容，需要扩容进行扩容，结束。</li></ol></li></ol><p>​    我们来画一张示意图来描述下：</p><p>​    <img src="2.jpg" alt="添加元素流程图"></p><ol><li><p>源码实现</p><ol><li>添加元素 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//如果数组为空，初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// hashCode的算法先右移16 在并上数组大小-1</span></span><br><span class="line">        <span class="comment">// 如果当前索引位置是空的，直接生成新的节点在当前索引位置上</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 如果hash冲突，当前索引上有值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 如果key equals都相等，那么当前节点就是我们要新增的</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 如果是红黑树，使用红黑树的方式新增</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 是个链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//如果是最后一个，还找不到和新增的元素相等的，直接新增</span></span><br><span class="line">                    <span class="comment">//节点是新增到链表最后的</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//p.next是新增的节点，但是e仍然是null</span></span><br><span class="line">                        <span class="comment">//e和p.next都是持有对null的引用,即使p.next后来赋予了值</span></span><br><span class="line">                        <span class="comment">// 只是改变了p.next指向的引用，和e没有关系</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//新增时，链表的长度大于等于8时，链表转红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//链表中有元素和新增的元素相等，结束循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//更改循环的当前元素</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//说明新增的元素table中原来就有</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">// 当前节点移动到队尾</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">//如果kv的实际大小大于扩容的门槛，开始扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 删除不经常使用的元素</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>链表添加细节</p><p> 链表的添加比较简单，和LinkedList的追加实现是一样的，上面代码中描述的很清楚了，注意一点，当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，此方法 有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，当数组 大小小于 64 时，只会触发扩容，不会转化成红黑树 ，转化成红黑树的过程也比较简单，此处不再赘述 。</p><p>至于为什么是8 才会转红黑树，源码中有注释，可以参照,大概意思如下文:</p><blockquote><p>链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候， 使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要 的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，所以我们需要定义出转化的边界值。</p><p>在考虑设计 8 这个值的时候，我们参考了泊松分布概率函数，由泊松分布中得出结论，链表各 个长度的命中概率为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 0:    0.60653066</span><br><span class="line">* 1:    0.30326533</span><br><span class="line">* 2:    0.07581633</span><br><span class="line">* 3:    0.01263606</span><br><span class="line">* 4:    0.00157952</span><br><span class="line">* 5:    0.00015795</span><br><span class="line">* 6:    0.00001316</span><br><span class="line">* 7:    0.00000094</span><br><span class="line">* 8:    0.00000006</span><br><span class="line">* more: less than 1 in ten million</span><br></pre></td></tr></table></figure></blockquote><p>意思是，当链表的长度是 8 的时候，出现的概率是 0.00000006，不到千万分之一，所以说正常 情况下，链表的长度不可能到达 8 ，而一旦到达 8 时，肯定是 hash 算法出了问题，所以在这 种情况下，为了让 HashMap 仍然有较高的查询性能，所以让链表转化成红黑树，我们正常写 代码， 使用 HashMap 时， 几乎不会碰到链表转化成红黑树的情况， 毕竟概念只有千万分之 一。</p></li><li><p>红黑树添加细节</p><p>红黑树是一种动态平衡的数据结构 和AVL树、跳表类似，都具有动态平衡的特点，其实本身没多难，只是插入元素和删除元素后，需要平衡调整-“打补丁”操作,具体的调整规则就不再叙述了，红黑树不了解的可先跳过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树中加入节点</span></span><br><span class="line">        <span class="comment">//在计算新增的节点挂在那个节点上，是线程不安全的，</span></span><br><span class="line">        <span class="comment">//关键在于没有锁住tab,table可能是在动态的变化的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1:首先判断新增的节点在红黑树上是不是已经存在。</span></span><br><span class="line">        <span class="comment">//2:不在的话，根据hashcode，或者自定义的comparTo,递归找到要挂载的节点</span></span><br><span class="line">        <span class="comment">//3:和要挂载的节点建立父子，前后关系</span></span><br><span class="line">        <span class="comment">//4:判断是否需要着色，旋转。</span></span><br><span class="line">        <span class="comment">//5:对红黑树的根节点进行校验</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//h：key 的hash值</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//找到根节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">//自旋</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="comment">// p hash 值大于 h，说明 p 在 h 的右边</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// p hash 值小于 h，说明 p 在 h 的左边</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//要放进去key在当前树中已经存在了(equals来判断)</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="comment">//自己实现的Comparable的话，不能用hashcode比较了，需要用compareTo</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          <span class="comment">//得到key的Class类型，如果key没有实现Comparable就是null</span></span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                          <span class="comment">//当前节点pk和入参k不等</span></span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//找到和当前hashcode值相近的节点(当前节点的左右子节点其中一个为空即可)</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    <span class="comment">//生成新的节点</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="comment">//把新节点放在当前子节点为空的位置上</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">//当前节点和新节点建立父子，前后关系</span></span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    <span class="comment">//balanceInsertion 对红黑树进行着色或旋转，以达到更多的查找效率，着色或旋转的几种场景如下</span></span><br><span class="line">                    <span class="comment">//着色：新节点总是为红色；如果新节点的父亲是黑色，则不需要重新着色；如果父亲是红色，那么必须通过重新</span></span><br><span class="line">                    <span class="comment">//着色或者旋转的方法，再次达到红黑树的5个约束条件</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//旋转： 父亲是红色，叔叔是黑色时(前提是当前)</span></span><br><span class="line">                    <span class="comment">//如果当前节点是父亲的右节点，则进行左旋</span></span><br><span class="line">                    <span class="comment">//如果当前节点是父亲的左节点，则进行右旋</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//moveRootToFront 方法是把算出来的root放到根节点上</span></span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>HashMap 的查找主要分为以下三步：</p><ol><li><p>根据hashcode,算出数组的索引，找到槽点,槽点的key和查询的key相等，直接返回</p></li><li><p>判断当前节点有无 next 节点，有的话判断是链表类型，还是红黑树类型。</p></li><li><p>分别走链表和红黑树不同类型的查找方法。</p><ol><li><p>链表查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用自旋方式从链表中查找 key，e 初始为为链表的头节点 </span></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">// 如果当前节点 hash 等于 key 的 hash，并且 equals 相等，当前节点就是我们要找的节点 </span></span><br><span class="line">  <span class="comment">// 当 hash 冲突时，同一个 hash 值上是一个链表的时候，我们是通过 equals 方法来比较 key 是否相同</span></span><br><span class="line">  <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    <span class="keyword">return</span> e; </span><br><span class="line">  <span class="comment">// 否则，把当前节点的下一个节点拿出来继续寻找 &#125; </span></span><br><span class="line">&#125;<span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li><li><p>红黑树查找</p><p>说下思路:</p><ol><li><p>从根节点递归查找；</p></li><li><p>根据 hashcode，比较查找节点，左边节点，右边节点之间的大小，根本红黑树左小右大</p><p>的特性进行判断；</p></li><li><p>判断查找节点在第 2 步有无定位节点位置，有的话返回，没有的话重复 2，3 两步；</p></li><li><p>一直自旋到定位到节点位置为止。</p><p>如果红黑树比较平衡的话，每次查找的次数就是树的深度。</p></li></ol></li></ol></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​        HashMap 的内容虽然较多，但大多数 api 都只是对数组 + 链表 + 红黑树这种数据结构进行封 装而已，本文我们从新增和查找两个角度进行了源码的深入分析，分析了是如何对数组、链表 和红黑树进行操作的,更详细的内容可以自行阅读源码。</p>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link href="/2018/08/03/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-05-3-Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2018/08/03/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-05-3-Longest-Substring-Without-Repeating-Characters/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a> </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a string <code>s</code>, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3.</span><br><span class="line">Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> consists of English letters, digits, symbols and spaces.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题相对简单，属于中等难度，可以使用滑动窗口或者动态规划来做，看到最优解，习惯性的使用DP来解</li><li>定义dp[i]含义为以i位置结尾的最长不重复子串长度，思考如何用dp[i]推导出dp[i+1],由于是不重复子串， 所以i+1位置结尾的子串，需要考虑i+1位置自符出现的位置,可以建立一个辅助map，来记录当前字符上次出现的位置,递推方程如下:</li></ul><script type="math/tex; mode=display">dp[i] = \left\{dp[i-1],i-map[chars[i]] \right\}\left ( i=1,2...n-1 \right )</script><ul><li>动态规划在分析过程中，经常是“需要什么就要创建什么”，通常要建立一些辅助数组来推导最优解</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">            map[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[chars[<span class="number">0</span>]] = <span class="number">0</span>;<span class="comment">//注意记录字符最近一次出现的位置，不要漏掉首个字符</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p1 = dp[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> p2 = i-map[chars[i]];</span><br><span class="line">            dp[i] = Math.min(p1,p2);</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">            map[chars[i]]  = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. Add Two Numbers</title>
      <link href="/2018/08/01/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-05-2-Add-Two-Numbers/"/>
      <url>/2018/08/01/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-05-2-Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode.com/problems/add-two-numbers/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">Output: [7,0,8]</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">Output: [8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>It is guaranteed that the list represents a number that does not have leading zeros.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>注意几个点</p><ul><li>注意进位的处理，每次累加 记得加上进位</li><li>最后若仍有进位，需要单独新建一个节点来保留进位</li><li>为减少额外空间，可以将结果累加到l1上或者l2上而不必新建节点。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jie = <span class="number">0</span>;</span><br><span class="line">        ListNode p1 = l1;</span><br><span class="line">        ListNode p2 = l2;</span><br><span class="line">        ListNode p1_last = <span class="keyword">null</span>;;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = (p1.val + p2.val + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (p1.val + p2.val + jie)/<span class="number">10</span>;</span><br><span class="line">            p1.val = left;</span><br><span class="line">            p1_last = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = (p1.val + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (p1.val + jie)/<span class="number">10</span>;</span><br><span class="line">            p1.val = left;</span><br><span class="line">            p1_last = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = (p2.val + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (p2.val + jie)/<span class="number">10</span>;</span><br><span class="line">            p1_last.next = <span class="keyword">new</span> ListNode(left);</span><br><span class="line">            p1_last = p1_last.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jie != <span class="number">0</span>)&#123;</span><br><span class="line">            p1_last.next = <span class="keyword">new</span> ListNode(jie);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/2018/08/01/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-04-1-Two-Sum/"/>
      <url>/2018/08/01/leetcode-leetcode%E9%AB%98%E9%A2%91-2022-07-04-1-Two-Sum/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p> <a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p><p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p><p>You can return the answer in any order.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: Because nums[0] + nums[1] &#x3D;&#x3D; 9, we return [0, 1].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">Output: [0,1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>Only one valid answer exists.</strong></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>此题比较简单，可以学到一个基本技巧-“在遍历过程中寻找已经处理过的元素”，并且尽可能快的查找元素，优先考虑到有序表结构。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(target - nums[i]), i &#125;;</span><br><span class="line">&#125;</span><br><span class="line">map.put(nums[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
