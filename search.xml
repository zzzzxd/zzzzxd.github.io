<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>116. Populating Next Right Pointers in Each Node</title>
      <link href="/2022/07/11/116-Populating-Next-Right-Pointers-in-Each-Node/"/>
      <url>/2022/07/11/116-Populating-Next-Right-Pointers-in-Each-Node/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">https://leetcode.com/problems/populating-next-right-pointers-in-each-node/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 212 - 1]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>Follow-up:</strong></p><ul><li>You may only use constant extra space.</li><li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>T103 提到了层次遍历一次取一批的技巧，这个题就用的上了，一次取出来一批，设置好右节点即可 。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> bathSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            Node pre = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bathSize; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre = cur;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre.next = cur;</span><br><span class="line">                     pre = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(cur.left);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(cur.right);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bathSize = next_batch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>108. Convert Sorted Array to Binary Search Tree</title>
      <link href="/2022/07/11/108-Convert-Sorted-Array-to-Binary-Search-Tree/"/>
      <url>/2022/07/11/108-Convert-Sorted-Array-to-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a <strong>height-balanced</strong> binary search tree</em>.</p><p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line">Explanation: [0,-10,5,null,-3,null,9] is also accepted:</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3]</span><br><span class="line">Output: [3,1]</span><br><span class="line">Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> is sorted in a <strong>strictly increasing</strong> order.</li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这是个简单题，主要要求的很明确了，要是高度是平衡的，那么就用二分，中点当根，然后递归下去即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r -l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> TreeNode left = process(num, l, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> TreeNode right = process(num, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">final</span> TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        root.left = left;</span><br><span class="line">        root.right = right;</span><br><span class="line">        root.val = num[mid];</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary Search </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/2022/07/11/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/"/>
      <url>/2022/07/11/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder &#x3D; [-1], inorder &#x3D; [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> and <code>inorder</code> consist of <strong>unique</strong> values.</li><li>Each value of <code>inorder</code> also appears in <code>preorder</code>.</li><li><code>preorder</code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.</li><li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>前序遍历与中序遍历，前序与层序，加上保证值不同，便可以唯一确定一棵树，先序确定出跟，然后另一个数组确定出对应的左右子树。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constuctTree(preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constuctTree</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,<span class="keyword">int</span> l2,<span class="keyword">int</span> r2,HashMap&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 &gt; r1) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(preorder[l1]);</span><br><span class="line">            <span class="keyword">final</span> Integer loc = map.get(root.val);</span><br><span class="line">            <span class="keyword">final</span> TreeNode left = constuctTree(preorder, l1 + <span class="number">1</span>, l1 + loc -l2, l2, loc - <span class="number">1</span>, map);</span><br><span class="line">            <span class="keyword">final</span> TreeNode right = constuctTree(preorder, l1 + loc - l2 + <span class="number">1</span>, l1 - l2 + r2, loc + <span class="number">1</span>, r2, map);</span><br><span class="line">            root.left = left;</span><br><span class="line">            root.right = right;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104. Maximum Depth of Binary Tree</title>
      <link href="/2022/07/11/104-Maximum-Depth-of-Binary-Tree/"/>
      <url>/2022/07/11/104-Maximum-Depth-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p><p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 104]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>很简单的递归套路</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> l = getHeight(root.left);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> r = getHeight(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l,r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>103. Binary Tree Zigzag Level Order Traversal</title>
      <link href="/2022/07/11/103-Binary-Tree-Zigzag-Level-Order-Traversal/"/>
      <url>/2022/07/11/103-Binary-Tree-Zigzag-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes’ values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[20,9],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是让你一层是从左到右，下一层又是从右到左</li><li>这里介绍一个特别重要的技巧，好多题目可以这么解，就是用队列层序遍历时候，每次从队列里拿元素，一次性拿一批，把这一层的都是拿出来，拿出来你想正着就正着，想倒着就倒着 再折腾一次就可以！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; batchSize;i++)&#123;</span><br><span class="line">                <span class="keyword">final</span> TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(node.left);</span><br><span class="line">                        next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(node.right);</span><br><span class="line">                        next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                c.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">                    reverse(c);</span><br><span class="line">                &#125;</span><br><span class="line">            batchSize = next_batch;</span><br><span class="line">            flag ^= <span class="number">1</span>;</span><br><span class="line">            list.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ArrayList&lt;Integer&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = c.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size()/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = c.get(i);</span><br><span class="line">            c.set(i,c.get(len-<span class="number">1</span>-i));</span><br><span class="line">            c.set(len-<span class="number">1</span>-i,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>102. Binary Tree Level Order Traversal</title>
      <link href="/2022/07/11/102-Binary-Tree-Level-Order-Traversal/"/>
      <url>/2022/07/11/102-Binary-Tree-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>二叉树的层序遍历，常规操作.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> batch = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> next_batch=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; batch;i++)&#123;</span><br><span class="line">                <span class="keyword">final</span> TreeNode tmp = queue.poll();</span><br><span class="line">                list.add(tmp.val);</span><br><span class="line">                <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(tmp.left);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(tmp.right);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">            batch = next_batch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>101. Symmetric Tree</title>
      <link href="/2022/07/11/101-Symmetric-Tree/"/>
      <url>/2022/07/11/101-Symmetric-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/symmetric-tree/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>好题啊好题，虽说是简单题，还蛮考验小聪明的，其实就是说你得始终验证每个节点的左树是不是和右树一样，对每个节点都得验证这是递归，进行验证的时候，你得拿到对应的兄弟节点，所以可以 直接传两次！把树直接传两次！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode leftRoot,TreeNode rightRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftRoot != <span class="keyword">null</span> &amp;&amp; rightRoot != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftRoot.val != rightRoot.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> isMirror(leftRoot.left,rightRoot.right) &amp;&amp; isMirror(leftRoot.right,rightRoot.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(leftRoot == <span class="keyword">null</span> &amp;&amp; rightRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>98. Validate Binary Search Tree</title>
      <link href="/2022/07/11/98-Validate-Binary-Search-Tree/"/>
      <url>/2022/07/11/98-Validate-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/validate-binary-search-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p><p>A <strong>valid BST</strong> is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&#39;s value is 5 but its right child&#39;s value is 4.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 104]</code>.</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>BST的中序遍历一定是递增的，验证这个条件即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root,list);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i) &lt;= list.get(i-<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left,list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inOrder(root.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>94. Binary Tree Inorder Traversal</title>
      <link href="/2022/07/11/94-Binary-Tree-Inorder-Traversal/"/>
      <url>/2022/07/11/94-Binary-Tree-Inorder-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-inorder-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes’ values</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2,3]</span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>普通的中序遍历</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        process(res,root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; res,TreeNode root)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">          process(res,root.left);</span><br><span class="line">          res.add(root.val);</span><br><span class="line">          process(res,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>91. Decode Ways</title>
      <link href="/2022/07/11/91-Decode-Ways/"/>
      <url>/2022/07/11/91-Decode-Ways/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">https://leetcode.com/problems/decode-ways/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A message containing letters from <code>A-Z</code> can be <strong>encoded</strong> into numbers using the following mapping:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; &quot;1&quot;</span><br><span class="line">&#39;B&#39; -&gt; &quot;2&quot;</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; &quot;26&quot;</span><br></pre></td></tr></table></figure><p>To <strong>decode</strong> an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, <code>&quot;11106&quot;</code> can be mapped into:</p><ul><li><code>&quot;AAJF&quot;</code> with the grouping <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> with the grouping <code>(11 10 6)</code></li></ul><p>Note that the grouping <code>(1 11 06)</code> is invalid because <code>&quot;06&quot;</code> cannot be mapped into <code>&#39;F&#39;</code> since <code>&quot;6&quot;</code> is different from <code>&quot;06&quot;</code>.</p><p>Given a string <code>s</code> containing only digits, return <em>the <strong>number</strong> of ways to <strong>decode</strong> it</em>.</p><p>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: &quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: &quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;06&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: &quot;06&quot; cannot be mapped to &quot;F&quot; because of the leading zero (&quot;6&quot; is different from &quot;06&quot;).</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> contains only digits and may contain leading zero(s).</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求解码的字符串种数，这种求种数、求最优解的都可以考虑dp，主要是思路来的快</li><li>定义dp[i]  表示 [i~len-1]区间上 解码字符串的种数</li><li>考虑当前 chars[i],字符单独解码的情况，考虑它与后面字符共同解码的情况，进行枚举即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">//明显的dp,dp[i]，表示i~s.lengtn-1有多少种解码方式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = chars.length;</span><br><span class="line">        <span class="keyword">int</span> pre1 = chars[N-<span class="number">1</span>] == <span class="string">'0'</span> ?  <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(chars[i] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//一位数的时候</span></span><br><span class="line">                <span class="keyword">if</span>(chars[i+<span class="number">1</span>] != <span class="string">'0'</span>)&#123;</span><br><span class="line">                    p1 = pre1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//两位数计算</span></span><br><span class="line">                <span class="keyword">int</span> num = (chars[i]-<span class="string">'0'</span>)*<span class="number">10</span>+(chars[i+<span class="number">1</span>]-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                    p2 = pre2;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = p1 + p2;</span><br><span class="line">            &#125;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>88. Merge Sorted Array</title>
      <link href="/2022/07/11/88-Merge-Sorted-Array/"/>
      <url>/2022/07/11/88-Merge-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p><p><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.</p><p>The final sorted array should not be returned by the function, but instead be <em>stored inside the array</em> <code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3</span><br><span class="line">Output: [1,2,2,3,5,6]</span><br><span class="line">Explanation: The arrays we are merging are [1,2,3] and [2,5,6].</span><br><span class="line">The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The arrays we are merging are [1] and [].</span><br><span class="line">The result of the merge is [1].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The arrays we are merging are [] and [1].</span><br><span class="line">The result of the merge is [1].</span><br><span class="line">Note that because m &#x3D; 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-109 &lt;= nums1[i], nums2[j] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>小小的考察，从后遍历，往后放置即可，还是从题目本身出发，好好分析！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m-<span class="number">1</span>,j = n-<span class="number">1</span>,k = nums1.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                    nums1[k--] = nums1[i--];</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k != -<span class="number">1</span> &amp;&amp; i == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (k &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> Merge Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>84. Largest Rectangle in Histogram</title>
      <link href="/2022/07/11/84-Largest-Rectangle-in-Histogram/"/>
      <url>/2022/07/11/84-Largest-Rectangle-in-Histogram/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-rectangle-in-histogram/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of integers <code>heights</code> representing the histogram’s bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: heights &#x3D; [2,1,5,6,2,3]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: The above is a histogram where width of each bar is 1.</span><br><span class="line">The largest rectangle is shown in the red area, which has an area &#x3D; 10 units.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: heights &#x3D; [2,4]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= heights.length &lt;= 105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个是单调栈的应用，单调栈求的是，以当前值为最小值的最大区间。</li><li>还是从题目本身出发，先分析，分析出哪个知识点，用哪个知识点，最大的矩形面积，这个矩形一定是以某个高度为高，然后以这个高度尽可能向两边扩形成一个最大矩形。此外，这个高度一定是在所有的高度里面的，所以我们就可以遍历这些高度，对这些高度，找每个高度形成的最大区间，所有里面的最大面积就是答案。所以说，我们一定要通过分析，找到一个突破点，可以通过枚举去找到所有可能性，进而找到答案。</li><li>有关单调栈的实现这一块，看其它文章的总结。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> N = heights.length,top = -<span class="number">1</span>,res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (top != -<span class="number">1</span> &amp;&amp; heights[stack[top]] &gt;= heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> elem = stack[top--];</span><br><span class="line">                <span class="keyword">int</span> leftMin = top == -<span class="number">1</span> ? -<span class="number">1</span> : stack[top];</span><br><span class="line">                <span class="keyword">int</span> rightMin = i;</span><br><span class="line">                <span class="keyword">int</span> num = (rightMin - <span class="number">1</span> - leftMin) * heights[elem];</span><br><span class="line">                res =  Math.max(res,num);</span><br><span class="line">            &#125;</span><br><span class="line">            stack[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (top!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> elem = stack[top--];</span><br><span class="line">            <span class="keyword">int</span> leftMin = top == -<span class="number">1</span> ? -<span class="number">1</span> : stack[top];</span><br><span class="line">            <span class="keyword">int</span> rightMin = N;</span><br><span class="line">            <span class="keyword">int</span> num = (rightMin - <span class="number">1</span> - leftMin) * heights[elem];</span><br><span class="line">            res = Math.max(res,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Monotonic Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>79. Word Search</title>
      <link href="/2022/07/11/79-Word-Search/"/>
      <url>/2022/07/11/79-Word-Search/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">https://leetcode.com/problems/word-search/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</p><p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;SEE&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCB&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是简单的暴力搜索即可。</li><li>下面两个方法，其实思路时一模一样，但是 方法二，就是省掉了数组标记，而是在自身上做标记，用回溯的方法，判断也少点，就这它的时间比方法一快了一倍。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board[<span class="number">0</span>].length * board.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] arr = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(i,j,<span class="number">0</span>,arr,board,visited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法一，暴力搜索，dfs，对每个位置去搜索单词即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> index,<span class="keyword">char</span>[] arr,<span class="keyword">char</span>[][] board,<span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> loc = i*board[<span class="number">0</span>].length + j;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span>|| j &gt;= board[<span class="number">0</span>].length || visited[loc])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[index] == board[i][j];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == arr[index])&#123;</span><br><span class="line">                visited[loc] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">4</span>;d++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(i+dir_x[d],j+dir_y[d],index+<span class="number">1</span>,arr,board,visited))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[loc] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] w = word.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (f(board, i, j, w, <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前到达了b[i][j]，word[k....]</span></span><br><span class="line"><span class="comment">// 从b[i][j]出发，能不能搞定word[k....] true false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>[][] b, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] w, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k == w.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// word[k.....] 有字符</span></span><br><span class="line"><span class="comment">// 如果(i,j)越界，返回false</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == b.length || j &lt; <span class="number">0</span> || j == b[<span class="number">0</span>].length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b[i][j] != w[k]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> tmp = b[i][j];</span><br><span class="line">b[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> ans = f(b, i - <span class="number">1</span>, j, w, k + <span class="number">1</span>) </span><br><span class="line">|| f(b, i + <span class="number">1</span>, j, w, k + <span class="number">1</span>) </span><br><span class="line">|| f(b, i, j - <span class="number">1</span>, w, k + <span class="number">1</span>)</span><br><span class="line">|| f(b, i, j + <span class="number">1</span>, w, k + <span class="number">1</span>);</span><br><span class="line">b[i][j] = tmp;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>78. Subsets</title>
      <link href="/2022/07/11/78-Subsets/"/>
      <url>/2022/07/11/78-Subsets/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode.com/problems/subsets/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible subsets (the power set)</em>.</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: [[],[0]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求子集，从左到右递归枚举，加上回溯，收集起来即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; fin = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fin.add(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            fin.add(nums[i]);</span><br><span class="line">            process(res,path,nums,<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        res.add(fin);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; path,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index,<span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lim == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">            res.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index==nums.length || nums.length-index &lt; lim)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(nums[index]);</span><br><span class="line">        process(res,path,nums,index+<span class="number">1</span>,lim-<span class="number">1</span>);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        process(res,path,nums,index+<span class="number">1</span>,lim);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>76. Minimum Window Substring</title>
      <link href="/2022/07/11/76-Minimum-Window-Substring/"/>
      <url>/2022/07/11/76-Minimum-Window-Substring/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-window-substring/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window substring</strong> of</em> <code>s</code> <em>such that every character in</em> <code>t</code> <em>(<strong>including duplicates</strong>) is included in the window. If there is no such substring**, return the empty string</em> <code>&quot;&quot;</code><em>.</em></p><p>The testcases will be generated such that the answer is <strong>unique</strong>.</p><p>A <strong>substring</strong> is a contiguous sequence of characters within the string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot;</span><br><span class="line">Output: &quot;BANC&quot;</span><br><span class="line">Explanation: The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;, t &#x3D; &quot;a&quot;</span><br><span class="line">Output: &quot;a&quot;</span><br><span class="line">Explanation: The entire string s is the minimum window.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;, t &#x3D; &quot;aa&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: Both &#39;a&#39;s from t must be included in the window.</span><br><span class="line">Since the largest window of s only has one &#39;a&#39;, return empty string.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == s.length</code></li><li><code>n == t.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><p>尝试考虑滑动窗口，滑动窗口能使用，一定要具有单调性，能保证求解的时候，R可以不回退！比如说</p><p>L=2，R=6，此时满足条件了，记录下来，继续考量L = 3，R= 6是否是更优的，来逼近答案，那为什么不考虑 L = 3，R = 4，5 这两个窗口呢？这两个窗口不是被跳过去了吗？因为L = 2,R = 5的时候 都不满足条件，那L=3，R= 5这个更小的窗口 怎么可能满足条件呢！所以这叫R 不回退！</p></li><li><p>第二点，如何判断此时窗口是满足条件的窗口，窗口内的元素是包含制定字符串元素，种类以及对应的个数。我们引入一种“欠债表”的思想，这个表内，初始化时，是我们要还的字符，也就是指定的字符串对应字符及个数，此外维护一个变量是代表 我们还欠着多少，当变量为0时，表明此窗口如何符合条件。具体看代码来理解。</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] tb = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>]; <span class="comment">//欠债表</span></span><br><span class="line">        <span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] p_str = t.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p_str.length; i++) &#123;</span><br><span class="line">            tb[p_str[i]]++;</span><br><span class="line">            in++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_n = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sloc = <span class="number">0</span>,eloc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;p1 &lt; str.length;p1++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p2 &lt; str.length &amp;&amp; in &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (--tb[str[p2++]] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    in--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(in == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p2 - p1 &lt; min_n)&#123;</span><br><span class="line">                    min_n = p2-p1;</span><br><span class="line">                    sloc = p1;</span><br><span class="line">                    eloc = p2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++tb[str[p1]] &gt; <span class="number">0</span>)&#123; in++; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(sloc,eloc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75. Sort Colors</title>
      <link href="/2022/07/11/75-Sort-Colors/"/>
      <url>/2022/07/11/75-Sort-Colors/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-colors/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p><p>We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.</p><p>You must solve this problem without using the library’s sort function.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,0,1]</span><br><span class="line">Output: [0,1,2]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>nums[i]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这就是经典的三色旗问题呢，高频题里还是主要以经典题目为主。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>,p3 = nums.length-<span class="number">1</span>,p2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= p3)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[p2] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,p1,p2);</span><br><span class="line">                p2++;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[p2] == <span class="number">2</span>)&#123;</span><br><span class="line">                swap(nums,p2,p3);</span><br><span class="line">                p3--;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                p2++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>73. Set Matrix Zeroes</title>
      <link href="/2022/07/11/73-Set-Matrix-Zeroes/"/>
      <url>/2022/07/11/73-Set-Matrix-Zeroes/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/set-matrix-zeroes/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>‘s.</p><p>You must do it <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in place</a>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: [[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[0].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>-231 &lt;= matrix[i][j] &lt;= 231 - 1</code></li></ul><p><strong>Follow up:</strong></p><ul><li>A straightforward solution using <code>O(mn)</code> space is probably a bad idea.</li><li>A simple improvement uses <code>O(m + n)</code> space, but still not the best solution.</li><li>Could you devise a constant space solution?</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题有点像炸弹人游戏，我们遍历一趟就可以，简单的做法就是利用数组标记下哪一行，哪一列需要置0</li><li>Follow Up中，提示 能不能用常量空间做标记，这种优化，在面试中也常问。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>​    方法一:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] elemVisited = <span class="keyword">new</span> <span class="keyword">int</span>[M*N];</span><br><span class="line">        <span class="keyword">int</span>[] rowVisited = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">        <span class="keyword">int</span>[] colVisited = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="comment">//标记初始的0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> index = i*N+j;</span><br><span class="line">                    elemVisited[index] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = i*N+j;</span><br><span class="line">                <span class="keyword">if</span>(elemVisited[index]==<span class="number">1</span> &amp;&amp; matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                  <span class="keyword">if</span>(rowVisited[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                      rowVisited[i]=<span class="number">1</span>;</span><br><span class="line">                      Arrays.fill(matrix[i],<span class="number">0</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span>(colVisited[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                      colVisited[j]=<span class="number">1</span>;</span><br><span class="line">                      <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; M;k++)&#123;</span><br><span class="line">                          matrix[k][j] = <span class="number">0</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    优化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> col0 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">col0 = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = matrix.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (col0) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>70. Climbing Stairs</title>
      <link href="/2022/07/11/70-Climbing-Stairs/"/>
      <url>/2022/07/11/70-Climbing-Stairs/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">https://leetcode.com/problems/climbing-stairs/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p><p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>比较经典的递归问题了，现在回过头来看，用动归的递推，还是挺简单的。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">2</span>,pre2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = pre1 + pre2;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>69. Sqrt(x)</title>
      <link href="/2022/07/11/69-Sqrt-x/"/>
      <url>/2022/07/11/69-Sqrt-x/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">https://leetcode.com/problems/sqrtx/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a non-negative integer <code>x</code>, compute and return <em>the square root of</em> <code>x</code>.</p><p>Since the return type is an integer, the decimal digits are <strong>truncated</strong>, and only <strong>the integer part</strong> of the result is returned.</p><p><strong>Note:</strong> You are not allowed to use any built-in exponent function or operator, such as <code>pow(x, 0.5)</code> or <code>x ** 0.5</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= x &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这就是经典的二分求根号，不过这个题更简单，求的就是第一个满足((long)mid * mid) &lt;= x的整数。用res保留下解，不断的去推进这个值，这种写法简单好用，推荐！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = x;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(((<span class="keyword">long</span>)mid * mid) &lt;= x)&#123;</span><br><span class="line">               res = mid;</span><br><span class="line">               l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66. Plus One</title>
      <link href="/2022/07/11/66-Plus-One/"/>
      <url>/2022/07/11/66-Plus-One/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">https://leetcode.com/problems/plus-one/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given a <strong>large integer</strong> represented as an integer array <code>digits</code>, where each <code>digits[i]</code> is the <code>ith</code> digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading <code>0</code>‘s.</p><p>Increment the large integer by one and return <em>the resulting array of digits</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br><span class="line">Incrementing by one gives 123 + 1 &#x3D; 124.</span><br><span class="line">Thus, the result should be [1,2,4].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br><span class="line">Incrementing by one gives 4321 + 1 &#x3D; 4322.</span><br><span class="line">Thus, the result should be [4,3,2,2].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; [9]</span><br><span class="line">Output: [1,0]</span><br><span class="line">Explanation: The array represents the integer 9.</span><br><span class="line">Incrementing by one gives 9 + 1 &#x3D; 10.</span><br><span class="line">Thus, the result should be [1,0].</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li><li><code>digits</code> does not contain any leading <code>0</code>‘s.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>其实就是用数组进行大数运算，这个比较简单，只是简单的加法，累加时候注意加入进位，最后要判断是不是仍有进位，如果还有，要注意扩容数组</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有点类似大数运算，需要考虑进位情况，这个是比较简答的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> jie = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(jie == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> mod = (digits[i] + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (digits[i] + jie)/<span class="number">10</span>;</span><br><span class="line">            digits[i] = mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jie == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[]  new_digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; digits.length;i++) new_digits[i] = digits[i];</span><br><span class="line">            new_digits[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> new_digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>62. Unique Paths</title>
      <link href="/2022/07/11/62-Unique-Paths/"/>
      <url>/2022/07/11/62-Unique-Paths/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">https://leetcode.com/problems/unique-paths/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p><p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p>The test cases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: m &#x3D; 3, n &#x3D; 7</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Down</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题实际就是求排列组合，能想到这就简单，不然就吃力了，因为是矩型，而且只能左到右，上到下的走，所以从开始点到结束点，从左到右，从上到下 一定都是固定的步数。</li><li>排列组合的计算，方法数有很多，主要是用到简化公式的方法，不然直接计算 很容易就溢出了，至于计算方法，待我其它文章详细总结。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)C2(m+n-<span class="number">2</span>,m-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">C2</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            res =res*(n-m+i)/i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. Merge Intervals</title>
      <link href="/2022/07/11/56-Merge-Intervals/"/>
      <url>/2022/07/11/56-Merge-Intervals/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-intervals/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目比较简单，就是输出有多少个覆盖的区间，遍历一趟，记录下来即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = intervals.length;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= end)&#123;</span><br><span class="line">                end = Math.max(intervals[i][<span class="number">1</span>],end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                intervals[t][<span class="number">0</span>] = start;</span><br><span class="line">                intervals[t++][<span class="number">1</span>] = end;</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals[t][<span class="number">0</span>] = start;</span><br><span class="line">        intervals[t++][<span class="number">1</span>] = end;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[t][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t;i++)&#123;</span><br><span class="line">            res[i][<span class="number">0</span>] = intervals[i][<span class="number">0</span>];</span><br><span class="line">            res[i][<span class="number">1</span>] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55. Jump Game</title>
      <link href="/2022/07/10/55-Jump-Game/"/>
      <url>/2022/07/10/55-Jump-Game/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>54. Spiral Matrix</title>
      <link href="/2022/07/10/54-Spiral-Matrix/"/>
      <url>/2022/07/10/54-Spiral-Matrix/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/spiral-matrix/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题不难，也没什么特殊的知识点，就是一个技巧，用几个变量控制好 从左到右，从右到左，从上到下，从下到上的范围，循环进行即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> d_left=<span class="number">0</span>,d_right=N-<span class="number">1</span>,d_up=<span class="number">0</span>,d_down = M-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>,cur_row = -<span class="number">1</span>,cur_col = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (c &lt; M*N)&#123;</span><br><span class="line">            <span class="comment">//往右</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d_left;i &lt;= d_right;i++)&#123;</span><br><span class="line">                list.add(matrix[d_up][i]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_up++;</span><br><span class="line">            <span class="comment">//往下</span></span><br><span class="line">            <span class="keyword">if</span>(c &gt;= M * N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = d_up;i &lt;= d_down;i++)&#123;</span><br><span class="line">                list.add(matrix[i][d_right]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_right--;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= M * N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//往左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = d_right;i &gt;= d_left;i--)&#123;</span><br><span class="line">                list.add(matrix[d_down][i]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_down--;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= M * N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//往上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d_down;i &gt;= d_up;i--)&#123;</span><br><span class="line">                list.add(matrix[i][d_left]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>53. Maximum Subarray</title>
      <link href="/2022/07/10/53-Maximum-Subarray/"/>
      <url>/2022/07/10/53-Maximum-Subarray/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.</p><p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,4,-1,7,8]</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution using the <strong>divide and conquer</strong> approach, which is more subtle.</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>比较常见的dp模型，从左到右,dp[i] 表示以i结尾的最大字数组的和</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = arr.length;</span><br><span class="line">        <span class="keyword">int</span> pre = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            pre = Math.max(arr[i],arr[i]+pre);</span><br><span class="line">            res = Math.max(res,pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50. Pow(x, n)</title>
      <link href="/2022/07/10/50-Pow-x-n/"/>
      <url>/2022/07/10/50-Pow-x-n/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">https://leetcode.com/problems/powx-n/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(x, n)</a>, which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>xn</code>).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li><code>-231 &lt;= n &lt;= 231-1</code></li><li><code>-104 &lt;= xn &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求m^n，可以对n用二分，加快累乘的速度</li><li>m^ (-n) = 1/m^n,这容易，所以，如果是负的，我们统一成正的处理，最后看是不是用1除即可。</li><li>注意边界，(-n)可能是Integer的最小值，所以如果直接转成绝对值就出错了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> raw = n;</span><br><span class="line">        n = n &gt; <span class="number">0</span> ? n : (n == Integer.MIN_VALUE ? Integer.MAX_VALUE : -n);</span><br><span class="line">        <span class="keyword">double</span> power = x;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                res *= power;</span><br><span class="line">            &#125;</span><br><span class="line">            power *= power;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> raw &gt; <span class="number">0</span> ? res : <span class="number">1</span>/res/(raw == Integer.MIN_VALUE ? x:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49. Group Anagrams</title>
      <link href="/2022/07/10/49-Group-Anagrams/"/>
      <url>/2022/07/10/49-Group-Anagrams/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener">https://leetcode.com/problems/group-anagrams/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p><p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]</span><br><span class="line">Output: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;&quot;]</span><br><span class="line">Output: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;a&quot;]</span><br><span class="line">Output: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> consists of lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>与字母种数有关，与字母顺序无关，这种题目出现的很高，也不难，做一个词频映射表表，能表示出来哪个字符出现的次数即可</li><li>是26个字符，所以char[26], 即可，注意这个地方就是要用char类型数组，因为不同的频次对应不同的字符。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        HashMap&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = strs[i].toCharArray();</span><br><span class="line">            <span class="keyword">char</span>[] dic = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; chars.length; i1++) &#123;</span><br><span class="line">                dic[chars[i1]-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> String dic_key = <span class="keyword">new</span> String(dic);</span><br><span class="line">            <span class="keyword">if</span>(map.get(dic_key) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(strs[i]);</span><br><span class="line">                map.put(dic_key,list);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.get(dic_key).add(strs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        map.forEach((k,v)-&gt;lists.add(v));</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48. Rotate Image</title>
      <link href="/2022/07/10/48-Rotate-Image/"/>
      <url>/2022/07/10/48-Rotate-Image/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>46. Permutations</title>
      <link href="/2022/07/10/46-Permutations/"/>
      <url>/2022/07/10/46-Permutations/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1]</span><br><span class="line">Output: [[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>All the integers of <code>nums</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>全排列，基础的递归题目。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        process(list,nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回[index,len-1]位置的全排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length)&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                tmp.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            swap(nums,index,i);</span><br><span class="line">            process(list,nums,index+<span class="number">1</span>);</span><br><span class="line">            swap(nums,index,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = num[i];</span><br><span class="line">        num[i] = num[j];</span><br><span class="line">        num[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>44. Wildcard Matching</title>
      <link href="/2022/07/10/44-Wildcard-Matching/"/>
      <url>/2022/07/10/44-Wildcard-Matching/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/wildcard-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/wildcard-matching/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code> where:</p><ul><li><code>&#39;?&#39;</code> Matches any single character.</li><li><code>&#39;*&#39;</code> Matches any sequence of characters (including the empty sequence).</li></ul><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; matches any sequence.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cb&quot;, p &#x3D; &quot;?a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length, p.length &lt;= 2000</code></li><li><code>s</code> contains only lowercase English letters.</li><li><code>p</code> contains only lowercase English letters, <code>&#39;?&#39;</code> or <code>&#39;*&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目是通配符匹配，用动态规划会简单点, i,j的含义是s的前0~i字符能否与p的0~j字符匹配,然后根据p[j]是什么样的字符进行可能性的枚举即可。</li><li></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"**"</span>.equals(p) || <span class="string">"*"</span>.equals(p))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] p_str = p.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str.length + <span class="number">1</span>][p_str.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process(str,p_str,s.length()-<span class="number">1</span>,p.length()-<span class="number">1</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">char</span>[] p,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j+<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span>)&#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = i==-<span class="number">1</span>?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j;k &gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[k] != <span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p[j] == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i;k &gt;= -<span class="number">1</span>;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(process(str,p,k,j-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p[j] == <span class="string">'?'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (process(str,p,i-<span class="number">1</span>,j-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==p[j]&amp;&amp;process(str,p,i-<span class="number">1</span>,j-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. Trapping Rain Water</title>
      <link href="/2022/07/10/42-Trapping-Rain-Water/"/>
      <url>/2022/07/10/42-Trapping-Rain-Water/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">https://leetcode.com/problems/trapping-rain-water/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [4,2,0,3,2,5]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>乍一看，以为是单调栈，单调栈最大的特点就是，能求以当前元素为最小值的最长区间，这个题实际上并不适合，所以说上来先不要急着套模型，先从题目本身出发，去思考如何解决。</li><li>每个柱子都有可能接住雨水，接的大小实际就是它能“涨”多高，不就是取决于它左边最高高度和右面最高高度的最小值么。想明白这个地方，这个题就有了。</li><li>构造出辅助数组left[i],表示从0~i中的最大值，right[i]，表示i~lenth-1中的最大值，其中left可以再第二次遍历求每个柱子接水的时候一并算出，这样两个循环就搞定了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        <span class="keyword">int</span> max_n = height[height.length-<span class="number">1</span>];</span><br><span class="line">        right[height.length-<span class="number">1</span>] = max_n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = height.length-<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            max_n = Math.max(height[i],max_n);</span><br><span class="line">            right[i] = max_n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        max_n = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; height.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> expect = Math.min(max_n,right[i+<span class="number">1</span>]);</span><br><span class="line">            res += expect &lt; height[i] ? <span class="number">0</span> : expect-height[i];</span><br><span class="line">            max_n = Math.max(max_n,height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>41. First Missing Positive</title>
      <link href="/2022/07/10/41-First-Missing-Positive/"/>
      <url>/2022/07/10/41-First-Missing-Positive/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">https://leetcode.com/problems/first-missing-positive/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an unsorted integer array <code>nums</code>, return the smallest missing positive integer.</p><p>You must implement an algorithm that runs in <code>O(n)</code> time and uses constant extra space.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,0]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,4,-1,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题为hard 难度,不过确实不错！理解好题目，要求O(N),那肯定不能排序。</li><li>假设数组长度为N，最理想的情况就是return N+1，说明1～N 全部出现了，那如果，在我们遍历过程中，出现了一个 不在[1,N]区间的元素或者重复出现[1,N]中的元素 意味着，我们期待的N+1不可能实现了，因为有其他元素 “占位”了，此时最理想的情况是 [1,N-1]仍然满足条件，return N,所以，当扫描到异常元素时，会导致我们期望的值缩小。</li><li>有一点，我们怎么保证我们扫描过的元素是连续的，并且是不重复的，因为重复的会占位，所以我们用双指针，L代表扫描过有效的元素。R代表我们期望的，利用下表与值的关系来重新排列，让元素在对应的下表位置(O(N)),</li><li>特别注意<code>nums[L] == nums[nums[L]-1]</code>,当要置位的元素已经存在时候，说明也是垃圾值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>; <span class="comment">//L,R为虚指,所谓的有效区得保证有效，关键是连续，也就是扫描过去的元素得是连续的才行,L位置必须是放L+1的值</span></span><br><span class="line">        <span class="keyword">int</span> R = nums.length-<span class="number">1</span>; <span class="comment">//R+1代表可连续增长的最大值</span></span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[L]==L+<span class="number">1</span>)&#123;</span><br><span class="line">               L++;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[L] &lt;= L||nums[L] &gt; R+<span class="number">1</span> ||nums[L] == nums[nums[L]-<span class="number">1</span>])&#123;</span><br><span class="line">               swap(nums,L,R);</span><br><span class="line">               R--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               swap(nums,L,nums[L]-<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> loc1,<span class="keyword">int</span> loc2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num[loc1];</span><br><span class="line">        num[loc1] = num[loc2];</span><br><span class="line">        num[loc2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>38. Count and Say</title>
      <link href="/2022/07/10/38-Count-and-Say/"/>
      <url>/2022/07/10/38-Count-and-Say/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">https://leetcode.com/problems/count-and-say/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    The <strong>count-and-say</strong> sequence is a sequence of digit strings defined by the recursive formula:</p><ul><li><code>countAndSay(1) = &quot;1&quot;</code></li><li><code>countAndSay(n)</code> is the way you would “say” the digit string from <code>countAndSay(n-1)</code>, which is then converted into a different digit string.</li></ul><p>To determine how you “say” a digit string, split it into the <strong>minimal</strong> number of substrings such that each substring contains exactly <strong>one</strong> unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.</p><p>For example, the saying and conversion for digit string <code>&quot;3322251&quot;</code>:</p><p><img src="https://assets.leetcode.com/uploads/2020/10/23/countandsay.jpg" alt="img"></p><p>Given a positive integer <code>n</code>, return <em>the</em> <code>nth</code> <em>term of the <strong>count-and-say</strong> sequence</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: &quot;1&quot;</span><br><span class="line">Explanation: This is the base case.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 4</span><br><span class="line">Output: &quot;1211&quot;</span><br><span class="line">Explanation:</span><br><span class="line">countAndSay(1) &#x3D; &quot;1&quot;</span><br><span class="line">countAndSay(2) &#x3D; say &quot;1&quot; &#x3D; one 1 &#x3D; &quot;11&quot;</span><br><span class="line">countAndSay(3) &#x3D; say &quot;11&quot; &#x3D; two 1&#39;s &#x3D; &quot;21&quot;</span><br><span class="line">countAndSay(4) &#x3D; say &quot;21&quot; &#x3D; one 2 + one 1 &#x3D; &quot;12&quot; + &quot;11&quot; &#x3D; &quot;1211&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 30</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>很多题目只是表面花里胡哨，读懂了，把题目简化一下，就发现时一个很普通的模型，此题就属于这类，写好递归即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] last = countAndSay(n - <span class="number">1</span>).toCharArray();</span><br><span class="line">StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; last.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (last[i - <span class="number">1</span>] == last[i]) &#123;</span><br><span class="line">times++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans.append(times);</span><br><span class="line">ans.append(last[i - <span class="number">1</span>]);</span><br><span class="line">times = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.append(times);</span><br><span class="line">ans.append(last[last.length - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36. Valid Sudoku</title>
      <link href="/2022/07/10/36-Valid-Sudoku/"/>
      <url>/2022/07/10/36-Valid-Sudoku/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode.com/problems/valid-sudoku/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-sudoku/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Determine if a <code>9 x 9</code> Sudoku board is valid. Only the filled cells need to be validated <strong>according to the following rules</strong>:</p><ol><li>Each row must contain the digits <code>1-9</code> without repetition.</li><li>Each column must contain the digits <code>1-9</code> without repetition.</li><li>Each of the nine <code>3 x 3</code> sub-boxes of the grid must contain the digits <code>1-9</code> without repetition.</li></ol><p><strong>Note:</strong></p><ul><li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li><li>Only the filled cells need to be validated according to the mentioned rules.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; </span><br><span class="line">[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> is a digit <code>1-9</code> or <code>&#39;.&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>其实就是遍历，判断一下此时在列方向、行方向是不是不满足条件，遍历过程中标记好条件即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//主要是存当前行、当前列、当前子块</span></span><br><span class="line">        <span class="keyword">int</span>[][] rowVisited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">10</span>]; <span class="comment">// 第二维是数字</span></span><br><span class="line">        <span class="keyword">int</span>[][] colVisited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">10</span>]; <span class="comment">//第二维是数字</span></span><br><span class="line">        <span class="keyword">int</span>[][] subMatrixVisited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> subId =<span class="number">3</span> * (i/<span class="number">3</span>) + j/<span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">char</span> t = board[i][j]; </span><br><span class="line">                    <span class="keyword">if</span>(t == <span class="string">'.'</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> num = t - <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(rowVisited[i][num] == <span class="number">1</span> || colVisited[j][num] == <span class="number">1</span> || subMatrixVisited[subId][num]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rowVisited[i][num] = <span class="number">1</span>;</span><br><span class="line">                    colVisited[j][num] = <span class="number">1</span>;</span><br><span class="line">                    subMatrixVisited[subId][num]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> Find First and Last Position of Element in Sorted Array</title>
      <link href="/2022/07/10/Find-First-and-Last-Position-of-Element-in-Sorted-Array/"/>
      <url>/2022/07/10/Find-First-and-Last-Position-of-Element-in-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p><p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [], target &#x3D; 0</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>nums</code> is a non-decreasing array.</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>二分的典型应用，查找第一个满足条件的值，其实 二分在求某个函数的解时，威力无穷，有机会专门总结一下。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.length==<span class="number">0</span>?<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125; : (nums[<span class="number">0</span>]==target ? <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125; : <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = binarySearch(nums, target );</span><br><span class="line">        <span class="keyword">if</span>(left == Integer.MAX_VALUE||nums[left] &gt; target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> right = binarySearch(nums, target + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right == Integer.MAX_VALUE ? nums.length-<span class="number">1</span>:right-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找 查找第一个一个大于等于target的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r =nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                res = Math.min(res,mid);</span><br><span class="line">                r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                l = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>33. Search in Rotated Sorted Array</title>
      <link href="/2022/07/10/33-Search-in-Rotated-Sorted-Array/"/>
      <url>/2022/07/10/33-Search-in-Rotated-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/search-in-rotated-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p><p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p><p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of</em> <code>target</code> <em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li>All values of <code>nums</code> are <strong>unique</strong>.</li><li><code>nums</code> is an ascending array that is possibly rotated.</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目不错，已经要求你log(n)的时间复杂度，那只能往二分上去想了，这是很明确的吧。</li><li>既然二分，关键在于根据题目的特点，找到能每次二分的点，每次能砍掉近一半的数据，此题的特点是原先是上升的，如果出现了下降的元素，那么就是发生了旋转,我们可以先通过比较l和r位置元素判断出此时是否是旋转区间，如果不是，直接二分查找，如果是可以通过l、mid、r三个位置的元素来确定哪个区间出现了旋转区间，对于无旋转区间的 可以直接判断出target是否存在此区间。</li><li>利用好，无旋转区间，即上升区间的特点，可以减少很多复杂的判断，最终目的就是缩小解空间，最终逼近答案</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[r])&#123; <span class="comment">//l 到 r内 是递增区间，无旋转点，直接二分查找</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//l 到 r内 含有旋转点 ,进一步通过mid 来定位旋转点</span></span><br><span class="line">                <span class="keyword">if</span>(nums[l] &lt;= nums[mid])&#123; <span class="comment">//左边无旋转点,从[l,mid]是升区间</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[l] &lt;= target &amp;&amp; nums[mid] &gt;= target)&#123;</span><br><span class="line">                        <span class="comment">//来此区间找</span></span><br><span class="line">                        r = mid -<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        l = mid +<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  <span class="comment">//从mid+1到r才是正常区间</span></span><br><span class="line">                        <span class="comment">//左边有旋转区间,右边无旋转点，即问题变成了，此时如何判断target是在左变还是右边?通过右区间判断</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[mid] &lt;= target &amp;&amp; nums[r] &gt;=target)&#123; <span class="comment">//来右边</span></span><br><span class="line">                        l = mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                        r = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>29. Divide Two Integers</title>
      <link href="/2022/07/10/29-Divide-Two-Integers/"/>
      <url>/2022/07/10/29-Divide-Two-Integers/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/divide-two-integers/" target="_blank" rel="noopener">https://leetcode.com/problems/divide-two-integers/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers <strong>without</strong> using multiplication, division, and mod operator.</p><p>The integer division should truncate toward zero, which means losing its fractional part. For example, <code>8.345</code> would be truncated to <code>8</code>, and <code>-2.7335</code> would be truncated to <code>-2</code>.</p><p>Return <em>the <strong>quotient</strong> after dividing</em> <code>dividend</code> <em>by</em> <code>divisor</code>.</p><p><strong>Note:</strong> Assume we are dealing with an environment that could only store integers within the <strong>32-bit</strong> signed integer range: <code>[−231, 231 − 1]</code>. For this problem, if the quotient is <strong>strictly greater than</strong> <code>231 - 1</code>, then return <code>231 - 1</code>, and if the quotient is <strong>strictly less than</strong> <code>-231</code>, then return <code>-231</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend &#x3D; 10, divisor &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 10&#x2F;3 &#x3D; 3.33333.. which is truncated to 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend &#x3D; 7, divisor &#x3D; -3</span><br><span class="line">Output: -2</span><br><span class="line">Explanation: 7&#x2F;-3 &#x3D; -2.33333.. which is truncated to -2.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= dividend, divisor &lt;= 231 - 1</code></li><li><code>divisor != 0</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这题leetcode标注为中等难度，点踩的人特别多， 我也比较晕 不知道考察什么，可能还没领会到精髓。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//溢出的情况判断</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> dividend/divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28. Implement strStr()</title>
      <link href="/2022/07/10/28-Implement-strStr/"/>
      <url>/2022/07/10/28-Implement-strStr/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-strstr/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strStr()</a>.</p><p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p><p><strong>Clarification:</strong></p><p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p><p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C’s <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strstr()</a> and Java’s <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String" target="_blank" rel="noopener">indexOf()</a>).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> and <code>needle</code> consist of only lowercase English characters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题leetcode是标注是easy,其实考察的是kmp字符串匹配算法，疑问java的indexOf方法底层实际就是kmp的实现，所以这个地方就偷个懒了，有关Kmp方法以及它的改进，有机会我会详细讲解。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26. Remove Duplicates from Sorted Array</title>
      <link href="/2022/07/10/26-Remove-Duplicates-from-Sorted-Array/"/>
      <url>/2022/07/10/26-Remove-Duplicates-from-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>.</p><p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code> should hold the final result. It does not matter what you leave beyond the first <code>k</code> elements.</p><p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p><p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p><p><strong>Custom Judge:</strong></p><p>The judge will test your solution with the following code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums &#x3D; [...]; &#x2F;&#x2F; Input array</span><br><span class="line">int[] expectedNums &#x3D; [...]; &#x2F;&#x2F; The expected answer with correct length</span><br><span class="line"></span><br><span class="line">int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; Calls your implementation</span><br><span class="line"></span><br><span class="line">assert k &#x3D;&#x3D; expectedNums.length;</span><br><span class="line">for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] &#x3D;&#x3D; expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,2]</span><br><span class="line">Output: 2, nums &#x3D; [1,2,_]</span><br><span class="line">Explanation: Your function should return k &#x3D; 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">Output: 5, nums &#x3D; [0,1,2,3,4,_,_,_,_,_]</span><br><span class="line">Explanation: Your function should return k &#x3D; 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li><li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，双指针，通过一次遍历把重复元素去除掉，简答题目第一次能做出来也挺不错的，不知道为什么那么多人点踩。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>; <span class="comment">//p1实指，p1以及之后都是留下来的了</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> p2 = <span class="number">0</span>;p2 &lt; nums.length;p2++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p1] != nums[p2])&#123;</span><br><span class="line">                nums[++p1] = nums[p2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23. Merge k Sorted Lists</title>
      <link href="/2022/07/10/23-Merge-k-Sorted-Lists/"/>
      <url>/2022/07/10/23-Merge-k-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-k-sorted-lists/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p><p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">Output: [1,1,2,3,4,4,5,6]</span><br><span class="line">Explanation: The linked-lists are:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">merging them into one sorted list:</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; [[]]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 104</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-104 &lt;= lists[i][j] &lt;= 104</code></li><li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li><li>The sum of <code>lists[i].length</code> will not exceed <code>10^4</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>难度不大，主要考察堆，属于堆的典型题目，再配合链表，算是常考题目了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        ListNode last = <span class="keyword">null</span>;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;((a,b)-&gt;a.val - b.val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                heap.add(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">final</span> ListNode t = heap.poll();</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">                head = t;</span><br><span class="line">                last = t;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                last.next = t;</span><br><span class="line">                last = last.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                heap.add(t.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22. Generate Parentheses</title>
      <link href="/2022/07/10/22-Generate-Parentheses/"/>
      <url>/2022/07/10/22-Generate-Parentheses/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/generate-parentheses/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: [&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: [&quot;()&quot;]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>普通题，考察写递归的能力。</li><li>要的是全部解，这种全部可能性的肯定是递归来收集答案了，注意递归的写法，确定递归函数中需要哪些信息来确定参数，要尽可能的减少参数</li><li>递归中，假设到[0,index-1]的已经正确的填完了，现在来填index的位置，每次填，用条件保证填对，这样到length的位置，递归结束，此时的填写的path是正确的一种，不用再进行判断。如何判断此时填什么符合？<ul><li>首先，leftSize表示还能填左括号的个数，开始默认是n个,那么leftSize &gt; 0，此时可以填 左括号,填完leftSize 需要减1</li><li>右括号填写的条件是，已经填的右括号的个数: $index-(N-leftSize)$  仍然小于左括号个数：$N-leftSize$,整理可得$index &lt; 2 *(N-leftSize)$</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        process(n,<span class="number">0</span>,res,path,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> leftRest,<span class="keyword">int</span> index,List&lt;String&gt; res,StringBuilder path,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">2</span>*N)&#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftRest &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            process(leftRest-<span class="number">1</span>,index+<span class="number">1</span>,res,path.append(<span class="string">"("</span>),N);</span><br><span class="line">            path.deleteCharAt(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">2</span> *(N-leftRest))&#123;</span><br><span class="line">            process(leftRest,index+<span class="number">1</span>,res,path.append(<span class="string">")"</span>),N);</span><br><span class="line">            path.deleteCharAt(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21. Merge Two Sorted Lists</title>
      <link href="/2022/07/10/21-Merge-Two-Sorted-Lists/"/>
      <url>/2022/07/10/21-Merge-Two-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p> <a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p><p>Merge the two lists in a one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p><p>Return <em>the head of the merged linked list</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: list1 &#x3D; [1,2,4], list2 &#x3D; [1,3,4]</span><br><span class="line">Output: [1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: list1 &#x3D; [], list2 &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: list1 &#x3D; [], list2 &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>Both <code>list1</code> and <code>list2</code> are sorted in <strong>non-decreasing</strong> order.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，细心点就可以了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">        ListNode head = list1;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">                pre = pre ==<span class="keyword">null</span>?list1:pre.next;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode tmp = list2.next;</span><br><span class="line">                list2.next = list1;</span><br><span class="line">                <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre = list2;</span><br><span class="line">                    head = list2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre.next = list2;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                list2 = tmp;</span><br><span class="line">                list1 = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list2 != <span class="keyword">null</span>)</span><br><span class="line">            pre.next = list2;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20. Valid Parentheses</title>
      <link href="/2022/07/10/20-Valid-Parentheses/"/>
      <url>/2022/07/10/20-Valid-Parentheses/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-parentheses/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> consists of parentheses only <code>&#39;()[]{}&#39;</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>很简单，栈的最基本应用</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> N = str.length;</span><br><span class="line"><span class="keyword">char</span>[] stack = <span class="keyword">new</span> <span class="keyword">char</span>[N];</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> cha = str[i];</span><br><span class="line"><span class="keyword">if</span> (cha == <span class="string">'('</span> || cha == <span class="string">'['</span> || cha == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">stack[size++] = cha == <span class="string">'('</span> ? <span class="string">')'</span> : (cha == <span class="string">'['</span> ? <span class="string">']'</span> : <span class="string">'&#125;'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> last = stack[--size];</span><br><span class="line"><span class="keyword">if</span> (cha != last) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19. Remove Nth Node From End of List</title>
      <link href="/2022/07/10/19-Remove-Nth-Node-From-End-of-List/"/>
      <url>/2022/07/10/19-Remove-Nth-Node-From-End-of-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-nth-node-from-end-of-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">Output: [1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1], n &#x3D; 1</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], n &#x3D; 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is <code>sz</code>.</li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，考察数据结构基本功，写的时候耐心点，细节点即可。</li><li>小技巧，保留一个pre和cur遍历指针相隔K个，这样等cur==null时，pre指向的就是要的元素。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          ListNode cur = head,pre = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(step &gt;= n)&#123;</span><br><span class="line">                  pre = pre == <span class="keyword">null</span> ? head : pre.next;</span><br><span class="line">              &#125;</span><br><span class="line">              cur = cur.next;</span><br><span class="line">              step++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> head.next;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              pre.next = pre.next.next;</span><br><span class="line">              <span class="keyword">return</span> head;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> Letter Combinations of a Phone Number</title>
      <link href="/2022/07/10/Letter-Combinations-of-a-Phone-Number/"/>
      <url>/2022/07/10/Letter-Combinations-of-a-Phone-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">https://leetcode.com/problems/letter-combinations-of-a-phone-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p><p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><img src="https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png" alt="img"></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; &quot;&quot;</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; &quot;2&quot;</span><br><span class="line">Output: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> is a digit in the range <code>[&#39;2&#39;, &#39;9&#39;]</code>.</li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>不难，主要是考察会不会写递归，在递归中收集组合</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[][] phone = &#123; </span><br><span class="line">&#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> &#125;, <span class="comment">// 2    0</span></span><br><span class="line">&#123; <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span> &#125;, <span class="comment">// 3    1</span></span><br><span class="line">&#123; <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span> &#125;, <span class="comment">// 4    2</span></span><br><span class="line">&#123; <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span> &#125;, <span class="comment">// 5    3</span></span><br><span class="line">&#123; <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span> &#125;, <span class="comment">// 6    </span></span><br><span class="line">&#123; <span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span> &#125;, <span class="comment">// 7 </span></span><br><span class="line">&#123; <span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span> &#125;,   <span class="comment">// 8</span></span><br><span class="line">&#123; <span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span> &#125;, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "23"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = digits.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] path = <span class="keyword">new</span> <span class="keyword">char</span>[str.length];</span><br><span class="line">process(str, <span class="number">0</span>, path, ans);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> index, <span class="keyword">char</span>[] path, List&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == str.length) &#123;</span><br><span class="line">ans.add(String.valueOf(path));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">char</span>[] cands = phone[str[index] - <span class="string">'2'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> cur : cands) &#123;</span><br><span class="line">path[index] = cur;</span><br><span class="line">process(str, index + <span class="number">1</span>, path, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 3Sum</title>
      <link href="/2022/07/10/15-3Sum/"/>
      <url>/2022/07/10/15-3Sum/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p><p>Notice that the solution set must not contain duplicate triplets.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,0,1,2,-1,-4]</span><br><span class="line">Output: [[-1,-1,2],[-1,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">nums[0] + nums[1] + nums[1] &#x3D; (-1) + 0 + 1 &#x3D; 0.</span><br><span class="line">nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0.</span><br><span class="line">nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0.</span><br><span class="line">The distinct triplets are [-1,0,1] and [-1,-1,2].</span><br><span class="line">Notice that the order of the output and the order of the triplets does not matter.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,1]</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The only possible triplet does not sum up to 0.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,0,0]</span><br><span class="line">Output: [[0,0,0]]</span><br><span class="line">Explanation: The only possible triplet sums up to 0.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>中等难度，不错的题目。先理解题目，要求输出的三元组 是元素的值，并且list里面的3元组不能重复</li><li>可以这样想3元组和为0，3个元素一定是小中大的关系，可以枚举小的元素，再去找中和大的元素。可以将元素排序，这样依次枚举，枚举的一定是小的元素，巧妙的避免重复。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> p1 = i+<span class="number">1</span>,p2 = nums.length-<span class="number">1</span>,target = <span class="number">0</span>-nums[i];</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; p2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[p1]+nums[p2] == target)&#123;</span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    tmp.add(nums[i]);</span><br><span class="line">                    tmp.add(nums[p1++]);</span><br><span class="line">                    tmp.add(nums[p2--]);</span><br><span class="line">                    list.add(tmp);</span><br><span class="line">                    <span class="keyword">while</span> (p2 &gt; p1 &amp;&amp; nums[p2] == nums[p2+<span class="number">1</span>]) p2--;</span><br><span class="line">                    <span class="keyword">while</span> (p1 &lt; p2 &amp;&amp; nums[p1] == nums[p1-<span class="number">1</span>]) p1++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[p1]+nums[p2] &lt; target)&#123;</span><br><span class="line">                    p1++;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14. Longest Common Prefix</title>
      <link href="/2022/07/10/14-Longest-Common-Prefix/"/>
      <url>/2022/07/10/14-Longest-Common-Prefix/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-common-prefix/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> consists of only lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>遍历，不断缩短前缀即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String commonPrefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[i].indexOf(commonPrefix) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> length = commonPrefix.length();</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> ( j = length-<span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(strs[i].indexOf(commonPrefix.substring(<span class="number">0</span>,j)) == <span class="number">0</span>)&#123;</span><br><span class="line">                        commonPrefix = commonPrefix.substring(<span class="number">0</span>,j);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    commonPrefix = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> commonPrefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13. Roman to Integer</title>
      <link href="/2022/07/10/13-Roman-to-Integer/"/>
      <url>/2022/07/10/13-Roman-to-Integer/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/roman-to-integer/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>For example, <code>2</code> is written as <code>II</code> in Roman numeral, just two ones added together. <code>12</code> is written as <code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;III&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: III &#x3D; 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 15</code></li><li><code>s</code> contains only the characters <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code>.</li><li>It is <strong>guaranteed</strong> that <code>s</code> is a valid roman numeral in the range <code>[1, 3999]</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>水题，比较简单，看懂题意就能做.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">// C     M     X   C     I   X</span></span><br><span class="line"><span class="comment">// 100  1000  10   100   1   10</span></span><br><span class="line"><span class="keyword">int</span> nums[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">switch</span> (s.charAt(i)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">nums[i] = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">nums[i] = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">nums[i] = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">nums[i] = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">nums[i] = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">nums[i] = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">nums[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">sum -= nums[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum + nums[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Container With Most Water</title>
      <link href="/2022/07/10/11-Container-With-Most-Water/"/>
      <url>/2022/07/10/11-Container-With-Most-Water/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode.com/problems/container-with-most-water/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>ith</code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p><p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p><p>Return <em>the maximum amount of water a container can store</em>.</p><p><strong>Notice</strong> that you may not slant the container.</p><p><strong>Example 1:</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br><span class="line">Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [1,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>绝对的经典问题，通过双指针，不断的推高答案，不是一下找到答案，而是尽可能的寻找到最接近答案的值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[p1] &lt; height[p2])&#123;</span><br><span class="line">               res = Math.max((p2-p1)*height[p1],res);</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max((p2-p1)*height[p2],res);</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two pointer </tag>
            
            <tag> greed </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Regular Expression Matching</title>
      <link href="/2022/07/10/Regular-Expression-Matching/"/>
      <url>/2022/07/10/Regular-Expression-Matching/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an input string <code>s</code> and a pattern <code>p</code>, implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code> where:</p><ul><li><code>&#39;.&#39;</code> Matches any single character.</li><li><code>&#39;*&#39;</code> Matches zero or more of the preceding element.</li></ul><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ab&quot;, p &#x3D; &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= p.length &lt;= 30</code></li><li><code>s</code> contains only lowercase English letters.</li><li><code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and <code>&#39;*&#39;</code>.</li><li>It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!validCheck(p)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">".*"</span>.equals(p)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process(s.toCharArray(),p.toCharArray(),<span class="number">0</span>,<span class="number">0</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] s,<span class="keyword">char</span>[] p,<span class="keyword">int</span> si,<span class="keyword">int</span> ei,<span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ei == p.length)&#123; <span class="comment">//ex表达式没了，看s没了没有</span></span><br><span class="line">            <span class="keyword">return</span> si == s.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[si][ei] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[si][ei]==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ex表达式还有,*不会单独匹配</span></span><br><span class="line">        <span class="keyword">if</span>(ei+<span class="number">1</span> == p.length || p[ei+<span class="number">1</span>]!= <span class="string">'*'</span>)&#123; <span class="comment">//意味着当前字符必须匹配</span></span><br><span class="line">            <span class="keyword">return</span> si != s.length &amp;&amp; (s[si]==p[ei] || p[ei] == <span class="string">'.'</span>) &amp;&amp; process(s,p,si+<span class="number">1</span>,ei+<span class="number">1</span>,dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下个位置有'.'</span></span><br><span class="line">        <span class="keyword">while</span> (si != s.length &amp;&amp; (p[ei] == s[si]||p[ei] == <span class="string">'.'</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(process(s,p,si,ei+<span class="number">2</span>,dp))&#123;</span><br><span class="line">                dp[si][ei] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[si][ei] = -<span class="number">1</span>;</span><br><span class="line">            si++;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[si][ei] = process(s, p, si, ei + <span class="number">2</span>, dp) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[si][ei]==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">validCheck</span><span class="params">(String  p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.length() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i = p.indexOf(<span class="string">"*"</span>);</span><br><span class="line">        <span class="keyword">if</span>(i==-<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || p.charAt(i-<span class="number">1</span>)== <span class="string">'?'</span> ||p.charAt(i-<span class="number">1</span>)== <span class="string">'*'</span> ) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8. String to Integer (atoi)</title>
      <link href="/2022/07/10/8-String-to-Integer-atoi/"/>
      <url>/2022/07/10/8-String-to-Integer-atoi/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode.com/problems/string-to-integer-atoi/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer (similar to C/C++’s <code>atoi</code> function).</p><p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p><ol><li>Read in and ignore any leading whitespace.</li><li>Check if the next character (if not already at the end of the string) is <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code>. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.</li><li>Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.</li><li>Convert these digits into an integer (i.e. <code>&quot;123&quot; -&gt; 123</code>, <code>&quot;0032&quot; -&gt; 32</code>). If no digits were read, then the integer is <code>0</code>. Change the sign as necessary (from step 2).</li><li>If the integer is out of the 32-bit signed integer range <code>[-231, 231 - 1]</code>, then clamp the integer so that it remains in the range. Specifically, integers less than <code>-231</code> should be clamped to <code>-231</code>, and integers greater than <code>231 - 1</code> should be clamped to <code>231 - 1</code>.</li><li>Return the integer as the final result.</li></ol><p><strong>Note:</strong></p><ul><li>Only the space character <code>&#39; &#39;</code> is considered a whitespace character.</li><li><strong>Do not ignore</strong> any characters other than the leading whitespace or the rest of the string after the digits.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;42&quot;</span><br><span class="line">Output: 42</span><br><span class="line">Explanation: The underlined characters are what is read in, the caret is the current reader position.</span><br><span class="line">Step 1: &quot;42&quot; (no characters read because there is no leading whitespace)</span><br><span class="line">         ^</span><br><span class="line">Step 2: &quot;42&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)</span><br><span class="line">         ^</span><br><span class="line">Step 3: &quot;42&quot; (&quot;42&quot; is read in)</span><br><span class="line">           ^</span><br><span class="line">The parsed integer is 42.</span><br><span class="line">Since 42 is in the range [-231, 231 - 1], the final result is 42.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation:</span><br><span class="line">Step 1: &quot;   -42&quot; (leading whitespace is read and ignored)</span><br><span class="line">            ^</span><br><span class="line">Step 2: &quot;   -42&quot; (&#39;-&#39; is read, so the result should be negative)</span><br><span class="line">             ^</span><br><span class="line">Step 3: &quot;   -42&quot; (&quot;42&quot; is read in)</span><br><span class="line">               ^</span><br><span class="line">The parsed integer is -42.</span><br><span class="line">Since -42 is in the range [-231, 231 - 1], the final result is -42.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation:</span><br><span class="line">Step 1: &quot;4193 with words&quot; (no characters read because there is no leading whitespace)</span><br><span class="line">         ^</span><br><span class="line">Step 2: &quot;4193 with words&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)</span><br><span class="line">         ^</span><br><span class="line">Step 3: &quot;4193 with words&quot; (&quot;4193&quot; is read in; reading stops because the next character is a non-digit)</span><br><span class="line">             ^</span><br><span class="line">The parsed integer is 4193.</span><br><span class="line">Since 4193 is in the range [-231, 231 - 1], the final result is 4193.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length &lt;= 200</code></li><li><code>s</code> consists of English letters (lower-case and upper-case), digits (<code>0-9</code>), <code>&#39; &#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;.&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这题点踩的人有点多，个人也感觉这个题不是很漂亮，主要条件描述不清楚，各种异常的情况 报错了才知道，而且也考察不出什么东西。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="keyword">if</span>(s.length() ==<span class="number">0</span> || s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span> c = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(c&lt;=<span class="string">'z'</span> &amp;&amp; c &gt;= <span class="string">'a'</span> || c == <span class="string">'.'</span> || c &lt;= <span class="string">'Z'</span>&amp;&amp; c &gt;= <span class="string">'A'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//一定是以数字或者字符或者空白开头</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span> || s.charAt(i) == <span class="string">'-'</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">if</span>(!(s.charAt(<span class="number">0</span>) &lt;= <span class="string">'9'</span> &amp;&amp; s.charAt(<span class="number">0</span>) &gt;= <span class="string">'0'</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.length() &amp;&amp; !(s.charAt(i+<span class="number">1</span>) &gt;=<span class="string">'0'</span> &amp;&amp; s.charAt(i+<span class="number">1</span>) &lt;=<span class="string">'9'</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String regex = <span class="string">"[-+]?\\d+"</span>;</span><br><span class="line">        <span class="keyword">final</span> Pattern pattern = Pattern.compile(regex);</span><br><span class="line">        <span class="keyword">final</span> Matcher matcher = pattern.matcher(s);</span><br><span class="line">        <span class="keyword">if</span>(matcher.find())&#123;</span><br><span class="line">            <span class="keyword">final</span> String int_str = matcher.group();</span><br><span class="line">            <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                l = Integer.parseInt(int_str);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">if</span>(int_str.charAt(<span class="number">0</span>) == <span class="string">'-'</span>)</span><br><span class="line">                    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 -	leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7. Reverse Integer</title>
      <link href="/2022/07/10/7-Reverse-Integer/"/>
      <url>/2022/07/10/7-Reverse-Integer/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-integer/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a signed 32-bit integer <code>x</code>, return <code>x</code> <em>with its digits reversed</em>. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range <code>[-2^31, 2^31 - 1]</code>, then return <code>0</code>.</p><p><strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</strong></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= x &lt;= 23^1 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ol><li>此题偏简单，不能使用Long来存，反转之后，我们需要一位一位的进行计算存值，肯定会有溢出的情况，所以，我们要学会“提前处理”，<code>res==m &amp;&amp; x%10 &lt; o</code>  否则很有可能到最后是溢出的情况而我们又判断不出此时的情况。</li><li>可以将传入的整数以负数形式存储，这样存的值对于反转之后Integer.MIN来说正好存下，当然此题不会传入这种值，但若是以字符串形式传入，这个技巧就生效了。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> neg = x &lt; <span class="number">0</span>;</span><br><span class="line">        x = neg ? x : -x;   <span class="comment">//溢出是两个方向的，统一变负数处理，可以换成一个方向上 </span></span><br><span class="line">        <span class="keyword">int</span> m = Integer.MIN_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> o = Integer.MIN_VALUE % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res &lt; m || res==m &amp;&amp; x%<span class="number">10</span> &lt; o) <span class="comment">//提前进行整数溢出的判断</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neg ? res : Math.abs(res);  <span class="comment">//理论会有 负数没溢出，转绝对值溢出的情况，所以应该特殊处理，但这个题输入是一个整数，不会出现反转是-2147483647</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. Longest Palindromic Substring</title>
      <link href="/2022/07/10/5-Longest-Palindromic-Substring/"/>
      <url>/2022/07/10/5-Longest-Palindromic-Substring/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-palindromic-substring/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code>, return <em>the longest palindromic substring</em> in <code>s</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Explanation: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> consist of only digits and English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题是比较经典的DP问题，可以先对边界进行单独处理，转移方程如下:<script type="math/tex; mode=display">dp[i][j] = \begin{cases} true & i = j\\equal(chars[i],chars[j]) & j=i+1,j < N  \end{cases}</script>然后，再对非边界内元素进行递推即可:<script type="math/tex; mode=display">dp[i][j] = \begin{cases}  if (chars[i]=chars[j])  & dp[i+1][j-1]\\ else & false \end{cases}</script></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sd=<span class="number">0</span>,ed=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; N)&#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = chars[i]==chars[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][i+<span class="number">1</span>])&#123;</span><br><span class="line">                        res = <span class="number">2</span>;</span><br><span class="line">                        sd = i;</span><br><span class="line">                        ed = i+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">3</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">2</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[i] == chars[j])&#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i+<span class="number">1</span> &gt; res)&#123;</span><br><span class="line">                        res = j-i+<span class="number">1</span>;</span><br><span class="line">                        sd = i;</span><br><span class="line">                        ed = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(sd,ed+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. Median of Two Sorted Arrays</title>
      <link href="/2022/07/10/4-Median-of-Two-Sorted-Arrays/"/>
      <url>/2022/07/10/4-Median-of-Two-Sorted-Arrays/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH协议原理及最佳实践</title>
      <link href="/2022/07/07/SSH%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2022/07/07/SSH%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="初识SSH"><a href="#初识SSH" class="headerlink" title="初识SSH"></a>初识SSH</h3><p>​    维基百科是这样描述ssh协议的 ：</p><blockquote><p><strong>Secure Shell</strong>（安全外壳协议，简称<strong>SSH</strong>）是一种加密的<a href="https://zh.m.wikipedia.org/wiki/网络传输协议" target="_blank" rel="noopener">网络传输协议</a>，可在不安全的网络中为网络服务提供安全的传输环境<a href="https://zh.m.wikipedia.org/zh-cn/Secure_Shell#cite_note-rfc4251-1" target="_blank" rel="noopener">[1]</a>。SSH通过在网络中创建<a href="https://zh.m.wikipedia.org/w/index.php?title=安全隧道&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">安全隧道</a>（英语：<a href="https://en.wikipedia.org/wiki/secure_channel" target="_blank" rel="noopener">secure channel</a>）来实现SSH客户端与服务器之间的连接<a href="https://zh.m.wikipedia.org/zh-cn/Secure_Shell#cite_note-rfc4252-2" target="_blank" rel="noopener">[2]</a>。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输<a href="https://zh.m.wikipedia.org/wiki/命令行界面" target="_blank" rel="noopener">命令行界面</a>和远程执行命令。</p></blockquote><p>通常是用来建立一条相对安全的连接，而不是明文传输。</p><h3 id="SSH原理"><a href="#SSH原理" class="headerlink" title="SSH原理"></a>SSH原理</h3><p>同样，SSH协议也要解决三个问题，即</p><ul><li>如何保证信息的保密性？</li><li>如和保证信息的完整性？</li><li>如何识别对方身份？</li></ul><p>其中前两个问题，通过使用对称加密与非对称加密、数字签名可以解决，在之前的HTTPS相关的文章中都有详细的解释，现在我们重点讨论第三个问题，如何识别对方身份？我们知道HTTPS是通过CA机构颁发证书的方式来确认对方的身份，而SSH的公钥和私钥是客户端自己生成，所以没有CA机构认证。SSH协议有两种识别对方身份的方式</p><ul><li>基于口令的认证</li><li>基于公钥认证</li></ul><h4 id="口令认证"><a href="#口令认证" class="headerlink" title="口令认证"></a>口令认证</h4><p>基于口令的认证，我个人认为，实际上基于口令的认证是第一次的时候需要与 “正确的对方”建立连接,次此连接之后给主机生成一个唯一的host_key，相当于”认识“了这台主机，下次建立链接时，如果与一台错误的主机建立链接时，通过host_key便可以识别出来！</p><p> 如下图，第一登陆的时候:</p><p><img src="1.png" alt=""></p><p>图中显是的是，先通过RSA算法对域名+ip这个key结合公钥对应的唯一信息生成加密串,然后做一个hash提取一个比较短的摘要作为指纹（实际上这只是通俗的解释，指纹的生成用到ECDSA算法，这个算法比较复杂，本人也没详细了解就不做过多的介绍了）,询问你是否继续连接</p><p><img src="2.png" alt=""></p><p>其中know hosts用来存放已经接受识别的身份。</p><p>再下一步就是输入密码进行登录了，其实验证是双向的，指纹验证是验证服务器，用户密码就是服务器再验证客户端了。</p><h4 id="公钥认证"><a href="#公钥认证" class="headerlink" title="公钥认证"></a>公钥认证</h4><p>第一种验证方式，再服务器验证客户端的时候，每次都得使用密码来进行验证，所以通过有了第二种方式来进行免密登录。</p><p>具体流程如下:</p><ol><li>Client将自己的公钥存放在Server上，追加在文件authorized_keys中。</li><li>Server端接收到Client的连接请求后，会在authorized_keys中匹配到Client的公钥pubKey，并生成随机数R，用Client的公钥对该随机数进行加密得到pubKey(R)<br> ，然后将加密后信息发送给Client。</li><li>Client端通过私钥进行解密得到随机数R，然后对随机数R和本次会话的SessionKey利用MD5生成摘要Digest1，发送给Server端。</li><li>Server端会也会对R和SessionKey利用同样摘要算法生成Digest2。</li><li>Server端会最后比较Digest1和Digest2是否相同，完成认证过程。</li></ol><p><img src="3.png" alt="img"></p><blockquote><p>在步骤1中，Client将自己的公钥存放在Server上。需要用户手动将公钥copy到server上。这就是在配置ssh的时候进程进行的操作。下图是GitHub上SSH keys设置视图：</p></blockquote><p><img src="4.png" alt=""></p><h3 id="SSH的最佳实践"><a href="#SSH的最佳实践" class="headerlink" title="SSH的最佳实践"></a>SSH的最佳实践</h3><h4 id="SSH生成的文件"><a href="#SSH生成的文件" class="headerlink" title="SSH生成的文件"></a>SSH生成的文件</h4><p><img src="5.png" alt=""></p><ol><li>d_rsa：保存私钥</li><li>id_rsa.pub：保存公钥</li><li>authorized_keys：保存已授权的客户端公钥</li><li>known_hosts：保存已认证的远程主机ID</li></ol><p><img src="6.png" alt=""></p><blockquote><p>需要注意的是：一台主机可能既是Client，也是Server。所以会同时拥有authorized_keys和known_hosts。</p></blockquote><h4 id="有关文件的常见疑问"><a href="#有关文件的常见疑问" class="headerlink" title="有关文件的常见疑问"></a>有关文件的常见疑问</h4><ol><li>known_hosts中存储的内容是什么？</li></ol><p>​    known_hosts中存储是已认证的远程主机host key，每个SSH Server都有一个<strong>secret, unique ID, called a host key</strong>。    </p><ol><li>host key何时加入known_hosts的？</li></ol><p>​    当我们第一次通过SSH登录远程主机的时候</p><ol><li>为什么需要known_hosts？</li></ol><p>​    最后探讨下为什么需要known_hosts，这个文件主要是通过Client和Server的双向认证，从而避免中间人（<strong>man-in-the-middle attack</strong>）攻击，每次Client向Server发起连接的时候，不仅仅Server要验证Client的合法性，Client同样也需要验证Server的身份，SSH client就是通过known_hosts中的host key来验证Server的身份的。</p><blockquote><p>这中方案足够安全吗？当然不，比如第一次连接一个未知Server的时候，known_hosts还没有该Server的host key，这不也可能遭到<strong>中间人</strong>攻击吗？这可能只是安全性和可操作性之间的折中吧。</p></blockquote><h4 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h4><p>记住三步走:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.客户端生成公钥私钥 </span><br><span class="line">ssh-keygen</span><br><span class="line">2.上传公钥到服务器</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.100</span><br><span class="line">3.免密登录</span><br><span class="line">ssh root@192.168.1.100</span><br></pre></td></tr></table></figure><blockquote><p>参考:<a href="https://www.jianshu.com/p/33461b619d53" target="_blank" rel="noopener">https://www.jianshu.com/p/33461b619d53</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> ssh </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS与&quot;中间人攻击&quot;</title>
      <link href="/2022/07/07/HTTPS%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
      <url>/2022/07/07/HTTPS%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="引导问题"><a href="#引导问题" class="headerlink" title="引导问题"></a>引导问题</h3><ol><li><p>为什么使用Https是安全的？</p></li><li><p>Https的底层原理如何实现？</p></li><li><p>使用Https是绝对安全的吗？</p></li></ol><h3 id="Https实现原理"><a href="#Https实现原理" class="headerlink" title="Https实现原理"></a>Https实现原理</h3><p>Https协议在内容传输上使用的加密是“对称加密”，而“非对称加密”只作用于证书验证阶段。Https的整体实现过程分为“证书验证”和“数据传输”两个阶段，过程如下所示：</p><ul><li>Https协议在内容传输上使用的加密是“对称加密”，而“非对称加密”只作用于证书验证阶段。</li><li>Https的整体实现过程分为“证书验证”和“数据传输”两个阶段，过程如下所示：</li></ul><p>​    <img src="1.png" alt="0"></p><p><strong>证书验证阶段</strong></p><ol><li><p>浏览器发起Https请求；</p></li><li><p>服务器端返回Https证书；</p></li><li><p>浏览器客户端验证证书是否合法，若不合法则提示警告</p></li></ol><p><strong>数据传输阶段</strong></p><ol><li><p>当证书验证合法后，在客户端本地生成随机数；</p></li><li><p>通过公钥加密随机数，并将加密后的随机数传输到服务端；</p></li><li><p>服务端通过私钥对接收到的加密随机数进行解密操作；</p></li><li><p>服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密操作后再进行内容传输。</p></li></ol><h3 id="为什么数据传输是用对称加密？"><a href="#为什么数据传输是用对称加密？" class="headerlink" title="为什么数据传输是用对称加密？"></a>为什么数据传输是用对称加密？</h3><p>首先，非对称加密的加密效率是非常低的，而http的应用场景通常存在着端与端之间的大量数据交互，从效率来说是无法接受的；</p><p>其次，在Https场景中只有服务端保存了私钥，而一对公私钥只能实现单向的加解密（即服务端无法使用私钥对传回浏览器客户端的数据进行加密，只能用于解密），所以Https中内容传输加密采取的是对称加密，而不是非对称加密（此处随机数则是对称加密的介体，即客户端和服务器端所拥有的随机数都是一致的，能够进行双向加解密）。</p><h3 id="为什么需要CA认证机构颁发证书？"><a href="#为什么需要CA认证机构颁发证书？" class="headerlink" title="为什么需要CA认证机构颁发证书？"></a>为什么需要CA认证机构颁发证书？</h3><p>Http协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而Https协议主要就是解决网络传输的安全性问题。</p><p>首先，我们假设不存在认证机构，任何人都可以制作证书，这存在的风险便是经典的“中间人攻击”问题。具体过程如下：</p><p>​    <img src="2.png" alt="0"></p><h3 id="“中间人攻击”原理"><a href="#“中间人攻击”原理" class="headerlink" title="“中间人攻击”原理"></a>“中间人攻击”原理</h3><ol><li><p>客户端请求被劫持（如DNS劫持等），所有的客户端请求均被转发至中间人的服务器；</p></li><li><p>中间人服务器返回中间人伪造的“伪证书”（包含伪公钥）；</p></li><li><p>客户端创建随机数，通过中间人证书的伪公钥对随机数进行加密后传输给中间人，然后凭随机数构造对称加密算法对要进行传输的数据内容进行对称加密后传输；</p></li><li><p>中间人因为拥有客户端生成的随机数，从而能够通过对称加密算法进行数据内容解密；</p></li><li><p>中间人再以“伪客户端”的身份向正规的服务端发起请求；</p></li><li><p>因为中间人与服务器之间的通信过程是合法的，正规服务端通过建立的安全通道返回加密后的数据内容；</p></li><li><p>中间人凭借与正规服务器建立的对称加密算法进行数据内容解密；</p></li><li><p>中间人再通过与客户端建立的对称加密算法对正规服务器返回的数据内容进行加密传输；</p></li><li><p>客户端通过中间人建立的对称加密算法对返回的数据内容进行解密；</p></li></ol><p>由于缺少对证书的真伪性验证，所有客户端即使发起了Https请求，但客户端完全不知道自己发送的请求已经被第三方拦截，导致其中传输的数据内容被中间人窃取。</p><h3 id="浏览器如何确保CA证书的合法性？"><a href="#浏览器如何确保CA证书的合法性？" class="headerlink" title="浏览器如何确保CA证书的合法性？"></a>浏览器如何确保CA证书的合法性？</h3><ol><li>证书包含的主要信息：</li></ol><ul><li>颁发机构信息</li><li>公钥</li><li>公司信息</li><li>域名</li><li>有效期</li><li>指纹</li><li>等等</li></ul><ol><li>证书的合法性依据</li></ol><p>首先，权威机构是需要通过认证的。其次证书的可信性基于信任制，CA认证机构需要对其颁发的证书进行信用担保，只要是CA认证机构颁发的证书，我们就认为是合法的。CA认证机构会对证书申请人的信息进行审核的。</p><ol><li><p>浏览器如何验证证书的合法性？</p><p>浏览器发起https请求时，服务器会返回网站的SSL证书，浏览器需要对证书做以下验证：</p></li></ol><ul><li>验证域名、有效期等信息是否正确；</li><li>判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发的证书进行来源验证；</li><li>判断证书是否被篡改。需要与CA服务器进行对比校验；</li><li>判断证书是否已被吊销。通过CRL(Certificate Revocation List 证书注销列表) 和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中OCSP可用于第3步中以减少与CA服务器的交互，提高验证效率。</li></ul><p>以上任意一步都同时满足的情况下，浏览器才认为证书是合法的。</p><h3 id="只有认证机构可以生产证书吗？"><a href="#只有认证机构可以生产证书吗？" class="headerlink" title="只有认证机构可以生产证书吗？"></a>只有认证机构可以生产证书吗？</h3><p>如果需要浏览器不提示安全风险，那只能通过认证机构签发的证书。但浏览器通常只是会提示安全风险，并不会限制网站的访问，所有从技术上来说，谁都可以生产证书，只要有证书就能够完成网站的https传输。</p><h3 id="客户端的本地随机数被窃取了怎么办？"><a href="#客户端的本地随机数被窃取了怎么办？" class="headerlink" title="客户端的本地随机数被窃取了怎么办？"></a>客户端的本地随机数被窃取了怎么办？</h3><p>其实https并不包含对随机数的安全保证，https保证的只是数据传输过程安全，而随机数存储于本地，本地的安全属于另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。（这也反映了Https协议并不是绝对的安全的）</p><h3 id="使用Https被抓包了会怎样？"><a href="#使用Https被抓包了会怎样？" class="headerlink" title="使用Https被抓包了会怎样？"></a>使用Https被抓包了会怎样？</h3><p>由于Https的数据是加密，常规下抓包工具代理请求后抓到的包内容是加密状态的，无法直接查看。</p><p>但是，浏览器只会提示安全风险，如果用户授权仍然继续访问网站，完成请求。那么，只有客户端是我们自己的终端，我们授权的情况下，便能够建立中间人网络，而抓包工具作为中间人的代理。</p><p>通常， HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。</p><p>即是，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。</p><blockquote><p>引用:<a href="https://blog.csdn.net/Jop_qq/article/details/104362064" target="_blank" rel="noopener">https://blog.csdn.net/Jop_qq/article/details/104362064</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashSet与TreeSet源码解析</title>
      <link href="/2022/07/06/HashSet%E4%B8%8ETreeSet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/HashSet%E4%B8%8ETreeSet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TreeMap源码解析</title>
      <link href="/2022/07/06/TreeMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/TreeMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>TreeMap是一种常用的key有序的数据结构,底层原理主要是用到动态平衡树，之前研究过了HashMap，解决冲突时链表会转化红黑树，同样这里平衡树依然是红黑树,可见这个数据结构的重要性了。如果红黑树原理不熟悉，那么涉及到具体的操作源码 可先跳过，有关红黑树只需要记住一点，红黑树和AVL都是动态平衡树的一种，都是在BST的基础上改进而来，基础的查询操作和BST一模一样，插入元素与删除元素，都是在元素插入或删除之后根据自己的特性取调整节点-“打补丁”以维持平衡。</p></blockquote><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li>结构图</li><li><p>类注释信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较器，如果外部有传进来 Comparator 比较器，首先用外部的</span></span><br><span class="line"><span class="comment">//如果外部比较器为空，则使用 key 自己的 Comparable 的 compareTo 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"><span class="comment">//红黑树的根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">//树节点的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//树的版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ol><p>看一下这棵红黑树的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> keyHash = (key==<span class="keyword">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> valueHash = (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">"="</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><ol><li>常用属性</li></ol><h3 id="常用操作源码解析"><a href="#常用操作源码解析" class="headerlink" title="常用操作源码解析"></a>常用操作源码解析</h3><ol><li>添加元素</li><li>查找</li><li>删除</li><li>迭代</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList源码解析</title>
      <link href="/2022/07/06/LinkList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/LinkList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li><p>整体结构</p><p>LinkedList也是常用的一种数据结构,它和ArrayList在逻辑上都是线性结构，而在物理存储上ArrayList是连续存储，LinkedList是非连续存储。LinkedList实现是一个双向链表。Node节点源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     E item;</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line">   </span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">         <span class="keyword">this</span>.item = element;</span><br><span class="line">         <span class="keyword">this</span>.next = next;</span><br><span class="line">         <span class="keyword">this</span>.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>只要稍微熟悉点数据结构对这种实现就不陌生，典型的链表结构，整体的图示如下:</p></li></ol><ol><li><p>类注释信息</p><pre><code>    1. 没有实现线程同步，多线程的时候需要外部来做同步。</code></pre><ol><li>ListIterator也是有“fail-fast”机制的。</li></ol></li><li><p>常见属性</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">transient int size &#x3D; 0;</span><br><span class="line">&#x2F;**</span><br><span class="line">     * Pointer to first node.</span><br><span class="line">     * Invariant: (first &#x3D;&#x3D; null &amp;&amp; last &#x3D;&#x3D; null) ||</span><br><span class="line">     *            (first.prev &#x3D;&#x3D; null &amp;&amp; first.item !&#x3D; null)</span><br><span class="line">     *&#x2F;</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">     * Pointer to last node.</span><br><span class="line">     * Invariant: (first &#x3D;&#x3D; null &amp;&amp; last &#x3D;&#x3D; null) ||</span><br><span class="line">     *            (last.next &#x3D;&#x3D; null &amp;&amp; last.item !&#x3D; null)</span><br><span class="line">     *&#x2F;</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h3 id="常用操作解析"><a href="#常用操作解析" class="headerlink" title="常用操作解析"></a>常用操作解析</h3><ol><li><p>添加</p><ol><li><p>从头插入</p><p>因为比较简单，都是最基础的数据结构，就不过多解释了，源码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从头部追加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//头节点赋值给临时变量</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="comment">//新建节点，前一个节点指向null，e是新建节点的值，f 是新建节点的下一个节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">        <span class="comment">//新建节点成为头节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="comment">//头节点为空，就是链表唯恐，头尾节点是一个节点。</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="comment">//上一个头节点的前一个节点就是当前节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>从尾巴插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从尾部开始追加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把尾节点数据暂存</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="comment">//新建新的节点，l 是前一个节点，e 是当前节点的值，后一个节点是 null</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//新建的节点放在尾部</span></span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="comment">//如果链表为空，头部和尾部是同一个节点，都是新建的节点</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="comment">//否则把前尾节点的下一个节点，指向当前尾节点。</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        <span class="comment">//大小和版本更改</span></span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>删除</p><ol><li>从头删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从头删除节点 f 是链表头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拿出头节点的值，作为方法的返回值</span></span><br><span class="line">        <span class="keyword">final</span> E element = f.item;</span><br><span class="line">        <span class="comment">// 拿出头节点的下一个节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        <span class="comment">//帮助 GC 回收头节点</span></span><br><span class="line">        f.item = <span class="keyword">null</span>;</span><br><span class="line">        f.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 头节点的下一个节点成为头节点</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="comment">//如果 next 为空，表明链表为空</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//链表不为空，头节点的前一个节点指向 null</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//修改链表大小和版本</span></span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>从尾巴删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> l == last &amp;&amp; l != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> E element = l.item;</span><br><span class="line">        <span class="comment">//删除之前先保留前一个节点，last前移做准备</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = <span class="keyword">null</span>;</span><br><span class="line">        l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">            first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//修改版本</span></span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代</p><p>有关迭代器相关的知识，在ArrayList文章中已经解释的比较详细了，这里就重点看下源码好了，比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>LinkedList是双向链表，所以实现的接口也是双向迭代器,继承关系如下:</p><p><img src="2.png" alt=""></p><p>接下来我们看下，它的向前，向后的迭代方法</p><ol><li>　向后迭代</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断还有没有下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextIndex &lt; size;<span class="comment">//下一个节点的索引小于链表的大小，就有</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//检查期望版本号有无发生变化</span></span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="keyword">if</span> (!hasNext())<span class="comment">//再次检查</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="comment">// next 是当前节点</span></span><br><span class="line">  lastReturned = next;</span><br><span class="line">  <span class="comment">// next 是下一个节点了，为下次迭代做准备</span></span><br><span class="line">  next = next.next;</span><br><span class="line">  nextIndex++;</span><br><span class="line">  <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>向前</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果上次节点索引位置大于 0，就还有节点可以迭代</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取前一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="comment">// next 为空场景：说明是第一次迭代，取尾节点(last)</span></span><br><span class="line">  <span class="comment">// next 不为空场景：说明已经发生过迭代了，直接取前一个节点即可(next.prev)</span></span><br><span class="line">  lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">  <span class="comment">// 索引位置变化</span></span><br><span class="line">  nextIndex--;</span><br><span class="line">  <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>迭代器删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="comment">// lastReturned 为空，说明没有执行 next 或者 previos，直接报错</span></span><br><span class="line">  <span class="comment">// lastReturned = next() 方法执行的结果</span></span><br><span class="line">  <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">  <span class="comment">//删除当前节点</span></span><br><span class="line">  unlink(lastReturned);</span><br><span class="line">  <span class="comment">// 从尾到头递归顺序，并且是第一次迭代，并且要删除最后一个元素的情况下</span></span><br><span class="line">  <span class="comment">// 这种情况下，previous 方法里面设置了 lastReturned = next = last。</span></span><br><span class="line">  <span class="comment">// 我们必须把 next 设置成 null，这样在下次递归时，previous 方法才会让队尾最后一个节点赋值给 next</span></span><br><span class="line">  <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">    next = lastNext;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    nextIndex--;</span><br><span class="line">  lastReturned = <span class="keyword">null</span>;</span><br><span class="line">  expectedModCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    LinkedList无非是链表的封装，使用起来也很简单，它的插入与删除都是O(1) 的复杂度，虽然ArrayList也是O(1)的，但那是在均摊分析下的，LinkedList是真正的O (1)操作，主要是它不需要考虑动态的扩容缩容操作。</p><p>此外，LinkedList也常用来作为DeQueue的实现。Queue接口，我觉得它主要就是拿来做并发用的，有关它的知识点，有机会来介绍一下。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList源码解析</title>
      <link href="/2022/07/06/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ArrayList几乎是最常用的一种数据结构,本篇就研究一下ArrayList的常用操作的底层实现。通过学习底层实现的细节，帮助自己写出更优秀的代码 。</p></blockquote><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li>结构图</li></ol><p>​    ArrayList实际上就是封装了一个数组 ,代码体现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装的数组</span></span><br><span class="line"><span class="keyword">transient</span>  Object[] elementData;</span><br></pre></td></tr></table></figure><p><img src="1.jpg" alt=""></p><ol><li>类注释信息        </li></ol><ul><li>允许 put null 值，会自动扩容；</li><li>size、isEmpty、get、set、add 等方法时间复杂度都是 O (1)；</li></ul><ol><li>常见属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认数组大小10</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"> <span class="comment">//数组使用的大小</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">transient</span>  Object[] elementData;</span><br></pre></td></tr></table></figure><ul><li>DEFAULT_CAPACITY 表示数组的初始大小，默认是 10，这个数字要记住；</li><li>size 表示当前数组的大小，类型 int，没有使用 volatile 修饰，非线程安全的；</li><li>还有一个特别重要的变量,继承自AbstractList </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>​        这个变量与ArrayList源码注释中提到的”fail-fast”有关，这个变量源码中有详细的解释，翻译过来大致如下 ：</p><blockquote><p>此列表在结构上被修改的次数。结构修改是指改变列表的大小，或以某种方式干扰列表，使正在进行的迭代可能产生不正确的结果。</p><p>该字段由迭代器和列表迭代器方法返回的迭代器和列表迭代器实现使用。如果此字段的值意外更改，迭代器（或列表迭代器）将抛出ConcurrentModificationException，以响应下一个、删除、上一个、设置或添加操作。这提供了快速失效行为，而不是在迭代过程中面对并发修改时的不确定性行为。</p><p>子类使用此字段是可选的。如果子类希望提供故障快速迭代器（和列表迭代器），那么它只需在其add（int，E）和remove（int）方法（以及它覆盖的任何其他导致列表结构修改的方法）中增加该字段。对add（int，E）或remove（int）的单个调用只能向该字段添加一个，否则迭代器（和列表迭代器）将抛出虚假的ConcurrentModificationException。如果实现不希望提供故障快速迭代器，则可以忽略此字段。</p></blockquote><p>什么意思呢，所谓的”fail-fast”就是指如果在迭代时，容器发生结构性的改变，元素减少或者增多（注意更新不算）,那么遍历时会立刻抛出异常结束迭代，而这个”fail-fast”机制就是通过检查modCount变量来实现的，下文在源码中我会再详细解释。 算法导论中 也曾提过 “循环不变性”,是指如果在循环的某一次迭代开始之前是正确的，那么在下一次迭代开始之前，也是正确的，感觉是有一丢丢的联系。在很多框架的实现中也见过类似的操作，对List中的元素，会先copy一份出来，再去迭代，目的就是避免迭代过程中容器发生变更而必须加锁的操作。</p><h3 id="常用操作的源码解析"><a href="#常用操作的源码解析" class="headerlink" title="常用操作的源码解析"></a>常用操作的源码解析</h3><ol><li>初始化</li></ol><p>​        初始化代码有3种:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                         initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  无参数构造器，默认是空数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//指定初始数据初始化</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//elementData 是保存数组的容器，默认为 null</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">//如果给定的集合（c）数据有值，则进行拷贝赋值操作</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">      <span class="comment">//如果集合元素类型不是 Object 类型，才开始拷贝，否则不执行</span></span><br><span class="line">      <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 给定集合（c）无值，则默认空数组</span></span><br><span class="line">      <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意: ArrayList 无参构造器初始化时，默认大小是空数组，并不是10，10 是在第一次 add 的时候扩容的数组值。</p><ol><li>新增与扩容</li></ol><p>​    添加元素的逻辑很简单，首先判断是不是需要扩容，保证容量够用，然后添加元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确保数组大小足够，不够需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//直接赋值，线程不安全的</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>继续看 ensureCapacityInternal()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是空数组，就从最小容量和默认容量10之间取最大值</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">      minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保容积足够</span></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录数组被修改</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果我们希望的最小容量大于目前数组的长度，那么就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">      grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最终实际是在grow方法中进行了扩容，并且做了旧值的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老的数组大小2倍，最后把现有数据拷贝到新的数组里面去</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// oldCapacity &gt;&gt; 1 是把 oldCapacity / 2 的意思</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就去 Integer 的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// 通过复制进行扩容</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>添加以及扩容操作也比较简单，有两个细节，需要注意一下</p><ul><li><p>扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是 原来容量的 1.5 倍；</p></li><li><p>ArrayList 中的数组的最大值是 Integer.MAX_VALUE，超过这个值， JVM 就不会给数组 分配内存空间了。</p></li></ul><ol><li>扩容的具体实现</li></ol><p>​    实际上，我们看到最终调用的扩容，不过是用工具类新生成了一个数组，而这个工具类的底层实际调用的也是系统类，进行数组的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Params:</span><br><span class="line">  src – the source array.</span><br><span class="line">  srcPos – starting position in the source array.</span><br><span class="line">  dest – the destination array.</span><br><span class="line">  destPos – starting position in the destination data.</span><br><span class="line">  length – the number of array elements to be copied</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>删除</li></ol><p>​    删除元素有两种，一种是根据下标删除，一种是根据值删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据数组下标去删除</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">      System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                       numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据值去删除</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果值是空的，找到第一个值是空的删除</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">        <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">          fastRemove(index);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 值不为空，找到第一个和入参相等的删除</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">        <span class="comment">// 这里是根据  equals 来判断值相等的</span></span><br><span class="line">        <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">          fastRemove(index);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>迭代器遍历</li></ol><p>​    Iterator我们来详细解释一下，这种遍历的思想在国外的很多企业算法面试题中都有涉及，并且它还是一种设计模式，同时我们再看下上文中提到的modCount是如何来实现“fail-fast”机制的。</p><p>首先看一下ArrayList的iterator方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//源码带注释 * &lt;p&gt;The returned iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际就是返回来一个Iterator接口的实现<code>private class Itr implements Iterator&lt;E&gt;</code></p><p>我们先看一下Iterator接口，再看一下在ArrayList中的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中就这几个方法，其中<code>hasNext()</code>、<code>next()</code>、<code>remove()</code>方法通常是迭代器重点使用的方法,而<code>forEachRemaining()</code>方法我们也看到实际调用的也是迭代器，它是传入的是一个函数式接口, 接下来我们重点关注前三种方法的实现，先看下Iterator在ArrayList中的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 迭代过程中，下一个元素的位置，从 0 开始，用来控制拿下一个元素</span></span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="comment">// 新增时表示上一次迭代过程中，索引的位置，删除成功时为 -1</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="comment">// 迭代过程中期望数组修改版本号</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasNext()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> cursor != size;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>next()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span></span><br><span class="line">      checkForComodification();</span><br><span class="line">      <span class="comment">//本次迭代过程中，元素的索引位置</span></span><br><span class="line">      <span class="keyword">int</span> i = cursor;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      <span class="comment">// 下一次迭代时，元素的位置</span></span><br><span class="line">      cursor = i + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 返回元素值</span></span><br><span class="line">      <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有关这个”fail-fast”,我们看下checkForComodification()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>迭代器一创建出来，就会赋值expectedModCount，然后每次操作前会比较modCount与它的值，用来做检查，而迭代器删除的时候，会重新赋值<code>expectedModCount = modCount</code>,保证可以通过检查，下面我们也会看到。</p><p>remove()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果上一次操作时，数组的位置已经小于 0 了，说明数组已经被删除完了</span></span><br><span class="line">      <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">      <span class="comment">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span></span><br><span class="line">      checkForComodification();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        <span class="comment">// -1 表示元素已经被删除，这里也防止重复删除</span></span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 删除元素时 modCount 的值已经发生变化，再此赋值给 expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>​    ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多 个线程对这些变量进行操作时，可能会有值被覆盖的情况。</p><p>类注释中推荐我们使用 Collections#synchronizedList 来保证线程安全，SynchronizedList 是 通过在每个方法上面加上锁来实现，虽然实现了线程安全，但是性能大大降低，具体实现源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">synchronized</span> (mutex) &#123;<span class="comment">// synchronized 是一种 重量级锁，但具有锁升级的概念，mutex 表示一把互斥锁 </span></span><br><span class="line">    <span class="keyword">return</span> c.add(e); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    本文从 ArrayList 整体架构出发，落地到初始化、新增、扩容、删除、迭代等核心源码实现，我 们发现 ArrayList 其实就是围绕底层数组结构，各个 API 都是对数组的操作进行封装，让使用者 无需感知底层实现，只需关注如何使用即可。</p>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS对称与非对称加密协议</title>
      <link href="/2022/07/06/Httptps%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/07/06/Httptps%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>众所周知，WEB服务存在http和https两种通信方式，http默认采用80作为通讯端口，对于传输采用不加密的方式，https默认采用443，对于传输的数据进行加密传输。本文重点介绍https涉及到的对称加密和非对称加密协议原理。</p></blockquote><p>首先我们先不谈https，先从一个简单的通讯原理图讲起：</p><p>​    <img src="1.png" alt="0"></p><h4 id="http通信原理"><a href="#http通信原理" class="headerlink" title="http通信原理"></a>http通信原理</h4><p>客户端发送一句client hello给服务器端，服务器端返回一句serverhello给客户端，鉴于本文讨论是https的加密主题，我们只讨论信息传输的加密问题实现客户端和服务端发送的信息client hello 和server hello，即使中间的包被窃取了，也无法解密传输的内容</p><p>http：client hello和server hello在通讯的过程中，以明文的形式进行传输，采用wireshark抓包的效果如下图：</p><p>​    <img src="2.png" alt="0"></p><p>有没有感觉这个的信息传输是完全暴露在互联网上面，你请求的所有信息都可以被窥测到，是不是感觉心一凉，不过不用担心，我们的安全信息现在都是采用https的传输，后面讲到https的时候大家心里会顿时轻松。但这不是最关键的，http的传输最大的隐患是信息劫持和篡改，如下图：</p><p>​    <img src="3.png" alt="0"></p><p>可以看到，http的信息传输中，信息很容易被×××给劫持，更有甚者，×××可以伪装服务器将篡改后的信息返回给用户，试想一下，如果×××劫持的是你的银行信息，是不是很可怕。所以对于http传出存在的问题可以总结如下：</p><p>（1）信息篡改：修改通信的内容</p><p>（2）信息劫持：拦截到信息通信的内容</p><p>这些是http不安全的体现，说完http，我们回到本文的主题https，看下人家是怎么保护信息的，所有的请求信息都采用了TLS加密，如果没有秘钥是无法解析传输的是什么信息</p><p>​    <img src="4.png" alt="0"></p><h4 id="对于加密传输存在对称加密和非对称加密"><a href="#对于加密传输存在对称加密和非对称加密" class="headerlink" title="对于加密传输存在对称加密和非对称加密"></a>对于加密传输存在对称加密和非对称加密</h4><h5 id="对称加密-——对称加密传输"><a href="#对称加密-——对称加密传输" class="headerlink" title="对称加密 ——对称加密传输"></a>对称加密 ——对称加密传输</h5><p>​    <img src="5.png" alt="0"></p><p>当客户端发送Hello字符串的时候，在进行信息传输前，采用加密算法（上图中的秘钥S）将hello加密程JDuEW8&amp;*21!@#进行传输，即使中间被×××劫持了，如果没有对应的秘钥S也无法知道传出的信息为何物，在上图中信息的加密和解密都是通过同一个秘钥进行的，对于这种加密我们称之为对称加密，只要A和B之间知道加解密的秘钥，任何第三方都无法获取秘钥S，则在一定条件下，基本上解决了信息通信的安全问题。但在现实的情况下（www），实际的通讯模型远比上图复杂，下图为实际的通信模型</p><p>​    <img src="6.png" alt="0"></p><p>server和所有的client都采用同一个秘钥S进行加解密，但大家思考下，如果这样的话，无异于没有加密，请做下思考</p><p>由于server和所有的client都采用同一个秘钥S，则×××们作为一个client也可以获取到秘钥S，此地无银三百两。所以在实际的通讯中，一般不会采用同一个秘钥，而是采用不同的秘钥加解密，如下图——通过协商的方式获取不同的秘钥</p><p>​    <img src="7.png" alt="0"></p><p>如上图，A和server通信采用对称加密A算法，B和server通信采用对称秘钥B算法，因此可以很好的解决了不同的客户端采用相同的秘钥进行通讯的问题</p><p>那现在又存在问题了，A通过明文传输和server协商采用了加密算法A，但这条信息本身是没有加密的，因此×××们还是可以窃取到秘钥的，整个的通讯仍然存在风险。那该如何处理呢？有人说，把这条信息（协调秘钥的过程）再次加密，那是不是还要协商加密秘钥，如此反复，永无止境。从根本上无法解决信息通讯的安全问题</p><h5 id="如何对协商过程进行加密-（-非对称加密原理图）"><a href="#如何对协商过程进行加密-（-非对称加密原理图）" class="headerlink" title="如何对协商过程进行加密 （ 非对称加密原理图）"></a>如何对协商过程进行加密 （ 非对称加密原理图）</h5><p>​    <img src="8.png" alt="0"></p><p>在密码学跟对称加密一起出现的，应用最广的加密机制“非对称加密”，如上图，特点是私钥加密后的密文，只要是公钥，都可以解密，但是反过来公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。</p><p>基于上述的特点，我们可以得出如下结论：</p><p>（1）公钥是开放给所有人的，但私钥是需要保密的，存在于服务端</p><p>（2）服务器端server向client端（A、B…）的信息传输是不安全的：因为所有人都可以获取公钥</p><p>（3）但client端（A、B…）向server端的信息传输确实安全的：因为私钥只有server端存在</p><p>因此，如何协商加密算法的问题，我们解决了，非对称加密算法进行对称加密算法协商过程。</p><p>​    <img src="9.png" alt="0"></p><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>信息通信采用http是不安全的，存在信息劫持、篡改的风险，https是加密传输，是安全的通信，对于https加密的过程，我们首先介绍的对称加密，采用对称加密进行通信存在秘钥协商过程的不安全性，因此我们采用了非对称加密算法解决了对协商过程的加密，因此https是集对称加密和非对称加密为一体的加密过程</p><p><strong>安全的获取公钥</strong></p><p>细心的人可能已经注意到了如果使用非对称加密算法，我们的客户端A，B需要一开始就持有公钥，要不没法开展加密行为啊。</p><p>这下，我们又遇到新问题了，如何让A、B客户端安全地得到公钥？</p><p>​    <img src="10.png" alt="0"></p><p>client获取公钥最最直接的方法是服务器端server将公钥发送给每一个client用户，但这个时候就出现了公钥被劫持的问题，如上图，client请求公钥，在请求返回的过程中被×××劫持，那么我们将采用劫持后的假秘钥进行通信，则后续的通讯过程都是采用假秘钥进行，数据库的风险仍然存在。在获取公钥的过程中，我们又引出了一个新的话题：如何安全的获取公钥，并确保公钥的获取是安全的， 那就需要用到终极武器了：SSL 证书（需要购买）和CA机构</p><p>​    <img src="11.png" alt="0"></p><p>如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有证书的颁发机构、有效期、公钥、证书持有者、签名，通过第三方的校验保证了身份的合法，解决了公钥获取的安全性</p><p>以浏览器为例说明如下整个的校验过程：</p><p>（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验</p><p>（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发</p><p>（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。</p><p>（4）如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密</p><p>（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比</p><p>（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充</p><p>（7）此时浏览器就可以读取证书中的公钥，用于后续加密了</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​        HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。</p><blockquote><p>引用：<a href="https://blog.csdn.net/weixin_42504145/article/details/85207103/" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42504145/article/details/85207103/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> 加密算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS、证书机构（CA）、证书、数字签名、私钥、公钥</title>
      <link href="/2022/07/06/HTTPS%E3%80%81%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84%EF%BC%88CA%EF%BC%89%E3%80%81%E8%AF%81%E4%B9%A6%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E3%80%81%E7%A7%81%E9%92%A5%E3%80%81%E5%85%AC%E9%92%A5/"/>
      <url>/2022/07/06/HTTPS%E3%80%81%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84%EF%BC%88CA%EF%BC%89%E3%80%81%E8%AF%81%E4%B9%A6%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E3%80%81%E7%A7%81%E9%92%A5%E3%80%81%E5%85%AC%E9%92%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文内容主要来自简书博主olaH的文章，作者对概念之间的联系解释的非常清楚，熟悉这些概念可以对理解SSH协议、Https协议以及证书颁发等打下基础</p><p>原文链接:<a href="https://www.jianshu.com/u/ab311efd67d7" target="_blank" rel="noopener">olaH</a></p></blockquote><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密是指双方持有相同的密钥进行通信，加密速度快，但是有一个安全问题，双方怎样获得相同的密钥？你总不能总是拿着U盘把密钥拷贝给对方吧。</p><p>常见的对称加密算法有DES、3DES、AES等</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密，又称为公开密钥加密，是为了解决对称加密中的安全问题而诞生，一个称为公开密钥(public key)，即公钥，另一个称为私钥(private key)，即私钥。但是它的加密速度相对于对称加密来说很慢。</p><ul><li>公钥(public key)是对外开放的，私钥(private key)是自己拥有的。</li><li>公钥(public key)加密的数据，只能用私钥(private key)解密。</li><li>私钥(private key)加密的数据，只能用公钥(public key)解密。</li></ul><h3 id="信息安全问题"><a href="#信息安全问题" class="headerlink" title="信息安全问题"></a>信息安全问题</h3><p>在信息安全性问题中，我们常常要做到三点才能保证信息的安全：</p><ol><li>信息的保密性</li><li>信息的完整性</li><li>身份识别</li></ol><h4 id="信息的保密性（加密算法）"><a href="#信息的保密性（加密算法）" class="headerlink" title="信息的保密性（加密算法）"></a>信息的保密性（加密算法）</h4><p>信息的保密性我们可以使用对称加密和非对称加密来完成，使用对称加密来完成，速度相对非对称加密很快，但是存在一个安全问题，密钥如何传递？由此通用的方法是使用非对称加密+对称加密来完成。客户端使用公钥对对称加密的密钥进行加密，然后传递给服务端，服务端使用私钥进行解密确认密钥，开始传输数据。</p><p>​    <img src="1.png" alt="0"></p><h4 id="信息的完整性（数字签名）"><a href="#信息的完整性（数字签名）" class="headerlink" title="信息的完整性（数字签名）"></a>信息的完整性（数字签名）</h4><p>信息传输的途中，我们的信息很有可能被第三方劫持篡改，所以我们需要保证信息的完整性，通用方法是使用散列算法如SHA1，MD5将传输内容hash一次获得hash值，即摘要。客户端使用服务端的公钥对摘要和信息内容进行加密，然后传输给服务端，服务端使用私钥进行解密获得原始内容和摘要值，这时服务端使用相同的hash算法对原始内容进行hash，然后与摘要值比对，如果一致，说明信息是完整的。</p><p>​    <img src="2.png" alt="0"></p><p>image.png</p><h4 id="身份识别（数字证书）"><a href="#身份识别（数字证书）" class="headerlink" title="身份识别（数字证书）"></a>身份识别（数字证书）</h4><p>在信息传输的过程中，我们通常需要验证信息的发送方的身份，这时我们转化一下思路就可以完成，把发送端的公钥发送给接收端，发送端通过把自己的内容使用私钥加密然后发送给接收端，接收端只能用发送端的公钥解密，自然就验证了发送端的身份。</p><p>​    <img src="3.png" alt="0"></p><p>image.png</p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>在传输的过程中，客户端如何获得服务器端的公钥呢？当时是服务器分发给客户端，如果一开始服务端发送的公钥到客户端的过程中有可能被第三方劫持，然后第三方自己伪造一对密钥，将公钥发送给客户端，当服务器发送数据给客户端的时候，中间人将信息进行劫持，用一开始劫持的公钥进行解密后，然后使用自己的私钥将数据加密发送给客户端，而客户端收到后使用公钥解密，反过来亦是如此，整个过程中间人是透明的，但信息泄露却不得而知。</p><p>​    <img src="4.png" alt="0"></p><p>image.png</p><p>为了防止这种情况，数字证书就出现了，它其实就是基于上上面所说的私钥加密数据，公钥解密来验证其身份。</p><p>数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，最重要的是公钥在数字证书中。</p><p>数字证书是如何保证公钥来自请求的服务器呢？数字证书上由持有人的相关信息，通过这点可以确定其不是一个中间人；但是证书也是可以伪造的，如何保证证书为真呢？</p><p>一个证书中含有三个部分:”证书内容，散列算法，加密密文”，证书内容会被散列算法hash计算出hash值，然后使用CA机构提供的私钥进行RSA加密。</p><p>​    <img src="5.png" alt="0"></p><p>image.png</p><p>当客户端发起请求时，服务器将该数字证书发送给客户端，客户端通过CA机构提供的公钥对加密密文进行解密获得散列值（数字签名），同时将证书内容使用相同的散列算法进行Hash得到另一个散列值，比对两个散列值，如果两者相等则说明证书没问题。</p><p>​    <img src="6.png" alt="0"></p><p>image.png</p><p>一些常见的证书文件类型如下：</p><p>X.509#DER 二进制格式证书，常用后缀.cer .crt</p><p>X.509#PEM 文本格式证书，常用后缀.pem</p><p>有的证书内容是只包含公钥（服务器的公钥），如.crt、.cer、.pem</p><p>有的证书既包含公钥又包含私钥（服务器的私钥），如.pfx、.p12</p><h3 id="HTTPS，TLS-SSL"><a href="#HTTPS，TLS-SSL" class="headerlink" title="HTTPS，TLS/SSL"></a>HTTPS，TLS/SSL</h3><p>Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。</p><p>使用TCP端口默认为443</p><p>TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。</p><p>SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。</p><p>SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。</p><h4 id="对称加密-1"><a href="#对称加密-1" class="headerlink" title="对称加密"></a>对称加密</h4><p>速度高，可加密内容较大，用来加密会话过程中的消息</p><h4 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h4><p>加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</p><p>​    <img src="7.png" alt="0"></p><p>image.png</p><h4 id="HTTPS单向认证"><a href="#HTTPS单向认证" class="headerlink" title="HTTPS单向认证"></a>HTTPS单向认证</h4><p>Https在建立Socket连接之前，需要进行握手，具体过程如下：</p><p>​    <img src="8.png" alt="0"></p><p>image.png</p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息;</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书;</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：</li></ol><ul><li><ul><li>证书是否过期;</li><li>发行服务器证书的CA是否可靠;(通过查询浏览器或本机内的CA证书)</li><li>返回的公钥是否能正确解开返回证书中的数字签名;（通过使用本机或浏览器内置的CA公钥进行解密）</li><li>服务器证书上的域名是否和服务器的实际域名相匹配;</li><li>验证通过后，将继续进行通信，否则，终止通信;</li></ul></li></ul><ol><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择;</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式;</li><li>服务器将选择好的加密方案通过明文方式返回给客户端;</li><li>客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器;</li><li>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥;</li></ol><p>在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全;</p><h4 id="HTTPS双向认证"><a href="#HTTPS双向认证" class="headerlink" title="HTTPS双向认证"></a>HTTPS双向认证</h4><p>双向认证和单向认证类似，它额外增加了服务端对客户端的认证：</p><p>​    <img src="9.png" alt="0"></p><p>image.png</p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息;</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书;</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：</li></ol><ul><li><ul><li>证书是否过期;</li><li>发行服务器证书的CA是否可靠;(通过查询浏览器或本机内的CA证书)</li><li>返回的公钥是否能正确解开返回证书中的数字签名;（通过使用本机或浏览器内置的CA公钥进行解密）</li><li>服务器证书上的域名是否和服务器的实际域名相匹配;</li><li>验证通过后，将继续进行通信，否则，终止通信;</li></ul></li></ul><ol><li>服务端要求客户端发送客户端的证书即客户端证书公钥，客户端会将自己的证书发送至服务端；</li><li>验证客户端的证书，通过验证后，会获得客户端的公钥；</li><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式;</li><li>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</li><li>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端；</li><li>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全；</li></ol>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码解析</title>
      <link href="/2018/10/05/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/10/05/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>HashMap是特别常用的数据结构，源码很长,但底层原理并不复杂，本篇主要介绍hashmap的存储原理以及底层用到的数据结构，并对核心代码进行分析。</p></blockquote><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li><p>结构图</p><p>HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。其中当链表的长度大于等于 8 时， 链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表，整体的数据结构 如下：</p><p><img src="1.jpg" alt="结构图"></p></li><li><p>类注释信息</p><ul><li>允许 null 值，不同于 HashTable ，是线程不安全的;</li><li>load factor（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值，较高的 值会减少空间开销（扩容减少，数组大小增长速度变慢），但增加了查找成本（hash 冲突增加，链表长度变长），不扩容的条件：数组容量 &gt; 需要的数组大小 /load factor;</li><li>如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的 大小，这样可以防止在其过程中不断的扩容，影响性能；</li><li>HashMap 是非线程安全的，我们可以自己在外部加锁，或者通过Collections#synchronizedMap 来实现线程安全，Collections#synchronizedMap 的实 现是在每个方法上加上了 synchronized 锁；</li><li>在迭代过程中，如果 HashMap 的结构被修改，会快速失败。</li></ul></li><li><p>常见属性</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">   <span class="comment">//最大容量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">  <span class="comment">//负载因子默认值</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">   <span class="comment">//bin(桶)容量大于等于8时，链表转化成红黑树</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//bin(桶)容量小于等于6时，红黑树转化成链表</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//容量最小64时才会转会成红黑树</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于fail-fast的，记录HashMap结构发生变化(数量变化或rehash)的数目</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//HashMap 的实际大小，可能不准(因为当你拿到这个值的时候，可能又发生了变化)</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 扩容的门槛，如果初始化时，给定数组大小的话，通过tableSizeFor 方法计算，永远接近于 2 的幂次方</span></span><br><span class="line">   <span class="comment">// 如果是通过 resize 方法进行扩容后，大小 = 数组容量 * 0.75</span></span><br><span class="line">   <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//存放数据的数组</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ol><li><p>整体流程</p><p>新增 key，value 大概的步骤如下：</p><ol><li>空数组有无初始化，没有的话初始化；</li><li>如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；</li><li>如果 hash 冲突，两种解决方案：链表 or 红黑树；</li><li>如果是链表，递归循环，把新元素追加到队尾；</li><li>如果是红黑树，调用红黑树新增的方法；</li><li>通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；</li><li>判断是否需要扩容，需要扩容进行扩容，结束。</li></ol></li></ol><p>​    我们来画一张示意图来描述下：</p><p>​    <img src="2.jpg" alt="添加元素流程图"></p><ol><li><p>源码实现</p><ol><li>添加元素 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//如果数组为空，初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// hashCode的算法先右移16 在并上数组大小-1</span></span><br><span class="line">        <span class="comment">// 如果当前索引位置是空的，直接生成新的节点在当前索引位置上</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 如果hash冲突，当前索引上有值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 如果key equals都相等，那么当前节点就是我们要新增的</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 如果是红黑树，使用红黑树的方式新增</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 是个链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//如果是最后一个，还找不到和新增的元素相等的，直接新增</span></span><br><span class="line">                    <span class="comment">//节点是新增到链表最后的</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//p.next是新增的节点，但是e仍然是null</span></span><br><span class="line">                        <span class="comment">//e和p.next都是持有对null的引用,即使p.next后来赋予了值</span></span><br><span class="line">                        <span class="comment">// 只是改变了p.next指向的引用，和e没有关系</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//新增时，链表的长度大于等于8时，链表转红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//链表中有元素和新增的元素相等，结束循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//更改循环的当前元素</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//说明新增的元素table中原来就有</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">// 当前节点移动到队尾</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">//如果kv的实际大小大于扩容的门槛，开始扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 删除不经常使用的元素</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>链表添加细节</p><p> 链表的添加比较简单，和LinkedList的追加实现是一样的，上面代码中描述的很清楚了，注意一点，当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，此方法 有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，当数组 大小小于 64 时，只会触发扩容，不会转化成红黑树 ，转化成红黑树的过程也比较简单，此处不再赘述 。</p><p>至于为什么是8 才会转红黑树，源码中有注释，可以参照,大概意思如下文:</p><blockquote><p>链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候， 使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要 的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，所以我们需要定义出转化的边界值。</p><p>在考虑设计 8 这个值的时候，我们参考了泊松分布概率函数，由泊松分布中得出结论，链表各 个长度的命中概率为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 0:    0.60653066</span><br><span class="line">* 1:    0.30326533</span><br><span class="line">* 2:    0.07581633</span><br><span class="line">* 3:    0.01263606</span><br><span class="line">* 4:    0.00157952</span><br><span class="line">* 5:    0.00015795</span><br><span class="line">* 6:    0.00001316</span><br><span class="line">* 7:    0.00000094</span><br><span class="line">* 8:    0.00000006</span><br><span class="line">* more: less than 1 in ten million</span><br></pre></td></tr></table></figure></blockquote><p>意思是，当链表的长度是 8 的时候，出现的概率是 0.00000006，不到千万分之一，所以说正常 情况下，链表的长度不可能到达 8 ，而一旦到达 8 时，肯定是 hash 算法出了问题，所以在这 种情况下，为了让 HashMap 仍然有较高的查询性能，所以让链表转化成红黑树，我们正常写 代码， 使用 HashMap 时， 几乎不会碰到链表转化成红黑树的情况， 毕竟概念只有千万分之 一。</p></li><li><p>红黑树添加细节</p><p>红黑树是一种动态平衡的数据结构 和AVL树、跳表类似，都具有动态平衡的特点，其实本身没多难，只是插入元素和删除元素后，需要平衡调整-“打补丁”操作,具体的调整规则就不再叙述了，红黑树不了解的可先跳过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树中加入节点</span></span><br><span class="line">        <span class="comment">//在计算新增的节点挂在那个节点上，是线程不安全的，</span></span><br><span class="line">        <span class="comment">//关键在于没有锁住tab,table可能是在动态的变化的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1:首先判断新增的节点在红黑树上是不是已经存在。</span></span><br><span class="line">        <span class="comment">//2:不在的话，根据hashcode，或者自定义的comparTo,递归找到要挂载的节点</span></span><br><span class="line">        <span class="comment">//3:和要挂载的节点建立父子，前后关系</span></span><br><span class="line">        <span class="comment">//4:判断是否需要着色，旋转。</span></span><br><span class="line">        <span class="comment">//5:对红黑树的根节点进行校验</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//h：key 的hash值</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//找到根节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">//自旋</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="comment">// p hash 值大于 h，说明 p 在 h 的右边</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// p hash 值小于 h，说明 p 在 h 的左边</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//要放进去key在当前树中已经存在了(equals来判断)</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="comment">//自己实现的Comparable的话，不能用hashcode比较了，需要用compareTo</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          <span class="comment">//得到key的Class类型，如果key没有实现Comparable就是null</span></span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                          <span class="comment">//当前节点pk和入参k不等</span></span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//找到和当前hashcode值相近的节点(当前节点的左右子节点其中一个为空即可)</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    <span class="comment">//生成新的节点</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="comment">//把新节点放在当前子节点为空的位置上</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">//当前节点和新节点建立父子，前后关系</span></span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    <span class="comment">//balanceInsertion 对红黑树进行着色或旋转，以达到更多的查找效率，着色或旋转的几种场景如下</span></span><br><span class="line">                    <span class="comment">//着色：新节点总是为红色；如果新节点的父亲是黑色，则不需要重新着色；如果父亲是红色，那么必须通过重新</span></span><br><span class="line">                    <span class="comment">//着色或者旋转的方法，再次达到红黑树的5个约束条件</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//旋转： 父亲是红色，叔叔是黑色时(前提是当前)</span></span><br><span class="line">                    <span class="comment">//如果当前节点是父亲的右节点，则进行左旋</span></span><br><span class="line">                    <span class="comment">//如果当前节点是父亲的左节点，则进行右旋</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//moveRootToFront 方法是把算出来的root放到根节点上</span></span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>HashMap 的查找主要分为以下三步：</p><ol><li><p>根据hashcode,算出数组的索引，找到槽点,槽点的key和查询的key相等，直接返回</p></li><li><p>判断当前节点有无 next 节点，有的话判断是链表类型，还是红黑树类型。</p></li><li><p>分别走链表和红黑树不同类型的查找方法。</p><ol><li><p>链表查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用自旋方式从链表中查找 key，e 初始为为链表的头节点 </span></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">// 如果当前节点 hash 等于 key 的 hash，并且 equals 相等，当前节点就是我们要找的节点 </span></span><br><span class="line">  <span class="comment">// 当 hash 冲突时，同一个 hash 值上是一个链表的时候，我们是通过 equals 方法来比较 key 是否相同</span></span><br><span class="line">  <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    <span class="keyword">return</span> e; </span><br><span class="line">  <span class="comment">// 否则，把当前节点的下一个节点拿出来继续寻找 &#125; </span></span><br><span class="line">&#125;<span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li><li><p>红黑树查找</p><p>说下思路:</p><ol><li><p>从根节点递归查找；</p></li><li><p>根据 hashcode，比较查找节点，左边节点，右边节点之间的大小，根本红黑树左小右大</p><p>的特性进行判断；</p></li><li><p>判断查找节点在第 2 步有无定位节点位置，有的话返回，没有的话重复 2，3 两步；</p></li><li><p>一直自旋到定位到节点位置为止。</p><p>如果红黑树比较平衡的话，每次查找的次数就是树的深度。</p></li></ol></li></ol></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​        HashMap 的内容虽然较多，但大多数 api 都只是对数组 + 链表 + 红黑树这种数据结构进行封 装而已，本文我们从新增和查找两个角度进行了源码的深入分析，分析了是如何对数组、链表 和红黑树进行操作的,更详细的内容可以自行阅读源码。</p>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link href="/2018/08/03/3-Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2018/08/03/3-Longest-Substring-Without-Repeating-Characters/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a> </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a string <code>s</code>, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3.</span><br><span class="line">Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> consists of English letters, digits, symbols and spaces.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题相对简单，属于中等难度，可以使用滑动窗口或者动态规划来做，看到最优解，习惯性的使用DP来解</li><li>定义dp[i]含义为以i位置结尾的最长不重复子串长度，思考如何用dp[i]推导出dp[i+1],由于是不重复子串， 所以i+1位置结尾的子串，需要考虑i+1位置自符出现的位置,可以建立一个辅助map，来记录当前字符上次出现的位置,递推方程如下:</li></ul><script type="math/tex; mode=display">dp[i] = \left\{dp[i-1],i-map[chars[i]] \right\}\left ( i=1,2...n-1 \right )</script><ul><li>动态规划在分析过程中，经常是“需要什么就要创建什么”，通常要建立一些辅助数组来推导最优解</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">            map[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[chars[<span class="number">0</span>]] = <span class="number">0</span>;<span class="comment">//注意记录字符最近一次出现的位置，不要漏掉首个字符</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p1 = dp[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> p2 = i-map[chars[i]];</span><br><span class="line">            dp[i] = Math.min(p1,p2);</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">            map[chars[i]]  = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. Add Two Numbers</title>
      <link href="/2018/08/01/2-Add-Two-Numbers/"/>
      <url>/2018/08/01/2-Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode.com/problems/add-two-numbers/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">Output: [7,0,8]</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">Output: [8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>It is guaranteed that the list represents a number that does not have leading zeros.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>注意几个点</p><ul><li>注意进位的处理，每次累加 记得加上进位</li><li>最后若仍有进位，需要单独新建一个节点来保留进位</li><li>为减少额外空间，可以将结果累加到l1上或者l2上而不必新建节点。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jie = <span class="number">0</span>;</span><br><span class="line">        ListNode p1 = l1;</span><br><span class="line">        ListNode p2 = l2;</span><br><span class="line">        ListNode p1_last = <span class="keyword">null</span>;;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = (p1.val + p2.val + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (p1.val + p2.val + jie)/<span class="number">10</span>;</span><br><span class="line">            p1.val = left;</span><br><span class="line">            p1_last = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = (p1.val + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (p1.val + jie)/<span class="number">10</span>;</span><br><span class="line">            p1.val = left;</span><br><span class="line">            p1_last = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = (p2.val + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (p2.val + jie)/<span class="number">10</span>;</span><br><span class="line">            p1_last.next = <span class="keyword">new</span> ListNode(left);</span><br><span class="line">            p1_last = p1_last.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jie != <span class="number">0</span>)&#123;</span><br><span class="line">            p1_last.next = <span class="keyword">new</span> ListNode(jie);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.Two Sum</title>
      <link href="/2018/08/01/1-Two-Sum/"/>
      <url>/2018/08/01/1-Two-Sum/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p> <a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p><p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p><p>You can return the answer in any order.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: Because nums[0] + nums[1] &#x3D;&#x3D; 9, we return [0, 1].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">Output: [0,1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>Only one valid answer exists.</strong></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>此题比较简单，可以学到一个基本技巧-“在遍历过程中寻找已经处理过的元素”，并且尽可能快的查找元素，优先考虑到有序表结构。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(target - nums[i]), i &#125;;</span><br><span class="line">&#125;</span><br><span class="line">map.put(nums[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
