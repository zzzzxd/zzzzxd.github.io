<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>磁盘使用流程及企业分区方案</title>
      <link href="/2022/12/14/%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/12/14/%E7%A3%81%E7%9B%98%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="磁盘使用流程概述"><a href="#磁盘使用流程概述" class="headerlink" title="磁盘使用流程概述"></a>磁盘使用流程概述</h2><p>其实磁盘的使用，主要就是三个步骤，分区、格式化、挂载</p><ol><li><p>磁盘分区 :有了一块地,划分隔断. fdisk/parted</p></li><li><p>格式化（创建文件系统） :对房间进行装修. mkfs</p></li><li><p>挂载 :安装门窗,可以入住与使用. mount Linux下面设备必须要挂载才能访问与使用,没有挂载相当于房子没 有门窗. 挂载相当于给设备设置了一个入口.</p></li></ol><h2 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h2><h3 id="磁盘分区-对新添加的sdb磁盘划分一个分区"><a href="#磁盘分区-对新添加的sdb磁盘划分一个分区" class="headerlink" title="磁盘分区 对新添加的sdb磁盘划分一个分区"></a>磁盘分区 对新添加的sdb磁盘划分一个分区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@linx01 ~]# fdisk -l</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sda：21.5 GB, 21474836480 字节，41943040 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x000e3ccf</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     2099199     1048576   83  Linux</span><br><span class="line">/dev/sda2         2099200    37742591    17821696   83  Linux</span><br><span class="line">/dev/sda3        37742592    39831551     1044480   82  Linux swap / Solaris</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line"></span><br><span class="line">[root@linx01 ~]# fdisk /dev/sdb</span><br><span class="line">欢迎使用 fdisk (util-linux 2.23.2)。</span><br><span class="line"></span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">使用磁盘标识符 0x139651f9 创建新的 DOS 磁盘标签。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">分区号 (1-4，默认 1)：1</span><br><span class="line">起始 扇区 (2048-10485759，默认为 2048)：</span><br><span class="line">将使用默认值 2048</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-10485759，默认为 10485759)：</span><br><span class="line">将使用默认值 10485759</span><br><span class="line">分区 1 已设置为 Linux 类型，大小设为 5 GiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">正在同步磁盘。</span><br><span class="line">[root@linx01 ~]# fdisk -l</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sda：21.5 GB, 21474836480 字节，41943040 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x000e3ccf</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     2099199     1048576   83  Linux</span><br><span class="line">/dev/sda2         2099200    37742591    17821696   83  Linux</span><br><span class="line">/dev/sda3        37742592    39831551     1044480   82  Linux swap / Solaris</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x139651f9</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048    10485759     5241856   83  Linux</span><br><span class="line">[root@linx01 ~]#</span><br></pre></td></tr></table></figure><h3 id="格式化操作"><a href="#格式化操作" class="headerlink" title="格式化操作"></a>格式化操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# mkfs.xfs /dev/sdb1</span><br><span class="line">meta-data=/dev/sdb1              isize=512    agcount=4, agsize=327616 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0, sparse=0</span><br><span class="line">data     =                       bsize=4096   blocks=1310464, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line">log      =internal log           bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# mount /dev/sdb1 /mnt</span><br><span class="line">[root@linx01 ~]# df -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs        710M     0  710M    0% /dev</span><br><span class="line">tmpfs           721M   12K  721M    1% /dev/shm</span><br><span class="line">tmpfs           721M  9.7M  711M    2% /run</span><br><span class="line">tmpfs           721M     0  721M    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda2        17G  8.1G  8.9G   48% /</span><br><span class="line">/dev/sda1      1014M  138M  877M   14% /boot</span><br><span class="line">tmpfs           145M     0  145M    0% /run/user/0</span><br><span class="line">/dev/sdb1       5.0G   33M  5.0G    1% /mnt</span><br></pre></td></tr></table></figure><h4 id="永久挂载"><a href="#永久挂载" class="headerlink" title="永久挂载"></a>永久挂载</h4><p>上述演示的只是临时挂载，要想永久挂载，一般有两种方法:</p><ol><li>修改/etc/rc.local</li></ol><ul><li>存放的命令,脚本会在开机的时候自动运行.</li><li><p>第1次使用,需要给 /etc/rc.d/rc.local 加上执行权限. chmod +x /etc/rc.d/rc.local</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdb1 /mnt  #写入到/etc/rc.local</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>修改/etc/fstab(推荐)</p><p><img src="image-20221214214951906.png" alt="image-20221214214951906"></p></li></ol><h2 id="磁盘分区相关指令总结"><a href="#磁盘分区相关指令总结" class="headerlink" title="磁盘分区相关指令总结"></a>磁盘分区相关指令总结</h2><ul><li>fdisk</li><li>lsblk</li><li>mount 、umount</li><li>mkfs  mkfs.xfs 、mkfs.ext3、mkfs.ext4</li></ul><h2 id="企业分区的通用方案"><a href="#企业分区的通用方案" class="headerlink" title="企业分区的通用方案"></a>企业分区的通用方案</h2><p>磁盘分区整个过程还是比较简单的，在这总结了 企业中常见的分区方案，给大家做一个建议。</p><h3 id="物理机"><a href="#物理机" class="headerlink" title="物理机"></a>物理机</h3><h4 id="方案01-测试环境，不太重要的环境"><a href="#方案01-测试环境，不太重要的环境" class="headerlink" title="方案01:测试环境，不太重要的环境"></a>方案01:测试环境，不太重要的环境</h4><div class="table-container"><table><thead><tr><th>分区</th><th>解释</th></tr></thead><tbody><tr><td>/boot 分区</td><td>用于引导系统启动,linux内核文件。 1G即可（如果需要升级linux内核） (200MB)</td></tr><tr><td>/swap 分区</td><td>内存不足的时候，swap    空间临时充当内存使用。<br />内存小于8G swap 可以给内存的1.5倍或2倍。 最大控制在8-16G <br />内存大于8G swap 给8G 8-16G<br />在一些生产环境中为了极致的速度、性能。会关闭<br />注意:swap 云服务器默认没有swap</td></tr><tr><td>/</td><td>剩余多少给多少</td></tr></tbody></table></div><h4 id="方案02-生产环境，有重要数据的环境"><a href="#方案02-生产环境，有重要数据的环境" class="headerlink" title="方案02:生产环境，有重要数据的环境"></a>方案02:生产环境，有重要数据的环境</h4><p></p><div class="table-container"><table><thead><tr><th>分区</th><th>解释</th></tr></thead><tbody><tr><td>/boot 分区</td><td>用于引导系统启动,linux内核文件。 1G即可（如果需要升级linux内核） (200MB)</td></tr><tr><td>/swap分区</td><td>内存不足的时候，swap    空间临时充当内存使用。<br />内存小于8G swap 可以给内存的1.5倍或2倍。 最大控制在8-16G <br />内存大于8G swap 给8G 8-16G<br />在一些生产环境中为了极致的速度、性能。会关闭<br /></td></tr><tr><td>/ 分区</td><td>根分区40-100G</td></tr><tr><td>/data 数据分区</td><td>重要数据放在/data 目录、分区中。</td></tr></tbody></table></div><h4 id="方案03-可能会有重要数据"><a href="#方案03-可能会有重要数据" class="headerlink" title="方案03:可能会有重要数据"></a>方案03:可能会有重要数据</h4><div class="table-container"><table><thead><tr><th></th><th>解释</th></tr></thead><tbody><tr><td>/boot 分区</td><td>用于引导系统启动,linux内核文件。 1G即可（如果需要升级linux内核） (200MB)</td></tr><tr><td>/swap分区</td><td>内存不足的时候，swap    空间临时充当内存使用。<br />内存小于8G swap 可以给内存的1.5倍或2倍。 最大控制在8-16G <br />内存大于8G swap 给8G 8-16G<br />在一些生产环境中为了极致的速度、性能。会关闭<br /></td></tr><tr><td>/ 分区</td><td>根分区40-100G</td></tr><tr><td>剩余暂不分配</td></tr></tbody></table></div><h3 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h3><p>根据需求，规划好。所需要的磁盘空间。 如果后期添加，扩容云服务器都很方便。</p><p>/ 系统分区 根分区 40-100G  /dev/sda</p><p>/data 数据分区 数据分区 不限制。</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘空间不足案例分析</title>
      <link href="/2022/12/14/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
      <url>/2022/12/14/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>fdisk磁盘分区实战</title>
      <link href="/2022/12/14/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%AE%9E%E6%88%98/"/>
      <url>/2022/12/14/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>​    此次我们在虚拟机上添加磁盘进行操作。具体的添加操作，由于不同的虚拟机添加方法不一样就不在叙述了。</p><p>添加完磁盘后，使用lsblk命令可以查看所以的块设备</p><p><img src="image-20221214192320994.png" alt="image-20221214192320994"></p><p>可以看到，当前虚拟机上共有三块设备，两块硬盘，一块光盘，只要能看到自己添加的硬盘即可。</p><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><h3 id="fdisk分区指令"><a href="#fdisk分区指令" class="headerlink" title="fdisk分区指令"></a>fdisk分区指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk [选项][参数]</span><br></pre></td></tr></table></figure><p>​    fdisk 指令是 Linux 下通用的磁盘分区工具，它可以操纵硬盘分区表，完成对硬盘分区进行管理的各种操作。</p><p>它也是交互的，在进行分区的时候会有提示。在分区之前 可以使用 fdisk -l 查看磁盘的所有分区列表。</p><p><img src="image-20221214192950364.png" alt="image-20221214192950364"></p><h3 id="分区案例演示"><a href="#分区案例演示" class="headerlink" title="分区案例演示"></a>分区案例演示</h3><p>​    接下来。我以第二块硬盘sdb 逐步进行分区演示。</p><p>Case01:创建一个100M的分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# fdisk /dev/sdb</span><br><span class="line">欢迎使用 fdisk (util-linux 2.23.2)。</span><br><span class="line"></span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：m</span><br><span class="line">命令操作</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create an IRIX (SGI) partition table</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   print this menu</span><br><span class="line">   n   add a new partition</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   print the partition table</span><br><span class="line">   q   quit without saving changes</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition's system id</span><br><span class="line">   u   change display/entry units</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   w   write table to disk and exit</span><br><span class="line">   x   extra functionality (experts only)</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：p</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0xf6a444cb</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">分区号 (1-4，默认 1)：</span><br><span class="line">起始 扇区 (2048-10485759，默认为 2048)：</span><br><span class="line">将使用默认值 2048</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-10485759，默认为 10485759)：100M</span><br><span class="line">值超出范围。</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-10485759，默认为 10485759)：+100M</span><br><span class="line">分区 1 已设置为 Linux 类型，大小设为 100 MiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line"></span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: 设备或资源忙.</span><br><span class="line">The kernel still uses the old table. The new table will be used at</span><br><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span><br><span class="line">正在同步磁盘。</span><br></pre></td></tr></table></figure><p>上述整个过程可以看到，我们通过交互命令打印出，当前分区为0，然后添加了一个100M的分区</p><p>其中上述的交互命令，常用的有如下这些</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p (print) 显示当前磁盘分区信息.</span><br><span class="line">n (new) 创建磁盘分区.</span><br><span class="line">d (delete) 删除分区.</span><br><span class="line">q (quit) 退出不保存.</span><br><span class="line">w (write) 保存并退出. 让磁盘分区生效.</span><br></pre></td></tr></table></figure><p>Case02:删除创建的一个分区,再创建 1个主分区500M，2个逻辑分区分别为1G、500M</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# fdisk /dev/sdb</span><br><span class="line">欢迎使用 fdisk (util-linux 2.23.2)。</span><br><span class="line"></span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：p</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0xf6a444cb</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048      206847      102400   83  Linux</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：d</span><br><span class="line">已选择分区 1</span><br><span class="line">分区 1 已删除</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">分区号 (1-4，默认 1)：</span><br><span class="line">起始 扇区 (2048-10485759，默认为 2048)：</span><br><span class="line">将使用默认值 2048</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-10485759，默认为 10485759)：+500M  </span><br><span class="line">分区 1 已设置为 Linux 类型，大小设为 500 MiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): e</span><br><span class="line">分区号 (2-4，默认 2)：</span><br><span class="line">起始 扇区 (1026048-10485759，默认为 1026048)：</span><br><span class="line">将使用默认值 1026048</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (1026048-10485759，默认为 10485759)：+2G</span><br><span class="line">分区 2 已设置为 Extended 类型，大小设为 2 GiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 1 extended, 2 free)</span><br><span class="line">   l   logical (numbered from 5)</span><br><span class="line">Select (default p): l</span><br><span class="line">添加逻辑分区 5</span><br><span class="line">起始 扇区 (1028096-5220351，默认为 1028096)：</span><br><span class="line">将使用默认值 1028096</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (1028096-5220351，默认为 5220351)：+1G</span><br><span class="line">分区 5 已设置为 Linux 类型，大小设为 1 GiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 1 extended, 2 free)</span><br><span class="line">   l   logical (numbered from 5)</span><br><span class="line">Select (default p): l</span><br><span class="line">添加逻辑分区 6</span><br><span class="line">起始 扇区 (3127296-5220351，默认为 3127296)：</span><br><span class="line">将使用默认值 3127296</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (3127296-5220351，默认为 5220351)：+1G</span><br><span class="line">值超出范围。</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (3127296-5220351，默认为 5220351)：+500M  </span><br><span class="line">分区 6 已设置为 Linux 类型，大小设为 500 MiB</span><br><span class="line">命令(输入 m 获取帮助)：p</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sdb：5368 MB, 5368709120 字节，10485760 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0xf6a444cb</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048     1026047      512000   83  Linux</span><br><span class="line">/dev/sdb2         1026048     5220351     2097152    5  Extended</span><br><span class="line">/dev/sdb5         1028096     3125247     1048576   83  Linux</span><br><span class="line">/dev/sdb6         3127296     4151295      512000   83  Linux</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line"></span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: 设备或资源忙.</span><br><span class="line">The kernel still uses the old table. The new table will be used at</span><br><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span><br><span class="line">正在同步磁盘。</span><br></pre></td></tr></table></figure><p>可以看到。在创建扩展分区之后，在进行创建时候就看到逻辑分区了。这就是因为逻辑分区是依赖扩展分区的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>我们看到整个分区的过程还是比较简单的，分区就类似给房子打隔断，打完隔断就变成一个一个的房间，但这时候还是不能用的，还需要格式化 类似于装修，最后挂载相当于装门，就可以用了。完整的流程我们后面还会总结。</p></li><li><p>fdisk 分区是mbr各式的，除了fdisk指令还有其它指令我们总结如下:</p><p>| 指令   | 分区格式        | 限制            |<br>| ——— | ———————- | ———————- |<br>| fdisk  | mbr             | 磁盘不能大于2tb |<br>| parted | mbr(msdos)、gpt | 支持2tb以上     |<br>| gdisk  | gpt             | 2tb以上         |</p><p> 大于2tb的磁盘需要用gpt的分区格式，所以通常用 parted或者gdisk指令 。其实只要熟练掌握一种指令 其它都是类似的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SWAP分区实战</title>
      <link href="/2022/12/14/SWAP%E5%88%86%E5%8C%BA%E5%AE%9E%E6%88%98/"/>
      <url>/2022/12/14/SWAP%E5%88%86%E5%8C%BA%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux的磁盘管理体系</title>
      <link href="/2022/12/14/Linux%E7%9A%84%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB/"/>
      <url>/2022/12/14/Linux%E7%9A%84%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="　前言"></a>　前言</h2><p>磁盘相关的知识是Linux系统中的重头戏，需要了解的点比较多。但现在随着云计算的兴起，在很多企业中很少碰到物理服务器了也就不会接触到屋里磁盘。所以更多的是停留在使用的层面。下面我们就系统的回顾一下linux的磁盘知识。</p><h2 id="磁盘管理基础"><a href="#磁盘管理基础" class="headerlink" title="磁盘管理基础"></a>磁盘管理基础</h2><h3 id="磁盘分类与接口"><a href="#磁盘分类与接口" class="headerlink" title="磁盘分类与接口"></a>磁盘分类与接口</h3><p>磁盘分类:</p><ul><li>机械硬盘HDD</li><li>固态硬盘SSD</li></ul><p>磁盘接口分类:</p><div class="table-container"><table><thead><tr><th>类型</th><th>磁盘类型</th><th>适应场景</th></tr></thead><tbody><tr><td>sata</td><td>机械、固态</td><td>家用更多</td></tr><tr><td>sas(由scsi改进而来)</td><td>机械、固态</td><td>企业更多</td></tr><tr><td>pic-e</td><td>固态</td><td>企业、家用</td></tr></tbody></table></div><p>注:以上只列举了目前家庭企业比较常见的，实际上现在还有较新的M2接口，速度也更快，感兴趣的可以自己了解下。</p><h3 id="企业磁盘选型"><a href="#企业磁盘选型" class="headerlink" title="企业磁盘选型"></a>企业磁盘选型</h3><p>在企业场景中，选择磁盘的时候 要考虑很多方面，包括性能、性价比等，要根据不同的场景选择合适的磁盘，也是为了节省成本。</p><div class="table-container"><table><thead><tr><th>接口</th><th>应用场景</th><th></th></tr></thead><tbody><tr><td>sata</td><td>企业内部使用,存放备份. 线下业务(给自己内部人员使用)</td><td>4tb 6tb 7.2k转 * 8</td></tr><tr><td>SAS</td><td>企业标配,线上业务(线上环境,生产环境)使用(提供给用户环境)</td><td>300g 600g 900g 15k硬盘 *8</td></tr><tr><td>固态硬盘(pci- e/sas/sata)</td><td>访问量巨大(并发高). 数据量不是很大. (架构优化策略:把用户经常访问的数据存 放在固态)</td><td>500g 1tb 2tb *4</td></tr></tbody></table></div><h3 id="磁盘内部结构"><a href="#磁盘内部结构" class="headerlink" title="磁盘内部结构"></a>磁盘内部结构</h3><p>机械硬盘:</p><p><img src="20191123182101621.png" alt="img"></p><p>固态硬盘: 闪存颗粒 nand flash</p><p>上述只是粗略的描述，固态硬盘的内部结构比较复杂。感兴趣的可以寻找其他资料。</p><h3 id="固态VS机械"><a href="#固态VS机械" class="headerlink" title="固态VS机械"></a>固态VS机械</h3><div class="table-container"><table><thead><tr><th>指标</th><th>机械硬盘</th><th>固态硬盘</th></tr></thead><tbody><tr><td>性价比</td><td>容量大价格低</td><td>容量小价格高</td></tr><tr><td>稳定性</td><td>抗击打能力弱</td><td>抗击打能力高</td></tr><tr><td>速度</td><td>读写速度稍慢</td><td><strong>读写速度很快</strong></td></tr><tr><td>数据安全</td><td>数据恢复易</td><td>数据恢复难</td></tr><tr><td>寿命</td><td>无限</td><td>1-2w次</td></tr></tbody></table></div><h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p>​    我们都知道现在的互联网时代，尤其对于一家互联网公司而言，数据就是核心，数据存储在磁盘上，如果磁盘坏掉了 那公司不是要瘫痪掉吗。所以RAID技术就是来解决数据安全的。如果一块磁盘坏掉，我们是不是有其他方案能替换掉这块磁盘来作一个兜底。RAID相当于是一个节点上的磁盘的保障方案。同理，如果一个节点坏掉呢？那么就要使用其他节点 也就是分布式了。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>磁盘冗余阵列 RAID 物理服务器的硬盘,通过raid管理,才能使用。</li><li>常见的raid级别: raid 0 , raid 1 , raid 5,raid 10</li></ul><div class="table-container"><table><thead><tr><th></th><th>至少几块硬盘</th><th>容量</th><th>冗余</th><th>性能</th></tr></thead><tbody><tr><td>raid 0 (条 带)</td><td>1</td><td>所有硬盘容量总和.</td><td>最低,没有冗余.</td><td>最快的.</td></tr><tr><td>raid 1 (镜 像)</td><td>2块硬盘(制作的时候,1次只能给2块硬 盘做raid1)</td><td>一半.</td><td>冗余100%</td><td>写入性能较慢,读取类似于单 块硬盘.</td></tr><tr><td>raid 5</td><td>至少3块硬盘</td><td>损失n-1 (n硬盘总 数,n&gt;=3)</td><td>损坏1块.</td><td>读取性能还可以,写入较慢.</td></tr><tr><td>raid 10</td><td>至少需要4块硬盘</td><td>减半</td><td>损坏一半,但是不能在1 个组里.</td><td>读写性能强悍</td></tr></tbody></table></div><p>我们来看几张图，更容易理解 ：</p><p><img src="1.jpg" alt="img" style="zoom:50%;" /></p><p><img src="2.jpg" alt="img" style="zoom:50%;" /></p><p><img src="3.jpg" alt="img"></p><p><img src="4.jpg" alt="img"></p><h3 id="RAID与LVM"><a href="#RAID与LVM" class="headerlink" title="RAID与LVM"></a>RAID与LVM</h3><p>​    RAID相当于在物理层面，将多块磁盘进行组合给上层使用。而LVM 逻辑卷 是在软件层面也就是 逻辑上的 去进行多个磁盘块的整合 以达到屏蔽效果，它的好处是 可以支持动态扩容磁盘。缺点就是 使用起来会慢。由关LVM的细节，此处就不多介绍了，以后会详细介绍。</p><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><h3 id="磁盘分区概述"><a href="#磁盘分区概述" class="headerlink" title="磁盘分区概述"></a>磁盘分区概述</h3><ul><li>磁盘的第1个扇区: 0磁头(盘面)0磁道1扇区 1个扇区 512字节 <ul><li>MBR 磁盘的引导程序(主引导记录) : 引导系统启动. </li><li>分区表:存放分区开始结束信息</li></ul></li></ul><p><img src="5.jpg" alt="image-20221214155901109" style="zoom:50%;" /></p><h3 id="主分区-扩展分区-逻辑分区·"><a href="#主分区-扩展分区-逻辑分区·" class="headerlink" title="主分区,扩展分区,逻辑分区·"></a>主分区,扩展分区,逻辑分区·</h3><ul><li>主分区: 最多有4个,每个占用16字节分区表空间 </li><li><p>扩展分区:主要用来解决主分区最多4个. 主分区无法直接存放数据与使用. 如果要使用需要在扩展分区中创建逻辑分区. 扩展分区在一个磁盘中只有1个.</p></li><li><p>逻辑分区:需要先创建扩展分区. 使用逻辑分区存放数据.</p></li></ul><p><img src="image-20221214160133501.png" alt="image-20221214160133501"></p><h3 id="分区命名规则"><a href="#分区命名规则" class="headerlink" title="分区命名规则"></a>分区命名规则</h3><p> 磁盘名字:/dev/sda(第一块磁盘不做分区) 、/dev/sda1、/dev/sda2 </p><ul><li><p>第1块硬盘 /dev/sda </p></li><li><p>第2块硬盘 /dev/sdb</p></li></ul><p>分区命名规则:</p><ul><li>主分区或扩展分区 1-4  /dev/sda1-4</li><li>逻辑分区从5开始 /dev/sda5</li></ul><p>例子:</p><ul><li>第3块sata硬盘的第1个主分区 /dev/sdc1 </li><li>第4块sas硬盘的第2个逻辑分区 /dev/sdd6</li></ul><h3 id="MBR-vs-GPT"><a href="#MBR-vs-GPT" class="headerlink" title="MBR vs GPT"></a>MBR vs GPT</h3><p>MBR与GPT可以理解分两种磁盘分区的标准GPT可以解决MBR的问题。</p><ul><li>MBR主引导记录,磁盘分区格式 。磁盘大小不能大于2tb,如果大于2tb则无法使用.</li><li>GPT分区表格式,解决问题. 解决系统支持大硬盘的问题。主分区随便用,不用区分主分区,扩展分区逻辑分区.</li></ul><div class="table-container"><table><thead><tr><th>MBR VS GPT</th><th>支持的主分区数量</th><th>支持的硬盘大小</th><th>磁盘分区命令</th></tr></thead><tbody><tr><td>MBR</td><td>支持的主分区+扩展分区 最多 4个</td><td>小于2tb硬盘</td><td>fdsik 只支持mbr</td></tr><tr><td>GPT</td><td>可以理解无限</td><td>可以各种容量的磁盘</td><td>parted/gdisk 支持 gpt和mbr</td></tr></tbody></table></div><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>格式化的目的就是创建一个文件系统，分区之后必须要格式化才能使用。</p><div class="table-container"><table><thead><tr><th>系统类型</th><th>文件系统</th></tr></thead><tbody><tr><td>Linux</td><td>ext3(centOS5)、ext4 (C6 ) 、xfs(C7),btrfs</td></tr><tr><td>Windows</td><td>fat32, ntfs</td></tr></tbody></table></div><p>格式化常用的命令就是mkfs。 日后我们会在实战中详细的进行 的演示。</p><h2 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h2><p>Swap 是在 内存不足的时候临时充当内存 </p><p><img src="image-20221214162643361.png" alt="image-20221214162643361"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>我们这次只是对磁盘体系进行一个概要的梳理，命令的使用是细节，更重要的是让知识成体系</p><p><img src="6.jpg" alt="image-20221214163042509"></p></li><li><p>简单来讲，对于一块磁盘使用，只需要三步走</p><ol><li>分区 :fdisk/parted/gdisk,</li><li>格式化 :mkfs.xfs</li><li>挂载 ：  临时挂载:mount/umount 永久挂载： /etc/rc.local /etc/fstab</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sed、awk的混合使用</title>
      <link href="/2022/12/14/sed%E3%80%81awk%E7%9A%84%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/12/14/sed%E3%80%81awk%E7%9A%84%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux中的正则表达式</title>
      <link href="/2022/12/14/Linux%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/12/14/Linux%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux的特殊符号总结</title>
      <link href="/2022/12/14/Linux%E7%9A%84%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E6%80%BB%E7%BB%93/"/>
      <url>/2022/12/14/Linux%E7%9A%84%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>linux系统中充满着各种各式的符号，尤其是在书写shell脚本时候，更是明显，今天索性把所有常见的符号进行总结，方便记忆。</p><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><div class="table-container"><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>反引号:`` 或 $()</td><td>优先执行,先执行里面的命令. 一般创建/打包的时候给文件名加上个日期.</td></tr><tr><td>单引号: ‘’</td><td>所见即所得,单引号里面的内容会原封不动的输出.</td></tr><tr><td>双引号: “”</td><td>与单引号类似,但是对引号的里面特殊符号会进行解析(运行)</td></tr><tr><td>不加引号:</td><td>与双引号类似,同时支持{}.</td></tr></tbody></table></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">case01:单引号,所见及所得</span></span><br><span class="line">[root@linx01 ~]# echo 'root $UID `whoami` &#123;1..5&#125;'</span><br><span class="line">root $UID `whoami` &#123;1..5&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">case02:双引号 ，会进行解析</span></span><br><span class="line">[root@linx01 ~]# echo "root $UID `whoami` &#123;1..5&#125;"</span><br><span class="line">root 0 root &#123;1..5&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">case03:反引号 运行指令的</span></span><br><span class="line">[root@linx01 ~]# echo "root $UID whoami &#123;1..5&#125;"</span><br><span class="line">root 0 whoami &#123;1..5&#125;</span><br></pre></td></tr></table></figure><h2 id="重定向符号"><a href="#重定向符号" class="headerlink" title="重定向符号"></a>重定向符号</h2><div class="table-container"><table><thead><tr><th>重定向符号</th><th>含义</th></tr></thead><tbody><tr><td>&gt;或 1&gt;</td><td>标准输出重定向,先清空文件内容,然后写入.</td></tr><tr><td>&gt;&gt;或 1&gt;&gt;</td><td>标准输出追加重定向, 把内容追加到文件末尾.</td></tr><tr><td>2&gt;</td><td>标准错误输出重定向, 先清空文件,然后写入错误信息到文件.</td></tr><tr><td>2&gt;&gt;</td><td>标准错误追加输出重定向, ,把错误信息追加到文件末尾.</td></tr><tr><td>&gt; test.log 2&gt;&amp;1</td><td>把标准错误输出与标准输出合并,然后重定向到test.log中.</td></tr><tr><td>&gt;&gt; test.log 2&gt;&amp;1</td><td>追加到test.log中.</td></tr><tr><td>&amp;&gt;test.txt</td><td>正确输出和错误输出重定向到test.txt中</td></tr><tr><td><strong>&amp;&gt;&gt;test.txt</strong></td><td>正确输出和错误输出 追加到test.txt中</td></tr><tr><td>&lt;或0&lt;</td><td>标准输入重定向</td></tr><tr><td>&lt;&lt;或0&lt;&lt;</td><td>标准输入追加重定向</td></tr></tbody></table></div><p>补充：0,1,2都是文件打开的描述符 每个程序都自带这3个打开描述符号。</p><p>以上都比较简单，就不给事例了。</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><div class="table-container"><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>匹配任意0个或多个字符 字符串</td></tr><tr><td>?</td><td><strong>匹配任意1个字符，有且只有一个字符  </strong> 千万不要和正则混了</td></tr><tr><td>{}</td><td>生成序列</td></tr><tr><td>?</td><td>任意一个字符</td></tr><tr><td>[]</td><td>其中一个即可</td></tr><tr><td><sup><a href="#fn_" id="reffn_"></a></sup></td><td>排除其中的</td></tr><tr><td>\</td><td></td><td>管道符号</td></tr><tr><td>～</td><td>用户的家目录，超级用户为 /root， 普通用户为 /用户名</td></tr><tr><td>-</td><td>代表上一次（相对于当前路径） 用户所在的路径</td></tr><tr><td>.</td><td>代表当前目录(正则中的任意字符)</td></tr><tr><td>..</td><td>代表上一级目录</td></tr></tbody></table></div><p>我们对其中一些字符进行演示</p><h3 id="、"><a href="#、" class="headerlink" title="{}、*"></a>{}、*</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> * 匹配所有文件</span></span><br><span class="line">[root@linx01 dev]# rm -rf *    </span><br><span class="line"><span class="meta">#</span><span class="bash"> &#123;&#125; 生成序列</span></span><br><span class="line">[root@linx01 dev]# touch test&#123;1..10&#125;</span><br><span class="line">[root@linx01 dev]# ls</span><br><span class="line">test1  test10  test2  test3  test4  test5  test6  test7  test8  test9</span><br><span class="line"><span class="meta">#</span><span class="bash"> 利用*匹配特定的文件</span></span><br><span class="line">[root@linx01 dev]# ls test1*</span><br><span class="line">test1  test10</span><br></pre></td></tr></table></figure><h3 id="、-1"><a href="#、-1" class="headerlink" title="[]、"></a>[]、<sup><a href="#fn_" id="reffn_"></a></sup></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">利用 &#123;&#125;生成文件</span></span><br><span class="line">[root@linx01 dev]# touch &#123;a..z&#125;.sh</span><br><span class="line">[root@linx01 dev]# ls</span><br><span class="line">a.sh  c.sh  e.sh  g.sh  i.sh  k.sh  m.sh  o.sh  q.sh  s.sh  u.sh  w.sh  y.sh</span><br><span class="line">b.sh  d.sh  f.sh  h.sh  j.sh  l.sh  n.sh  p.sh  r.sh  t.sh  v.sh  x.sh  z.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">利用[] 匹配开头是a-c其中，以sh结尾的文件</span></span><br><span class="line">[root@linx01 dev]# ls [a-c].sh</span><br><span class="line">a.sh  b.sh  c.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">利用[^] 匹配开头不是a-c其中并且以sh结尾的文件</span></span><br><span class="line">[root@linx01 dev]# ls [^a-y].sh</span><br><span class="line">z.sh</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title="-"></a>-</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# pwd</span><br><span class="line">/opt/dev</span><br><span class="line">[root@linx01 dev]# cd /etc/sysconfig/network-scripts/</span><br><span class="line">[root@linx01 network-scripts]# pwd</span><br><span class="line">/etc/sysconfig/network-scripts</span><br><span class="line"><span class="meta">#</span><span class="bash"> 利用- 跳回上次所在路径</span></span><br><span class="line">[root@linx01 network-scripts]# cd -</span><br><span class="line">/opt/dev</span><br><span class="line">[root@linx01 dev]# pwd</span><br><span class="line">/opt/dev</span><br></pre></td></tr></table></figure><h3 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h3><p>查找 /etc 目录下包含 hosts 字符串的所有文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# find /etc/ -type f -name "*host.*"</span><br><span class="line">/etc/host.conf</span><br></pre></td></tr></table></figure><p>查找 /etc 目录下的所有文件，规则是文件名的第一个字符为任意字符，第二个字符为o、p、q中的任意一个字符，第三个字符不能在a到r之间，结尾是ts。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# find /etc/ -type f -name "?[opq][^a-r]ts"</span><br><span class="line">/etc/hosts</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的12位权限体系</title>
      <link href="/2022/12/13/Linux%E7%9A%8412%E4%BD%8D%E6%9D%83%E9%99%90%E4%BD%93%E7%B3%BB/"/>
      <url>/2022/12/13/Linux%E7%9A%8412%E4%BD%8D%E6%9D%83%E9%99%90%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    LINUX权限管理也是linux系统管理中很重要的一部分，通过权限管理最终保障系统网站的安全。接下来我们系统的总结一下linux权限相关的知识点，以及遇到权限问题的排查思路，可以应对工作中常见的权限问题。</p><h2 id="LINUX基础权限"><a href="#LINUX基础权限" class="headerlink" title="LINUX基础权限"></a>LINUX基础权限</h2><h3 id="rwx权限与用户"><a href="#rwx权限与用户" class="headerlink" title="rwx权限与用户"></a>rwx权限与用户</h3><div class="table-container"><table><thead><tr><th>权限的字符</th><th>含义与说明</th></tr></thead><tbody><tr><td>r</td><td>read 读,是否可以读取内容</td></tr><tr><td>w</td><td>write 写, 是否可以修改内容</td></tr><tr><td>x</td><td>executable执行, 是否可以执行内容? 一般执行命令,脚本(shell脚本).</td></tr><tr><td>-</td><td>没有权限</td></tr></tbody></table></div><p><img src="image-20221213185155306.png" alt="image-20221213185155306"></p><p>从左到右依次是:所有者权限、用户权限、其他人权限、所有者、用户组</p><h3 id="Linux的默认权限"><a href="#Linux的默认权限" class="headerlink" title="Linux的默认权限"></a>Linux的默认权限</h3><ul><li><p>创建文件,文件权限是644 </p></li><li><p>创建目录,目录权限是755 </p></li></ul><p>这个是由umask 反掩码(控制Liunx系统默认的权限) 决定的.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 ~]# umask</span><br><span class="line">0022</span><br></pre></td></tr></table></figure><p>文件的默认权限则是 666-umask ,结果若为奇数还需要加一.</p><p>目录的默认权限则是777-umask。</p><p>Eg:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">文件的默认权限 </span></span><br><span class="line">666</span><br><span class="line">- 022</span><br><span class="line">---</span><br><span class="line">644</span><br><span class="line"><span class="meta">#</span><span class="bash">文件的默认权限 </span></span><br><span class="line">  666</span><br><span class="line">- 032</span><br><span class="line">  ---</span><br><span class="line">  634 </span><br><span class="line">+ 1</span><br><span class="line">  ---</span><br><span class="line">  644</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">目录的默认权限 </span></span><br><span class="line"> 777</span><br><span class="line">-032</span><br><span class="line"> ---</span><br><span class="line"> 745</span><br></pre></td></tr></table></figure><p>上述了解即可,一般情况不需要改动。</p><p>此外 在/etc/bashrc 中，可以得到这样一段shell</p><p><img src="image-20221213213919204.png" alt="image-20221213213919204"></p><p>可以得出 root用户的umask 是 022 其他用的umask 002。当然umask可以直接用命令修改的，但通常也用不到。</p><h3 id="设置权限常用的命令"><a href="#设置权限常用的命令" class="headerlink" title="设置权限常用的命令"></a>设置权限常用的命令</h3><div class="table-container"><table><thead><tr><th>chown:修改所有者</th><th></th></tr></thead><tbody><tr><td>基本用法 chown 用户.用户组 文件/目录</td><td></td></tr><tr><td>-R</td><td>递归修改所有者.</td></tr></tbody></table></div><p>用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">chown 用户 文件/目录 </span><br><span class="line">chown 用户.用户组 文件/目录</span><br><span class="line"><span class="meta">#</span><span class="bash">修改文件</span></span><br><span class="line">[root@linx01 dev]# ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r-- 1 root root 0 12月 13 08:53 data</span><br><span class="line">[root@linx01 dev]# chown test.test data</span><br><span class="line">[root@linx01 dev]# ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r-- 1 test test 0 12月 13 08:53 data</span><br><span class="line"><span class="meta">#</span><span class="bash">修改目录</span></span><br><span class="line">[root@linx01 dev]# ll -d /root/dev</span><br><span class="line">drwxr-xr-x 2 root root 18 12月 13 08:53 /root/dev</span><br><span class="line">[root@linx01 dev]# chown test.test /root/dev</span><br><span class="line"><span class="meta">#</span><span class="bash">递归修改</span></span><br><span class="line">[root@linx01 dev]# chown test.test -R /root/dev</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>chmod</th><th></th><th></th></tr></thead><tbody><tr><td>chmod 权限 文件/目录</td><td></td><td></td></tr><tr><td>-R</td><td>递归修改权限</td></tr></tbody></table></div><ul><li>通过数字修改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# touch b</span><br><span class="line">[root@linx01 dev]# chmod 777 b</span><br><span class="line">[root@linx01 dev]# ll</span><br><span class="line">总用量 0</span><br><span class="line">-rwxrwxrwx 1 root root 0 12月 13 09:00 b</span><br></pre></td></tr></table></figure><ul><li>通过字符修改</li></ul><p>​    chmod命令  ugo  +/- r/w/x 文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r-- 1 root root 0 12月 13 09:02 a</span><br><span class="line">[root@linx01 dev]# chmod g+w a</span><br><span class="line">[root@linx01 dev]# ll</span><br><span class="line">-rw-rw-r-- 1 root root 0 12月 13 09:02 a</span><br></pre></td></tr></table></figure><h2 id="文件及目录权限"><a href="#文件及目录权限" class="headerlink" title="文件及目录权限"></a>文件及目录权限</h2><h3 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h3><div class="table-container"><table><thead><tr><th>文件的rwx</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>读,是否能查看文件内容(显示与查看)</td></tr><tr><td>w</td><td>写,是否能修改文件内容</td></tr><tr><td>x</td><td>执行, 是否能执行这个文件(命令,脚本)</td></tr></tbody></table></div><p>:warning:对普通用户而言,执行文件只有x权限，没有r权限依然不能执行，见下方验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# touch t.sh</span><br><span class="line">[root@linx01 dev]# chown test.test t.sh</span><br><span class="line">[root@linx01 dev]# ll</span><br><span class="line">总用量 0</span><br><span class="line">---xr--r-- 1 test test 0 12月 13 09:13 t.sh</span><br><span class="line">[root@linx01 dev]# su - test</span><br><span class="line">上一次登录：二 12月 13 09:11:10 EST 2022pts/1 上</span><br><span class="line">[test@linx01 ~]$ cd /opt/dev</span><br><span class="line">[test@linx01 dev]$ sh t.sh</span><br><span class="line">sh: t.sh: Permission denied</span><br></pre></td></tr></table></figure><h3 id="目录的权限"><a href="#目录的权限" class="headerlink" title="目录的权限"></a>目录的权限</h3><p>:star2:生产中是不会用root用户的，使用普通用户的时候经常遇到Permission Denied 问题，熟悉目录的权限是熟练解决Permission Denied 问题的基础。</p><div class="table-container"><table><thead><tr><th>目录rwx</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>查看,查看目录内容.(站在门口看看屋里的内容)</td></tr><tr><td>w</td><td>修改,在目录中创建,删除,重命名文件的权限.</td></tr><tr><td>x</td><td>是否可以进入目录权限.</td></tr></tbody></table></div><ul><li>目录的r权限只能查看内部的文件名字。不能查看详细信息，需要配合x权限1</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@linx01 dev]# ll -d /opt/dev</span><br><span class="line">drwxr-xr-x 2 root root 18 12月 13 09:13 /opt/dev</span><br><span class="line">[root@linx01 dev]# chmod u=r /opt/dev</span><br><span class="line">[root@linx01 dev]# chown test.test /opt/dev</span><br><span class="line">[test@linx01 opt]$ ll /opt</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x   4 root root 162 Dec  8 07:33 apps</span><br><span class="line">dr--r-xr-x   2 test test  18 Dec 13 09:13 dev</span><br><span class="line">[test@linx01 opt]$ ll  /opt/dev</span><br><span class="line">ls: cannot access /opt/dev/t.sh: Permission denied</span><br><span class="line">total 0</span><br><span class="line">-????????? ? ? ? ?            ? t.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">增加x权限</span></span><br><span class="line">[root@linx01 dev]# chmod u+x /opt/dev</span><br><span class="line">[test@linx01 opt]$ ll  /opt/dev</span><br><span class="line">total 0</span><br><span class="line">---xr--r-- 1 test test 0 Dec 13 09:13 t.sh</span><br></pre></td></tr></table></figure><ul><li><p>目录只有w权限无法操作，需要x配合</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[test@linx01 opt]$ ll -d /opt/dev</span><br><span class="line">d-w-r-xr-x 2 test test 18 Dec 13 09:13 /opt/dev</span><br><span class="line">[test@linx01 opt]$ touch /opt/dev/t</span><br><span class="line">touch: cannot touch ‘/opt/dev/t’: Permission denied</span><br></pre></td></tr></table></figure></li></ul><p>:star2:删除文件或目录要对文件或目录所在目录拥有w(rwx)权限.</p><h2 id="权限问题总结-star2"><a href="#权限问题总结-star2" class="headerlink" title="权限问题总结:star2:"></a>权限问题总结:star2:</h2><h3 id="操作与权限"><a href="#操作与权限" class="headerlink" title="操作与权限"></a>操作与权限</h3><div class="table-container"><table><thead><tr><th></th><th>文件rwx</th><th>目录rwx含义</th></tr></thead><tbody><tr><td>r</td><td>是否可以查看内容</td><td>查看,查看目录内容.(站在门口看看屋里的内容),需要x权限配合.</td></tr><tr><td>w</td><td>是否可以修改文件内容(需要r)</td><td>修改,在目录中创建,删除,重命名文件的权限.需要x配合,(工作一般要rx配合)</td></tr><tr><td>x</td><td>是否可以执行文件(需要r)</td><td>是否可以进入目录权限. 能否查看或修改目录中文件属性信息.</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>日常操作</th><th>需要的权限</th></tr></thead><tbody><tr><td>查看文件的内容</td><td>文件要有r权限.</td></tr><tr><td>编辑或修改文件内容</td><td>文件要有rw权限.</td></tr><tr><td>执行脚本/命令</td><td>文件需要有rx权限.</td></tr><tr><td>查看目录内容</td><td>目录要有rx权限</td></tr><tr><td>创建文件,删除文件</td><td>文件所在目录要有rwx权限</td></tr><tr><td>重命名</td><td>文件所在目录要有rwx权限</td></tr></tbody></table></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">缺少查看权限</span></span><br><span class="line">[test@linx01 dev]$ ll /root</span><br><span class="line">ls: cannot open directory /root: Permission denied</span><br><span class="line">[test@linx01 dev]$ ll -d /root</span><br><span class="line">dr-xr-x---. 8 root root 4096 Dec 13 08:52 /root</span><br><span class="line"><span class="meta">#</span><span class="bash">缺少写权限</span></span><br><span class="line">[test@linx01 dev]$ echo 1 &gt; /etc/passwd</span><br><span class="line">-bash: /etc/passwd: Permission denied</span><br><span class="line">[test@linx01 dev]$ ll /etc/passwd</span><br><span class="line">-rw-r--r-- 1 root root 2174 Dec 13 04:10 /etc/passwd</span><br></pre></td></tr></table></figure><h2 id="三个特殊权限位"><a href="#三个特殊权限位" class="headerlink" title="三个特殊权限位"></a>三个特殊权限位</h2><p>除了能直接看到的9位权限外，其实还有3位 ，分别是:suid,sgid,sticky</p><h3 id="uid"><a href="#uid" class="headerlink" title="uid"></a>uid</h3><p>​    uid ( setuid) 位通过S字符标识，存在于基本权限的用户权限位的×权限对应的位<br>置，如果用户权限位对应的x权限位上有x权限，则 suid 就用小写的s标识，suid 的<br>对应的数字权限为4，完整权限用八进制数 4000 表示。</p><p>​     suid 的作用就是让普通用户可以在执行某个设置了 suid 位的命令或程序时，拥<br>有和 root 管理员一样的身份和权限（默认)。</p><p>可以看一下passwd命令。这样普通用户就可以利用passwd命令来修改自己的密码</p><p><img src="image-20221213225638896.png" alt="image-20221213225638896"></p><h3 id="suid"><a href="#suid" class="headerlink" title="suid"></a>suid</h3><p>​    suid 的作用就是让普通用户可以在执行某个设置了 suid 位的命令或程序时，拥<br>有和 root 管理员一样的身份和权限（默认)。<br>对于二进制命令或者程序来说，sgid 的功能和 suid 基本相同，唯一的区别是 suid<br>是获得命令所属用户的身份和权限，而 sgid 是获得命令的所属用户组的身份和权限</p><h3 id="sbit"><a href="#sbit" class="headerlink" title="sbit"></a>sbit</h3><p>粘贴位的用途一般是把一个文件夹的权限都打开，然后来共享文件，像/tmp 目录一样。虽然方便，但是带来了一定的安全險患，生产环境应禁止设置粘滞位权限。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次我们总结了Linux权限相关的点。对于3个特殊权限 并没有过多的介绍，因为目前生产中也用的极少极少，通常解决问题的方法有很多种，这种不常用的不了解也罢，而像目录权限，文件权限这种基础的知识更应该掌握熟练。</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux用户管理</title>
      <link href="/2022/12/13/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>/2022/12/13/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    用户管理体系是linux系统中一样很重要的内容，不同的用户分配不同等级的权限可以保障系统的安全，问题发生以后也方便追溯问题的原因。接下来总结一下与用户管理相关的一些比较重要的内容。</p><h2 id="用户分类"><a href="#用户分类" class="headerlink" title="用户分类"></a>用户分类</h2><div class="table-container"><table><thead><tr><th>用户分类</th><th style="text-align:center">含义</th><th>uid</th></tr></thead><tbody><tr><td>root用户</td><td style="text-align:center">最高权限用户。</td><td>0</td></tr><tr><td>虚拟用户（傀儡用 户）</td><td style="text-align:center">这种用户存在是用于让一些服务正常运行。一些服务运行需要指定 的用户。</td><td>uid是1-999 （非唯一判断标准）</td></tr><tr><td>普通用户</td><td style="text-align:center">只对自己家目录拥有权限的用户。</td><td>1000开始 （CentOS 7. 8. ) C5 c6 (从500开始）</td></tr></tbody></table></div><h3 id="补充：最小化原则"><a href="#补充：最小化原则" class="headerlink" title="补充：最小化原则"></a>补充：最小化原则</h3><p> Linux中，像文件、进程 天生就要有主人，一定要有归属的用户，文件要有属主，进程要有启动用户，目的就是为了安全，不要让别人看一些不该看的东西，也不要让一些进程做你不应该做的。</p><ol><li>安装软件最小化</li><li>登录安全最小化（普通用户）</li><li>进程启动权限最小化。</li><li>权限最小化</li></ol><p>​    linux中使用命令的时候应该时刻想到最小化原则,比如一个进程需要启动，那么就只给这个用户启动这个进程的权限就好，不要扩大权限。再比如使用find命令 查找文件继而进行删除的时候，find查找的范围要尽可能的精确多使用参数来控制比如文件类型、修改时间、文件大小等等，避免误删这也是最小化原则。</p><h2 id="用户相关的配置文件"><a href="#用户相关的配置文件" class="headerlink" title="用户相关的配置文件"></a>用户相关的配置文件</h2><h3 id="直接相关文件"><a href="#直接相关文件" class="headerlink" title="直接相关文件"></a>直接相关文件</h3><div class="table-container"><table><thead><tr><th>文件名</th><th>含义</th></tr></thead><tbody><tr><td>/etc/passwd</td><td>用户主配置文件，用户的各种属性（UID,GID,家目录，登录SHELL）</td></tr><tr><td>/etc/shadow</td><td>用户密码文件，存放密码及密码的属性（失效时间，修改密码时间等）。</td></tr><tr><td>/etc/group</td><td>组文件，存放用户组及属性。</td></tr><tr><td>/etc/gshadow</td><td>用户组的密码文件（废弃）</td></tr></tbody></table></div><h3 id="创建用户相关的文件"><a href="#创建用户相关的文件" class="headerlink" title="创建用户相关的文件"></a>创建用户相关的文件</h3><div class="table-container"><table><thead><tr><th>文件名</th><th>含义</th></tr></thead><tbody><tr><td>/etc/default/useradd</td><td>创建用户命令useradd的配置文件</td></tr><tr><td>/etc/skel</td><td>创建用户环境变量原始文件存放地。</td></tr><tr><td>/etc/login.defs</td><td>创建用户系统配置对应文件。</td></tr></tbody></table></div><h3 id="环境变量丢失问题"><a href="#环境变量丢失问题" class="headerlink" title="环境变量丢失问题"></a>环境变量丢失问题</h3><p>对于创建用户的三个文件，我们来看一个常见的问题来深入理解一下。</p><p>问题: 使用test用户登录到Linux系统后，发现提示符为如下所示异常情况，    请问如何恢复到正常的Linux命令行提示符情况？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-bash-4.1$ </span><br><span class="line">-bash-4.1$</span><br></pre></td></tr></table></figure><p>解答:</p><p>我们来复现一下 </p><p><img src="image-20221213170640466.png" alt="image-20221213170640466"></p><p>我们看到一句重要的提示 “不再向其中复制任何文件”，可以看到家目录内也是空的。</p><p><img src="image-20221213171128265.png" alt="image-20221213171128265"></p><p>我们先来解决这个问题再来解释</p><p><img src="image-20221213171832654.png" alt="image-20221213171832654"></p><p>我们从/etc/skel/目录下 将bash的几个文件拷贝拷贝到家目录就好了，这几个文件是控制用户环境变量的，如果没有这几个文件 ，家目录是有问题的 就会出现-bash-4.2$的问题。那至于为什么要从/etc/skel中拷贝也是 linux事先在配置文件中规定好的,查看useradd文件</p><p><img src="image-20221213172329965.png" alt="image-20221213172329965"></p><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><p>这些命令都比较简单，就不再进行演示了，感兴趣的可以自己操作一下。</p><h2 id="增加用户"><a href="#增加用户" class="headerlink" title="增加用户"></a>增加用户</h2><div class="table-container"><table><thead><tr><th>useradd 选项</th><th>含义</th><th></th></tr></thead><tbody><tr><td>基本用法: useradd 用户名</td><td></td><td></td></tr><tr><td>-s</td><td>添加用户的时候指定用户的命令解释器，如果不指定默认是/bin/bash.</td><td></td></tr><tr><td>-M</td><td>添加的用户的时候不创建家目录。（一般与-sM搭配使用)</td><td></td></tr><tr><td>-u</td><td>添加用户的时候指定uid。</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>-g</td><td>主要组（原生组） 替换默认创建的组。</td><td></td></tr><tr><td>-G</td><td>附加组（额外组）添加用户的时候，让用户属于多个组</td></tr></tbody></table></div><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><div class="table-container"><table><thead><tr><th>userdel 删除用户 宣传</th><th></th></tr></thead><tbody><tr><td>-r</td><td>删除用户及用户相关数据（家目录，邮箱） 极其危险。</td></tr></tbody></table></div><p>⚠️工作中一般不会使用这种操作，最简单的做法就是在passwd文件中注释此用户即可。</p><h3 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h3><ul><li>usermod 修改已存在的用户的信息，useradd添加用户时候设置的信息，usermod都可以改。</li><li>uesrmod的选项与useradd 类似。</li></ul><h2 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h2><h4 id="查看用户基本信息"><a href="#查看用户基本信息" class="headerlink" title="查看用户基本信息"></a>查看用户基本信息</h4><ul><li>whoami 显示当前用户的名字。</li><li>id 查看当前或指定用户的信息（uid,gid,用户组信息）</li></ul><h4 id="查看用户登录情况"><a href="#查看用户登录情况" class="headerlink" title="查看用户登录情况"></a>查看用户登录情况</h4><ul><li>w </li><li>last 查看用户的登录情况。</li><li>lastlog 查看所有用户最近1次的登录情况。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hive中四种有效的SQL优化</title>
      <link href="/2022/10/09/hive-2022-10-09-hive%E4%B8%AD%E5%9B%9B%E7%A7%8D%E6%9C%89%E6%95%88%E7%9A%84SQL%E4%BC%98%E5%8C%96/"/>
      <url>/2022/10/09/hive-2022-10-09-hive%E4%B8%AD%E5%9B%9B%E7%A7%8D%E6%9C%89%E6%95%88%E7%9A%84SQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>首先虚拟一张表user，字段为：</p><p>（1）<strong>user_id</strong>（用户的id）；</p><p>（2）<strong>age</strong>（用户的年龄）；</p><p>（3）<strong>sex</strong>（用户的性别）；</p><p>（4）<strong>order_id</strong>（用户的订单编号，一个用户可能有多个订单编号）。</p><p>另设一张表，叫order，里面包含order_id, order_date两个字段。</p><h3 id="multi-table-insert优化union-all"><a href="#multi-table-insert优化union-all" class="headerlink" title="multi-table-insert优化union all"></a>multi-table-insert优化union all</h3><p><strong>原SQL</strong>（目标是往一个新表user_new里，插入最大值和最小值的数据）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> user_new</span><br><span class="line"><span class="keyword">select</span> sex, <span class="keyword">max</span>(age) <span class="keyword">as</span> stat, <span class="string">'max'</span> <span class="keyword">as</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> sex, <span class="keyword">min</span>(age) <span class="keyword">as</span> stat, <span class="string">'min'</span> <span class="keyword">as</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure><p><strong>优化SQL</strong>（完成相同的目标，使用multi-table-insert写法）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from user</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> user_new</span><br><span class="line"><span class="keyword">select</span> sex, <span class="keyword">max</span>(age) <span class="keyword">as</span> stat, <span class="string">'max'</span> <span class="keyword">as</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> user_new</span><br><span class="line"><span class="keyword">select</span> sex, <span class="keyword">min</span>(age) <span class="keyword">as</span> stat, <span class="string">'min'</span> <span class="keyword">as</span> <span class="keyword">class</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure><p>如果SQL是在MapReduce上运行的话，进行这种改写可以减少中间结果的产生，即降低了读写（I/O）资源的消耗，提升程序的效率和速度。具体原理是减少了MapReduce作业数量。</p><h3 id="使用grouping-sets替代union-all"><a href="#使用grouping-sets替代union-all" class="headerlink" title="使用grouping sets替代union all"></a>使用grouping sets替代union all</h3><p><strong>原SQL</strong>（目标是进行2个group by，但后一个的分组字段是前者的子集）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (</span><br><span class="line">  <span class="keyword">select</span> sex, age, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> user_num</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> sex, age</span><br><span class="line">  <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">  <span class="keyword">select</span> sex, <span class="literal">null</span> <span class="keyword">as</span> age, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> user_num</span><br><span class="line">  <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> sex) a;</span><br></pre></td></tr></table></figure><p><strong>优化SQL</strong>（完成相同的目标，使用grouping sets写法）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, age, <span class="keyword">count</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex, age</span><br><span class="line"><span class="keyword">grouping</span> <span class="keyword">sets</span>((sex),(sex,age));</span><br></pre></td></tr></table></figure><h3 id="使用子查询对count-distinct-可能造成的数据倾斜进行优化"><a href="#使用子查询对count-distinct-可能造成的数据倾斜进行优化" class="headerlink" title="使用子查询对count(distinct)可能造成的数据倾斜进行优化"></a><strong>使用子查询对count(distinct)可能造成的数据倾斜进行优化</strong></h3><p><strong>原SQL</strong>（统计每种性别有多少种不同年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="keyword">count</span>(<span class="keyword">distinct</span> age) <span class="keyword">as</span> age_num</span><br><span class="line"><span class="keyword">from</span> sex</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br></pre></td></tr></table></figure><p><strong>优化SQL</strong>（完成相同的目标，使用子查询避免数据出现倾斜而导致性能问题）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sex, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> age_num</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">  <span class="keyword">select</span> sex, age, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">as</span> <span class="keyword">num</span></span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> sex, age</span><br><span class="line">) a;</span><br></pre></td></tr></table></figure><h3 id="使用left-join替代not-in完成取A表中没有但B表中有的数据"><a href="#使用left-join替代not-in完成取A表中没有但B表中有的数据" class="headerlink" title="使用left join替代not in完成取A表中没有但B表中有的数据"></a>使用left join替代not in完成取A表中没有但B表中有的数据</h3><p><strong>原SQL</strong>（查找订单日期不在2020-10-23日的用户的user_id）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> order_id <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">  <span class="keyword">select</span> order_id <span class="keyword">from</span> <span class="keyword">order</span></span><br><span class="line">  <span class="keyword">where</span> order_date != <span class="string">'2020-10-23'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>优化SQL</strong>（完成相同的目标，用left join去实现，避免not in不走索引带来的问题）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.user_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span> a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line"><span class="keyword">order</span> b</span><br><span class="line"><span class="keyword">on</span> a.order_id = b.order_id <span class="keyword">and</span> b.order_date != <span class="string">'2020-10-23'</span></span><br><span class="line"><span class="keyword">where</span> b.user_id <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>checkpoint的生产配置</title>
      <link href="/2022/10/09/Flink-2022-10-09-checkpoint%E7%9A%84%E7%94%9F%E4%BA%A7%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/10/09/Flink-2022-10-09-checkpoint%E7%9A%84%E7%94%9F%E4%BA%A7%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Checkpoint相关配置"><a href="#Checkpoint相关配置" class="headerlink" title="Checkpoint相关配置"></a>Checkpoint相关配置</h2><div class="table-container"><table><thead><tr><th>配置项</th><th>含义</th></tr></thead><tbody><tr><td>state.backend</td><td>状态存储后端，可配置值有’jobmanager’, ‘filesystem’, ‘rocksdb’等，在checkpoint数据存储在hdfs上时，配置该值为filesystem</td></tr><tr><td>state.checkpoints.dir</td><td>checkpoints写出的目录位置，比如：hdfs://ns/flink/flink-checkpoints</td></tr><tr><td>state.savepoints.dir</td><td>savepoints写出的目录位置，比如：hdfs://ns/flink/flink-checkpoints，一般与上面的值配置一致</td></tr><tr><td>execution.checkpointing.mode</td><td>检查点模式，默认值EXACTLY_ONCE，可选项AT_LEAST_ONCE</td></tr><tr><td>execution.checkpointing.interval</td><td>checkpoint的时间间隔，单位毫秒，比如5000</td></tr><tr><td>state.checkpoints.num-retained</td><td>checkpoint保留的个数，默认值1，不过建议比如设置为3，防止想要恢复更久前的状态，或者最近的一个checkpoint被误删除等情况。</td></tr><tr><td>execution.checkpointing.externalized-checkpoint-retention</td><td>该配置项定义了在任务取消（cancel，注意不是job failed是主动的cancel）时如何清理外部化的检查点。一般我们会配置为RETAIN_ON_CANCELLATION，即cancel时保留检查点。而DELETE_ON_CANCELLATION则表示cancel任务时删除检查点，只有在任务失败时，才会被保留。</td></tr><tr><td><font color=red>execution.checkpointing.tolerable-failed-checkpoints</font></td><td>允许的连续checkpoint失败的次数，默认值是0，即只要出现checkpoint失败，作业就会失败，然后按照设置了的重启策略开始重启（setRestartStrategy），所以生产环境中一般设置2，即允许偶尔出现checkpoints失败的。</td></tr></tbody></table></div><p> <font color=red>execution.checkpointing.tolerable-failed-checkpoints</font> 需要特别注意，flink可能会因为某些原因被hang住，导致cp失败，如果不设置，容忍就是0，则会直接导致任务挂掉。严重可能导致任务连续失败。所以一定要根据任务重要程度设置一定的容忍度。</p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步IO</title>
      <link href="/2022/10/09/Flink-2022-10-09-%E5%BC%82%E6%AD%A5IO/"/>
      <url>/2022/10/09/Flink-2022-10-09-%E5%BC%82%E6%AD%A5IO/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常情况我们在进行维表关联时，是进行同步的查询，为了提高吞吐率，提高处理的数据量，可以利用异步的查询，但是有一个问题，异步访问的后的结果 如何反回到主流中？这就需要Flink给我们提供支持了。我们看一下官网的介绍。</p><p><img src="1.jpg" alt="image-20221009112349107"></p><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>引用官网的一段话:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">As illustrated in the section above, implementing proper asynchronous I/<span class="function">O to a <span class="title">database</span> <span class="params">(or key/value store)</span> <span class="keyword">requires</span> a client to that database that supports asynchronous requests. Many popular databases offer such a client.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">In the absence of such a client, one can <span class="keyword">try</span> and turn a synchronous client into a limited concurrent client by creating multiple clients and handling the synchronous calls with a thread pool. However, <span class="keyword">this</span> approach is usually less efficient than a proper asynchronous client.</span></span><br></pre></td></tr></table></figure><p>也就是说。其实Flink提供的只是如何让数据反回到主流。异步需要你自己实现。实现的方式有两种</p><ol><li>第一种比较简单，是指异步的客户端。也就说有些组建的客户端本身提供了异步查询的功能。那就省下了很多事情。</li><li>如果客户端没有异步功能，那就只能自己用多线程来实现，简单的方法就是用CompletableFuture异步编排这个类来实现异步功能。</li></ol><p>看一下 官网提供的demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncDatabaseRequest</span> <span class="keyword">extends</span> <span class="title">RichAsyncFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The database specific client that can issue concurrent requests with callbacks */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> DatabaseClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        client = <span class="keyword">new</span> DatabaseClient(host, post, credentials);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncInvoke</span><span class="params">(String key, <span class="keyword">final</span> ResultFuture&lt;Tuple2&lt;String, String&gt;&gt; resultFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// issue the asynchronous request, receive a future for result</span></span><br><span class="line">        <span class="keyword">final</span> Future&lt;String&gt; result = client.query(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set the callback to be executed once the request by the client is complete</span></span><br><span class="line">        <span class="comment">// the callback simply forwards the result to the result future</span></span><br><span class="line">        CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> result.get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                    <span class="comment">// Normally handled explicitly.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).thenAccept( (String dbResult) -&gt; &#123;</span><br><span class="line">            resultFuture.complete(Collections.singleton(<span class="keyword">new</span> Tuple2&lt;&gt;(key, dbResult)));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create the original stream</span></span><br><span class="line">DataStream&lt;String&gt; stream = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply the async I/O transformation</span></span><br><span class="line">DataStream&lt;Tuple2&lt;String, String&gt;&gt; resultStream =</span><br><span class="line">    AsyncDataStream.unorderedWait(stream, <span class="keyword">new</span> AsyncDatabaseRequest(), <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>Important note</strong>: The <code>ResultFuture</code> is completed with the first call of <code>ResultFuture.complete</code>. All subsequent <code>complete</code> calls will be ignored.</p><p>The following two parameters control the asynchronous operations:</p><ul><li><strong>Timeout</strong>: The timeout defines how long an asynchronous request may take before it is considered failed. This parameter guards against dead/failed requests.</li><li><strong>Capacity</strong>: This parameter defines how many asynchronous requests may be in progress at the same time. Even though the async I/O approach leads typically to much better throughput, the operator can still be the bottleneck in the streaming application. Limiting the number of concurrent requests ensures that the operator will not accumulate an ever-growing backlog of pending requests, but that it will trigger backpressure once the capacity is exhausted.</li></ul></blockquote><h2 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h2><p>​    当异步I/O请求超时时，默认情况下会抛出异常并重新启动作业。如果要处理超时，可以重写AsyncFunction#timeout。确保调用ResultFuture。complete() 或 ResultFuture.completeExceptionally（），以便向Flink指示此输入记录的处理已完成。如果不想在发生超时时发出任何记录，可以调用ResultFuture.complete（Collections.emptyList()）。</p><h2 id="返回顺序"><a href="#返回顺序" class="headerlink" title="返回顺序"></a>返回顺序</h2><p>​    AsyncFunction发出的并发请求通常以未定义的顺序完成，这取决于哪个请求先完成。为了控制结果记录的发出顺序，Flink提供了两种模式：</p><ul><li>Unordered：一旦异步请求完成，就会发出结果记录。流中记录的顺序在异步I/O操作符之后与之前不同。当使用处理时间作为基本时间特征时，此模式具有最低的延迟和最低的开销。对此模式使用AsyncDataStream.unorderedWait（…）。</li><li>Ordered：在这种情况下，将保留流顺序。结果记录的发出顺序与触发异步请求的顺序相同（操作员输入记录的顺序）。为了实现这一点，操作员缓冲一个结果记录，直到它前面的所有记录都被发出（或超时）。这通常会在检查点中引入一些额外的延迟和开销，因为与无序模式相比，记录或结果在检查点状态下维护的时间更长。对此模式使用AsyncDataStream.orderedWait（…）。</li></ul><p>简单来讲，就是保证发送到下游的数据是不是请求发起的顺序，如果是，那么需要额外维护这个顺序，增加一定的开销。</p><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><p>生成6条数据，从0开始递增的6个数字。模拟异步查询之后，加上时间戳输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncIODemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maxCount = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> taskNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> timeout = <span class="number">40000</span>;</span><br><span class="line"></span><br><span class="line">        DataStream&lt;Integer&gt; inputStream = env.addSource(<span class="keyword">new</span> SimpleSource(maxCount));</span><br><span class="line">        AsyncFunction&lt;Integer, String&gt; function = <span class="keyword">new</span> SampleAsyncFunction();</span><br><span class="line"></span><br><span class="line">        DataStream&lt;String&gt; result = AsyncDataStream.unorderedWait(</span><br><span class="line">                    inputStream,</span><br><span class="line">                    function,</span><br><span class="line">                    timeout,</span><br><span class="line">                    TimeUnit.MILLISECONDS,</span><br><span class="line">                    <span class="number">10</span>).setParallelism(taskNum);</span><br><span class="line"></span><br><span class="line">        result.map(<span class="keyword">new</span> MapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value + <span class="string">","</span> + System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).print();</span><br><span class="line"></span><br><span class="line">        env.execute(<span class="string">"Async IO Demo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSource</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SimpleSource</span><span class="params">(<span class="keyword">int</span> maxNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.counter = maxNum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Integer&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> ((start &lt; counter || counter == -<span class="number">1</span>) &amp;&amp; isRunning) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (ctx.getCheckpointLock()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"send data:"</span> + start);</span><br><span class="line">                    ctx.collect(start);</span><br><span class="line">                    ++start;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            isRunning = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步方法"><a href="#异步方法" class="headerlink" title="异步方法"></a>异步方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleAsyncFunction</span> <span class="keyword">extends</span> <span class="title">RichAsyncFunction</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] sleep = &#123;<span class="number">100L</span>, <span class="number">1000L</span>, <span class="number">5000L</span>, <span class="number">2000L</span>, <span class="number">6000L</span>, <span class="number">100L</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.open(parameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncInvoke</span><span class="params">(<span class="keyword">final</span> Integer input, <span class="keyword">final</span> ResultFuture&lt;String&gt; resultFuture)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">"-input:"</span> + input + <span class="string">" will sleep "</span> + sleep[input] + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        query(input, resultFuture);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">final</span> Integer input, <span class="keyword">final</span> ResultFuture&lt;String&gt; resultFuture)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(sleep[input]);</span><br><span class="line">            resultFuture.complete(Collections.singletonList(String.valueOf(input)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            resultFuture.complete(<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">asyncQuery</span><span class="params">(<span class="keyword">final</span> Integer input, <span class="keyword">final</span> ResultFuture&lt;String&gt; resultFuture)</span> </span>&#123;</span><br><span class="line">        CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(sleep[input]);</span><br><span class="line">                    <span class="keyword">return</span> input;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).thenAccept((Integer dbResult) -&gt; &#123;</span><br><span class="line">            resultFuture.complete(Collections.singleton(String.valueOf(dbResult)));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中有两个方法query()和asyncQuery()，其中Thread.sleep(sleep[input]);用来模拟查询需要等待的时间，每条数据等待的时间分别为100L, 1000L, 5000L, 2000L, 6000L, 100L毫秒。</p><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>运行query()的结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">send data:<span class="number">0</span></span><br><span class="line">send data:<span class="number">1</span></span><br><span class="line">send data:<span class="number">2</span></span><br><span class="line">send data:<span class="number">3</span></span><br><span class="line">send data:<span class="number">4</span></span><br><span class="line">send data:<span class="number">5</span></span><br><span class="line"><span class="number">1577801193230</span>-input:<span class="number">0</span> will sleep <span class="number">100</span> ms</span><br><span class="line"><span class="number">1577801193331</span>-input:<span class="number">1</span> will sleep <span class="number">1000</span> ms</span><br><span class="line"><span class="number">0</span>,<span class="number">1577801194336</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1577801194336</span></span><br><span class="line"><span class="number">1577801194336</span>-input:<span class="number">2</span> will sleep <span class="number">5000</span> ms</span><br><span class="line"><span class="number">1577801199339</span>-input:<span class="number">3</span> will sleep <span class="number">2000</span> ms</span><br><span class="line"><span class="number">2</span>,<span class="number">1577801201341</span></span><br><span class="line"><span class="number">1577801201342</span>-input:<span class="number">4</span> will sleep <span class="number">6000</span> ms</span><br><span class="line"><span class="number">3</span>,<span class="number">1577801207345</span></span><br><span class="line"><span class="number">4</span>,<span class="number">1577801207345</span></span><br><span class="line"><span class="number">1577801207346</span>-input:<span class="number">5</span> will sleep <span class="number">100</span> ms</span><br><span class="line"><span class="number">5</span>,<span class="number">1577801207451</span></span><br></pre></td></tr></table></figure><p>可以看到第一条数据进入到map算子的时间与最后一条相差了13115毫秒，执行的顺序与source中数据的顺序一致，并且是串行的。</p><p>运行asyncQuery()的结果为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">send data:<span class="number">0</span></span><br><span class="line">send data:<span class="number">1</span></span><br><span class="line">send data:<span class="number">2</span></span><br><span class="line">send data:<span class="number">3</span></span><br><span class="line"><span class="number">1577802161755</span>-input:<span class="number">0</span> will sleep <span class="number">100</span> ms</span><br><span class="line"><span class="number">1577802161756</span>-input:<span class="number">1</span> will sleep <span class="number">1000</span> ms</span><br><span class="line"><span class="number">1577802161757</span>-input:<span class="number">2</span> will sleep <span class="number">5000</span> ms</span><br><span class="line">send data:<span class="number">4</span></span><br><span class="line">send data:<span class="number">5</span></span><br><span class="line"><span class="number">1577802161783</span>-input:<span class="number">3</span> will sleep <span class="number">2000</span> ms</span><br><span class="line"><span class="number">1577802161784</span>-input:<span class="number">4</span> will sleep <span class="number">6000</span> ms</span><br><span class="line"><span class="number">1577802161785</span>-input:<span class="number">5</span> will sleep <span class="number">100</span> ms</span><br><span class="line"><span class="number">0</span>,<span class="number">1577802161859</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1577802162759</span></span><br><span class="line"><span class="number">3</span>,<span class="number">1577802163862</span></span><br><span class="line"><span class="number">5</span>,<span class="number">1577802163962</span></span><br><span class="line"><span class="number">2</span>,<span class="number">1577802166760</span></span><br><span class="line"><span class="number">4</span>,<span class="number">1577802168762</span></span><br></pre></td></tr></table></figure><p>同样第一条数据进入map算子的时间与最后一条仅相差了6903毫秒，而且输出结果的顺序并不是source中的顺序，而是按照查询时间递增的顺序输出，并且查询请求几乎是同一时间发出的。</p><p>通过上面的例子可以看出，flink所谓的异步IO，并不是只要实现了asyncInvoke方法就是异步了，这个方法并不是异步的，而是要依靠这个方法里面所写的查询是异步的才可以。否则像是上面query()方法那样，同样会阻塞查询相当于同步IO。在实现flink异步IO的时候一定要注意。官方文档也给出了相关的说明。</p><blockquote><p>For example, the following patterns result in a blocking asyncInvoke(…) functions and thus void the asynchronous behavior:Using a database client whose lookup/query method call blocks until the result has been received back.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    要注意Flink的异步IO，需要自己在算子中实现，具体的超时参数、有序无序的要求要根据场景来设置。</p><p>​    更详细的原理在flink官网推荐的博客中有比较详细的解释，喜欢研究的可以参考下。</p><blockquote><p>参考:<a href="https://cloud.tencent.com/developer/article/1780022" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1780022</a></p><p>​        <a href="https://nightlies.apache.org/flink/flink-docs-release-1.15/docs/dev/datastream/operators/asyncio/" target="_blank" rel="noopener">https://nightlies.apache.org/flink/flink-docs-release-1.15/docs/dev/datastream/operators/asyncio/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CompletableFuture详解</title>
      <link href="/2022/09/27/JUC-2022-09-27-CompletableFuture%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/09/27/JUC-2022-09-27-CompletableFuture%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="CompletableFuture介绍"><a href="#CompletableFuture介绍" class="headerlink" title="CompletableFuture介绍"></a>CompletableFuture介绍</h2><p>Future 是 Java 5 添加的类，用来描述一个异步计算的结果。你可以使用<code>isDone</code>方法检查计算是否完成，或者使用<code>get</code>阻塞住调用线程，直到计算完成返回结果，你也可以使用<code>cancel</code> 方法停止任务的执行。</p><p>虽然<code>Future</code>以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不 方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的 初衷相违背，轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果，为 什么不能用观察者设计模式当计算结果完成及时通知监听者呢？</p><p>很多语言，比如 Node.js，采用回调的方式实现异步编程。Java 的一些框架，比如 Netty，自 己扩展了 Java 的 <code>Future</code>接口，提供了<code>addListener</code>等多个扩展方法；Google guava 也提供了 通用的扩展 Future；Scala 也提供了简单易用且功能强大的 Future/Promise 异步编程模式。</p><p>作为正统的 Java 类库，是不是应该做点什么，加强一下自身库的功能呢？</p><p>在 Java 8 中, 新增加了一个包含 50 个方法左右的类: CompletableFuture，提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以 通过回调的方式处理计算结果，并且提供了转换和组合 CompletableFuture 的方法。 CompletableFuture 类实现了 Future 接口，所以你还是可以像以前一样通过<code>get</code>方法阻塞或 者轮询的方式获得结果，但是这种方式不推荐使用。</p><p>CompletableFuture 和 FutureTask 同属于 Future 接口的实现类，都可以获取线程的执行结果。</p><p><img src="1.jpg" alt="WeChat855e5fbbf1876597d4e703b4d87f8caf"></p><h2 id="CompletableFuture-详解"><a href="#CompletableFuture-详解" class="headerlink" title="CompletableFuture 详解"></a>CompletableFuture 详解</h2><h3 id="创建异步对象"><a href="#创建异步对象" class="headerlink" title="创建异步对象"></a>创建异步对象</h3><p>CompletableFuture 提供了四个静态方法来创建一个异步操作。</p><p><img src="2.jpg" alt="WeChat0f5a185875b9b00af5dabae5b74434f5"></p><ol><li>runXxxx 都是没有返回结果的，supplyXxx 都是可以获取返回结果的</li><li>可以传入自定义的线程池，否则就用默认的线程池；</li></ol><h3 id="计算完成时回调方法"><a href="#计算完成时回调方法" class="headerlink" title="计算完成时回调方法"></a>计算完成时回调方法</h3><p><img src="10.jpg" alt="WeChat18437bf3db525f104cb8133df7c91f02"></p><p>whenComplete 可以处理正常和异常的计算结果，exceptionally 处理异常情况。 whenComplete 和 whenCompleteAsync 的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whenComplete：是执行当前任务的线程执行继续执行 whenComplete 的任务。</span><br><span class="line">whenCompleteAsync：是执行把 whenCompleteAsync 这个任务继续提交给线程池 来进行执行。 方法不以 Async 结尾，意味着 Action 使用相同的线程执行， 而 Async 可能会使用其他线程 执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">CompletableFuture future = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Object&gt;() &#123; </span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"\t completableFuture"</span>); </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">1024</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.whenComplete(<span class="keyword">new</span> BiConsumer&lt;Object, Throwable&gt;() &#123;</span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Object o, Throwable throwable)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"-------o="</span> + o.toString()); </span><br><span class="line">  System.out.println(<span class="string">"-------throwable="</span> + throwable); </span><br><span class="line"> &#125;</span><br><span class="line"> &#125;).exceptionally(<span class="keyword">new</span> Function&lt;Throwable, Object&gt;() &#123; </span><br><span class="line">   <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">apply</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"throwable="</span> + throwable); <span class="keyword">return</span> <span class="number">6666</span>; &#125; </span><br><span class="line">   &#125;); </span><br><span class="line">  System.out.println(future.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="handle方法"><a href="#handle方法" class="headerlink" title="handle方法"></a>handle方法</h3><p><img src="3.jpg" alt="WeChat354da1ba030b0bc1395809554055b169"></p><p>和 complete 一样，可对结果做最后的处理（可处理异常），可改变返回值。</p><h3 id="线程串行化方法"><a href="#线程串行化方法" class="headerlink" title="线程串行化方法"></a>线程串行化方法</h3><p><img src="4.jpg" alt="WeChatbf6a1fc5b93b123ffb2466797903b9e0"></p><ul><li>thenApply 方法：当一个线程依赖另一个线程时，获取上一个任务返回的结果，并返回当前 任务的返回值。</li><li>thenAccept 方法：消费处理结果。接收任务的处理结果，并消费处理，无返回结果。 </li><li>thenRun 方法：只要上面的任务执行完成，就开始执行 thenRun，只是处理完任务后，执行 thenRun 的后续操作 </li><li>带有 Async 默认是异步执行的。同之前。 </li><li>以上都要前置任务成功完成。</li><li>Function&lt;? super T,? extends U&gt;<ul><li>T：上一个任务返回结果的类型</li><li>U：当前任务的返回值类型</li></ul></li></ul><h3 id="两任务组合-都要完成"><a href="#两任务组合-都要完成" class="headerlink" title="两任务组合-都要完成"></a>两任务组合-都要完成</h3><p><img src="5.jpg" alt="WeChat128b25d933d9f51c66a5beb8aad09a93"></p><p><img src="6.jpg" alt="WeChat53f817c0659a029b88ee7151e6ed1b9a"></p><p>两个任务必须都完成，触发该任务。</p><ul><li>thenCombine：组合两个 future，获取两个 future 的返回结果，并返回当前任务的返回值</li><li>thenAcceptBoth：组合两个 future，获取两个 future 任务的返回结果，然后处理任务，没有 返回值。 </li><li>runAfterBoth：组合两个 future，不需要获取 future 的结果，只需两个 future 处理完任务后， 处理该任务。</li></ul><h3 id="两任务组合-一个完成"><a href="#两任务组合-一个完成" class="headerlink" title="两任务组合- 一个完成"></a>两任务组合- 一个完成</h3><p><img src="7.jpg" alt="WeChat6f1f2f0b5e3294772ed627071cfda607"></p><p><img src="8.jpg" alt="WeChat3f9223bb296ca8133d39e4a4986e00c3"></p><p>当两个任务中，任意一个 future 任务完成的时候，执行任务。</p><ul><li>applyToEither：两个任务有一个执行完成， 获取它的返回值，处理任务并有新的返回值。</li><li>acceptEither：两个任务有一个执行完成， 获取它的返回值，处理任务，没有新的返回值。</li><li>runAfterEither：两个任务有一个执行完成， 不需要获取 future 的结果，处理任务，也没有返 回值。</li></ul><h3 id="多任务组合"><a href="#多任务组合" class="headerlink" title="多任务组合"></a>多任务组合</h3><p><img src="9.jpg" alt="WeChatecbc58603097f0359f4e715b5100e265"></p><ul><li><p>allOf：等待所有任务完成 </p></li><li><p>anyOf：只要有一个任务完成</p></li></ul><h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><p>以商城购物车添加商品为例，添加商品时，需要填充商品信息，需要做多次的远程调用，多次的调用如果没有先后关系制约，可以异步的同时进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、远程查询当前要添加的商品的信息</span></span><br><span class="line">       CartItem cartItem = <span class="keyword">new</span> CartItem();</span><br><span class="line">       CompletableFuture&lt;Void&gt; getSkuInfoTask = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">           R skuInfo = productFeignService.getSkuInfo(skuId);</span><br><span class="line">           SkuInfoVo data = skuInfo.getData(<span class="string">"skuInfo"</span>, <span class="keyword">new</span> TypeReference&lt;SkuInfoVo&gt;() &#123;</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           cartItem.setCheck(<span class="keyword">true</span>);</span><br><span class="line">           cartItem.setCount(num);</span><br><span class="line">           cartItem.setImage(data.getSkuDefaultImg());</span><br><span class="line">           cartItem.setTitle(data.getSkuTitle());</span><br><span class="line">           cartItem.setSkuId(skuId);</span><br><span class="line">           cartItem.setPrice(data.getPrice());</span><br><span class="line">       &#125;,executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//2、远程查询sku的组合信息</span></span><br><span class="line">       CompletableFuture&lt;Void&gt; getSkuSaleAttrValues = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">           List&lt;String&gt; values = productFeignService.getSkuSaleAttrValues(skuId);</span><br><span class="line">           cartItem.setSkuAttr(values);</span><br><span class="line">       &#125;, executor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       CompletableFuture.allOf(getSkuInfoTask,getSkuSaleAttrValues).get();</span><br><span class="line">       String s = JSON.toJSONString(cartItem);</span><br><span class="line">       log.info(<span class="string">"cartItem:&#123;&#125;"</span>,s);</span><br><span class="line">       cartOps.put(skuId.toString(),s);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Future模式</title>
      <link href="/2022/09/27/JUC-2022-09-27-Future%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/27/JUC-2022-09-27-Future%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h2><p>​    我们了解的Thread 和 runnable，实现多线程的方式是新起线程运行 run 方法，但是 run 方法有个缺陷是没有返回值，并且主线程也并不知道新的线程何时运行完毕。Future 持有要运行的任 务，以及任务的结果。主线程只要声明了 Future 对象，并且启动新的线程运行他。那么随时能通过 Future 对象获 取另外线程运行的结果。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>​    我们通过一个简单例子来介绍一下使用方法 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; cookTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>); <span class="keyword">return</span> <span class="string">"5斤的龙虾"</span>;</span><br><span class="line">         &#125;&#125;);</span><br><span class="line"></span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"我点了5斤的龙虾。"</span>); <span class="keyword">new</span> Thread(cookTask).start();</span><br><span class="line">        System.out.println(<span class="string">"我去买牙膏。"</span>); TimeUnit.SECONDS.sleep(<span class="number">2</span>); System.out.println(<span class="string">"我买到牙膏了！"</span>);</span><br><span class="line"></span><br><span class="line">        String lunch = cookTask.get(); </span><br><span class="line">        System.out.println(<span class="string">"我点的"</span>+lunch+<span class="string">"已经OK了！"</span>);</span><br><span class="line">        Long userTime = (System.currentTimeMillis() - startTime)/<span class="number">1000</span>; System.out.println(<span class="string">"我一共用了"</span>+userTime+<span class="string">"秒买午餐并且买牙膏。"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中先了一个 FutureTask 对象，称之为 cookTask。顾名思义，这个 task 是用来做饭的。可以看到构造方法中 传入 Callable 的实现。实现的 call 方法中模拟做饭用了 3 秒钟。</p><p>主线程运行后，先点了 5 斤的龙虾，然后一个新的线程就开始去执行 cookTask 了。等会儿，到这里你一定会 问，Thread 构造方法需要传入 Runnable 的实现啊？没错，FutureTask 实现了 Runnable 接口。FutureTask 的 run方法实际执行的是 Callable 的 call 方法。那么新的线程 start 后，实际做饭的逻辑会被执行：自线程 sleep3 秒后返 回 “5 斤的龙虾”。</p><p>主线程在启动做饭的自线程后继续向下执行，去买牙膏。这里 sleep 两秒，模拟买牙膏的时间消耗。</p><p>买到牙膏接下来的一行代码 String lobster = cookTask.get (); 重点说一下，此时分两种情况：</p><ol><li>cookTask 运行的线程已经结束了，那么可以直接取到运行的结果赋值给 lunch；</li><li>cookTask 运行的线程还没有执行结束，此时主线程会阻塞，直到能取得运行结果。</li></ol><p>​    cookTask 就是你的购物小票，只要你没弄丢，随时能去取你的午饭。</p><p>​    程序最后计算了整个过程的执行时间。由于采用了多线程并发，所以执行时间应该等于耗时最长的那个任务。这个 例子中做龙虾 3 秒 &gt; 买牙膏 2 秒，所以总共耗时 3 秒，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我点了<span class="number">5</span>斤的龙虾 </span><br><span class="line">我去买牙膏 我买到牙膏了！ </span><br><span class="line">我点的<span class="number">5</span>斤的龙虾已经OK了 </span><br><span class="line">我一共用了<span class="number">3</span>秒买午餐并且买牙膏</span><br></pre></td></tr></table></figure><p>加入我调整买牙膏需要 10 秒，那么输出则如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我点了<span class="number">5</span>斤的龙虾 </span><br><span class="line">我去买牙膏 </span><br><span class="line">我买到牙膏了！ </span><br><span class="line">我点的<span class="number">5</span>斤的龙虾已经OK了 </span><br><span class="line">我一共用了<span class="number">10</span>秒买午餐并且买牙膏</span><br></pre></td></tr></table></figure><p>总共耗时 10 秒。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>Future 是一个接口，而 FutrueTask 则是他的实现，我们看一下它们的继承关系：</p><p><img src="1.jpg" alt="WeChatd192175825d8fb235fce099659172545" style="zoom:50%;" /></p><p>FutureTask 不但实现了 Future 而且实现了 Runnable 接口。这也是为什么它能作为参数传入 Thread 构造方法。我们看一下 Future 接口有哪些方法：</p><p><img src="4.jpg" alt="WeChate273a460f8bd667f2a5cf78f52db12c7"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cancel 用于尝试取消任务。</span><br><span class="line">get 用于等待并获取任务执行结果。带时间参数的 get 方法只会等待指定时间长度。</span><br><span class="line">isCancelled 返回任务在完成前是否已经被取消。</span><br><span class="line">isDone 返回任务是否完成。</span><br></pre></td></tr></table></figure><h3 id="FutureTask-构造方法"><a href="#FutureTask-构造方法" class="headerlink" title="FutureTask 构造方法"></a>FutureTask 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">    <span class="keyword">this</span>.callable = callable; </span><br><span class="line">    <span class="keyword">this</span>.state = NEW; <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要传入 Callable 的实现，Callable 是一个接口，定义了 call 方法，返回 V 类型。</p><p>然后定义了 FutureTask 的状态为 NEW。FutrueTask 定义了如下状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL = <span class="number">3</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">4</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>通过字面我们很容易理解其含义。</p><h3 id="Run方法"><a href="#Run方法" class="headerlink" title="Run方法"></a>Run方法</h3><p>FutrueTask 实现了 Runnbale 接口，所以 Thread 运行后实际上执行的是 FutrueTask 的 run 方法。我们要想了解 Future 的实现原理，那么就应该从它的 run 方法开始入手。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果此时状态不为NEW 直接结束 </span></span><br><span class="line"><span class="comment">//如果为NEW ，但是CAS操作把本线程写入为runner时，发现runner已经不为null，那么也直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset, <span class="keyword">null</span>, Thread.currentThread())) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="comment">//取得Callable对象 </span></span><br><span class="line">        Callable&lt;V&gt; c = callable; </span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">             V result; </span><br><span class="line">             <span class="keyword">boolean</span> ran; </span><br><span class="line">             <span class="keyword">try</span> &#123; </span><br><span class="line">             <span class="comment">//运行Callable对象的call方法，并且取得返回值。 </span></span><br><span class="line">             result = c.call(); </span><br><span class="line">             ran = <span class="keyword">true</span>; </span><br><span class="line">             &#125; <span class="keyword">catch</span> (Throwable ex) &#123; </span><br><span class="line">                 result = <span class="keyword">null</span>; </span><br><span class="line">                 ran = <span class="keyword">false</span>; </span><br><span class="line">                 setException(ex); </span><br><span class="line">             &#125; </span><br><span class="line">             <span class="comment">//如果call方法成功执行结束，那么把执行结果设置给成员变量outcome; </span></span><br><span class="line">             <span class="keyword">if</span> (ran) </span><br><span class="line">                set(result);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to </span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run() </span></span><br><span class="line">        runner = <span class="keyword">null</span>; </span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent </span></span><br><span class="line">        <span class="comment">// leaked interrupts </span></span><br><span class="line">        <span class="keyword">int</span> s = state; </span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING) </span><br><span class="line">        handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">核心逻辑就是执行运行 Call</span><br></pre></td></tr></table></figure><h3 id="Set-方法"><a href="#Set-方法" class="headerlink" title="Set 方法"></a>Set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//状态还是NEW ，保存计算结果给outcome </span></span><br><span class="line"><span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">    outcome = v; </span><br><span class="line">    <span class="comment">//更新状态为NORMAL</span></span><br><span class="line">    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); </span><br><span class="line">    <span class="comment">// final state </span></span><br><span class="line">    <span class="comment">//唤醒等待的线程</span></span><br><span class="line">    finishCompletion(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有被取消则会保存计算结果 v 到 outcome。然后更新最终状态为 NORMAL。最后调用 finishCompletion 方法 唤醒阻塞的线程。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// assert state &gt; COMPLETING; </span></span><br><span class="line"><span class="comment">//遍历等待线程，结束等待 </span></span><br><span class="line"><span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123; </span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123; </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">            <span class="comment">//结束等待线程的挂起 </span></span><br><span class="line">            Thread t = q.thread; </span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                q.thread = <span class="keyword">null</span>; </span><br><span class="line">                LockSupport.unpark(t); </span><br><span class="line">             &#125; </span><br><span class="line">             <span class="comment">//如果没有下一个等待线程，那么结束循环 </span></span><br><span class="line">             WaitNode next = q.next; </span><br><span class="line">             <span class="keyword">if</span> (next == <span class="keyword">null</span>) </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">             q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc </span></span><br><span class="line">             q = next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//全部完成后回调FutrueTask的done方法。done方法为空，可以由子类实现。</span></span><br><span class="line">    done(); </span><br><span class="line"><span class="comment">//清除callable</span></span><br><span class="line"> callable = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>get 方法用于获取任务的返回值，如果还没有执行完成，则会阻塞，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123; </span><br><span class="line"><span class="comment">//获取当前Task的状态 </span></span><br><span class="line"><span class="keyword">int</span> s = state; </span><br><span class="line"><span class="comment">//如果还没有完成，则阻塞等待完成 </span></span><br><span class="line"><span class="keyword">if</span> (s &lt;= COMPLETING) </span><br><span class="line">    s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>); </span><br><span class="line">    <span class="comment">//获取任务执行的返回结果 </span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看 awaitDone 的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//计算等待截止时长 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>; </span><br><span class="line">WaitNode q = <span class="keyword">null</span>; </span><br><span class="line"><span class="keyword">boolean</span> queued = <span class="keyword">false</span>; </span><br><span class="line"><span class="keyword">for</span> (;;) &#123; </span><br><span class="line">    <span class="comment">//当前线程如果被打断，则不再等待。从等待链表中移除 </span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123; </span><br><span class="line">            removeWaiter(q); </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//取得目前的状态 </span></span><br><span class="line">        <span class="keyword">int</span> s = state; </span><br><span class="line">        <span class="comment">//如果已经执行完成，清空q节点保存的线程 </span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123; </span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>) </span><br><span class="line">            q.thread = <span class="keyword">null</span>; </span><br><span class="line">            <span class="keyword">return</span> s; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//如果正在执行，让出CPU执行权 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet </span></span><br><span class="line">            Thread.yield(); </span><br><span class="line">        <span class="comment">//没有进入以上分支，运行到此分支，这说明此线程确实需要开始等待了， </span></span><br><span class="line">        <span class="comment">//那么如果还未为此线程建立关联的等待节点，则进行创建。 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>) </span><br><span class="line">            q = <span class="keyword">new</span> WaitNode(); </span><br><span class="line">        <span class="comment">//通过CAS把此线程的等待node加入到连表中。失败的话，下次循环若能运行到此分支，会继续添加。 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued) </span><br><span class="line">        queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q.next = waiters, q); <span class="comment">//如果设置了超时，检查是否超时。超时的话结束等待。否则挂起超时时长 </span></span><br><span class="line">        <span class="comment">//如果没有设置超时时长，则永久挂起 </span></span><br><span class="line">        <span class="comment">//回到上面的finishCompletion方法，等到task执行完成后会执行LockSupport.unpark(t)，结束阻塞。 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;   </span><br><span class="line">            nanos = deadline - System.nanoTime(); </span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">             removeWaiter(q); </span><br><span class="line">             <span class="keyword">return</span> state; </span><br><span class="line">            &#125; </span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们看一下 report 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123; </span><br><span class="line">    <span class="comment">//获取执行结果 </span></span><br><span class="line">    Object x = outcome; </span><br><span class="line">    <span class="comment">//NORMAL为正常结束，那么直接把X转型后返回 </span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL) </span><br><span class="line">        <span class="keyword">return</span> (V)x; </span><br><span class="line">    <span class="comment">//如果任务被取消了，则抛出异常 </span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException(); </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>outcome 保存的就是任务的执行结果。根据此时的状态，选择返回执行结果还是抛出取消的异常。</p><p>最后我们总结下 FutureTask 的代码：</p><ol><li><p>FutureTask 实现 Runnable 和 Future 接口；</p></li><li><p>在线程上运行 FutureTask 后，run 方法被调用，run 方法会调用传入的 Callable 接口的 call 方法；</p></li><li>拿到返回值后，通过 set 方法保存结果到 outcome，并且唤醒所有等待的线程；</li><li>调用 get 方法获取执行结果时，如果没有执行完毕，则进入等待，直到 set 方法调用后被唤醒。</li></ol><p>下图示意了两个线程运行 task 和 get 时的程序逻辑：</p><p><img src="3.jpg" alt="WeChat2d6c1ed19feedb49de736d5f87f888da"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Future 模式在实际开发中有着大量的应用场景。比如说微服务架构中，需要调用不同服务接口获取数据，但是接口 调用间并无依赖关系，那么可以通过 FutureTask 并发调用，然后再执行后续逻辑。如果我们采用串行的方式，则 需要一个接口返回后，再调用下一个接口。FutreTask 需要结合 Callable 接口使用，示例代码中为了让大家显示的 看到 Callable 接口，所以采用匿名对象的方式。实际使用中我们可以使用 lambda 表达式来简化代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;String&gt; cookTask = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123; Thread.sleep(<span class="number">3000</span>); <span class="keyword">return</span> <span class="string">"5斤的龙虾"</span>; &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Reactor模式到Netty架构演进</title>
      <link href="/2022/09/26/IO-2022-09-26-%E4%BB%8EReactor%E6%A8%A1%E5%BC%8F%E5%88%B0Netty%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/"/>
      <url>/2022/09/26/IO-2022-09-26-%E4%BB%8EReactor%E6%A8%A1%E5%BC%8F%E5%88%B0Netty%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="单线程Reactor"><a href="#单线程Reactor" class="headerlink" title="单线程Reactor"></a>单线程Reactor</h2><h3 id="Reactor模型的朴素原型"><a href="#Reactor模型的朴素原型" class="headerlink" title="Reactor模型的朴素原型"></a>Reactor模型的朴素原型</h3><p>之前的文章探讨过IO模型，其中最优化的是基于多路复用器的NIO。Java的NIO模式的Selector网络通讯，其实就是一个简单的Reactor模型。可以说是Reactor模型的朴素原型。</p><p>我们再来回顾一下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingSingleThreadv1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;   <span class="comment">//linux 多路复用器（select poll    epoll kqueue） nginx  event&#123;&#125;</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initServer();</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了。。。。。"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">                System.out.println(keys.size()+<span class="string">"   size"</span>);</span><br><span class="line">                <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();  <span class="comment">//返回的有状态的fd集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">              </span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        iter.remove(); <span class="comment">//set  不移除会重复循环处理</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;       </span><br><span class="line">                            acceptHandler(key);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            readHandler(key);           </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">            SocketChannel client = ssc.accept(); <span class="comment">//来啦，目的是调用accept接受客户端  fd7</span></span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">            System.out.println(<span class="string">"新客户端："</span> + client.getRemoteAddress());</span><br><span class="line">            <span class="keyword">final</span> String[] split = client.getRemoteAddress().toString().split(<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">if</span> (split[<span class="number">1</span>].equals(<span class="string">"15098"</span>))</span><br><span class="line">                System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                read = client.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        client.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketMultiplexingSingleThreadv1 service = <span class="keyword">new</span> SocketMultiplexingSingleThreadv1();</span><br><span class="line">        System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">        service.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单线程Reactor-1"><a href="#单线程Reactor-1" class="headerlink" title="单线程Reactor"></a>单线程Reactor</h3><p>实际上的Reactor模式，是基于Java NIO的，在他的基础上，抽象出来两个组件——Reactor和Handler两个组件：</p><p>（1）Reactor：负责响应IO事件，当检测到一个新的事件，将其发送给相应的Handler去处理；新的事件包含连接建立就绪、读就绪、写就绪等。</p><p>（2）Handler:将自身（handler）与事件绑定，负责事件的处理，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。</p><p>如下图所示:</p><p><img src="1.jpg" alt="wpsC334.tmp"></p><p>这是最简单的单Reactor单线程模型。Reactor线程是个多面手，负责多路分离套接字，Accept新连接，并分派请求到Handler处理器中。</p><p>下面的图，来自于“Scalable IO in Java”，和上面的图的意思，差不多。Reactor和Hander 处于一条线程执行。</p><p><img src="2.jpg" alt="wpsC345.tmp"></p><p>顺便说一下，可以将上图的accepter，看做是一种特殊的handler。</p><h2 id="多线程Reactor"><a href="#多线程Reactor" class="headerlink" title="多线程Reactor"></a>多线程Reactor</h2><p>​    上述的单线程Reactor虽然能使用单线程应对多个并发，但是还没有发挥出多线程的优势，现代的cpu都是多核cpu，如果只是单线程 明显发挥不出多核cpu的实力。我们尝试改造Reactor模式为多线程。<br>​    很容易想到，用一个主线程（reactor）来接收连接请求，具体的read、wirte等操作，拿一个线程池来去干活，这就可以发挥发线程的优势。</p><p>下面的图，来自于“Scalable IO in Java”,Reactor是一条独立的线程，Hander 处于线程池中执行。</p><p><img src="5.jpg" alt="wpsC376.tmp"></p><p>​    改造代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingSingleThreadv2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;   <span class="comment">//linux 多路复用器（select poll epoll） nginx  event&#123;&#125;</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            selector = Selector.open();  <span class="comment">//  select  poll  *epoll</span></span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initServer();</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了。。。。。"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (selector.select(<span class="number">50</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            acceptHandler(key);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"in....."</span>);</span><br><span class="line">                            readHandler(key);<span class="comment">//非阻塞  即便以抛出了线程去读取，但是在时差里，这个key的read事件会被重复触发</span></span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123;                    </span><br><span class="line">                            key.interestOps(key.interestOps() &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">                            writeHandler(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"write handler..."</span>);</span><br><span class="line">            SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    client.write(buffer);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">            SocketChannel client = ssc.accept();</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">            System.out.println(<span class="string">"新客户端："</span> + client.getRemoteAddress());</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"read handler....."</span>);</span><br><span class="line">            SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    read = client.read(buffer);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">" "</span> + read);</span><br><span class="line">                    <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        key.interestOps(  SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                        client.register(key.selector(),SelectionKey.OP_WRITE,buffer);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        client.close();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketMultiplexingSingleThreadv2 service = <span class="keyword">new</span> SocketMultiplexingSingleThreadv2();</span><br><span class="line">        service.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个乍一看好像没啥问题，实际运行的话是有点问题的，我们运行之后，在客户端处输入一个hello</p><p><img src="3.jpg" alt="image-20220926220333005"> <img src="4.jpg" alt="image-20220926220418249"></p><p>看到什么问题？我明明在客户端只输入了一次hello，但是确重复调用了，具体原因在代码中注释了,就是因为在切换线程处理的时候，这个空隙中 由于缓冲区没有读完，相当于read事件没有被处理完成，所以会一直调用。也就是说，每次输入，只要切换线程，这个背后可能就会调用多次epoll_wait得到read 事件。<font color=red>也就是会造成重复的系统调用</font>。</p><p>​    这样这么多浪费的系统调用被调肯定不行，并发多的时候 一定会影响性能，但我们还想利用多线程怎么办呢？</p><p>实际这个问题就是在于主线程非阻塞造成的，这一个reactor线程 判断获取了read事件、write事件 却切换了线程处理,如果我们让一个线程对此selector注册的事件负责到底，判断是read事件则进行read处理，判断是write事件就进行write处理，大不了多来几个reactor不就可以了吗？思路转，天地宽。</p><p>优化代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingThreads</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span>  Selector selector1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span>  Selector selector2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span>  Selector selector3 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            selector1 = Selector.open();</span><br><span class="line">            selector2 = Selector.open();</span><br><span class="line">            selector3 = Selector.open();</span><br><span class="line">            server.register(selector1, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketMultiplexingThreads service = <span class="keyword">new</span> SocketMultiplexingThreads();</span><br><span class="line">        service.initServer();</span><br><span class="line">        NioThread T1 = <span class="keyword">new</span> NioThread(service.selector1 ,<span class="number">2</span>);</span><br><span class="line">        NioThread T2 = <span class="keyword">new</span> NioThread(service.selector2);</span><br><span class="line">        NioThread T3 = <span class="keyword">new</span> NioThread(service.selector3);</span><br><span class="line"></span><br><span class="line">        T1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        T2.start();</span><br><span class="line">        T3.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器启动了。。。。。"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NioThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">     Selector selector = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> selectors = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">volatile</span> <span class="keyword">static</span> BlockingQueue&lt;SocketChannel&gt;[] queue;</span><br><span class="line">     <span class="keyword">static</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    NioThread(Selector sel,<span class="keyword">int</span> n ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.selector = sel;</span><br><span class="line">        <span class="keyword">this</span>.selectors =  n;</span><br><span class="line"></span><br><span class="line">        queue =<span class="keyword">new</span> LinkedBlockingQueue[selectors];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            queue[i] = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Boss 启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   NioThread(Selector sel  ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.selector = sel;</span><br><span class="line">       id = idx.getAndIncrement() % selectors  ;</span><br><span class="line">       System.out.println(<span class="string">"worker: "</span>+id +<span class="string">" 启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (selector.select(<span class="number">10</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            acceptHandler(key);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            readHandler(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( ! queue[id].isEmpty()) &#123;</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">                    SocketChannel client = queue[id].take();</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line">                    System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"新客户端："</span> + client.socket().getPort()+<span class="string">"分配到："</span>+ (id));</span><br><span class="line">                    System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">            SocketChannel client = ssc.accept();</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">int</span> num = idx.getAndIncrement() % selectors;</span><br><span class="line"></span><br><span class="line">            queue[num].add(client);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                read = client.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        client.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体架构大致如下:</p><p><img src="6.jpg" alt="image-20220926223327829"></p><p>​    我们用一个线程持有一个selector,在selector上只注册了accept事件,我们将其称为Boss,而我们再启动另外两个线程，每个线程持有一个selector，我们称其为worker线程，worker线程启动之后就负责对注册到本线程selector上的事件进行处理。</p><p>​    Boss线程接收客户端连接之后，我们直接将它注册到worker线程上selector，但是注意，直接注册由于worker调用select方法可能会阻塞，是注册不上的，此时需要唤醒操作。更好的处理方式就是代码中的通过队列解偶，让worker自己去注册即可，这就完成了一种多线程下的reactor模型。</p><h2 id="Netty-IO"><a href="#Netty-IO" class="headerlink" title="Netty IO"></a>Netty IO</h2><h3 id="Boss、Worker"><a href="#Boss、Worker" class="headerlink" title="Boss、Worker"></a>Boss、Worker</h3><p>​    多线程的reactor模式，其实重点就一个，就是让单线程持有一个selector，并且由它自己为注册到selector上的事件负责！那么，也就是说，我们将上图的Boss 变为多个线程，Worker变为更多的线程，并且Boss 线程或许也可以注册读写事件 由此来分担压力，或者 某些Worker专门注册写事件，某些Worker专门注册读事件，只要能充分利用多核cpu，可以任意组合。</p><p> 架构图:</p><p>​    <img src="7.jpg" alt="image-20220926225317405"></p><h3 id="简单的Netty实现"><a href="#简单的Netty实现" class="headerlink" title="简单的Netty实现"></a>简单的Netty实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.StandardSocketOptions;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingThreadsV2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup boss = <span class="keyword">new</span> EventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup worker = <span class="keyword">new</span> EventLoopGroup(<span class="number">3</span>);</span><br><span class="line">        ServerBootStrap b = <span class="keyword">new</span> ServerBootStrap();</span><br><span class="line">        b.group(boss, worker).bind(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerBootStrap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup group;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup chiledGroup;</span><br><span class="line">    ServerAcceptr sAcceptr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerBootStrap <span class="title">group</span><span class="params">(EventLoopGroup boss, EventLoopGroup worker)</span> </span>&#123;</span><br><span class="line">        group = boss;</span><br><span class="line">        chiledGroup = worker;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//bind 处理的是server的启动过程</span></span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        sAcceptr = <span class="keyword">new</span> ServerAcceptr(chiledGroup, server);</span><br><span class="line">        EventLoop eventloop = group.chosser();</span><br><span class="line">        <span class="comment">//把启动server，bind端口的操作变成task，推送到eventloop中执行。</span></span><br><span class="line">        eventloop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                eventloop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eventloop.name = Thread.currentThread() + eventloop.name;</span><br><span class="line">                            System.out.println(<span class="string">"bind...server...to "</span> + eventloop.name);</span><br><span class="line">                            server.register(eventloop.selector, SelectionKey.OP_ACCEPT, sAcceptr);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoopGroup</span> </span>&#123;</span><br><span class="line">    AtomicInteger cid = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    EventLoop[] childrens = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    EventLoopGroup(<span class="keyword">int</span> nThreads) &#123;</span><br><span class="line">        childrens = <span class="keyword">new</span> EventLoop[nThreads];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">            childrens[i] = <span class="keyword">new</span> EventLoop(<span class="string">"T"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventLoop <span class="title">chosser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> childrens[cid.getAndIncrement() % childrens.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doRead</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientReader</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SocketChannel key;</span><br><span class="line">    ClientReader(SocketChannel server) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = server;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ByteBuffer data = ByteBuffer.allocateDirect(<span class="number">4096</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            key.read(data);</span><br><span class="line">            data.flip();</span><br><span class="line">            <span class="keyword">byte</span>[] dd = <span class="keyword">new</span> <span class="keyword">byte</span>[data.limit()];</span><br><span class="line">            data.get(dd);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(dd));</span><br><span class="line">            data.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                data.put(<span class="string">"a"</span>.getBytes());</span><br><span class="line">                data.flip();</span><br><span class="line">                key.write(data);</span><br><span class="line">                data.clear();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerAcceptr</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    ServerSocketChannel key;</span><br><span class="line">    EventLoopGroup cGroup;</span><br><span class="line"></span><br><span class="line">    ServerAcceptr(EventLoopGroup cGroup, ServerSocketChannel server) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = server;</span><br><span class="line">        <span class="keyword">this</span>.cGroup = cGroup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> EventLoop eventLoop = cGroup.chosser();</span><br><span class="line">            <span class="keyword">final</span> SocketChannel client = key.accept();</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            client.setOption(StandardSocketOptions.TCP_NODELAY, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">final</span> ClientReader cHandler = <span class="keyword">new</span> ClientReader(client);</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"socket...send...to "</span> + eventLoop.name+ <span class="string">" client port : "</span> + client.socket().getPort());</span><br><span class="line"></span><br><span class="line">                        client.register(eventLoop.selector, SelectionKey.OP_READ, cHandler);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Selector selector;</span><br><span class="line">    Thread thread = <span class="keyword">null</span>;</span><br><span class="line">    BlockingQueue events = <span class="keyword">new</span> LinkedBlockingQueue();</span><br><span class="line">    <span class="keyword">int</span> NOT_STARTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> STARTED = <span class="number">2</span>;</span><br><span class="line">    AtomicInteger STAT = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventLoop</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Loop 需要一个死循环  这个死循环在哪里运行呢？当然在一个线程里，那，那个线程怎么出现的呢？？？当然是execute创建出来的。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"server已经开始："</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">//select</span></span><br><span class="line">            <span class="keyword">int</span> nums = selector.select();</span><br><span class="line">            <span class="comment">//selectedkeys to events</span></span><br><span class="line">            <span class="keyword">if</span> (nums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();  <span class="comment">//会一直阻塞，不过可以通过外界有task到达来wakeup唤醒</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    iter.remove();</span><br><span class="line">                    Handler handler = (Handler) key.attachment();</span><br><span class="line">                    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ServerAcceptr) &#123;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ClientReader) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    handler.doRead();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//run events</span></span><br><span class="line">            runrTask();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池需要持有线程和消息队列</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            events.put(task);</span><br><span class="line">            <span class="keyword">this</span>.selector.wakeup();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!inEventLoop() &amp;&amp; STAT.incrementAndGet() == STARTED) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        thread = Thread.currentThread();</span><br><span class="line">                        EventLoop.<span class="keyword">this</span>.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runrTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Runnable task = (Runnable) events.poll(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                events.remove(task);</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inEventLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thread == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="8.jpg" alt="image-20220926230127195"></p><blockquote><p>参考:<a href="https://www.cnblogs.com/crazymakercircle/p/9833847.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazymakercircle/p/9833847.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络IO-BIO、NIO</title>
      <link href="/2022/09/25/IO-2022-09-25-%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/09/25/IO-2022-09-25-%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>都是需求推动发展，网络IO模型也是一样，IO的发展都是围绕C10问题。总的来说就是如何建立高并发的连接。接下来我就看一下IO模型从最初的阻塞BIO到NIO再到多路复用器，一步一步如何发展过来。</p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="1.jpg" alt="image-20200615181255063"></p><p>看上图，所谓的BIO就是 阻塞式IO，需要一个线程监听端口，这个线程只能阻塞式的监听，再也不能干别的，当有连接上来时，linux建立对应的连接（注意这一步时内核干的，其实应用层的线程没有接受，连接也已经建立了）,这时候线程accpet即可获得一个用来读写的FD，需要一个专门的线程用来进行读写操作，并且是阻塞式的，也就说，多少个用户连接上来，需要多少个线程来进行处理。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Server:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketBIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9090</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"step1: new ServerSocket(9090) "</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket client = server.accept();  <span class="comment">//阻塞1</span></span><br><span class="line">            System.out.println(<span class="string">"step2:client\t"</span> + client.getPort());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    InputStream in = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        in = client.getInputStream();</span><br><span class="line">                        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">                        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                            String dataline = reader.readLine(); <span class="comment">//阻塞2</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(<span class="keyword">null</span> != dataline)&#123;</span><br><span class="line">                                System.out.println(dataline);</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                client.close();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">"客户端断开"</span>);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">9090</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            client.setSendBufferSize(<span class="number">20</span>);</span><br><span class="line">            client.setTcpNoDelay(<span class="keyword">true</span>);</span><br><span class="line">            OutputStream out = client.getOutputStream();</span><br><span class="line"></span><br><span class="line">            InputStream in = System.in;</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                String line = reader.readLine();</span><br><span class="line">                <span class="keyword">if</span>(line != <span class="keyword">null</span> )&#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] bb = line.getBytes();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">byte</span> b : bb) &#123;</span><br><span class="line">                        out.write(b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>上述代码对应的系统调用可用Strace命令进行查看,流程如下:</p><p><img src="2.jpg" alt="image-20220925223948199"></p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念:"></a>概念:</h3><p>​    BIO，每次上来一个用户需要开辟一个线程来维持会话，随着并发越来越大，资源开销太大了也，尽管我们可以使用线程池进行复用，可终归是治标不治本，所以我们急需一套真正的解决方法，来应付高并发。</p><p>​    我们思考一下，BIO的问题在哪？阻塞！主线程在监听端口的时候是阻塞式监听的，这就让它只能干这一个事情。同样读写的FD分配之后，持有FD的线程也是阻塞式的等待消息，不能干别的，这就是问题的根本原因。</p><p>所谓的NIO，就是非阻塞式IO（可以暂时这么理解）,我们假想一下，如果每次执行accpet、read这些系统调用都不是阻塞的，也就是说，有就有，没有就拉倒，那这个事情就太好办了。我们只需要一个线程，监听端口，然后accept 有连接就建立，没有就返回，我们把已经建立的连接，维护在一个集合里面，我们去遍历集合，挨个做读操作，因为read不阻塞，我们就可以对所有的连接进行处理了，尽管这样可能会慢一些，但相比BIO，我们已经可以用单个线程来应用多个连接，而不是一个连接需要一个线程来并发处理。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjmashibing.system.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.StandardSocketOptions;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketNIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  what   why  how</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">        LinkedList&lt;SocketChannel&gt; clients = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ss = ServerSocketChannel.open();  <span class="comment">//服务端开启监听：接受客户端</span></span><br><span class="line">        ss.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>));</span><br><span class="line">        ss.configureBlocking(<span class="keyword">false</span>); <span class="comment">//只让接受客户端  不阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            SocketChannel client = ss.accept(); <span class="comment">//不会阻塞？  -1 NULL</span></span><br><span class="line">            <span class="comment">//accept  调用内核了：非阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client.configureBlocking(<span class="keyword">false</span>); <span class="comment">//重点  socket（服务端的listen socket&lt;连接请求三次握手后，往我这里扔，我去通过accept 得到  连接的socket&gt;，连接socket&lt;连接后的数据读写使用的&gt; ）</span></span><br><span class="line">                <span class="keyword">int</span> port = client.socket().getPort();</span><br><span class="line">                System.out.println(<span class="string">"client..port: "</span> + port);</span><br><span class="line">                <span class="keyword">if</span>(port == <span class="number">15098</span>)</span><br><span class="line">                    System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">                clients.add(client);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">4096</span>);  <span class="comment">//可以在堆里   堆外</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历已经链接进来的客户端能不能读写数据</span></span><br><span class="line">            <span class="keyword">for</span> (SocketChannel c : clients) &#123;   <span class="comment">//串行化！！！！ 可以运用进多线程。灵活使用</span></span><br><span class="line">                <span class="keyword">int</span> num = c.read(buffer);  <span class="comment">// &gt;0  -1  0   //不会阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">byte</span>[] aaa = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</span><br><span class="line">                    buffer.get(aaa);</span><br><span class="line"></span><br><span class="line">                    String b = <span class="keyword">new</span> String(aaa);</span><br><span class="line">                    System.out.println(c.socket().getPort() + <span class="string">" : "</span> + b);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h3><p><img src="3.jpg" alt="image-20220925225025685"></p><h2 id="多路复用器"><a href="#多路复用器" class="headerlink" title="多路复用器"></a>多路复用器</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>​    有了NIO，我们已经可以用单个线程来应对多个连接，这样就可以极大的减少资源开销了。接下来就要考虑效率性能问题了。那如何优化呢？我们知道，我们现在一定是先触发accpet、read调用才知道到底有没有连接，有没有数据上来，换句话说，比如我们已经建立了1000个连接，但实际上并发消息并不多，可能只有1个人在频繁的发，剩余999都是沉默的状态，那我们不断的轮训，不断的对1000个FD执行read操作，实际上都是无用的，因为只有那1个才是有效的调用。</p><p>​    关键问题是，对我应用层而言，有没有消息我是先调了才知道的，我如何才能避开无效的调用呢？实际上，接下来的优化 对应用层已经没什么办法了，接下来的优化只能是内核来去做了。</p><p>​    内核如何做？接下来就是<font color=red>多路复用器</font>了</p><p>​    多路复用器的作用就是，让内核来帮你维护有事件的FD集合,线程要进行处理的时候，先做一步select操作，内核立刻返回一个集合，<font color=red>集合内是已经有事件的FD</font>，应用程序只需要遍历FD，做对应的处理即可。</p><p><img src="4.jpg" alt="image-20220926151649138" style="zoom:50%;" /></p><p>​    多路复用器的具体有3种，select、poll、epoll 在linux对应的系统调用。接下来 我们从原理上来解释一下它们的区别和演进过程。最后用一个JAVA代码来进行一个实战的应用讲解。</p><h3 id="Select、Poll"><a href="#Select、Poll" class="headerlink" title="Select、Poll"></a>Select、Poll</h3><p> select作为第一代的多路复用器，其大致原理应用程序在内存开辟一个读集合用来存放专门读的文件描述符,在开辟一个写集合专门存放用来写的集合，调用select操作时，需要将集合传递给内核，内核来线性遍历集合里的文件描述符，看看哪个已经处于就绪状态了。我们也可以从系统调用的原形上来观察。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>而 poll在本质上和select没有区别，原理是一样的。</p><p><img src="8.jpg" alt="image-20220926152357939" style="zoom:50%;" /></p><h4 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h4><p>Epoll可以说是性能最好，现在应用最广泛的多路复用器,它也是在select、poll基础上优化来的。</p><p>我们想一下，select poll有哪些可以优化的地方</p><pre><code>    1. 调用select 时，需要传递FD，从用户态传到内核态，FD多的时候 是一笔不小的开销。    1. 内核通过轮训来查看寻找就绪的FD，时间复杂度O(n),FD多了，势必会慢</code></pre><p>Epoll就解决了这两个问题。</p><p>它的原理是，首先在内核开辟一个空间用来组织所关心的文件描述符,所用的数据结构是红黑树,然后下一步，进行注册，将需要进行检测的FD 注册进红黑树,最后一步，执行类似select的操作，让内核返回就绪的文件描述符。这样，首先用户态不需要每次调用都得传递FD集合了！那么，内核是如何避免轮训查找就绪的FD呢？</p><p>​    我们思考一点，对应的FD什么时候就变的有序的呢？这里需要一点计组的前置知识。换句话说当 网卡有数据了，内核怎么知道数据到来了呢？从原始的 CPU程序式、中断式，到现在的DMA，CPU逐渐摆脱数据IO传输的工作，把更多的时间用于计算，但IO数据通过DMA搬运到内存之后，cpu还是要知道的呀，才能完成下一步的工作。也就是说，DMA把网卡数据搬运到内存之后，通过中断高知CPU数据到了内存buffer了，这时候内核就知道了哦，其对应的FD已经就绪了！所以，CPU在中断这一步就可以维护好就绪的FD，而不用后期再去轮训判断了。那Epoll的做法就是 内核维护一个链表，存放就绪的FD，中断时候就塞进链表，用户态调用Epoll_wait时候，内核直接返回此链表,O(1)</p><p>我们再来看一下 这3个重要的系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">epoll_create():内核开辟区域，建立红黑树</span><br><span class="line">epoll_ctl():用来对FD做一些操作,比如：将FD读事件 注册进红黑树 </span><br><span class="line">epoll_wait():用来获取就绪的FD集合</span><br></pre></td></tr></table></figure><p>具体流程如下 ：</p><p><img src="6.jpg" alt="image-20220926160230734"></p><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingSingleThreadv1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;   <span class="comment">//linux 多路复用器（select poll    epoll kqueue） nginx  event&#123;&#125;</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果在epoll模型下，open--》  epoll_create -&gt; fd3</span></span><br><span class="line">            selector = Selector.open();  <span class="comment">//  select  poll  *epoll  优先选择：epoll  但是可以 -D修正</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//server 约等于 listen状态的 fd4</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            register</span></span><br><span class="line"><span class="comment">            如果：</span></span><br><span class="line"><span class="comment">            select，poll：jvm里开辟一个数组 fd4 放进去</span></span><br><span class="line"><span class="comment">            epoll：  epoll_ctl(fd3,ADD,fd4,EPOLLIN</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initServer();</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了。。。。。"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  <span class="comment">//死循环</span></span><br><span class="line"></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">                System.out.println(keys.size()+<span class="string">"   size"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//1,调用多路复用器(select,poll  or  epoll  (epoll_wait))</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                select()是啥意思：</span></span><br><span class="line"><span class="comment">                1，select，poll  其实  内核的select（fd4）  poll(fd4)</span></span><br><span class="line"><span class="comment">                2，epoll：  其实 内核的 epoll_wait()</span></span><br><span class="line"><span class="comment">                *, 参数可以带时间：没有时间，0  ：  阻塞，有时间设置一个超时</span></span><br><span class="line"><span class="comment">                selector.wakeup()  结果返回0</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();  <span class="comment">//返回的有状态的fd集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">              </span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        iter.remove(); <span class="comment">//set  不移除会重复循环处理</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="comment">//看代码的时候，这里是重点，如果要去接受一个新的连接</span></span><br><span class="line">                            <span class="comment">//语义上，accept接受连接且返回新连接的FD对吧？</span></span><br><span class="line">                            <span class="comment">//那新的FD怎么办？</span></span><br><span class="line">                            <span class="comment">//select，poll，是在jvm中保存和前边的fd4那个listen的一起</span></span><br><span class="line">                            <span class="comment">//epoll： 我们希望通过epoll_ctl把新的客户端fd注册到内核空间</span></span><br><span class="line">                            acceptHandler(key);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            readHandler(key);  <span class="comment">//连read 还有 write都处理了</span></span><br><span class="line">                            <span class="comment">//在当前线程，这个方法可能会阻塞  ，如果阻塞了十年，其他的IO早就没电了。。。</span></span><br><span class="line">                            <span class="comment">//所以，为什么提出了 IO THREADS</span></span><br><span class="line">                            <span class="comment">//redis  是不是用了epoll，redis是不是有个io threads的概念 ，redis是不是单线程的</span></span><br><span class="line">                            <span class="comment">//tomcat 8,9  异步的处理方式  IO  和   处理上  解耦</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">            SocketChannel client = ssc.accept(); <span class="comment">//来啦，目的是调用accept接受客户端  fd7</span></span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);  <span class="comment">//前边讲过了</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            select，poll：jvm里开辟一个数组 fd7 放进去</span></span><br><span class="line"><span class="comment">            epoll：  epoll_ctl(fd3,ADD,fd7,EPOLLIN</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            client.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">            System.out.println(<span class="string">"新客户端："</span> + client.getRemoteAddress());</span><br><span class="line">            <span class="keyword">final</span> String[] split = client.getRemoteAddress().toString().split(<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">if</span> (split[<span class="number">1</span>].equals(<span class="string">"15098"</span>))</span><br><span class="line">                System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                read = client.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        client.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketMultiplexingSingleThreadv1 service = <span class="keyword">new</span> SocketMultiplexingSingleThreadv1();</span><br><span class="line">        System.out.println(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">        service.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="系统调用-2"><a href="#系统调用-2" class="headerlink" title="系统调用"></a>系统调用</h3><p>上述的代码，同一套代码，底层可以选用不同的多路复用器</p><p><img src="7.jpg" alt="image-20220926164833823"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><p>select的几大缺点：</p><ul><li><p>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</p></li><li><p>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</p></li><li><p>select支持的文件描述符数量太小了，默认是1024</p></li></ul></li><li><p>poll的实现和select非常相似，只是描述fd集合的方式不同</p></li><li><p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次。</p></li><li><p>poll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生</p><ol><li>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</li><li>对于第二个缺点，epoll利用在中断时添加回调函数，这个回调函数会把就绪的fd加入一个就绪链表。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd。</li></ol></li><li>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过从BIO-&gt;NIO-&gt;多路复用器 优化过程，尽可能的理解为什么有这些东西，以及如何发展来的。网络IO模型是基石，无论mysql、redis 还是各种RPC框架，只要涉及到网络通信，都需要用到IO模型，可以说是重中之重，一定要理解到位。</p>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DMA与零拷贝技术</title>
      <link href="/2022/09/25/IO-2022-09-25-DMA%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/09/25/IO-2022-09-25-DMA%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>注意事项</strong>：除了 Direct I/O，与磁盘相关的文件读写操作都有使用到 page cache 技术。</p></blockquote><h2 id="数据的四次拷贝与四次上下文切换"><a href="#数据的四次拷贝与四次上下文切换" class="headerlink" title="数据的四次拷贝与四次上下文切换"></a>数据的四次拷贝与四次上下文切换</h2><p>很多应用程序在面临客户端请求时，可以等价为进行如下的系统调用：</p><ol><li>File.read(file, buf, len);</li><li>Socket.send(socket, buf, len);</li></ol><p>例如消息中间件 Kafka 就是这个应用场景，从磁盘中读取一批消息后原封不动地写入网卡（NIC，Network interface controller）进行发送。</p><p>在没有任何优化技术使用的背景下，操作系统为此会进行 4 次数据拷贝，以及 4 次上下文切换，如下图所示：</p><p><img src="1.jpg" alt="NoOptimization"></p><p>如果没有优化，读取磁盘数据，再通过网卡传输的场景性能比较差：</p><p>4 次 copy：</p><ul><li>物理设备 &lt;-&gt; 内存：<ul><li>CPU 负责将数据从磁盘搬运到内核空间的 Page Cache 中；</li><li>CPU 负责将数据从内核空间的 Socket 缓冲区搬运到的网络中；</li></ul></li><li>内存内部拷贝：<ul><li>CPU 负责将数据从内核空间的 Page Cache 搬运到用户空间的缓冲区；</li><li>CPU 负责将数据从用户空间的缓冲区搬运到内核空间的 Socket 缓冲区中；</li></ul></li></ul><p>4 次上下文切换：</p><ol><li>read 系统调用时：用户态切换到内核态；</li><li>read 系统调用完毕：内核态切换回用户态；</li><li>write 系统调用时：用户态切换到内核态；</li><li>write 系统调用完毕：内核态切换回用户态；</li></ol><p>我们不免发出抱怨：</p><ol><li>CPU 全程负责内存内部的数据拷贝还可以接受，因为内存的数据拷贝效率还行（不过还是比 CPU 慢很多），但是如果要 CPU 全程负责内存与磁盘、内存与网卡的数据拷贝，这将难以接受，因为磁盘、网卡的 I/O 速度远小于内存；</li><li>4 次 copy 太多了，4 次上下文切换也太频繁了；</li></ol><h2 id="DMA-参与下的数据四次拷贝"><a href="#DMA-参与下的数据四次拷贝" class="headerlink" title="DMA 参与下的数据四次拷贝"></a>DMA 参与下的数据四次拷贝</h2><p>DMA 技术很容易理解，本质上，DMA 技术就是我们在主板上放一块独立的芯片。在进行内存和 I/O 设备的数据传输的时候，我们不再通过 CPU 来控制数据传输，而直接通过 DMA 控制器（DMA Controller，简称 DMAC）。这块芯片，我们可以认为它其实就是一个协处理器（Co-Processor）。</p><p>DMAC 的价值在如下情况中尤其明显：当我们要传输的数据特别大、速度特别快，或者传输的数据特别小、速度特别慢的时候。</p><p>比如说，我们用千兆网卡或者硬盘传输大量数据的时候，如果都用 CPU 来搬运的话，肯定忙不过来，所以可以选择 DMAC。而当数据传输很慢的时候，DMAC 可以等数据到齐了，再发送信号，给到 CPU 去处理，而不是让 CPU 在那里忙等待。</p><p><strong>注意</strong>：这里面的“协”字。DMAC 是在“协助”CPU，完成对应的数据传输工作。在 DMAC 控制数据传输的过程中，DMAC 还是被 CPU 控制，只是数据的拷贝行为不再由 CPU 来完成。</p><p>原本，计算机所有组件之间的数据拷贝（流动）必须经过 CPU。以磁盘读写为例，如下图所示：</p><p><img src="2.jpg" alt="image-20210202234430674"></p><p>现在，DMAC 代替了 CPU 负责内存与磁盘、内存与网卡之间的数据搬运，CPU 作为 DMAC 的控制者，如下图所示：</p><p><img src="3.jpg" alt="image-20210202234656779"></p><p>但是 DMAC 有其局限性，DMAC 仅仅能用于设备<strong>间</strong>交换数据时进行数据拷贝，但是<strong>设备内部的数据拷贝还需要 CPU 来亲力亲为</strong>。例如， CPU 需要负责内核空间与用户空间之间的数据拷贝（内存内部的拷贝），如下图所示：</p><p><img src="4.jpg" alt="image-20210202233454550"></p><p>上图中的 read buffer 也就是 page cache，socket buffer 也就是 Socket 缓冲区。</p><h2 id="3-零拷贝技术"><a href="#3-零拷贝技术" class="headerlink" title="3. 零拷贝技术"></a>3. 零拷贝技术</h2><h3 id="3-1-什么是零拷贝技术？"><a href="#3-1-什么是零拷贝技术？" class="headerlink" title="3.1 什么是零拷贝技术？"></a>3.1 什么是零拷贝技术？</h3><p>零拷贝技术是一个思想[3]，指的是指计算机执行操作时，CPU 不需要先将数据从某处内存复制到另一个特定区域。</p><p>可见，零拷贝的特点是 CPU 不全程负责内存中的数据写入其他组件，CPU 仅仅起到管理的作用。但注意，零拷贝不是不进行拷贝，而是 CPU 不再全程负责数据拷贝时的搬运工作。<font color=color>如果数据本身不在内存中，那么必须先通过某种方式拷贝到内存中（这个过程 CPU 可以仅仅负责管理，DMAC 来负责具体数据拷贝），因为数据只有在内存中，才能被转移，才能被 CPU 直接读取计算</font>。</p><p>零拷贝技术的具体实现方式有很多，例如：</p><ul><li>sendfile</li><li>mmap</li><li>直接 Direct I/O</li><li>splice</li></ul><p>不同的零拷贝技术适用于不同的应用场景，下面依次进行 sendfile、mmap、Direct I/O 的分析。</p><p>不过，我们不妨先在这里做一个前瞻性的技术总结。</p><ul><li>DMA 技术：DMA 负责内存与其他组件之间的数据拷贝，CPU 仅需负责管理，而无需负责全程的数据拷贝；</li><li>使用 page cache 的 zero copy：<ul><li>sendfile：一次代替 read/write 系统调用，通过使用 DMA 技术以及传递文件描述符，实现了 zero copy</li><li>mmap：仅代替 read 系统调用，将内核空间地址映射为用户空间地址，write 操作直接作用于内核空间。通过 DMA 技术以及地址映射技术，用户空间与内核空间无须数据拷贝，实现了 zero copy</li></ul></li><li>不使用 page cache 的 Direct I/O：读写操作直接在磁盘上进行，不使用 page cache 机制，通常结合用户空间的用户缓存使用。通过 DMA 技术直接与磁盘/网卡进行数据交互，实现了 zero copy</li></ul><h3 id="3-2-sendfile"><a href="#3-2-sendfile" class="headerlink" title="3.2 sendfile"></a>3.2 sendfile</h3><p>snedfile 的应用场景是：<strong>用户从磁盘读取一些文件数据后不需要经过任何计算与处理就通过网络传输出去</strong>。此场景的典型应用是消息队列。</p><p>在传统 I/O 下，正如第一节所示，上述应用场景的一次数据传输需要四次 CPU 全权负责的拷贝与四次上下文切换，正如本文第一节所述。</p><p>sendfile 主要使用到了两个技术：</p><ol><li>DMA 技术；</li><li>传递文件描述符代替数据拷贝；</li></ol><p>下面依次讲解这两个技术的作用。</p><p><strong>1.利用 DMA 技术</strong></p><p>sendfile 依赖于 DMA 技术，将四次 CPU 全程负责的拷贝与四次上下文切换减少到两次，如下图所示：</p><p><img src="5.jpg" alt="img"></p><blockquote><p>利用 DMA 技术减少 2 次 CPU 全程参与的拷贝</p></blockquote><p>DMA 负责磁盘到内核空间中的 Page cache（read buffer）的数据拷贝以及从内核空间中的 socket buffer 到网卡的数据拷贝。</p><p><strong>2.传递文件描述符代替数据拷贝</strong></p><p>传递文件描述可以代替数据拷贝，这是由于两个原因：</p><ul><li>page cache 以及 socket buffer 都在内核空间中；</li><li>数据在传输中没有被更新；</li></ul><p><img src="6.jpg" alt="img"></p><blockquote><p>利用传递文件描述符代替内核中的数据拷贝</p></blockquote><p><strong>注意事项</strong>：只有网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术才可以通过传递文件描述符的方式避免内核空间内的一次 CPU 拷贝。这意味着此优化取决于 Linux 系统的物理网卡是否支持（Linux 在内核 2.4 版本里引入了 DMA 的 scatter/gather – 分散/收集功能，只要确保 Linux 版本高于 2.4 即可）。</p><p><strong>3.一次系统调用代替两次系统调用</strong></p><p>由于 sendfile 仅仅对应一次系统调用，而传统文件操作则需要使用 read 以及 write 两个系统调用。</p><p>正因为如此，sendfile 能够将用户态与内核态之间的上下文切换从 4 次讲到 2 次。</p><p><img src="7.jpg" alt="sendfile"></p><blockquote><p>sendfile 系统调用仅仅需要两次上下文切换</p></blockquote><p>另一方面，我们需要注意 sendfile 系统调用的局限性。如果应用程序需要对从磁盘读取的数据进行写操作，例如解密或加密，那么 sendfile 系统调用就完全没法用。这是因为用户线程根本就不能够通过 sendfile 系统调用得到传输的数据。</p><h3 id="3-3-mmap"><a href="#3-3-mmap" class="headerlink" title="3.3 mmap"></a>3.3 mmap</h3><p>后面单独讲</p><h3 id="3-4-Direct-I-O"><a href="#3-4-Direct-I-O" class="headerlink" title="3.4 Direct I/O"></a>3.4 Direct I/O</h3><p>Direct I/O 即直接 I/O。其名字中的”直接”二字用于区分使用 page cache 机制的缓存 I/O。</p><ul><li>缓存文件 I/O：用户空间要读写一个文件并<strong>不直接</strong>与磁盘交互，而是中间夹了一层缓存，即 page cache；</li><li>直接文件 I/O：用户空间读取的文件<strong>直接</strong>与磁盘交互，没有中间 page cache 层；</li></ul><p>“直接”在这里还有另一层语义：其他所有技术中，数据至少需要在内核空间存储一份，但是在 Direct I/O 技术中，数据直接存储在用户空间中，绕过了内核。</p><p>Direct I/O 模式如下图所示：</p><p><img src="8.jpg" alt="directIO"></p><blockquote><p>Direct I/O 示意图</p></blockquote><p>此时用户空间直接通过 DMA 的方式与磁盘以及网卡进行数据拷贝。</p><p><strong>Direct I/O 的读写非常有特点</strong>：</p><ul><li>Write 操作：由于其不使用 page cache，所以其进行写文件，如果返回成功，数据就真的落盘了（不考虑磁盘自带的缓存）；</li><li>Read 操作：由于其不使用 page cache，每次读操作是真的从磁盘中读取，不会从文件系统的缓存中读取。</li></ul><p><strong>事实上，即使 Direct I/O 还是可能需要使用操作系统的 fsync 系统调用。为什么？</strong></p><p>这是因为虽然文件的数据本身没有使用任何缓存，但是文件的元数据仍然需要缓存，包括 VFS 中的 inode cache 和 dentry cache 等。</p><p>在部分操作系统中，在 Direct I/O 模式下进行 write 系统调用能够确保文件数据落盘，但是文件元数据不一定落盘。如果在此类操作系统上，那么还需要执行一次 fsync 系统调用确保文件元数据也落盘。否则，可能会导致文件异常、元数据确实等情况。MySQL 的 O_DIRECT 与 O_DIRECT_NO_FSYNC 配置是一个具体案例[9]。</p><p>Direct I/O 的优缺点：</p><p><strong>（1）优点</strong></p><ol><li>Linux 中的直接 I/O 技术省略掉缓存 I/O 技术中操作系统内核缓冲区的使用，数据直接在应用程序地址空间和磁盘之间进行传输，从而使得自缓存应用程序可以省略掉复杂的系统级别的缓存结构，而执行程序自己定义的数据读写管理，从而<strong>降低系统级别的管理对应用程序访问数据的影响</strong>。</li><li>与其他零拷贝技术一样，避免了内核空间到用户空间的数据拷贝，如果要传输的数据量很大，使用直接 I/O 的方式进行数据传输，而不需要操作系统内核地址空间拷贝数据操作的参与，这将会大大提高性能。</li></ol><p><strong>（2）缺点</strong></p><ol><li>由于设备之间的数据传输是通过 DMA 完成的，因此<strong>用户空间的数据缓冲区内存页必须进行 page pinning（页锁定）</strong>，这是为了防止其物理页框地址被交换到磁盘或者被移动到新的地址而导致 DMA 去拷贝数据的时候在指定的地址找不到内存页从而引发缺页错误，而页锁定的开销并不比 CPU 拷贝小，所以为了避免频繁的页锁定系统调用，应用程序必须分配和注册一个持久的内存池，用于数据缓冲。</li><li>如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘进行加载，这种直接加载会非常缓慢。</li><li>在应用层引入直接 I/O 需要应用层自己管理，这带来了额外的系统复杂性；</li></ol><p><strong>谁会使用 Direct I/O？</strong></p><p>IBM[5]的一篇文章指出，自缓存应用程序（ self-caching applications）可以选择使用 Direct I/O。</p><blockquote><p>自缓存应用程序</p><p>对于某些应用程序来说，它会有它自己的数据缓存机制，比如，它会将数据缓存在应用程序地址空间，这类应用程序完全不需要使用操作系统内核中的高速缓冲存储器，这类应用程序就被称作是自缓存应用程序（ self-caching applications ）。</p><p>例如，应用内部维护一个缓存空间，当有读操作时，首先读取应用层的缓存数据，如果没有，那么就通过 Direct I/O 直接通过磁盘 I/O 来读取数据。缓存仍然在应用，只不过应用觉得自己实现一个缓存比操作系统的缓存更高效。</p><p><strong>数据库管理系统是这类应用程序的一个代表</strong>。自缓存应用程序倾向于使用数据的逻辑表达方式，而非物理表达方式；当系统内存较低的时候，自缓存应用程序会让这种数据的逻辑缓存被换出，而并非是磁盘上实际的数据被换出。自缓存应用程序对要操作的数据的语义了如指掌，所以它可以采用更加高效的缓存替换算法。自缓存应用程序有可能会在多台主机之间共享一块内存，那么自缓存应用程序就需要提供一种能够有效地将用户地址空间的缓存数据置为无效的机制，从而确保应用程序地址空间缓存数据的一致性。</p><p>page cache 是 Linux 为所有应用提供的缓存机制，但是数据库应用太特殊了，page cache 影响了数据对特性的追求。</p></blockquote><p>另一方面，目前 Linux 上的异步 IO 库，其依赖于文件使用 O_DIRECT 模式打开，它们通常一起配合使用。</p><p><strong>如何使用 Direct I/O？</strong></p><p>用户应用需要实现用户空间内的缓存区，读/写操作应当尽量通过此缓存区提供。如果有性能上的考虑，那么尽量避免频繁地基于 Direct I/O 进行读/写操作。</p><h2 id="4-典型案例"><a href="#4-典型案例" class="headerlink" title="4. 典型案例"></a>4. 典型案例</h2><h3 id="4-1-Kakfa"><a href="#4-1-Kakfa" class="headerlink" title="4.1 Kakfa"></a>4.1 Kakfa</h3><p>Kafka 作为一个消息队列，涉及到磁盘 I/O 主要有两个操作：</p><ul><li>Provider 向 Kakfa 发送消息，Kakfa 负责将消息以日志的方式持久化落盘；</li><li>Consumer 向 Kakfa 进行拉取消息，Kafka 负责从磁盘中读取一批日志消息，然后再通过网卡发送；</li></ul><p>Kakfa 服务端接收 Provider 的消息并持久化的场景下使用 mmap 机制[6]，能够基于顺序磁盘 I/O 提供高效的持久化能力，使用的 Java 类为 java.nio.MappedByteBuffer。</p><p>Kakfa 服务端向 Consumer 发送消息的场景下使用 sendfile 机制[7]，这种机制主要两个好处：</p><ul><li>sendfile 避免了内核空间到用户空间的 CPU 全程负责的数据移动；</li><li>sendfile 基于 Page Cache 实现，因此如果有多个 Consumer 在同时消费一个主题的消息，那么由于消息一直在 page cache 中进行了缓存，因此只需一次磁盘 I/O，就可以服务于多个 Consumer；</li></ul><blockquote><p>使用 mmap 来对接收到的数据进行持久化，使用 sendfile 从持久化介质中读取数据然后对外发送是一对常用的组合。但是注意，你无法利用 sendfile 来持久化数据，利用 mmap 来实现 CPU 全程不参与数据搬运的数据拷贝。</p></blockquote><h3 id="4-2-MySQL"><a href="#4-2-MySQL" class="headerlink" title="4.2 MySQL"></a>4.2 MySQL</h3><p>MySQL 的具体实现比 Kakfa 复杂很多，这是因为支持 SQL 查询的数据库本身比消息队列对复杂很多。</p><p>MySQL 的零拷贝技术使用方式请移步我的另一篇文章[8]。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>DMA 技术使得内存与其他组件，例如磁盘、网卡进行数据拷贝时，CPU 仅仅需要发出控制信号，而拷贝数据的过程则由 DMAC 负责完成。</p><p>Linux 的零拷贝技术有多种实现策略，但根据策略可以分为如下几种类型：</p><ul><li><strong>减少甚至避免用户空间和内核空间之间的数据拷贝</strong>：在一些场景下，用户进程在数据传输过程中并不需要对数据进行访问和处理，那么数据在 Linux 的 <code>Page Cache</code> 和用户进程的缓冲区之间的传输就完全可以避免，让数据拷贝完全在内核里进行，甚至可以通过更巧妙的方式避免在内核里的数据拷贝。这一类实现一般是是通过增加新的系统调用来完成的，比如 Linux 中的 mmap()，sendfile() 以及 splice() 等。</li><li><strong>绕过内核的直接 I/O</strong>：允许在用户态进程绕过内核直接和硬件进行数据传输，内核在传输过程中只负责一些管理和辅助的工作。这种方式其实和第一种有点类似，也是试图避免用户空间和内核空间之间的数据传输，只是第一种方式是把数据传输过程放在内核态完成，而这种方式则是直接绕过内核和硬件通信，效果类似但原理完全不同。</li><li><strong>内核缓冲区和用户缓冲区之间的传输优化</strong>：这种方式侧重于在用户进程的缓冲区和操作系统的页缓存之间的 CPU 拷贝的优化。这种方法延续了以往那种传统的通信方式，但更灵活。</li></ul>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件IO与PageCache</title>
      <link href="/2022/09/25/IO-2022-09-25-%E6%96%87%E4%BB%B6IO%E4%B8%8EPageCache/"/>
      <url>/2022/09/25/IO-2022-09-25-%E6%96%87%E4%BB%B6IO%E4%B8%8EPageCache/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><p><img src="1.jpg" alt="WeChat3f9442a961bae5d63735680f0da3c7f9"></p><p>如上图，首先我们从图中得知两点:</p><ol><li>PageCache 是属于内核级别的，受到内核的管理</li><li>在用户态，用户可以使用mmap映射，直接访问PageCache，而不必进行内核态的切换。</li></ol><h2 id="PageCache"><a href="#PageCache" class="headerlink" title="PageCache"></a>PageCache</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>首先我们要了解一点，现在的内存管理方案中多数是分页管理，也就是内存会划分为4k一页作为一个基本单位。而pagecache呢通常也是4KB，用来缓存文件。提高IO的速度。</p><p><img src="2.jpg" alt="image-20220925160746941"></p><p>如上图演示的流程中，两个应用程序想使用同一个文件，其文件描述符对应的是同一个PC页，在内核层面并不关心是谁使用的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p> <strong>1.加快数据访问</strong></p><p>如果数据能够在内存中进行缓存，那么下一次访问就不需要通过磁盘 I/O 了，直接命中内存缓存即可。</p><p>由于内存访问比磁盘访问快很多，因此加快数据访问是 Page Cache 的一大优势。</p><p><strong>2.减少 I/O 次数，提高系统磁盘 I/O 吞吐量</strong></p><p>得益于 Page Cache 的缓存以及预读能力，而程序又往往符合局部性原理，因此通过一次 I/O 将多个 page 装入 Page Cache 能够减少磁盘 I/O 次数， 进而提高系统磁盘 I/O 吞吐量</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>​    page cache 也有其劣势，最直接的缺点是需要占用额外物理内存空间，物理内存在比较紧俏的时候可能会导致频繁的 swap 操作，最终导致系统的磁盘 I/O 负载的上升。</p><p>​    Page Cache 的另一个缺陷是对应用层并没有提供很好的管理 API，几乎是透明管理。应用层即使想优化 Page Cache 的使用策略也很难进行。因此一些应用选择在用户空间实现自己的 page 管理，而不使用 page cache，例如 MySQL InnoDB 存储引擎以 16KB 的页进行管理。</p><p>Page Cache 最后一个缺陷是在某些应用场景下比 Direct I/O 多一次磁盘读 I/O 以及磁盘写 I/O。</p><h3 id="JAVA的IO访问"><a href="#JAVA的IO访问" class="headerlink" title="JAVA的IO访问"></a>JAVA的IO访问</h3><p><img src="3.jpg" alt="未命名文件 (7)"></p><p>图中清晰的展示了 Java中访问文件使用的访问，要注意如下几点:</p><ol><li><p>jvm的堆再java的堆里. 堆内：说的jvm的堆里的字节数组,堆外：多的是jvm堆外，也就是java进程的堆里的</p></li><li><p>mapped映射：是mmap调用的一个进程和内核共享的内存区域,且这个内存区域是pagecache/到文件的映射速度上比较是:on heap &lt; off heap &lt; mapped (file)</p></li><li>应用层面 netty :on heap , off heap.  kafka log : mmap</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们简单的梳理了下PageCache的概念以及它在linux文件系统中起到的重要作用，需要读者有计算机组成原理的知识铺垫。PageCache是文件IO的基础，IO很多的优化都是在它基础之上的</p><blockquote><p>参考:<a href="https://www.bilibili.com/read/cv13132866a" target="_blank" rel="noopener">https://www.bilibili.com/read/cv13132866a</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象布局相关问题</title>
      <link href="/2022/09/25/jvm-2022-09-25-%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/25/jvm-2022-09-25-%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有关对象的创建、对象在内存中的布局，今天我们通过几道面试题来梳理一下。</p><h2 id="请解释一下对象的创建过程？"><a href="#请解释一下对象的创建过程？" class="headerlink" title="请解释一下对象的创建过程？"></a>请解释一下对象的创建过程？</h2><ol><li>class loading</li><li>class linking (verification, preparation, resolution) - 静态变量赋默认值</li><li>class initializing- 静态变量赋初始值</li><li>申请对象内存</li><li>成员变量赋默认值</li><li>调用构造方法<init><ol><li>成员变量顺序赋初始值</li><li>执行构造方法语句</li></ol></li></ol><h2 id="对象在内存中的存储布局？"><a href="#对象在内存中的存储布局？" class="headerlink" title="对象在内存中的存储布局？"></a>对象在内存中的存储布局？</h2><h3 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h3><ol><li>对象头：markword  8</li><li>ClassPointer指针：-XX:+UseCompressedClassPointers 为4字节 不开启为8字节</li><li>实例数据<ol><li>引用类型：-XX:+UseCompressedOops 为4字节 不开启为8字节<br>Oops Ordinary Object Pointers</li></ol></li><li>Padding对齐，8的倍数</li></ol><h3 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h3><ol><li>对象头：markword 8</li><li>ClassPointer指针同上</li><li>数组长度：4字节</li><li>数组数据</li><li>对齐 8的倍数</li></ol><h2 id="对象头具体包括什么？"><a href="#对象头具体包括什么？" class="headerlink" title="对象头具体包括什么？"></a>对象头具体包括什么？</h2><p><img src="1.jpg" alt="image-20220925122509859"></p><h2 id="对象怎么定位？"><a href="#对象怎么定位？" class="headerlink" title="对象怎么定位？"></a>对象怎么定位？</h2><ol><li>句柄池</li><li>直接指针</li></ol><p>​    参考:<a href="https://blog.csdn.net/clover_lily/article/details/80095580" target="_blank" rel="noopener">https://blog.csdn.net/clover_lily/article/details/80095580</a></p><h2 id="对象怎么分配？"><a href="#对象怎么分配？" class="headerlink" title="对象怎么分配？"></a>对象怎么分配？</h2><p><img src="2.jpg" alt="image-20220925143746967"></p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized锁升级过程</title>
      <link href="/2022/09/25/jvm-2022-09-25-Synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/09/25/jvm-2022-09-25-Synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Synchronized的经过优化之后，性能提高很多，接下来我们就看一下它的优化原理。</p><h2 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h2><p>Java的锁状态其实可以分为三种，分别是偏向锁，轻量级锁和重量级锁。</p><p>在Java HotSpot VM中，每个对象前面都有一个class指针和一个Mark Word。 Mark Word存储了哈希值以及分代年龄和标记位等，通过这些值的变化，JVM可以实现对java对象的不同程度的锁定。</p><p><img src="/Users/james/blogs/blog/source/_posts/2022-09-25-Synchronized锁升级过程/1.jpg" alt="img"></p><p>javaObject对象的对象头大小根据你使用的是32位还是64位的虚拟机的不同，稍有变化。这里我们使用的是64位的虚拟机为例。</p><p>Object的对象头，分为两部分，第一部分是Mark Word，用来存储对象的运行时数据比如：hashcode，GC分代年龄，锁状态，持有锁信息，偏向锁的thread ID等等。</p><p>在64位的虚拟机中，Mark Word是64bits，如果是在32位的虚拟机中Mark Word是32bits。</p><p>第二部分就是Klass Word，Klass Word是一个类型指针，指向class的元数据，JVM通过Klass Word来判断该对象是哪个class的实例。</p><p>我们可以看到对象头中的Mark Word根据状态的不同，存储的是不同的内容。</p><p>其中锁标记的值分别是：无锁=001，偏向锁=101，轻量级锁=000，重量级锁=010。</p><h2 id="java中锁状态的变化"><a href="#java中锁状态的变化" class="headerlink" title="java中锁状态的变化"></a>java中锁状态的变化</h2><p>为什么java中的锁有三种状态呢？其本质原因是为了提升锁的效率，因为不同情况下，锁的粒度是不一样的。</p><p>通过设置不同的锁的状态，从而可以不同的情况用不同的处理方式。</p><p>下图是java中的锁状态的变化图：</p><p><img src="4.jpg" alt="img"></p><p>上面的图基本上列出了java中锁状态的整个生命周期。接下来我们一个一个的讲解。</p><h2 id="偏向锁biased-locking"><a href="#偏向锁biased-locking" class="headerlink" title="偏向锁biased locking"></a>偏向锁biased locking</h2><p><font color=red>一般来说，一个对象被一个线程获得锁之后，很少发生线程切换的情况</font>。也就是说大部分情况下，一个对象只是被一个线程锁定的。</p><p>那么这个时候我们可以通过设置Mark word的一定结构，减少使用CAS来更新对象头的频率。</p><p>为了实现这样的目标，我们看下偏向锁的Mark word的结构：</p><p><img src="5.jpg" alt="img"></p><p>当偏向线程第一次进入同步块的时候，会去判断偏向锁的状态和thread ID，如果偏向锁状态是1，并且thread ID是空的话，将会使用CAS命令来更新对象的Mark word。</p><p>设置是否偏向锁=1，锁标记=01,线程ID设置为当前锁定该对象的线程。</p><p>下一次该对象进入同步块的时候，会先去判断锁定的线程ID和当前线程ID是否相等，如果相等的话则不需要执行CAS命令，直接进入同步块。</p><p>如果这个时候有第二个线程想访问该对象的同步块，因为当前对象头的thread ID是第一个线程的ID，跟第二个线程的ID不同。</p><p>如果这个时候线程1的同步块已经执行完毕，那么需要解除偏向锁的锁定。</p><p>解除锁定很简单，就是将线程ID设置为空，并且将偏向锁的标志位设为0，</p><p>如果这个时候线程1的同步块还在执行，那么需要将偏向锁升级为轻量级锁。</p><h2 id="轻量级锁thin-lock"><a href="#轻量级锁thin-lock" class="headerlink" title="轻量级锁thin lock"></a>轻量级锁thin lock</h2><p>先看下轻量级锁的结构：</p><p><img src="2.jpg" alt="img"></p><p>可以看到Mark word中存放的是栈中锁记录的指针和锁的标记=00。</p><p>如果对象现在处于未加锁状态，当一个线程尝试进入同步块的时候，会将把对象头和当前对象的指针拷贝一份，放在线程的栈中一个叫做lock record的地方。</p><p>然后JVM通过CAS操作，将对象头中的指针指向刚刚拷贝的lock record。如果成功，则该线程拥有该对象的锁。</p><p>实际上Lock Record和Mark word形成了一个互相指向对方的情况。</p><p>下次这个线程再次进入同步块的时候，同样执行CAS，比较Mark word中的指针是否和当前thread的lock record地址一致，如果一致表明是同一个线程，可以继续持有该锁。</p><p>如果这个时候有第二个线程，也想进入该对象的同步块，也会执行CAS操作，很明显会失败，因为对象头中的指针和lock record的地址不一样。</p><p>这个时候第二个线程就会自旋等待。</p><p>那么第一个线程什么时候会释放锁呢？</p><p>轻量级锁在线程退出同步块的时候，同样需要执行CAS命令，将锁标记从00替换成01，也就是无锁状态。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>如果第二个线程自旋时间太久，就会将锁标记替换成10（重量级锁），并且设置重量级锁的指针，指向第二个线程，然后进入阻塞状态。</p><p>当第一个线程退出同步块的时候，执行CAS命令就会出错，这时候第一个线程就知道锁已经膨胀成为重量级锁了。</p><p>第一个线程就会释放锁，并且唤醒等待的第二个线程。</p><p>第二个线程被唤醒之后，重新争夺锁。</p><p>我们看下重量级锁的结构：</p><p><img src="3.jpg" alt="img"></p><h2 id="三种锁状态的不同"><a href="#三种锁状态的不同" class="headerlink" title="三种锁状态的不同"></a>三种锁状态的不同</h2><p>偏向锁，轻量级锁和重量级锁到底有什么不同了？</p><p>这里总结一下，偏向锁下次进入的时候不需要执行CAS命令，只做线程ID的比较即可。</p><p>轻量级锁进入和退出同步块都需要执行CAS命令，但是轻量级锁不会阻塞，它使用的是自旋命令来获取锁。</p><p>重量级锁不使用自旋，但是会阻塞线程！</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized关键字原理</title>
      <link href="/2022/09/25/jvm-2022-09-25-Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/25/jvm-2022-09-25-Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    java聊到并发，synchronized关键字想必肯定是再熟悉不过了，它的使用非常简单，接下来我们就重点看一下使用时候的注意点和原理。</p><h2 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h2><ol><li>选用一个锁对象，可以是任意对象；</li><li>锁对象锁的是同步代码块，并不是自己；</li><li>不同类型的多个 Thread 如果有代码要同步执行，锁对象要使用所有线程共同持有的同一个对象；</li><li>需要同步的代码放到大括号中。需要同步的意思就是需要保证原子性、可见性、有序性中的任何一种或多种。不要放不需要同步的代码进来，影响代码效率。</li></ol><h2 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h2><h3 id="字节码实现"><a href="#字节码实现" class="headerlink" title="字节码实现"></a>字节码实现</h3><p>​    Synchronized在JVM里的实现都是基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p><p>​    <font color=red>monitorenter：每个对象都是一个监视器锁（monitor）</font>。</p><p>当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p><ol><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者;</li><li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；</li><li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</li></ol><p>monitorexit：执行monitorexit的线程必须是objectref所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。<br>monitorexit，指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；</p><p>通过上面描述，我们应该能很清楚的看出Synchronized的实现原理，<strong>Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，</strong>否则会抛出java.lang.IllegalMonitorStateException的异常的原因。<br>方法的同步：（加了Synchronized的方法）</p><p>​    两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p><h3 id="Mointor"><a href="#Mointor" class="headerlink" title="Mointor"></a>Mointor</h3><p>​    可以把它理解为 一个同步工具，也可以描述为 一种同步机制，它通常被 描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。也就是通常说Synchronized的对象锁，MarkWord锁标识位为10，其中指针指向的是Monitor对象的起始地址。在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）：</p><p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表（ 每个等待锁的线程都会被封装成<br>ObjectWaiter对象 ），_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时：</p><pre><code>1.    首先会进入 _EntryList 集合，当线程获取到对象的monitor后，进入 _Owner区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1； 2.    若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒； 3.    若当前线程执行完毕，也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)； 当多个线程同时请求某个对象锁时，对象锁会设置⼏种状态⽤来区分请求的线程： Contention List：所有请求锁的线程将被⾸先放置到该竞争队列 Entry List：Contention List中那些有资格成为候选⼈的线程被移到Entry List Wait Set：那些调⽤wait⽅法被阻塞的线程被放置到Wait Set OnDeck：任何时刻最多只能有⼀个线程正在竞争锁，该线程称为OnDeck Owner：获得锁的线程称为Owner !Owner：释放锁的线程 当⼀个线程尝试获得锁时，如果该锁已经被占⽤，则会将该线程封装成⼀个 ObjectWaiter 对象插⼊到Contention List的队列的队⾸，然后调⽤ park 函数挂起当前线程。</code></pre><p>当线程释放锁时，会从Contention List或EntryList中挑选⼀个线程唤醒，被选中的线程叫做 Heir presumptive 即假定继承⼈，假定继承⼈被唤醒后会尝试获得锁，但 synchronized 是⾮公平的，所以假定继承⼈不⼀定能获得锁。这是因为对于重量级锁，线程先⾃旋尝试获得锁，这样做的⽬的是为了减少执⾏操作系统同步操作带来的开销。如果⾃旋不成功再进⼊等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有⼀个不公平的地⽅是⾃旋线程可能会抢占了Ready线程的锁。线程获得锁后调⽤ Object.wait ⽅法，则会将线程加⼊到WaitSet中，当被 Object.notify 唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调⽤⼀个锁对象的 wait 或 notify ⽅法时，如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁。</p><p>同时，Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式<br>获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时notify/notifyAll/wait等方法会使用到Monitor锁对象，所以必须在同步代码块中使用。监视器Monitor有两种同步方式：互斥与协作。多线程环境下线程之间如果需要共享数据，需要解决互斥访问数据的问题，监视器可以确保监视器上的数据在同一时刻只会有一个线程在访问。</p><h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><ol><li>synchronized 使用的为非公平锁，如果你需要公平锁，那么不要使用 synchronized。可以使用 ReentrantLock，设置为公平锁。关于 ReentrantLock。</li><li>锁对象不能为 null。如果锁对象为 null，何谈对象头，以及保存与其关联的 monitor 锁呢？所以代码中要确保synchronized使用的锁对象不为 null；</li><li>只把需要同步的代码放入 synchronized 代码块。如果不思考，为了线程安全把方法中全部代码都放入同步代码块，那么将会丧失多线程的优势。再多的线程也只能串行执行，这完全违背了并发的初衷；</li><li>只有使用同一个对象作为锁对象，才能同步。记住是同一个对象，而不是同一个类。有一种常犯的错误是，不同线程持有的是同一个类的不同实例。那么该对象实例用作锁对象的话，多个线程并不会同步。还一种错误是使用不同类的实例作为锁对象，但是期望不同位置的同步代码块能够同步执行。这是不可能达到你想要的效果的。</li></ol><blockquote><p>参考:<a href="https://www.cnblogs.com/freelancy/p/15625602.html" target="_blank" rel="noopener">https://www.cnblogs.com/freelancy/p/15625602.html</a></p><p>​        <a href="https://www.jianshu.com/p/b624ca34fee2" target="_blank" rel="noopener">https://www.jianshu.com/p/b624ca34fee2</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile与可见性</title>
      <link href="/2022/09/25/jvm-2022-09-25-volatile%E4%B8%8E%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
      <url>/2022/09/25/jvm-2022-09-25-volatile%E4%B8%8E%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>​    可见性指的是，某个线程对共享变量进行了修改，其它线程能够立刻看到修改后的最新值。乍一听这个定义，你可能会觉得这不是废话吗？变量被修改了，线程当然能够立刻读取到！否则即使单线程的程序也会出问题啊！没错，变量被修改后，在本线程中确实能够立刻被看到，但并不保证别的线程会立刻看到。原因就是编程领域经典的两大难题之一——缓存一致性。</p><h2 id="观察可见性"><a href="#观察可见性" class="headerlink" title="观察可见性"></a>观察可见性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">visibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowVisibility</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">private</span> Boolean flag = <span class="keyword">false</span>; </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+flag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ShowVisibility showVisibility = <span class="keyword">new</span> ShowVisibility();</span><br><span class="line">        Thread blindThread = <span class="keyword">new</span> Thread(showVisibility);</span><br><span class="line">         blindThread.start();</span><br><span class="line">        <span class="comment">//给线程启动的时间</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//更新flag</span></span><br><span class="line">        showVisibility.flag=<span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"flag is true, thread should print"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"I have slept 1 seconds. I guess there was nothing printed "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，ShowVisibility 实现 Runnable 接口，在 run 方法中判断成员变量 flag 值为 true 时进行打印。main 方法中通过 showVisibility 对象启动一个线程。主线程等待 0.5 秒后，改变 showVisibility 中 flag 的值为 true。按正常思路，此时 blindThread 应该开始打印。但是，实际情况并非如此。运行此程序，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag is <span class="keyword">true</span>, thread should print</span><br><span class="line">I have slept <span class="number">1</span> seconds. I guess there was nothing printed</span><br></pre></td></tr></table></figure><p>没错，flag 改为 true 后，blindThread 没有任何打印。也就是说 blindThread 并没有观察到到 flag 的值变化。</p><p>如果是单线程程序，做了一个变量的修改，那么程序是立即就能看到的。然而在多线程程序中并非如此。原因是 CPU 为提高计算的速度，使用了缓存。</p><h2 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h2><p>​    大家一定都知道摩尔定律。根据定律，CPU 每 18 个月速度将会翻一番。CPU 的计算速度提升了，但是内存的访问速度却没有什么大幅度的提升。这就好比一个脑瓜很聪明程序员，接到需求后很快就想好程序怎么写了。但是他的电脑性能很差，每敲一行代码都要反应好久，导致完成编码的时间依旧很长。所以人再聪明没有用，瓶颈在计算机的速度上。CPU 计算也是同样的道理，瓶颈出现在对内存的访问上。没关系，我们可以使用缓存啊，这已经是路人皆知的手段了。CPU 更狠一点，用了 L1、L2、L3，一共三级缓存。其中 L1 缓存根据用途不同，还分为 L1i 和 L1d 两种缓存。如下图：</p><p>​                                    <img src="1.jpg" alt="图片描述"></p><p>​    缓存的访问速度是主存的几分之一，甚至几十分之一。通过缓存，极大的提高了 CPU 计算速度。CPU 会先从主存中复制数据到缓存，CPU 在计算的时候就可以从缓存读取数据了，在计算完成后再把数据从缓存更新回主存。这样在计算期间，就无须访问主存了，速度大大提升。加上缓存后，CPU 的数据访问如下：</p><p><img src="2.jpg" alt="图片描述"></p><p>​    我们再回头看上文的例子。blindThread 线程启动后，就进入 while 循环中，一直进行运算，运算时把 flag 从主存拿到了自己线程中的缓存，此后就会一直从缓存中读取 flag 的值。即便是main线程修改了 flag 的值。但是 blindThread 线程的缓存并未更新，所以取到的还一直是之前的值。导致 blindThread 线程一致也不会有输出。</p><h2 id="Volatile作用"><a href="#Volatile作用" class="headerlink" title="Volatile作用"></a>Volatile作用</h2><p>​    要想解决可见性问题其实很简单。第一种方法就是解决一切并发问题的方法–同步。不过读和写都需要同步。</p><p>​    此外还有一个方法会简单很多，使用 volatile 关键字。</p><p>​    我们把例子中下面这行代码做一下修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Boolean flag = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Boolean flag = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>这样就可以正确输出了。</p><p>Volatile的原理前面的文章已经解释过，就不再重复了，它的作用可以总结如下:</p><ul><li>解决可见性问题</li><li>解决有序性问题</li></ul><p>有关有序性，之前的文章也解释了，这里我们再给出一道面试题来回顾下：</p><p>​    单例模式中，单例对象是否需要加Volatile关键字？</p><p>答案是需要的。因为new 一个对象实际上是细分了3个步骤：</p><ol><li>申请内存</li><li>初始化内存</li><li>赋值变量</li></ol><p>而一旦发生乱序，并发来的线程就可能拿到一个未被初始化过的单例对象，会发生错误。尽管这种可能性比较低，但问题确实存在的。这也称为“对象逃逸”问题。</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序性与内存屏障</title>
      <link href="/2022/09/24/jvm-2022-09-24-%E6%9C%89%E5%BA%8F%E6%80%A7%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
      <url>/2022/09/24/jvm-2022-09-24-%E6%9C%89%E5%BA%8F%E6%80%A7%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="并发三大特性"><a href="#并发三大特性" class="headerlink" title="并发三大特性"></a>并发三大特性</h2><p>所有讲并发编程的书籍都会讲到并发编程的三大特性，这是并发编程中所有问题的根源，我们只有深刻理解了这三大特性，才不会编写出漏洞百出的并发程序，才不会遇到问题时无从下手，才不会对自己的程序没有信心。</p><p>这三大特性是：</p><ol><li>原子性 : 所有操作要么全部成功，要么全部失败。</li><li><p>可见性: 一个线程对变量进行了修改，另外一个线程能够立刻读取到此变量的最新值。</p></li><li><p>有序性: 代码在执行阶段，并不一定和你的编写顺序一致。</p></li></ol><p>​    其中原子性比较简单，熟悉事务ACID的都清楚，事务最重要的就是原子性，可见性暂时跳过，我们日后在谈，这次我们重点来分析有序性问题，这个是相对较难的地方。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>学习过计算机组成原理的同学都知道，cpu为了提高效率，指令的执行并不是一条指令执行完成之后再执行下一条，而是采用流水线的方式执行的。第一条执行在读取内存的过程中，这个等待的时间就可以进行第二条执行了，也就是说发生了乱序或者叫做指令的重排。这种优化，对于单线程是没问题的，因为优化的前提一定是不能影响结果的正确输出，但对于多线程而言就不太友好了。</p><p><img src="1.jpg" alt=""></p><p>往上有一个美团工程师给出的一个实验，可以观察出乱序问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Disorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; Long.MAX_VALUE; i++) &#123;</span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">            b = <span class="number">0</span>;</span><br><span class="line">            CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">            Thread one = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    a = <span class="number">1</span>;</span><br><span class="line">                    x = b;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread other = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    b = <span class="number">1</span>;</span><br><span class="line">                    y = a;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            one.start();</span><br><span class="line">            other.start();</span><br><span class="line">            latch.await();</span><br><span class="line">            String result = <span class="string">"第"</span> + i + <span class="string">"次 ("</span> + x + <span class="string">","</span> + y + <span class="string">"）"</span>;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                System.err.println(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实验中，我们可以分析一下，理论上是不会出现x=0,y=0的情况，但只要多次运行，确实会发现有这个情况。也就证明了乱序。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>我们前面观察到了乱序的问题，这种乱序在多线程的时候可能会出问题的，那么如何解决呢？首先我们要知道volatile是可以解决有序性的问题，其实它的原理也是内存屏障。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>我们要解决乱序问题，说白了就是 我们想办法让你先后执行的两条执行就应该串行执行。而不应该打破原来的顺序。最简单的方法就是加锁。第一条指令执行的时候，直接锁定相关的区域，第二条指令想要执行只能等。但cpu为了提高执行顺序，通常会采用内存屏障。</p><p><font color=red>内存屏障</font>就是说，加这么一道指令，屏障前的指令不能跑到屏障后，屏障后的指令也不能在屏障前执行。</p><h3 id="cpu保障有序性"><a href="#cpu保障有序性" class="headerlink" title="cpu保障有序性"></a>cpu保障有序性</h3><p>不同的cpu有不同的实现，这里我们还是以intel的x86为例</p><h4 id="X86-CPU内存屏障"><a href="#X86-CPU内存屏障" class="headerlink" title="X86 CPU内存屏障:"></a>X86 CPU内存屏障:</h4><p>sfence:在sfence指令前的写操作当必须在sfence指令后的写操作前完成。</p><p>lfence：在lfence指令前的读操作当必须在lfence指令后的读操作前完成。 </p><p>mfence：在mfence指令前的读写操作当必须在mfence指令后的读写操 作前完成。</p><h4 id="intel-lock汇编指令"><a href="#intel-lock汇编指令" class="headerlink" title="intel lock汇编指令"></a>intel lock汇编指令</h4><p>​    原子指令，如x86上的”lock …” 指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺 序，甚至跨多个CPU。Software Locks通常使用 了内存屏障或原子指令来实现变量可见性和保持 程序顺序</p><h3 id="JVM内存屏障"><a href="#JVM内存屏障" class="headerlink" title="JVM内存屏障"></a>JVM内存屏障</h3><p>在JVM层面,我们看到的也仅仅是JVM规范中提的，不同的JVM有不同的实现。</p><p>JSR内存屏障:</p><ul><li><p>LoadLoad屏障： 对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p></li><li><p>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p></li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</li></ul><h3 id="Volatile的实现"><a href="#Volatile的实现" class="headerlink" title="Volatile的实现"></a>Volatile的实现</h3><h4 id="编译器层面"><a href="#编译器层面" class="headerlink" title="编译器层面"></a>编译器层面</h4><p><img src="2.jpg" alt="image-20220925000504998"></p><p>可以看到volatile关键字编译完之后，在字节码的体现是在修饰符上。</p><h4 id="JVM层面"><a href="#JVM层面" class="headerlink" title="JVM层面"></a>JVM层面</h4><p>在JVM层面是通过内存屏障:</p><p>写操作:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StoreStoreBarrier</span><br><span class="line">volatile 写操作</span><br><span class="line">StoreLoadBarrier</span><br></pre></td></tr></table></figure><p>读操作:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadLoadBarrier</span><br><span class="line">volatile 读操作</span><br><span class="line">LoadStoreBarrier</span><br></pre></td></tr></table></figure><h4 id="操作系统硬件层面"><a href="#操作系统硬件层面" class="headerlink" title="操作系统硬件层面"></a>操作系统硬件层面</h4><p>想要观察在硬件层面是如何做的，就需要查看字节码对应的汇编指令，看看是使用什么cpu指令来保证有序的。操作过程比较复杂，可以参考博客：<a href="https://www.cnblogs.com/xrq730/p/7048693.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/7048693.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000000002931351</span>: lock add dword ptr [rsp],<span class="number">0</span>h  ;*putstatic instance</span><br><span class="line">                                               ; - org.xrq.test.design.singleton.LazySingleton::getInstance@<span class="number">13</span> (line <span class="number">14</span>)</span><br></pre></td></tr></table></figure><p>最终结论是: 依靠Lock 指令。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    对于有序性的解决，对cpu而言，可能会使用cpu的内存屏障或者lock指令，在JVM层面，也有相应的内存屏障。不同的的cpu有不同的实现，不同的JVM由于不同的实现，所以比较复杂 不能一概而论。但是 我们一定要注意一点，就是区分层次来看。</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMM与缓存一致性</title>
      <link href="/2022/09/24/jvm-2022-09-24-JMM%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2022/09/24/jvm-2022-09-24-JMM%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    随着CPU的不断发展，CPU的性能越来越强大，但受迫于频率提升的困难，现代CPU架构开始向多核发展。而作为软件开发人员为了充分使用CPU的性能，越来越多的开发者会选择多线程程序开发。CPU在计算时会做一些优化，这些优化对于单线程程序来说是没有问题的，但对多线程程序则不是那么的友好。接下来我们就从硬件底层来看一下硬件对多线程并发的影响。</p><h2 id="硬件层的并发优化"><a href="#硬件层的并发优化" class="headerlink" title="硬件层的并发优化"></a>硬件层的并发优化</h2><p>首先，我们来看一下硬件上的优化。</p><p><img src="1.jpg" alt="image-20220924223108249"></p><p>   首先要清楚，cpu的计算速度要远快于内存的工作速度，这也是各种引入各种缓存的原因，要尽可能节约cpu的宝贵时间。</p><p>​    <img src="2.jpg" alt="image-20220924223301679"></p><h2 id="Cache-Line"><a href="#Cache-Line" class="headerlink" title="Cache Line"></a>Cache Line</h2><p>​    此外，我们要清楚,缓存是以缓存行为单位出现的，也就是说每次缓存是缓存一个line，目前是64字节。那么，也就是说，两个变量可能会位于一个cache line，如下图:</p><p>​    <img src="3.jpg" alt="image-20220924223703696"></p><h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><p>​    缓存与一致性是分不开的。比如在上图中,cpu1 使用X变量，cpu2 使用Y变量，而cpu1修改了x变量，那么尽管cpu2关心的是变量Y，但由于缓存了与cpu1同样的cache line，为了避免产生不一致（X变量不一致)，就只能使得cpu2的缓存行失效，这时当cpu2读y变量时候发现缓存失效，不得已只能重新加载y变量。产生效率问题，这就是伪共享问题。</p><p>​    伪共享问题，是由于变量所在cache line 被其它变量影响导致失效造成的，那么就可以通过填充，让我们所使用的这个变量独自占用一个cache line来解决。</p><p>​    下图为Distuptor在解决伪共享问题时，对指针的填充.</p><p><img src="4.jpg" alt="image-20220924224539355"></p><h3 id="写合并"><a href="#写合并" class="headerlink" title="写合并"></a>写合并</h3><p>写合并也是为了提高效率的一种技术。比如当cpu 计算完一个值，需要写入缓存中，首先看L1，发现L1没有命中，就继续往L2写，但是L2可能写的比较慢，写这一次L2，可能这个值被修改好多次了，所以在L1和cpu之间加了一个缓存，就是为了把这几次的修改结果进行合并。</p><p><img src="5.jpg" alt="image-20220924225056785"></p><h2 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h2><p>使用缓存必然会带来一致性的问题，cache line 一致性的解决 大概有两种解决方案:总线锁、缓存锁</p><h3 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h3><p>总线锁比较简单，就是说，我在L2和L3之间加个锁，我cpu1使用的时候，我对cache line加锁，其它cpu不可以访问，这叫总线锁。但是尽管我使用x变量，其它cpu使用y变量依然无法访问缓存。所以这种效率比较低，是老cpu使用的。</p><p><img src="6.jpg" alt="image-20220924225645716"></p><h3 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h3><p>现代的cpu 会使用各种一致性协议来解决这个问题，有MSI、MESI、MOSI等，其中由于Intel 使用MESI，所以我们重点关注一下MESI协议。</p><p><img src="7.jpg" alt="image-20220924230053395"></p><p>MESI协议中的几种状态:</p><p><img src="8.jpg" alt="image-20220924230455970"></p><p>更多的有关MESI协议的内容，可以参考一下这篇文章:<a href="http://t.zoukankan.com/cherish010-p-8602635.html" target="_blank" rel="noopener">http://t.zoukankan.com/cherish010-p-8602635.html</a></p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class加载过程</title>
      <link href="/2022/09/24/jvm-2022-09-24-Class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/09/24/jvm-2022-09-24-Class%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="3.jpg" alt="image-20220924220503969">    </p><p>在java中当我们使用某个类的时候，首先做的就是把.class文件从硬盘中加载到内存中，这一步称为加载的过程，但实际上，要做的工作不止这一些，接下来我们看一下，在一个类被使用前要做哪些准备工作呢。</p><h2 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>全盘负责：当一个类加载器加载一个类时，该类所依赖的其他类也会被这个类加载器加载到内存中。</li><li><p>缓存机制：所有的Class对象都会被缓存，当程序需要使用某个Class时，类加载器先从缓存中查找，找不到，才从class文件中读取数据，转化成Class对象，存入缓存中。</p></li><li><p>双亲委派机制</p></li></ol><h4 id="类加载器层级"><a href="#类加载器层级" class="headerlink" title="类加载器层级"></a>类加载器层级</h4><p><img src="1.jpg" alt="image-20220924213851042"></p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>​    Java虚拟机对class文件采用的是按需加载的方式,也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时, Java虚拟机采用的是双亲委派模式,即把请求交由父类处理,它是一种任务委派模式。如下图所示:</p><p><img src="2.jpg" alt="img"></p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><ol><li>继承ClassLoader</li><li>重写findClass方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"/Users/james/Desktop/Hello.class"</span>);</span><br><span class="line"></span><br><span class="line">            FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">            ByteArrayOutputStream out = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!((size = in.read(buffer)) != -<span class="number">1</span>))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    out.write(buffer, <span class="number">0</span>, size);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes = out.toByteArray();</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader l = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        System.out.println(l.getParent());</span><br><span class="line"></span><br><span class="line">        Class clazz = l.loadClass(<span class="string">"com.zxd.jvm.Hello"</span>);</span><br><span class="line">        Class clazz1 = l.loadClass(<span class="string">"com.zxd.jvm.Hello"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz == clazz1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h3><p>尽管我们自定义了classloader，但实际我们只是重写了findclass方法，在我们使用的时候，调用的还是父类的loadclass方法，也就是说 loadclass方法中规定了加载类的步骤和流程，而 我们只是实现这个流程中要用的某一个方法，这叫模版方法设计模式。自然我们也就明白来，重写findClass方法并不会打破双亲委派。而重写classLoad方法，也就是重写设定这个加载类的流程才会打破这个机制。摘录核心源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当然一般情况下我们并不需要重写loadClass方法，那什么时候需要呢？</p><ol><li>在JDK1.2之前,在自定义类加载器时,总会去继承ClassLoader类并重写loadClass ()方法,从而实现自定义的类加载类,但是在JDK1.2之后已不再建议用户去覆盖loadClass ()方法,而是建议把自定义的类加载逻辑写在findClass ()方法中</li><li>像一些热加载的功能，代码改了之后，能自动重新load class文件，实际上，一旦load之后 加入缓存，就不会再加载了，那我们就必须打破这个过程。</li></ol><h2 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h2><p>链接又分为3个过程:</p><ol><li>Verification<ol><li>验证文件是否符合JVM规定</li></ol></li><li>Preparation<ol><li>静态成员变量赋默认值</li></ol></li><li>Resolution<ol><li>将类、方法、属性等符号引用解析为直接引用<br>常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用</li></ol></li></ol><h2 id="Initializing"><a href="#Initializing" class="headerlink" title="Initializing"></a>Initializing</h2><p>​    调用类初始化代码，给静态成员变量赋初始值</p><blockquote><p>引用:<a href="https://blog.csdn.net/m0_37450089/article/details/119962669" target="_blank" rel="noopener">https://blog.csdn.net/m0_37450089/article/details/119962669</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC包下的新型锁</title>
      <link href="/2022/09/23/JUC-2022-09-23-JUC%E5%8C%85%E4%B8%8B%E7%9A%84%E6%96%B0%E5%9E%8B%E9%94%81/"/>
      <url>/2022/09/23/JUC-2022-09-23-JUC%E5%8C%85%E4%B8%8B%E7%9A%84%E6%96%B0%E5%9E%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    可重入锁，就是拿到锁之后，还可以对此锁再拿一次，一层一层的加，synchronized本身就是可重入锁的一种</p><h3 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h3><ul><li>可以代替synchronied关键字，只需要在使用synchronized关键字的地方使用lock.lock()方法</li><li>synchronized关键字是自动解锁的，但是reen必须手动解锁</li><li>特别注意对于异常的处理，sync遇到异常jvm就手动释放了，reen一定要在finally里手动解开</li></ul><h3 id="与Synchronized相比的优势"><a href="#与Synchronized相比的优势" class="headerlink" title="与Synchronized相比的优势"></a>与Synchronized相比的优势</h3><ul><li>ryLock方法尝试拿锁，不管拿不拿到都能执行下去，而sync一旦拿不到就阻塞了</li><li>lockInterruptibly()可以对interrupt()方法做出响应,sync不受影响</li><li>true公平锁，可以指定不公平或者公平；sync只有不公平</li></ul><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>就是一个类似门栓的东西，定义一个初始值，每次减1，减到0，就可以放行，说白了，就是用来等待线程结束用的，可以用join方法，但它更灵活，它可以在一个线程里面铛铛铛的就减掉，可以用来做其它功能。</p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><ul><li>countDown()</li><li>await()</li></ul><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>​    类似CountDownLatch，定义三个线程，谁先干完，谁等着，满够三个(三个都调用await等着了)，再放行，不断循环这个过程</p><h3 id="核心方法-1"><a href="#核心方法-1" class="headerlink" title="核心方法"></a>核心方法</h3><p>​    await()</p><h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>​    就是CyclicBarrier的升级版，CyclicBrrier是一个栅栏循环执行，而phaser是一个一个的栅栏往前走</p><h3 id="核心方法-2"><a href="#核心方法-2" class="headerlink" title="核心方法"></a>核心方法</h3><ul><li>arriveAndAwaitAdvance()</li><li>arriveAndDeregister()</li><li>register()</li></ul><h3 id="举例：遗传算法"><a href="#举例：遗传算法" class="headerlink" title="举例：遗传算法"></a>举例：遗传算法</h3><ul><li>遗传算法有明显的阶段性</li></ul><h2 id="readwritelock（读写锁）"><a href="#readwritelock（读写锁）" class="headerlink" title="readwritelock（读写锁）"></a>readwritelock（读写锁）</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>​    共享锁+排它锁，读是共享的，写时排它，可以提高效率，毕竟读要占多数</p><h2 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>​    信号量机制，pv操作，操作系统常用的,初始值代表可用资源个数</p><h3 id="核心方法-3"><a href="#核心方法-3" class="headerlink" title="核心方法"></a>核心方法</h3><ul><li>acquire()</li><li>release()</li></ul><h2 id="exchanger"><a href="#exchanger" class="headerlink" title="exchanger"></a>exchanger</h2><p>​    两两交换：线程间通信的一种方式</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>我们简单总结了下，juc包下的一些锁，但实际上这些锁用的比较少，要求不高的话一般还是直接用synchronized关键词就可以了。主要是了解这些锁的作用，真有需要可以再看一下API。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atomic类与CAS分析</title>
      <link href="/2022/09/23/JUC-2022-09-23-Atomic%E7%B1%BB%E4%B8%8ECAS%E5%88%86%E6%9E%90/"/>
      <url>/2022/09/23/JUC-2022-09-23-Atomic%E7%B1%BB%E4%B8%8ECAS%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Atomic-简介"><a href="#Atomic-简介" class="headerlink" title="Atomic 简介"></a>Atomic 简介</h2><p>Atomic 相关类在 java.util.concurrent.atomic 包中。针对不同的原生类型及引用类型，有 AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference 等。另外还有数组对应类型 AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray。由于 Atomic 提供的功能类似，就不一个个过了。我们以 AtomicInteger 为例，看看 Atomic 类型变量所能提供的功能。</p><p>我们先看一个简单的例子，运算逻辑是对变量 count 的累加。假如 count 为 int 类型，多个线程并发时，可能各自读取到了同样的值，也可能 A 线程读到 2，但由于某种原因更新晚了，count 已经被其它线程更新为了 4，但是线程 A 还是继续执行了 count+1 的操作，count 反而被更新为更小的值 3。现在的多线程程序是不安全的。要处理此问题，按照我们已经学习过的知识，需要把 count=count+1 放入 synchronized 代码块中。这样做肯定能够解决问题。但是这种同步操作是悲观锁的方式，每次都认为有其它线程在和它并发操作，所以每次都要对资源进行锁定，而加锁这个操作自身就有很大消耗。而且不是每一次 count+1 时都有并发发生，无并发发生时的加锁并无必要。直接用 synchronized 进行同步，效率并不高。</p><p>下面我们看看怎么用 AtomicInteger 解决这个问题。使用 AtomicInteger 很简单，我们在声明 count 的时候，将其声明为 AtomicInteger 即可，然后把 count=count+1 的语句改为 count.incrementAndGet ()。问题就完美解决了。</p><p>接下来我们看看 Atomic 实现原子操作的原理。我们首先看看 AtomicInteger 的 incrementAndGet 方法注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>可以看到此方法以原子操作在当前 value 上加 1。count=count+1 这行语句其实隐含了两步操作，第一步取得 count 的值，第二步为 count 加 1 。而在这两步操作中间，count 的值可能已经改变了。而 AtomicInteger 提供的 incrementAndGet () 方法，则把这两步操作作为一个原子性操作来完成，则不会出现线程安全问题。</p><p>Atomic 变量的操作是如何保证原子性的呢？其实是使用了 CAS 算法。</p><h2 id="CAS-算法分析"><a href="#CAS-算法分析" class="headerlink" title="CAS 算法分析"></a>CAS 算法分析</h2><p>CAS 是 Compare and swap 的缩写，翻译过来就是比较替换。其实 CAS 是乐观锁的一种实现。而 Synchronized 则是悲观锁。这里的乐观和悲观指的是当前线程对是否有并发的判断。</p><p><font color = red>悲观锁–认为每一次自己的操作大概率会有其它线程在并发，所以自己在操作前都要对资源进行锁定，这种锁定是排他的。悲观锁的缺点是不但把多线程并行转化为了串行，而且加锁和释放锁都会有额外的开支</font>。</p><p><font color=red>乐观锁–认为每一次操作时大概率不会有其它线程并发，所以操作时并不加锁，而是在对数据操作时比较数据的版本，和自己更新前取得的版本一致才进行更新。乐观锁省掉了加锁、释放锁的资源消耗，而且在并发量并不是很大的时候，很少会发生版本不一致的情况，此时乐观锁效率会更高</font>。</p><p>Atomic 变量在做原子性操作时，会从内存中取得要被更新的变量值，并且和你期望的值进行比较，期望的值则是你要更新操作的值。如果两个值相等，那么说明没有其它线程对其更新，本线程可以继续执行。如果不等，说明有线程已经先于此线程进行了更新操作。那么则继续取得该变量的最新值，重复之前的逻辑，直至操作成功。这保证了每个线程对 Atomic 变量操作是线程安全的。</p><h2 id="Atomic-源代码分析"><a href="#Atomic-源代码分析" class="headerlink" title="Atomic 源代码分析"></a>Atomic 源代码分析</h2><p>下面我们看看 AtomicInteger 的源代码。首先，AtomicInteger 中有 3 个重要的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>第一个 Unsafe 对象，Atomic 中的原子操作都是借助 unsafe 对象所实现的；</p><p>第二个是 AtomicInteger 包装的变量在内存中的地址；</p><p>第三个是 AtomicInteger 包装的变量值，并且用 volatile 修饰，以确保变量的变化能被其它线程看到。</p><p>其实 valueOffset 就是 value 的内存地址</p><p>AtomicInteger 中有一段静态代码块如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中 unsafe 对象获取了 AtomicInteger 类中 value 这个字段的 offset。unsafe.objectFieldOffset () 是一个 native 的方法。</p><p>AtomicInteger 有一个构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到对它所包装的 int 变量 value 进行了赋值。</p><p>通过以上分析，我们来总结一下目前对 AtomicInteger 的了解：</p><ul><li>AtomicInteger 对象包装了通过构造函数传入的一个初始 int 值；</li><li>AtomicInteger 持有这个 int 变量的内存地址；</li><li>AtomicInteger 还有一个用来做原子性操作的 unsafe 对象。</li></ul><p>接下来我们以文章前面提到的 incrementAndGet 方法为例，来看看 Atomic 原子性的实现。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，调用了 <em>unsafe</em>.getAndAddInt(this, <em>valueOffset</em>, 1) 后，对其返回 +1，然后 return。</p><p>那么原子性实现的秘密就全在 <em>unsafe</em>.getAndAddInt () 这个方法中了。随便翻看一下 AtomicInteger 的源代码，这个方法被各种调用，其实我们搞清楚 <em>unsafe</em>.getAndAddInt () 的实现，谜底也就揭晓了。我们继续看 <em>unsafe</em>.getAndAddInt () 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object obj, <span class="keyword">long</span> valueOffset, <span class="keyword">int</span> <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expect;</span><br><span class="line">        <span class="comment">// 利用循环，直到更新成功才跳出循环。</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 获取value的最新值</span></span><br><span class="line">            expect = <span class="keyword">this</span>.getIntVolatile(obj, valueOffset);</span><br><span class="line">            <span class="comment">// expect + var表示需要更新的值，如果compareAndSwapInt返回false，说明value值被其他线程更改了。</span></span><br><span class="line">            <span class="comment">// 那么就循环重试，再次获取value最新值expect，然后再计算需要更新的值expect + var。直到更新成功</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(obj, valueOffset, expect, expect + <span class="keyword">var</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回当前线程在更改value成功后的，value变量原先值。并不是更改后的值</span></span><br><span class="line">        <span class="keyword">return</span> expect;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为了帮助理解，我加了一些注释。三个入参，第一个 obj 传入的是 AtomicInteger 对象自己，第二个是 value 变量的内存地址，第三个则是要增加的值。</p><p>程序体中是一个循环，循环中通过 AtomicInteger 对象和 value 属性的 offset，取得到当前的 value 值，接下来调用 this.compareAndSwapInt (obj, valueOffset, expect, expect + var)。这个方法名仔细看下，是不是很熟悉？是的，就是 CAS。调用前我们已经获取到了期望值，所以在这个方法中会把期望值和你要替换掉的值做比较，如果一直则替换，否则重复 while 循环，也就是再此获取最新的期望值，然后再比较替换，直至替换成功。</p><p>你现在一定很好奇 compareAndSwapInt 的方法是如何实现的。我们点开此方法后，可以看到是一个 native 方法，native 方法使用 C 语言编写。由于 JDK 并未开源，我们只能下载开源版本的 OpenJDK。</p><p>可以看到在 compareAndSwapInt 源代码的最后，调用了 Atomic::cmpxchg (x,addr,e)。这个方法在不同的平台会有不同的实现。不过总的思想如下：</p><ol><li>判断当前系统是否为多核处理器；</li><li>执行 CPU 指令 cmpxchg，如果为多核则在 cmpxchg 加 lock 前缀。</li></ol><p>可以看到最终是通过 CPU 指令 cmpxchg 来实现比较交换。那么 Lock 前缀起到什么作用呢？加了 Lock 前缀的操作，在执行期间，所使用的缓存会被锁定，其他处理器无法读写该指令要访问的内存区域，由此保证了比较替换的原子性。而这个操作过程称之为缓存锁定。</p><h2 id="CAS-的缺点"><a href="#CAS-的缺点" class="headerlink" title="CAS 的缺点"></a>CAS 的缺点</h2><p>CAS 最终通过 CPU 指令实现，把无谓的同步消耗降到最低，但是没有银弹，CAS 也有着几个致命的缺点：</p><ol><li>比较替换如果失败，则会一直循环，直至成功。这在并发量很大的情况下对 CPU 的消耗将会非常大；</li><li>只能保证一个变量自身操作的原子性，但多个变量操作要实现原子性，是无法实现的；</li><li>ABA 问题。</li></ol><p>前两个问题比较简单，我们重点看一下第三个 ABA 问题。</p><p>假如本线程更新前取得期望值为 A，和更新操作之间的这段时间内，其它线程可能把 value 改为了 B 又改回了 A。 而本线程更新时发现 value 和期望值一样还是 A，认为其没有变化，则执行了更新操作。但其实此时的 A 已经不是彼时的 A 了。</p><p>大多数情况下 ABA 不会造成业务上的问题。但是如果你认为 ABA 问题对你的程序业务有问题，那么就需要解决。 JDK 提供了 AtomicStampedReference 类，通过对 Atomic 包装的变量增加版本号，来解决 ABA 问题，即使 value 还是 A，但如果版本变化了，也认为比较失败。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>了解Atomic的原理，底层是CAS操作</li><li>CAS是一种乐观锁，也是自旋锁，要和synchronized区分开来，使用上也有所区分<ul><li>CAS：锁定区域，代码执行时间短，并发少</li><li>synchronized ：锁定区域代码执行时间长，并发大</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础</title>
      <link href="/2022/09/23/JUC-2022-09-23-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09/23/JUC-2022-09-23-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>线程的状态，是重点中的重点，在生产中遇到问题的时候，就需要观察线程状态来排查问题，比如用jstack查看堆栈信息时候，就需要重点关注block状态的线程。</p><h3 id="状态流转"><a href="#状态流转" class="headerlink" title="状态流转"></a>状态流转</h3><p><img src="1.jpg" alt="image-20220923140527513"></p><h3 id="状态的解释"><a href="#状态的解释" class="headerlink" title="状态的解释"></a>状态的解释</h3><ul><li>new: 线程刚刚创建，还没有启动</li><li>Runnable：可运行状态，可由线程调度器安排执行，具体分为：Ready等待调度，Running 正在执行</li><li>Waiting：等待被唤醒</li><li>Timed Waiting：隔一段时间，自动唤醒</li><li>Blocked：正在等锁</li><li>Terminated：线程结束</li></ul><h3 id="lock和synchronized的区别"><a href="#lock和synchronized的区别" class="headerlink" title="lock和synchronized的区别"></a>lock和synchronized的区别</h3><p>​    lock是用的juc的锁，基于cas实现，cas都是忙等，不是阻塞而是waiting，而synchronized是等锁，blocked，但两者都是阻塞态。</p><h2 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h2><p>介绍几种常见的线程启动的方式</p><ul><li><p>hread和Runnable 两种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MyThread().start();</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRun()).start();</span><br></pre></td></tr></table></figure></li><li><p>ThreadPool</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">service.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello ThreadPool"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>ThreadPool和Callable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">Future&lt;String&gt; f = service.submit(<span class="keyword">new</span> MyCall());</span><br><span class="line">String s = f.get();</span><br></pre></td></tr></table></figure></li><li><p>Thread和FutureTask</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCall());</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(task);</span><br><span class="line">t.start();</span><br><span class="line">System.out.println(task.get());</span><br></pre></td></tr></table></figure></li></ul><h2 id="线程打断"><a href="#线程打断" class="headerlink" title="线程打断"></a>线程打断</h2><h3 id="有关线程打断的三个方法"><a href="#有关线程打断的三个方法" class="headerlink" title="有关线程打断的三个方法"></a>有关线程打断的三个方法</h3><ul><li>interrupt方法:名为打断，但是一定注意，其本质是设置线程内部的中断标记位，发现标记修改后做什么样的反应，是线程自己实现</li><li>isInterrupt方法:查询标记位</li><li>interrupted方法:查询当前标记位是否被打断过，如果打断过，重置标记位</li></ul><h2 id="线程结束"><a href="#线程结束" class="headerlink" title="线程结束"></a>线程结束</h2><h3 id="优雅结束线程的几种方式"><a href="#优雅结束线程的几种方式" class="headerlink" title="优雅结束线程的几种方式"></a>优雅结束线程的几种方式</h3><h4 id="利用volatile变量设置标志位通知线程结束"><a href="#利用volatile变量设置标志位通知线程结束" class="headerlink" title="利用volatile变量设置标志位通知线程结束"></a>利用volatile变量设置标志位通知线程结束</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">long</span> i = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">//wait recv accept</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"end and i = "</span> + i); <span class="comment">//4168806262 4163032200</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    SleepHelper.sleepSeconds(<span class="number">1</span>);</span><br><span class="line">    running = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用interupt内部标记"><a href="#利用interupt内部标记" class="headerlink" title="利用interupt内部标记"></a>利用interupt内部标记</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//sleep wait</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"t1 end!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    SleepHelper.sleepSeconds(<span class="number">1</span>);</span><br><span class="line">    t.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用park方法配合interupt"><a href="#利用park方法配合interupt" class="headerlink" title="利用park方法配合interupt"></a>利用park方法配合interupt</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t.start();</span><br><span class="line">    SleepHelper.sleepSeconds(<span class="number">1</span>);</span><br><span class="line">    t.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCache 使用总结</title>
      <link href="/2022/09/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-09-22-SpringCache-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/09/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-09-22-SpringCache-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>Spring 从 3.1 开始定义了 org.springframework.cache.Cache 和 org.springframework.cache.CacheManager 接口来统一不同的缓存技术； 并支持使用 JCache（JSR-107）注解简化我们开发；</p></li><li><p>Cache 接口为缓存的组件规范定义，包含缓存的各种操作集合； Cache 接 口 下 Spring 提 供 了 各 种 xxxCache 的 实 现 ； 如 RedisCache ， EhCacheCache , ConcurrentMapCache 等；</p></li><li>每次调用需要缓存功能的方法时，Spring 会检查检查指定参数的指定的目标方法是否已 经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓 存结果后返回给用户。下次调用直接从缓存中获取。</li><li>使用 Spring 缓存抽象时我们需要关注以下两点； <ul><li>确定方法需要被缓存以及他们的缓存策略 </li><li>从缓存中读取之前缓存存储的数据</li></ul></li></ul><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><img src="1.jpg" alt="image-20220923101141154"></p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><img src="2.jpg" alt="image-20220923101355445"></p><h3 id="表达式语法"><a href="#表达式语法" class="headerlink" title="表达式语法"></a>表达式语法</h3><p><img src="4.jpg" alt="WeChatd3233d7e110a63f5fa8dfb06822727cd"></p><h3 id="缓存穿透问题解决"><a href="#缓存穿透问题解决" class="headerlink" title="缓存穿透问题解决"></a>缓存穿透问题解决</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>允许 null 值缓存</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Spring Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存使用总结</title>
      <link href="/2022/09/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-09-22-%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/09/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-09-22-%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h3><p>为了系统性能的提升，我们一般都会将部分数据放入缓存中，加速访问。而 db 承担数据落 盘工作。 哪些数据适合放入缓存？ </p><ul><li><p>即时性、数据一致性要求不高的 </p></li><li><p>访问量大且更新频率不高的数据（读多，写少）</p><p> 举例：电商类应用，商品分类，商品列表等适合缓存并加一个失效时间(根据数据更新频率 来定)，后台如果发布一个商品，买家需要 5 分钟才能看到新的商品一般还是可以接受的。</p><p><img src="1.jpg" alt="image-20220922162501682"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = cache.load(id);<span class="comment">//从缓存加载数据</span></span><br><span class="line">If(data == <span class="keyword">null</span>)&#123;</span><br><span class="line">data = db.load(id);<span class="comment">//从数据库加载数据</span></span><br><span class="line">cache.put(id,data);<span class="comment">//保存到 cache 中 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data;</span><br></pre></td></tr></table></figure><p>注意：在开发中，凡是放入缓存中的数据我们都应该指定过期时间，使其可以在系统即使没 有主动更新数据也能自动触发数据加载进缓存的流程。避免业务崩溃导致的数据永久不一致 问题。</p><h3 id="整合-redis-作为缓存"><a href="#整合-redis-作为缓存" class="headerlink" title="整合 redis 作为缓存"></a>整合 redis 作为缓存</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、引入 redis-starter</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="number">2</span>、配置 redis</span><br><span class="line">spring:</span><br><span class="line">redis:</span><br><span class="line">host: <span class="number">192.168</span><span class="number">.56</span><span class="number">.10</span></span><br><span class="line">port: <span class="number">6379</span></span><br><span class="line"><span class="number">3</span>、使用 RedisTemplate 操作 redis</span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line">StringRedisTemplate stringRedisTemplate; </span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringRedisTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); </span><br><span class="line">  ops.set(<span class="string">"hello"</span>,<span class="string">"world_"</span>+ UUID.randomUUID().toString()); </span><br><span class="line">  String hello = ops.get(<span class="string">"hello"</span>); System.out.println(hello);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span>、切换使用 jedis</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">  &lt;exclusions&gt;</span><br><span class="line">    &lt;exclusion&gt;</span><br><span class="line">      &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;/exclusion&gt;</span><br><span class="line">  &lt;/exclusions&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="缓存失效问题"><a href="#缓存失效问题" class="headerlink" title="缓存失效问题"></a>缓存失效问题</h2><p>先来解决大并发读情况下的缓存失效问题；</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><ul><li>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，但是数 据库也无此记录，我们没有将这次查询的 null 写入缓存，这将导致这个不存在的数据每次 请求都要到存储层去查询，失去了缓存的意义。 </li><li>在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，这就是 漏洞。</li><li>解决： 缓存空结果、并且设置短的过期时间。</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ul><li>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失 效，请求全部转发到 DB，DB 瞬时压力过重雪崩。</li><li>解决： 原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的 重复率就会降低，就很难引发集体失效的事件。</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><ul><li>对于一些设置了过期时间的 key， 如果这些 key 可能会在某些时间点被超高并发地访问， 是一种非常“热点”的数据。 </li><li>这个时候，需要考虑一个问题：如果这个 key 在大量请求同时进来前正好失效，那么所 有对这个 key 的数据查询都落到 db， 我们称为缓存击穿。</li><li>解决：加锁</li></ul><h2 id="缓存数据一致性"><a href="#缓存数据一致性" class="headerlink" title="缓存数据一致性"></a>缓存数据一致性</h2><h3 id="保证一致性模式"><a href="#保证一致性模式" class="headerlink" title="保证一致性模式"></a>保证一致性模式</h3><h4 id="双写模式"><a href="#双写模式" class="headerlink" title="双写模式"></a>双写模式</h4><p><img src="2.jpg" alt="image-20220922171402508"></p><h4 id="失效模式"><a href="#失效模式" class="headerlink" title="失效模式"></a>失效模式</h4><p><img src="3.jpg" alt="image-20220922171555860"></p><h4 id="改进方法-1-分布式读写锁"><a href="#改进方法-1-分布式读写锁" class="headerlink" title="改进方法 1-分布式读写锁"></a>改进方法 1-分布式读写锁</h4><p>分布式读写锁。读数据等待写数据整个操作完成</p><h4 id="改进方法-2-使用-cananl"><a href="#改进方法-2-使用-cananl" class="headerlink" title="改进方法 2-使用 cananl"></a>改进方法 2-使用 cananl</h4><p><img src="4.jpg" alt="image-20220922194108547"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis无主模式集群</title>
      <link href="/2022/09/22/Redis-2022-09-22-Redis%E6%97%A0%E4%B8%BB%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4/"/>
      <url>/2022/09/22/Redis-2022-09-22-Redis%E6%97%A0%E4%B8%BB%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>前面的文章我们讲了Redis的主从复制模式，它是来解决单点故障问题，从节点是主节点的备份，只读。这样一来就难解决容量问题，从AKF的原则讲，我们可以从y轴、Z轴来考虑搭建不同的集群来解决这个问题。接下来我们仔细的探讨下这个问题。</p></blockquote><h2 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h2><p>在AKF Y轴方向，我们可以从业务的角度出发，用户功能一个redis实例，订单功能一个redis实例,在业务端进行实例的区分。</p><p><img src="/Users/james/blogs/blog/source/_posts/Redis/2022-09-22-Redis无主模式集群/1.jpg" alt="WeChatc79ac39fa36a93fd82b0026afc139c36"></p><h2 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h2><p>不同的功能模块，进行拆分这是很容易想到的，也是比较简单的。问题是当这个单个业务数据量巨大，单实例压力大，如何拆分呢？AKF原则Z轴指导我们从数据分片的角度进行拆分。</p><h3 id="为什么分区非常有用"><a href="#为什么分区非常有用" class="headerlink" title="为什么分区非常有用"></a>为什么分区非常有用</h3><p>Redis分区主要有两个目的:</p><ul><li>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。</li><li>分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</li></ul><h3 id="分区基本概念"><a href="#分区基本概念" class="headerlink" title="分区基本概念"></a>分区基本概念</h3><p>有许多分区标准。假如我们有4个Redis实例<strong>R0</strong>, <strong>R1</strong>, <strong>R2</strong>, <strong>R3</strong>,有一批用户数据<code>user:1</code>, <code>user:2</code>, … ,那么有很多存储方案可以选择。从另一方面说，有很多<em>different systems to map</em>方案可以决定用户映射到哪个Redis实例。</p><p>一种最简单的方法就是<strong>范围分区</strong>,就是将不同范围的对象映射到不同Redis实例。比如说，用户ID从0到10000的都被存储到<strong>R0</strong>,用户ID从10001到20000被存储到<strong>R1</strong>,依此类推。</p><p>这是一种可行方案并且很多人已经在使用。但是这种方案也有缺点，你需要建一张表存储数据到redis实例的映射关系。这张表需要非常谨慎地维护并且需要为每一类对象建立映射关系，所以redis范围分区通常并不像你想象的那样运行，比另外一种分区方案效率要低很多。</p><p>另一种可选的范围分区方案是<strong>散列分区</strong>，这种方案要求更低，不需要key必须是<code>object_name:&lt;id&gt;</code>的形式，如此简单：</p><ul><li>使用散列函数 (如 <code>crc32</code> )将键名称转换为一个数字。例：键<code>foobar</code>, 使用<code>crc32(foobar)</code>函数将产生散列值<code>93024922</code>。</li><li>对转换后的散列值进行取模，以产生一个0到3的数字，以便可以使这个key映射到4个Redis实例当中的一个。<code>93024922 % 4</code> 等于 <code>2</code>, 所以 <code>foobar</code> 会被存储到第2个Redis实例。 <strong>R2</strong> <em>注意: 对一个数字进行取模，在大多数编程语言中是使用运算符%</em></li></ul><p>​    还有很多分区方法，上面只是给出了两个简单示例。有一种比较高级的散列分区方法叫<strong>一致性哈希</strong>，并且有一些客户端和代理（proxies)已经实现。</p><p><img src="/Users/james/blogs/blog/source/_posts/Redis/2022-09-22-Redis无主模式集群/2.jpg" alt="image-20220922112656472"></p><h3 id="不同的分区实现方案"><a href="#不同的分区实现方案" class="headerlink" title="不同的分区实现方案"></a>不同的分区实现方案</h3><p>分区可以在程序的不同层次实现。</p><ul><li><strong>客户端分区</strong>就是在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取。大多数客户端已经实现了客户端分区。</li></ul><p><img src="/Users/james/blogs/blog/source/_posts/Redis/2022-09-22-Redis无主模式集群/4.jpg" alt="图片"></p><ul><li><strong>代理分区</strong> 意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。redis和memcached的一种代理实现就是<a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">Twemproxy</a></li></ul><p><img src="/Users/james/blogs/blog/source/_posts/Redis/2022-09-22-Redis无主模式集群/5.jpg" alt="图片"></p><ul><li><strong>查询路由(Query routing)</strong> 的意思是客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点。Redis Cluster实现了一种混合形式的查询路由，但并不是直接将请求从一个redis节点转发到另一个redis节点，而是在客户端的帮助下直接<em>redirected</em>到正确的redis节点。</li></ul><h3 id="分区的缺点"><a href="#分区的缺点" class="headerlink" title="分区的缺点"></a>分区的缺点</h3><p>有些特性在分区的情况下将受到限制:</p><ul><li>涉及多个key的操作通常不会被支持。例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用交集指令）。</li><li>同时操作多个key,则不能使用Redis事务.</li><li>分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集（The partitioning granularity is the key, so it is not possible to shard a dataset with a single huge key like a very big sorted set）.</li><li>当使用分区的时候，数据处理会非常复杂，例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件。</li><li>分区时动态扩容或缩容可能非常复杂。Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种<font color=red><em>预分片</em></font>的技术也可以较好的解决这个问题。</li></ul><h2 id="持久化数据还是缓存？"><a href="#持久化数据还是缓存？" class="headerlink" title="持久化数据还是缓存？"></a>持久化数据还是缓存？</h2><p>无论是把Redis当做持久化的数据存储还是当作一个缓存，从分区的角度来看是没有区别的。当把Redis当做一个持久化的存储（服务）时，一个key必须严格地每次被映射到同一个Redis实例。当把Redis当做一个缓存（服务）时，即使Redis的其中一个节点不可用而把请求转给另外一个Redis实例，也不对我们的系统产生什么影响，我们可用任意的规则更改映射，进而提高系统的<em>高可用</em>（即系统的响应能力）。</p><p>一致性哈希能够实现当一个key的首选的节点不可用时切换至其他节点。同样地，如果你增加了一个新节点，立刻就会有新的key被分配至这个新节点。</p><p>重要结论如下:</p><ul><li>如果Redis被当做缓存使用，使用一致性哈希实现<strong>动态扩容缩容</strong>。</li><li>如果Redis被当做一个持久化存储使用，<strong>必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化</strong>。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样 - Redis 集群已经可用 <a href="https://groups.google.com/d/msg/redis-db/dO0bFyD_THQ/Uoo2GjIx6qgJ" target="_blank" rel="noopener">2015.4.1</a>.</li></ul><h2 id="预分片"><a href="#预分片" class="headerlink" title="预分片"></a>预分片</h2><p>从上面获知，除非我们把Redis当做缓存使用，否则（在生产环境动态）增加和删除节点将非常麻烦，但是使用固定的keys-instances则比较简单。</p><p>一般情况下随着时间的推移，数据存储需求总会发生变化。今天可能10个Redis节点就够了，但是明天可能就需要增加到50个节点。</p><p>既然Redis是如此的轻量（单实例只使用1M内存）,为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让Redis以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p><p>一开始就多设置几个Redis实例，例如32或者64个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p><p>这样的话，当你的数据不断增长，需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的Redis实例从第一台机器迁移到第二台机器。</p><p>使用Redis复制技术，你可以做到极短或者不停机地对用户提供服务：</p><ul><li>在你新服务器启动一个空Redis实例。</li><li>把新Redis实例配置为原实例的slave节点</li><li>停止你的客户端</li><li>更新你客户端配置，以便启用新的redis实例（更新IP）。</li><li>在新Redis实例中执行<code>SLAVEOF NO ONE</code>命令</li><li>（更新配置后）重启你的客户端</li><li>停止你原服务器的Redis实例</li></ul><h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><p>这里的redis cluster实际指的是redis 自带的一种模式，不需要引入其它组建。</p><h4 id="Redis集群介绍"><a href="#Redis集群介绍" class="headerlink" title="Redis集群介绍"></a>Redis集群介绍</h4><p>Redis 集群是一个提供在<strong>多个Redis间节点间共享数据</strong>的程序集。</p><p>Redis Cluster是一种<font color=red>服务器Sharding技术(分片和路由都是在服务端实现)</font>，采用多主多从，每一个分区都是由一个Redis主机和多个从机组成，片区和片区之间是相互平行的。Redis Cluster集群采用了P2P的模式，完全去中心化。</p><p><img src="/Users/james/blogs/blog/source/_posts/Redis/2022-09-22-Redis无主模式集群/3.jpg" alt="图片"></p><p>​    </p><p>Redis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.</p><p>Redis 集群通过分区来提供<strong>一定程度的可用性</strong>,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:</p><ul><li>自动分割数据到不同的节点上。</li><li>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</li></ul><h4 id="Redis-集群的数据分片"><a href="#Redis-集群的数据分片" class="headerlink" title="Redis 集群的数据分片"></a>Redis 集群的数据分片</h4><p>Redis 集群没有使用一致性hash, 而是引入了 <strong>哈希槽</strong>的概念.</p><p>Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:</p><ul><li>节点 A 包含 0 到 5500号哈希槽.</li><li>节点 B 包含5501 到 11000 号哈希槽.</li><li>节点 C 包含11001 到 16384号哈希槽.</li></ul><p>这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p><h3 id="Redis代理"><a href="#Redis代理" class="headerlink" title="Redis代理"></a>Redis代理</h3><h4 id="为什么引入代理"><a href="#为什么引入代理" class="headerlink" title="为什么引入代理"></a>为什么引入代理</h4><p>常见的Redis代理</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitMq 实现定时任务</title>
      <link href="/2022/09/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-09-21-rabbitMq-%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2022/09/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-09-21-rabbitMq-%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>利用RabbitMq的死信特点，可以对过期消息进行单独处理，从而实现一个定时处理的任务。</p></blockquote><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p><strong>场景：</strong></p><p>​    比如未付款订单，超过一定时间后，系统自动取消订单并释放占有物品。 </p><p><strong>常用解决方案：</strong>  spring的 schedule 定时任务轮询数据库 </p><p><strong>缺点：</strong>消耗系统内存、增加了数据库的压力、存在较大的时间误差</p><p><strong>解决：</strong>rabbitmq的消息TTL和死信Exchange结合</p><h2 id="RabbitMq实现"><a href="#RabbitMq实现" class="headerlink" title="RabbitMq实现"></a>RabbitMq实现</h2><h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><p>消息的TTL就是<font color= red>消息的存活时间</font>。</p><p>• RabbitMQ可以对<font color = red>队列</font>和<font color =red>消息</font>分别设置TTL。</p><p>• 对队列设置就是队列没有消费者连着的保留时间，<font color= red >也可以对每一个单独的消息做单独的 设置</font>。超过了这个时间，我们认为这个消息就死了，称之为死信。</p><p>• 如果队列设置了，消息也设置了，那么会<font color = red>取小的</font>。所以一个消息如果被路由到不同的队 列中，这个消息死亡的时间有可能不一样（不同的队列设置）。这里单讲单个消息的 TTL，<strong>因为它才是实现延迟任务的关键</strong>。可以通过设置消息的expiration字段或者xmessage-ttl属性来设置时间，两者是一样的效果。</p><h3 id="DLX"><a href="#DLX" class="headerlink" title="DLX"></a>DLX</h3><p>一个消息在满足如下条件下，会进死信路由，记住这里是路由而不是队列， 一个路由可以对应很多队列。（什么是死信）</p><p>• 一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不 会被再次放在队列里，被其他消费者使用。（basic.reject/ basic.nack）requeue=false</p><p>• 上面的消息的TTL到了，消息过期了。</p><p>• 队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上</p><p>• Dead Letter Exchange其实就是一种普通的exchange，和创建其他 exchange没有两样。只是在某一个设置Dead Letter Exchange的队列中有 消息过期了，会自动触发消息的转发，发送到Dead Letter Exchange中去。</p><p>• 我们既可以控制消息在一段时间后变成死信，又可以控制变成死信的消息 被路由到某一个指定的交换机，结合二者，其实就可以实现一个延时队列</p><p>• 手动ack&amp;异常消息统一放在一个队列处理建议的两种方式</p><p>• catch异常后，手动发送到指定队列，然后使用channel给rabbitmq确认消息已消费</p><p>• 给Queue绑定死信队列，使用nack（requque为false）确认消息消费失败</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图:"></a>流程图:</h4><p><img src="1.jpg" alt="image-20220921134515621"></p><h4 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计:"></a>详细设计:</h4><p><img src="2.jpg" alt="image-20220921134600852"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Bean Binding，Queue，Exchange</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器中的 Binding，Queue，Exchange 都会自动创建（RabbitMQ没有的情况）</span></span><br><span class="line"><span class="comment"> * RabbitMQ 只要有。<span class="doctag">@Bean</span>声明属性发生变化也不会覆盖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderDelayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * x-dead-letter-exchange: order-event-exchange</span></span><br><span class="line"><span class="comment">     * x-dead-letter-routing-key: order.release.order</span></span><br><span class="line"><span class="comment">     * x-message-ttl: 60000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-exchange"</span>,<span class="string">"order-event-exchange"</span>);</span><br><span class="line">    arguments.put(<span class="string">"x-dead-letter-routing-key"</span>,<span class="string">"order.release.order"</span>);</span><br><span class="line">    arguments.put(<span class="string">"x-message-ttl"</span>,<span class="number">60000</span>);</span><br><span class="line">    <span class="comment">//String name, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.delay.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,arguments);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">orderReleaseOrderQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue queue = <span class="keyword">new</span> Queue(<span class="string">"order.release.order.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Exchange <span class="title">orderEventExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//String name, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"order-event-exchange"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderCreateOrderBingding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//String destination, DestinationType destinationType, String exchange, String routingKey,</span></span><br><span class="line">    <span class="comment">//Map&lt;String, Object&gt; arguments</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.delay.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.create.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">orderReleaseOrderBingding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Binding(<span class="string">"order.release.order.queue"</span>,</span><br><span class="line">            Binding.DestinationType.QUEUE,</span><br><span class="line">            <span class="string">"order-event-exchange"</span>,</span><br><span class="line">            <span class="string">"order.release.order"</span>,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> rabbitmq的消息可以过期的特点,可以比较轻松的实现延迟任务。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redission 信号量</title>
      <link href="/2022/09/21/Redis-2022-09-21-Redission-%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2022/09/21/Redis-2022-09-21-Redission-%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>信号量大家应该够不陌生，比如操作系统中的pv信号量，依据功能还可以分成同步信号量、互斥信号量。由于redis是单进程，天生具有锁的这个特性，而redisson更是对redis做了一层包装，使得api接口更适用。今天我们就看一下redisson基于redis做的信号量。</p></blockquote><h2 id="Redisson信号量"><a href="#Redisson信号量" class="headerlink" title="Redisson信号量"></a>Redisson信号量</h2><p>​    Redisson的分布式信号量（Semaphore）Java对象 RSemaphore 采用了与 java.util.concurrent.Semaphore 相似的接口和用法。同时还提供了<strong>异步（Async）、反射式（Reactive）和RxJava2标准的接口</strong>。</p><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RSemaphore semaphore = redisson.getSemaphore(<span class="string">"semaphore"</span>);</span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.acquireAsync();</span><br><span class="line">semaphore.acquire(<span class="number">23</span>);</span><br><span class="line">semaphore.tryAcquire();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.tryAcquireAsync();</span><br><span class="line">semaphore.tryAcquire(<span class="number">23</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.tryAcquireAsync(<span class="number">23</span>, TimeUnit.SECONDS);</span><br><span class="line">semaphore.release(<span class="number">10</span>);</span><br><span class="line">semaphore.release();</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">semaphore.releaseAsync();</span><br></pre></td></tr></table></figure><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="1、限流"><a href="#1、限流" class="headerlink" title="1、限流"></a>1、限流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信号量可以做分布式限流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/park"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">park</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    RSemaphore park = redisson.getSemaphore(<span class="string">"park"</span>);</span><br><span class="line">    park.acquire();<span class="comment">//获取一个信号量（redis中信号量值-1）,如果redis中信号量为0了，则在这里阻塞住，直到信号量大于0，可以拿到信号量，才会继续执行。</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//boolean b = park.tryAcquire();//这个就是不阻塞，能拿到信号量就为true，拿不到（信号量为0 了）就是false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//业务代码...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span> + b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/go"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">go</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    RSemaphore park = redisson.getSemaphore(<span class="string">"park"</span>);</span><br><span class="line">    park.release();<span class="comment">//释放一个信号量（redis中信号量值+1）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"走了"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、商品秒杀"><a href="#2、商品秒杀" class="headerlink" title="2、商品秒杀"></a>2、商品秒杀</h4><p>1、商品上架设置，设置信号量控制商品可以秒杀的数目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//5、使用库存作为分布式的信号量  限流；</span></span><br><span class="line"> RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + token);</span><br><span class="line"><span class="comment">//商品可以秒杀的数量作为信号量</span></span><br><span class="line">semaphore.trySetPermits(seckillSkuVo.getSeckillCount());</span><br><span class="line"><span class="comment">//TODO 设置过期时间。</span></span><br><span class="line">semaphore.expireAt(sesssion.getEndTime());</span><br></pre></td></tr></table></figure><p>2、秒杀工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//验证这个人是否已经购买过。幂等性; 如果只要秒杀成功，就去占位。  userId_SessionId_skuId</span></span><br><span class="line"><span class="comment">//SETNX</span></span><br><span class="line">  String redisKey = respVo.getId() + <span class="string">"_"</span> + skuId;</span><br><span class="line">  <span class="comment">//自动过期</span></span><br><span class="line">  Boolean aBoolean = redisTemplate.opsForValue().setIfAbsent(redisKey, num.toString(), ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">  <span class="keyword">if</span> (aBoolean) &#123;</span><br><span class="line">   <span class="comment">//占位成功说明从来没有买过</span></span><br><span class="line">      RSemaphore semaphore = redissonClient.getSemaphore(SKU_STOCK_SEMAPHORE + randomCode);</span><br><span class="line">      <span class="comment">//120  20ms</span></span><br><span class="line">      <span class="keyword">boolean</span> b = semaphore.tryAcquire(num);</span><br><span class="line">      <span class="keyword">if</span> (b) &#123;</span><br><span class="line">       <span class="comment">//秒杀成功;</span></span><br><span class="line">       <span class="comment">//快速下单。发送MQ消息  10ms</span></span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis主从复制集群</title>
      <link href="/2022/09/21/Redis-2022-09-21-Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%9B%86%E7%BE%A4/"/>
      <url>/2022/09/21/Redis-2022-09-21-Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>主从复制，主要解决的是单点问题，从节点是主节点的备份，只读不能写，主节点可以读写。实际就是AKF原则中X轴的实现。但主从节点需要数据同步，就牵涉到数据一致性的问题，我们来看一下，集群主从集群需要注意的问题，以及redis是如何做的。</p></blockquote><h2 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h2><p>既然有从节点需要同步主节点数据，就涉及到一致性问题。</p><ul><li>强一致性（线性一致性）：即复制是同步的</li><li>弱一致性：即复制是异步的</li></ul><h3 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h3><p>所谓强一致性，以redis为例，当我们写到主节点时，主线同时去同步数据到从节点，此时主线程阻塞等待，如果一个从节点挂掉导致迟迟不能反回确认，不能同步，则导致主实例不可用，即破坏可用性。</p><p><img src="1.jpg" alt="image-20220921003822797"></p><p>这时候肯定是不行的，就是因为单点故障，我们引入主从集群，而因为保证强一致性导致 节点不可用，这不是又回去了吗？所以，我们是不能追求强一致性的。</p><h3 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h3><p>如果，采用异步的方式，即弱一致性，又容易发生丢失数据的情况。比如，主节点刚写完，还没同步挂掉了，从节点顶上来，那么未同步的数据一定就是丢失了。</p><p><img src="2.jpg" alt="image-20220921004139820"></p><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>如果我们利用上kafka这种可靠的消息组建，并且可以非常快速的返回，同步写入kafka，然后异步的进行同步，哪怕主节点挂掉，从节点上来也可以从kafka中同步消息，不至于丢失数据。</p><p><img src="3.jpg" alt="image-20220921004544714"></p><h3 id="Redis-一致性保证"><a href="#Redis-一致性保证" class="headerlink" title="Redis 一致性保证"></a>Redis 一致性保证</h3><p>下面文字引用redis中文官网</p><blockquote><p>Redis 并不能保证数据的<strong>强一致性</strong>. 这意味这在实际中集群在特定的条件下可能会丢失写操作.</p><p>第一个原因是因为集群是用了异步复制. 写操作过程:</p><ul><li>客户端向主节点B写入一条命令.</li><li>主节点B向客户端回复命令状态.</li><li>主节点将写操作复制给他得从节点 B1, B2 和 B3.</li></ul><p>主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。</p><p>举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .</p><p>Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.</p><p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项：</p></blockquote><h2 id="主节点HA"><a href="#主节点HA" class="headerlink" title="主节点HA"></a>主节点HA</h2><p>​    我们还要思考一个问题，主从集群，如果主挂掉了，那么是不是又不可用了，这就又回到单点故障问题了。</p><p>所以需要对主节点做高可用。</p><h3 id="监控节点个数"><a href="#监控节点个数" class="headerlink" title="监控节点个数"></a>监控节点个数</h3><p>​    我们思考，我们要监控主节点挂掉之后，能快速拉起从节点转为主节点，如果人工来做这件事 ，那可靠性是大有问题，你总不能24h守在机房里吧。所以我们要用专门的监控集群，比如keep alive 之类的技术，那现在问题变成，监控节点需要几个呢？如果是1个，那这一个监控节点是不是也会出现<font color=red>单点问题</font>？如果我们采用2个节点，那只有两个都回答 是死了，才能判定是死了，如果其中一个通信有问题，没法回答死了，那又没法判定是死了，又出现了<font color=red> 强一致性导致不可用</font>　，那两个只要一个判定死就死？那一个死 ，一个活 那也判定不了是死是活啊，于是我们采用3个节点，3个节点几个回答死就可以判定死了，3个？强一致性，2个呢？如果权值是一样的，2个回答死的，那从概率上讲，主节点死的概率是很大的，可以判定死。所以我们从过滤上讲，过半即可！那么，是不是越多越好，4个节点，要是3个节点都回答死 才判定死，是不是更好呢？当然会更准，但问题是，4个节点实际容忍1台监控节点发生故障，如果3个节点，2个节点判定死就死，也是容忍1个节点故障，3节点成本更低！ 而且，节点数越多，所以我们通常采用奇数节点。</p><h3 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h3><p>​    引用redis官网:</p><blockquote><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p><ul><li><strong>监控（Monitoring</strong>）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li><strong>提醒（Notification）</strong>： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>自动故障迁移（Automatic failover）</strong>： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><p>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</p><p>虽然 Redis Sentinel 释出为一个单独的可执行文件 redis-sentinel ， 但实际上它只是一个运行在特殊模式下的 Redis 服务器， 你可以在启动一个普通 Redis 服务器时通过给定 –sentinel 选项来启动 Redis Sentinel 。</p></blockquote><p> 有关Sentinel配置可以参考<a href="http://www.redis.cn/topics/sentinel.html" target="_blank" rel="noopener">官网</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集群原理-AKF原则</title>
      <link href="/2022/09/20/Redis-2022-09-20-%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/20/Redis-2022-09-20-%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我们在实际的工作中用到的组建通常会以集群的形式出现，目的就是解决单实例无法处理的情况，今天我们从AKF原则入手，总结一下 集群搭建的原理及要解决的问题。</p></blockquote><h2 id="AKF原则"><a href="#AKF原则" class="headerlink" title="AKF原则"></a>AKF原则</h2><h3 id="初识AKF"><a href="#初识AKF" class="headerlink" title="初识AKF"></a>初识AKF</h3><p>AKF原则是微服务拆分原则四条原则中的第一条，个人认为集群的搭建基本都是围绕AKF展开的。我们先思考单实例遇到的问题</p><ol><li>单点故障。一个实例挂掉，服务直接不可用了。</li><li>容量问题。以redis为例，一个实例可能10g的内存，那么20g的内存怎么办呢？</li><li>压力问题。单实例 能扛住的并发 始终是有上限的，如果想再提高并发？</li></ol><p>AKF原则就是 围绕上述3个问题展开的。<font color=red>需要注意的是，针对每一个问题可能就需要一套集群出来，AKF有3个轴，每个轴解决上述一个问题，每解决这一个问题 就需要一套集群，需要一个复杂的方案，如果想要同时解决上述3个问题，那么就需要一套组合拳，一套非常复杂的集群出来</font>。</p><h3 id="X轴"><a href="#X轴" class="headerlink" title="X轴"></a>X轴</h3><p><img src="1.jpg" alt="WeChat876d42a2a5c84f591f90d652cf9ddffc"></p><p>单点故障，我们通过备份，多个实例的数据做镜像，实例挂掉 可以再启动一个，这种集群模式叫做<font color = red> 主备模式</font>。但是，有一个问题，多个备份 如果只是作为备份，那么只有当主实例挂掉时候才能派上用场，是不是有点浪费？所以此时一般让备份实例可以作为读实例，主作为读写实例，从节点来同步主节点的数据。这种模式叫做 <font color = red>主从模式</font>。此时这套集群就看作是 主从架构的集群了。解决单点故障问题。</p><h3 id="Y轴"><a href="#Y轴" class="headerlink" title="Y轴"></a>Y轴</h3><p><img src="2.jpg" alt="WeChat705605ccda4a41743333ff78fee569a2" style="zoom:50%;"/></p><p>Y轴是说解决容量问题，redis一个实例4g内存，当存放16g数据呢？单实例放不开，我们可以找多个实例来存放。这就是Y轴要解决的问题。通常 可以按照业务功能来进行划分。比如 订单服务对应一个实例，用户服务对应一个实例，在容量是实际是划分开的。</p><h3 id="Z轴"><a href="#Z轴" class="headerlink" title="Z轴"></a>Z轴</h3><p><img src="3.jpg" alt="WeChat601e0b0d2d133f717a0a748bcfc067b0" style="zoom:50%;"/></p><p>继续来思考，如果经过Y轴拆分 ，单实例的压力还是达到瓶颈怎么办？比如用户服务的redis实例 已经撑不住了,我们是继续来一个 X、 Y的拆分吗？那这又回去了，AKF的Z轴就是解决这个问题的,我们可以利用分片再做一套集群出来，比如userid 10001~19999 一个redis 实例，20001~29999 一个实例，通过对数据进行分片来分解压力。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>AKF三条轴，围绕单点问题</p><p>X：全量，镜像</p><p>Y：业务，功能</p><p>Z：优先级，逻辑再拆分</p></li><li><p>注意，针对每一个问题，我们搭建集群来进行解决。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jstack 应用</title>
      <link href="/2022/09/20/jvm-2022-09-20-Jstack-%E5%BA%94%E7%94%A8/"/>
      <url>/2022/09/20/jvm-2022-09-20-Jstack-%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="jstack-参数"><a href="#jstack-参数" class="headerlink" title="jstack 参数"></a>jstack 参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/opt/java8/bin/jstack</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process) 连接活动线程</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process) 连接阻塞线程</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file) 连接dump的文件</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server) 连接远程服务器</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)</span><br><span class="line">    -m  to print both java and native frames (mixed mode)</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -h or -help to print this help message</span><br></pre></td></tr></table></figure><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object objA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object objB = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2());</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程1得到A对象的锁"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (objB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程1得到B对象的锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objB) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程2得到B对象的锁"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (objA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程2得到A对象的锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程1得到A对象的锁</span><br><span class="line">线程2得到B对象的锁</span><br></pre></td></tr></table></figure><h3 id="分析日志"><a href="#分析日志" class="headerlink" title="分析日志"></a>分析日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">[root@admin ~]# jps</span><br><span class="line">42576 Jps</span><br><span class="line">43616 DeadLock</span><br><span class="line">[root@admin ~]# jstack 43616</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.45-b08 mixed mode):</span><br><span class="line">"DestroyJavaVM" prio=6 tid=0x00000000047c1000 nid=0x9878 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">"Thread-1" prio=6 tid=0x0000000010aa3000 nid=0xafa0 waiting for monitor entry [0x000000001105f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at com.zaimeibian.Test$Thread2.run(Test.java:46)</span><br><span class="line">        - waiting to lock &lt;0x00000007c099cc20&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000007c099cc30&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:744)</span><br><span class="line">        </span><br><span class="line">"Thread-0" prio=6 tid=0x0000000010aa2800 nid=0xae74 waiting for monitor entry [0x0000000010f5f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at com.zaimeibian.Test$Thread1.run(Test.java:27)</span><br><span class="line">        - waiting to lock &lt;0x00000007c099cc30&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000007c099cc20&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:744)</span><br><span class="line"></span><br><span class="line">"Service Thread" daemon prio=6 tid=0x000000000f10a000 nid=0x9a8c runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C2 CompilerThread1" daemon prio=10 tid=0x000000000f109800 nid=0xaf28 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">"C2 CompilerThread0" daemon prio=10 tid=0x000000000f105800 nid=0x85dc waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">"Attach Listener" daemon prio=10 tid=0x000000000f104800 nid=0xac04 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">"Signal Dispatcher" daemon prio=10 tid=0x000000000f102000 nid=0xa678 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">"Finalizer" daemon prio=8 tid=0x000000000f0bd000 nid=0xaed8 in Object.wait() [0x000000001045f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x00000007c0905568&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:135)</span><br><span class="line">        - locked &lt;0x00000007c0905568&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:151)</span><br><span class="line">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:189)</span><br><span class="line">"Reference Handler" daemon prio=10 tid=0x000000000f0b2000 nid=0xaedc in Object.wait() [0x000000001035f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x00000007c09050f0&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.Object.wait(Object.java:503)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:133)</span><br><span class="line">        - locked &lt;0x00000007c09050f0&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">"VM Thread" prio=10 tid=0x000000000f0b0000 nid=0xaef0 runnable</span><br><span class="line"></span><br><span class="line">"GC task thread#0 (ParallelGC)" prio=6 tid=0x00000000047d6000 nid=0xacb0 runnable</span><br><span class="line">"GC task thread#1 (ParallelGC)" prio=6 tid=0x00000000047d8000 nid=0xaee0 runnable</span><br><span class="line">"GC task thread#2 (ParallelGC)" prio=6 tid=0x00000000047d9800 nid=0xaed4 runnable</span><br><span class="line">"GC task thread#3 (ParallelGC)" prio=6 tid=0x00000000047db000 nid=0xac54 runnable</span><br><span class="line">"VM Periodic Task Thread" prio=10 tid=0x000000000f132000 nid=0xaff0 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 105</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"Thread-1":</span><br><span class="line">  waiting to lock monitor 0x000000000f0ba488 (object 0x00000007c099cc20, a java.lang.Object),</span><br><span class="line">  which is held by "Thread-0"</span><br><span class="line">"Thread-0":</span><br><span class="line">  waiting to lock monitor 0x000000000f0bcf28 (object 0x00000007c099cc30, a java.lang.Object),</span><br><span class="line">  which is held by "Thread-1"</span><br><span class="line">  </span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line"></span><br><span class="line">===================================================</span><br><span class="line"></span><br><span class="line">"Thread-1":</span><br><span class="line"></span><br><span class="line">        at com.zaimeibian.Test$Thread2.run(Test.java:46)</span><br><span class="line"></span><br><span class="line">        - waiting to lock &lt;0x00000007c099cc20&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">        - locked &lt;0x00000007c099cc30&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">        at java.lang.Thread.run(Thread.java:744)</span><br><span class="line"></span><br><span class="line">"Thread-0":</span><br><span class="line"></span><br><span class="line">        at com.zaimeibian.Test$Thread1.run(Test.java:27)</span><br><span class="line"></span><br><span class="line">        - waiting to lock &lt;0x00000007c099cc30&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">        - locked &lt;0x00000007c099cc20&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">        at java.lang.Thread.run(Thread.java:744)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis应用 分布式锁实现</title>
      <link href="/2022/09/20/Redis-2022-09-20-Redis%E5%BA%94%E7%94%A8-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/09/20/Redis-2022-09-20-Redis%E5%BA%94%E7%94%A8-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Redis 除了做缓存、内存数据库之外，由于有线程的特性，经常可以拿来做分布式锁 、信号量等，应用起来也十分方便，我们来看一下一个分布式锁的简单实现。</p></blockquote><h2 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h2><blockquote><p>用redis实现分布式锁，其实我们要重点考虑3个方面问题：加锁、解锁、锁续期</p></blockquote><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>加锁要考虑的问题是，如果当前线程加锁之后挂掉了，相当于抱锁睡了，所以此时加锁时候 应该设置过期时间，保证能自动解锁。同时要注意应该是一个原子操作，否则还是有问题的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、占分布式锁。去redis占坑      设置过期时间必须和加锁是同步的，保证原子性（避免死锁）</span></span><br><span class="line">      String uuid = UUID.randomUUID().toString();</span><br><span class="line">      Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, uuid,<span class="number">300</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>加锁的本质是set nx 命令，只有锁不存在 才可以加锁成功。</p><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>解锁要考虑的是，解的一定是自己的锁才可以！比如，自己加锁之后 线程夯住，然后锁超时自动解开了，被别人抢走了，等线程活过来之后，完成业务去进行解锁操作，如果此时不加判断的解锁，解的就是别人的锁，那么就会有问题，并且判断与解锁的过程也要用原子操作，可以用lua脚本来保证。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line"><span class="comment">//删除锁</span></span><br><span class="line">stringRedisTemplate.execute(new DefaultRedisScript&lt;Long&gt;(script, Long.class), Arrays.asList("lock"), uuid);</span><br></pre></td></tr></table></figure><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p> 最后要考虑一个问题,加锁之后去执行业务，因为有自动解锁的机制，如果要解锁了，还没执行完业务呢？此时应该考虑。是否需要延时加锁时长，实际这一步就需要一个守护线程看到业务线程没执行完就要对锁进行续期。其实redisson 看门狗就是这么做的，理论是一样的，redis直接写的话代码比较复杂就不展示了，我们看一下redisson的实现。</p><h2 id="Redisson实现"><a href="#Redisson实现" class="headerlink" title="Redisson实现"></a>Redisson实现</h2><p>利用redisson 实现分布式锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建读锁</span></span><br><span class="line">    RReadWriteLock readWriteLock = redissonClient.getReadWriteLock(<span class="string">"catalogJson-lock"</span>);</span><br><span class="line"></span><br><span class="line">    RLock rLock = readWriteLock.readLock();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rLock.lock();</span><br><span class="line">        <span class="comment">//加锁成功...执行业务</span></span><br><span class="line">        dataFromDb = getCatalogJsonFromDB();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rLock.unlock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis RDB实现原理</title>
      <link href="/2022/09/19/Redis-2022-09-19-Redis-RDB%E4%B8%8EAOF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/19/Redis-2022-09-19-Redis-RDB%E4%B8%8EAOF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Redis的rdb 相信接触redis的同学都不陌生，rdb是redis持久化的快照文件。但有一个问题，时点的问题，比如redis 8点开始触发异步的持久化，假设需要十分钟的时间，那么这10分钟，主进程如果修改了内存数据，那么子进程进行持久化是写的修改后的数据吗？如果是，那此时持久化的数据就产生了脏数据,出现了数据一致性问题，如果不是，那此时内存数据被修改,又是如何做到呢？</p><p>那么通过回答这个问题来熟悉一下rdb的实现原理吧。</p></blockquote><h2 id="父子进程数据隔离"><a href="#父子进程数据隔离" class="headerlink" title="父子进程数据隔离"></a>父子进程数据隔离</h2><ol><li>$$ 与 $BASHPID均为取当前进程的PID</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bigdata ~]# echo $$</span><br><span class="line">19707</span><br><span class="line">[root@bigdata ~]# echo $BASHPID</span><br><span class="line">19707</span><br></pre></td></tr></table></figure><ol><li>| 管道会触发子进程</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bigdata ~]# echo $BASHPID</span><br><span class="line">19707</span><br><span class="line">[root@bigdata ~]# echo 1 | echo $BASHPID</span><br><span class="line">2483</span><br></pre></td></tr></table></figure><ol><li>$$ 优先级比$BASHPID要高</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@bigdata ~]# echo $$ | more</span><br><span class="line">19707</span><br><span class="line">[root@bigdata ~]# echo $BASHPID | more</span><br><span class="line">8651</span><br><span class="line">[root@bigdata ~]# echo $BASHPID | more</span><br><span class="line">8755</span><br></pre></td></tr></table></figure><p>4.父进程导出变量,子进程可以查看 不能修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@bigdata ~]# echo $$</span><br><span class="line">19707</span><br><span class="line">[root@bigdata ~]# export num</span><br><span class="line">[root@bigdata ~]# bash</span><br><span class="line">[root@bigdata ~]# echo $num</span><br><span class="line">1</span><br><span class="line">[root@bigdata ~]# num=1</span><br><span class="line">[root@bigdata ~]# num=5</span><br><span class="line">[root@bigdata ~]# exit</span><br><span class="line">exit</span><br><span class="line">[root@bigdata ~]# echo $num</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ol><li>父进程修改变量，不会影响子进程</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---子进程执行脚本</span><br><span class="line"><span class="meta">#</span><span class="bash">! bin/bash</span></span><br><span class="line">sleep 10s</span><br><span class="line">echo $$</span><br><span class="line">echo $num</span><br><span class="line">[root@bigdata ~]# sh child.sh &amp;</span><br><span class="line">[1] 21625</span><br><span class="line">[root@bigdata ~]# num=100</span><br><span class="line">[root@bigdata ~]# 21625</span><br><span class="line">10</span><br><span class="line">[1]+  完成                  sh child.sh</span><br><span class="line">[root@bigdata ~]# sh child.sh &amp;</span><br><span class="line">[1] 22285</span><br><span class="line">[root@bigdata ~]# 22285</span><br><span class="line">100</span><br><span class="line">[1]+  完成                  sh child.sh</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>​    通过shell命令的演示，可以看到linux中，父子进程的数据是导出的关系，而非共享，也就是说其中一方的修改，并不会影响另一方。</p><p>​    有linux数据隔离的支持，就为redis的异步保存快照提供了可能，同时有两个进程 主进程与异步的rdb子进程，主进程该写写，而做rdb的子进程看到的只是8点时刻的数据，并且只是进行一个读操作 。</p><h2 id="Fork系统调用"><a href="#Fork系统调用" class="headerlink" title="Fork系统调用"></a>Fork系统调用</h2><p>​    有了父子进程,通过数据隔离,就可以做异步持久化操作了,但还要考虑性能问题</p><p>​     进程都是需要进程空间的,拷贝子进程的时间？空间，如果当前redis内存占用10g，那么拷贝子进程至少拷贝10g数据，这个时间，再者，子进程也要占用10g内存，那么空间至少要啊20g才可以，这种情况下代价是不是有点大？</p><p><strong>fork()函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"this is the child process\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"this is the parent process\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1.jpg" alt="WeChat20ce515326f770bf4bde21542a0fa5ed"></p><p>linux的fork 系统调用 解决了上述的问题，fork出来的子进程，并非直接进行数据的拷贝。</p><p>linux编程中，通过fork函数会创建子进程，创建后根据写时复制策略，父子进程是共享父进程的堆与栈，当父子进程中的一方对内存进行了写操作后，父子进程的内存会分离，各自拥有自己独立的内存。</p><h2 id="COW-写时复制机制"><a href="#COW-写时复制机制" class="headerlink" title="COW 写时复制机制"></a>COW 写时复制机制</h2><p>在 Linux 系统中，调用 <code>fork</code> 系统调用创建子进程时，并不会把父进程所有占用的内存页复制一份，而是与父进程共用相同的<strong>内存页</strong>，而当子进程或者父进程对<strong>内存页</strong>进行修改时才会进行复制 —— 这就是著名的 <code>写时复制</code> 机制。</p><p><img src="2.jpg" alt="WeChat0facb54797c86a91122eae2013508029"></p><h2 id="配置及优缺点"><a href="#配置及优缺点" class="headerlink" title="配置及优缺点"></a>配置及优缺点</h2><ol><li><p>默认配置如下:</p><p>save 900 1<br>save 300 10<br>save 60 10000</p><p>从下往上，时间依次变长，只要满足一个条件就触发rdb保存。目的就是尽可能的减少数据丢失</p></li><li><p>缺点:丢失数据相对多一些 时点与时点之间窗口数据容易丢失 ,8点得到一个rdb，9点要落一个rdb，挂机了</p></li><li><p>优点：类似java中的序列化 恢复的速度相对快</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    涉及到持久化的方式 一般就两种，一种是快照 一种则是日志。今天我们介绍的就是快照的实现原理，通过linux 父子进程的数据隔离、fork系统调用以及cow机制 实现了rdb快照。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FullGC频繁排查思路</title>
      <link href="/2022/09/16/jvm-2022-09-16-FullGC%E9%A2%91%E7%B9%81%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/"/>
      <url>/2022/09/16/jvm-2022-09-16-FullGC%E9%A2%91%E7%B9%81%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://maimai.cn/article/detail?fid=1698450575&amp;efid=HoKY2iJmr6ceJpp0vT5P-Q" target="_blank" rel="noopener">https://maimai.cn/article/detail?fid=1698450575&amp;efid=HoKY2iJmr6ceJpp0vT5P-Q</a></p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>最近在整理JVM的知识体系，想到了大家平时都会讨论了一个话题，当然也是面试常问的一个话题，就是发生频繁fullGC的情况，我们应该如何应对，如何找到问题并且如何解决问题，这是让人头大的事情。</p><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a><strong>发现问题</strong></h2><p>我们先思考一下，我们平时是怎么发现频繁fullgc的，它的表现形式有哪些，这里只列举出来我能想到的几个点，可能还有其他的表现形式。</p><ol><li><p>CPU满载告警</p></li><li><p>API响应时间过长</p></li><li><p>内存反复波动</p></li><li><p>fullgc频繁告警(存在监控的情况下)</p></li></ol><p>其实发生CPU满载或者内存波动的原因可能会有很多，但是当我们发现这些情况，是可以往频繁fullgc上面想的，毕竟线上一旦出现问题，肯定要全面排查的嘛。</p><p>常用命令：</p><blockquote><p>jps：查看本机java进程信息</p><p> jstack：打印线程的栈信息，制作 线程dump文件</p><p> jmap：打印内存映射信息，制作 堆dump文件</p><p> jstat：性能监控工具</p><p>jhat：内存分析工具，用于解析堆dump文件并以适合人阅读的方式展示出来</p><p> jconsole：简易的JVM可视化工具</p><p> jvisualvm：功能更强大的JVM可视化工具</p></blockquote><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a><strong>定位问题</strong></h2><p>当我们发现了以上情况以及其他可以情况，就可以查看一下是否是频繁了fullgc，这里有个前提，就是什么频率算得上是频繁，这个要根据业务量和公司规定来的，比如我们公司，因为我们的项目是对B的，没有这么高的并发量，所以低于两天一次fullgc就属于频繁了，如果一天发生多次fullgc，那就一定出现问题了，就需要排查优化了，所以当我们确定了是频繁fullgc，就要开始定位，究竟是什么原因导致的fullgc。</p><ol><li><p>查看项目启动的GC命令，检查是否有异常指令：</p><p>比如有些同事可能对于GC参数理解的不是很透彻，本来想着优化的目的，但是却起了反作用。</p></li><li><p>查看yonggc的频率：</p><p>这一步主要是为了查看是否存在递归或者频繁创建对象，并且频繁回收，导致yonggc频繁，进而导致fullgc频繁，如果ygc频繁，则需要检查代码中是否存在不符合规范的地方了。</p></li><li><p>查看每一次fullgc的回收率：</p><p>如果ygc正常，但是fullgc频繁，那么这一步是为了查看是否存在内存泄漏，定位是否存在对象的长时间引用，内存泄露会占用大量内存空间，且无法正常回收，导致fullgc越发频繁，且stw时间越发长。</p></li><li><p>查看堆栈情况，找到占用内存较大的对象：</p><p>查看当前的堆栈信息，如果有监控工具可以直接使用，没有的话就使用JDK自带的一些命令，找到是否存在大对象的频繁创建。 </p></li><li><p>查看元数据区的回收频率：</p><p>Metadata GC Threshold，当我们发现以上情况都不存在，然后dump一下看看是否发生元数据区导致的频繁fullgc，当然这种情况很少见，但是可以定位排除一下。</p></li></ol><p>​    PS： 别忘了，还有一种可能，就是内存分配的太小了，大家往往会想到复杂的情况，也许调一下堆大小，就决解了呢。</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>minorGC前后的几种特殊情况</title>
      <link href="/2022/09/16/jvm-2022-09-16-minorGC%E5%89%8D%E5%90%8E%E7%9A%84%E5%87%A0%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5/"/>
      <url>/2022/09/16/jvm-2022-09-16-minorGC%E5%89%8D%E5%90%8E%E7%9A%84%E5%87%A0%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a><strong>大对象直接进入老年代</strong></h2><p> 相关参数 -XX:PretenureSizeThreshold</p><h2 id="动态年龄判断"><a href="#动态年龄判断" class="headerlink" title="动态年龄判断"></a><strong>动态年龄判断</strong></h2><p> minor gc 后，一批对象总大小超过了 survivor 区的 50%，那么就让大于等于这批对象年龄的对象直接进入老年代<br> 具体规则是，从年龄1的对象开始，把 年龄1 + 年龄2 + 年龄n 多个年龄的对象的总和超过survivor区的50%，就此时就会把年龄 n 以上的对象放入老年代</p><h2 id="老年代空间担保"><a href="#老年代空间担保" class="headerlink" title="老年代空间担保"></a><strong>老年代空间担保</strong></h2><p> 如果年轻代的对象需要晋升到老年代，老年代空间也可能不够。所以在执行 minor gc 之前，jvm会先检查一下老年代最大可用的连续内存空间， 是否能能放下 新生代所有的对象， 如果设置了 -XX:HandlePromotionFailure 则会进行下一步判断，看 是否大于  minor gc历次晋升到老年代对象的平均大小<br> 比如，上一次 minor gc 后有 10m 对象晋升到老年代，此时老年代最大连续可用空间大于10m，说明老年代空间是够的<br> 如果判断失败了，或者没有设置 “-XX:HandlePromotionFailure” 就会先进行一次 full gc 多腾出一些空间来， 然后在进行 mninor gc</p><blockquote><p>jdk1.6 update24之后， HandlePromotionFailure 没作用了，<br>只要老年代的连续空间大于新生代对象总大小或者历次晋升对象的平均<br>大小就可以进行 minor gc</p></blockquote><h2 id="minor-gc-后，survivor-区存放不下那部分存活对象-挪到老年代"><a href="#minor-gc-后，survivor-区存放不下那部分存活对象-挪到老年代" class="headerlink" title="minor gc 后，survivor 区存放不下那部分存活对象 挪到老年代"></a><strong>minor gc 后，survivor 区存放不下那部分存活对象 挪到老年代</strong></h2><p> a. 单个对象就比 survivor 大，直接挪到老年代<br> b. 并不是全部都挪到老年代<br> c. 如果老年代放不下所有的晋升对象 则会发生fullgc</p><p>老年代回收速度比年轻代慢 10 倍，年轻代一般就几十ms</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FullGC的发生时机</title>
      <link href="/2022/09/16/jvm-2022-09-16-FullGC%E7%9A%84%E5%8F%91%E7%94%9F%E6%97%B6%E6%9C%BA/"/>
      <url>/2022/09/16/jvm-2022-09-16-FullGC%E7%9A%84%E5%8F%91%E7%94%9F%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Major-GC-Full-GC"><a href="#Major-GC-Full-GC" class="headerlink" title="Major GC / Full GC"></a>Major GC / Full GC</h2><p>基于分代收集理论，目前的JVM堆内存大多分为了==新生代、老年代、方法区==。</p><p>JVM在进行GC时，并非每次都对上面三个内存区域（新生代、老年代；方法区）一起回收的，大部分时候回收的都是指新生代。</p><p>针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）。</p><h3 id="部分收集："><a href="#部分收集：" class="headerlink" title="部分收集："></a>部分收集：</h3><p>不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ol><li><p>新生代收集（Minor GC / Young GC）：只是新生代（Eden，s0，s1）的垃圾收集</p></li><li><p>老年代收集（Major GC / Old GC）：只是老年代的圾收集。</p></li></ol><p>​    目前，只有CMS GC会有单独收集老年代的行为。</p><p>​    注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</p><ol><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li></ol><h3 id="整堆收集（Full-GC）："><a href="#整堆收集（Full-GC）：" class="headerlink" title="整堆收集（Full GC）："></a>整堆收集（Full GC）：</h3><p>​    收集整个java堆和方法区的垃圾收集。</p><p>由于历史原因，外界各种解读，Major GC和Full GC有些混淆，下面的Full GC所指会说明，请仔细阅读。</p><h2 id="Full-GC触发机制"><a href="#Full-GC触发机制" class="headerlink" title="Full GC触发机制"></a>Full GC触发机制</h2><p>调用System.gc()时，系统建议执行Full GC，但是不必然执行<br>老年代空间不足<br>方法区空间不足<br>空间分配担保失败<br>下面逐一讲解。</p><ol><li><p>System.gc()的理解</p><blockquote><p>在默认情况下，通过<font color='red'> System.gc()</font>者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。<br>System.gc()内部实际上就是调用了<font color='red'> Runtime.getRuntime().gc()</font></p></blockquote></li></ol><p>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用（不能确保立即生效）<br>JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p><ol><li>老年代空间不足<br>何时新生代对象才会进入老年代，进一步触发老年代空间不足？</li></ol><blockquote><p>​    走正常流程，从Survivor区晋升到Old区，这时必然是伴随着Young GC才会导致Survivor区的被动回收。<br>当对象准备从Eden区经过Young GC转入Survivor区时，Survivor区空间不足，此时会直接进入老年代。<br>​    在经过Young GC后，Eden区仍然放不下新生的对象，则该对象直接进入Old区。<br>老年代空间不足所触发的其实是狭义上的Major GC</p><p>在此种情况下已经经历了Young GC，所以此时没有必要再进行一次Young GC。所以此时其实并不是整堆收集，也就不能算是狭义上的Full GC，但是由于一般都是混淆的，这里也把这种情况算入，在需要时可以特殊说明。</p><p>但如果是大对象直接分配老年代而空间不足，此时就没有经过young gc。所以尽管是只需要回收old区，但只有CMS才有专门的old区回收。</p><p>补充 进入老年代的常见四种情况:</p><p>1.躲过15次gc,达到15次高龄之后进入老年代.</p><p>2.动态年龄判定规则,如果Survivor区域内年龄1+年龄2+年龄3+年龄n的对象总和大于Survivor区的50%,此时年龄n以上的对象会进入老年代,不一定要达到15岁.</p><p>3.如果一次Young GC后存活对象太多无法进入Survivor区,此时直接进入老年代.</p><p>4.大对象直接进入老年代</p></blockquote><ol><li>方法区空间不足<br>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。</li></ol><blockquote><p>回收废弃常量与回收Java堆中的对象非常类似。也是通过可达性分析判断出常量不再被引用后进行回收。<br>类卸载的条件则相当苛刻，最困难的条件是 “加载该类的类加载器已经被回收” ，日常使用的类几乎都是通过系统类加载器或者向上的父加载器所加载，所以回收相当困难。<br>Java 8中方法区的实现改成了元空间（Meta Space），使用本地内存（Native memory）。只有在操作系统内存都被占满的情况下才可能报OOM。</p></blockquote><p>在报出OOM前必然会进行Full GC，因为方法区既不属于Young GC的回收范围，也不属于Old GC的回收范围，所以此时只有Full GC才能回收到方法区。</p><ol><li><p>空间分配担保失败</p><blockquote><p>在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看<font color='red'> -XX:HandlePromotionFailure</font>参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者<font color='red'> -XX:HandlePromotionFailure</font>设置不允许冒险，那这时就要改为进行一次Full GC。</p><p>一般空间分配担保机制都是打开的，以避免Full GC过于频繁。</p></blockquote></li></ol><p>这里的会出现Full GC的场景有两个：</p><ol><li>在开启空间分配担保机制后，老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，但这一次晋升上来的对象老年代放不下，这时会首先进行一次Young GC，若失败，则会直接进行Full GC。</li><li>未开启空间分配担保机制 / 老年代最大可用的连续空间小于历次晋升到老年代对象的平均大小。</li></ol>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM参数分类</title>
      <link href="/2022/09/15/jvm-2022-09-15-JVM%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB/"/>
      <url>/2022/09/15/jvm-2022-09-15-JVM%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM参数分类"><a href="#JVM参数分类" class="headerlink" title="JVM参数分类"></a>JVM参数分类</h2><div class="table-container"><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>标准参数（-）</td><td>所有的JVM实现都必须实现这些参数的功能，而且向后兼容；</td></tr><tr><td>非标准参数（-X）</td><td>这些参数不是虚拟机规范规定的。因此，不是所有VM的实现(如:HotSpot,JRockit,J9等)都支持这些配置参数。</td></tr><tr><td>非稳定参数（-XX）</td><td>这些参数是虚拟机规范中规定的。这些参数指定虚拟机实例在运行时的各种行为，从而对虚拟机的运行时性能有很大影响。</td></tr></tbody></table></div><p>对于-XX类型的配置选项，虚拟机规范有一些惯例，针对不同的平台虚拟机也会提供不同的默认值。</p><ol><li>对于布尔(Boolean)类型的配置选项，通过-XX:+来开启，通过-XX:-来关闭。</li><li>对于数字(Numberic)类型的配置选项，通过-XX:=来配置。后面可以携带单位字母，比如: ‘k’或者’K’代表千字节，’m’或者’M’代表兆字节，’g’或者’G’代表千兆字节。</li><li>对于字符串(String)类型的配置选项，通过-XX:=来配置。这种配置通过用来指定文件，路径或者命令列表。</li></ol><p>参考：<a href="http://www.nituchao.com/jvm-tuning/8.html" target="_blank" rel="noopener">http://www.nituchao.com/jvm-tuning/8.html</a></p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON字符串的嵌套机制</title>
      <link href="/2022/08/17/JSON%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B5%8C%E5%A5%97%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/08/17/JSON%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B5%8C%E5%A5%97%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="转义机制的嵌套："><a href="#转义机制的嵌套：" class="headerlink" title="转义机制的嵌套："></a>转义机制的嵌套：</h3><p>转义机制被任意嵌套、组合，只要识别方的处理逻辑是正确的，就不会发生命令识别错误或数据识别错误。转义机制是一个安全性完备的机制。</p><p>每增加一层转义机制，就需要增加一层还原机制。</p><h3 id="JSON字符串的多层嵌套"><a href="#JSON字符串的多层嵌套" class="headerlink" title="JSON字符串的多层嵌套"></a><strong>JSON字符串的多层嵌套</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.76&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多重嵌套转义测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multipleEscape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">    String s1 = <span class="string">"hello world."</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        jsonObject.set(<span class="string">"test"</span>, s1);</span><br><span class="line">        s1 = jsonObject.toString();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">&#123;<span class="string">"test"</span>:<span class="string">"hello world."</span>&#125;</span><br><span class="line">&#123;<span class="string">"test"</span>:<span class="string">"&#123;\"test\":\"hello world.\"&#125;"</span>&#125;</span><br><span class="line">&#123;<span class="string">"test"</span>:<span class="string">"&#123;\"test\":\"&#123;\\\"test\\\":\\\"hello world.\\\"&#125;\"&#125;"</span>&#125;</span><br><span class="line">&#123;<span class="string">"test"</span>:<span class="string">"&#123;\"test\":\"&#123;\\\"test\\\":\\\"&#123;\\\\\\\"test\\\\\\\":\\\\\\\"hello world.\\\\\\\"&#125;\\\"&#125;\"&#125;"</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac必备工具之brew</title>
      <link href="/2022/08/02/Mac%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E4%B9%8Bbrew/"/>
      <url>/2022/08/02/Mac%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E4%B9%8Bbrew/</url>
      
        <content type="html"><![CDATA[<blockquote><p>brew 是 Mac 下的一个包管理工具，类似于 centos 下的 yum，可以很方便地进行安装/卸载/更新各种软件包，例如：nodejs, elasticsearch, kibana, mysql, mongodb 等等，可以用来快速搭建各种本地环境，程序员必备工具</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>可以使用如下命令进行安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装/卸载/更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install nodejs</span><br><span class="line">brew upgrade nodejs</span><br><span class="line">brew remove  nodejs</span><br></pre></td></tr></table></figure><p>其它命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew list                   # 列出当前安装的软件</span><br><span class="line">brew search nodejs          # 查询与 nodejs 相关的可用软件</span><br><span class="line">brew info nodejs            # 查询 nodejs 的安装信息</span><br></pre></td></tr></table></figure><p>Services 命令</p><p> brew services 是一个非常强大的工具，可以用来管理各种服务的启停，有点像 linux 里面的 services</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services list    //列出当前管理的服务</span><br></pre></td></tr></table></figure><p>启动/停止/重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew start   nginx</span><br><span class="line">brew stop    nginx</span><br><span class="line">brew restart nginx</span><br></pre></td></tr></table></figure><h3 id="常见路径"><a href="#常见路径" class="headerlink" title="常见路径"></a>常见路径</h3><ul><li>配置路径：<code>/usr/local/etc/</code></li><li>日志路径：<code>/usr/local/var/log</code></li><li>安装路径   <code>/usr/local/Cellar</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作技巧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组合数计算的方法总结</title>
      <link href="/2022/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-24-%E7%BB%84%E5%90%88%E6%95%B0%E8%AE%A1%E7%AE%97%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-24-%E7%BB%84%E5%90%88%E6%95%B0%E8%AE%A1%E7%AE%97%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法题目中常见的计算技巧总结</title>
      <link href="/2022/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-24-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%A1%E7%AE%97%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-24-%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%A1%E7%AE%97%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天我们对算法题目中与数学运算相关的一些常用的知识进行简单总结，需要刻意记忆，如果对相关知识点不熟悉需要翻越更详细的资料。</p></blockquote><h3 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h3><h4 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h4><p>正整数a,b的最大公约数是指a与b的所有公约数中最大的那个公约数。求解最大公约数常用的是欧几里得算法(即辗转相除法),假设 a,b 均为正整数，则<code>gcd=(a,b) = gcd(b,a%b)</code></p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> b==<span class="number">0</span> ? a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h4><p>正整数a,b的最小公倍数是指a与b的所有公倍数中最小的那个公倍数。当得到a和b的最大公约数d之后,可以马上得到a和b的最小公倍数是<code>ab/d</code>,一般用lcm(a,b)来表示a和b的最小公倍数。由于<code>a*b</code>在实际运算时可能溢出 ，所以更恰当的写法是<code>a/d*b</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a/gcd(a,b)*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="素数筛选"><a href="#素数筛选" class="headerlink" title="素数筛选"></a>素数筛选</h3><p>素数又称质数，是指除了1和它自身，不能被其它数整除的数字。比较简单的做法是利用定义去挨个判断即可。但通常我们需要更快的做法去打表，以便后续更快的计算。这里我们常用是”埃氏筛法”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] primer_tb(<span class="keyword">int</span> maxn)&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] not_primer = <span class="keyword">new</span> <span class="keyword">boolean</span>[maxn]; <span class="comment">//true代表不是质数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; maxn;i++)</span><br><span class="line">        <span class="keyword">if</span> (!not_primer[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>*i;j &lt; maxn;j += i)</span><br><span class="line">                <span class="comment">//筛掉所有i的倍数</span></span><br><span class="line">                not_primer[j] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> not_primer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="质因子分解"><a href="#质因子分解" class="headerlink" title="质因子分解"></a>质因子分解</h3><p>所谓的质因子分解是指将一个正整数n写成一个或多个质数乘积的形式，例如 <code>180 = 2 * 2 * 3 * 3 * 5</code> 也即 </p><p>180 = 2^2^ <em> 3 ^2^ </em>5^1^  ,显然 数最终都是归到不同质数的乘积，所以我们需要先得到素数表 。</p><p>此外，我们需要理解一个结论 ,如果正整数n存在1和本身之外的因子，那么一定是在 sqrt(n)的左右成对出现，这是显然的。我们把这个结论应用到质因子上面得到一个强化的结论 ：<font color = red>对于一个正整数n来说，如果它存在[2,n]范围内的质因子，要么这些质因子全部小于等于sqrt(n),要么只存在一个大于sqrt(n)的质因子，而其余质因子全部小于等于 sqrt(n)。</font></p><p>有这个结论，接下来写代码就好办了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">factor</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> x; <span class="comment">//质数</span></span><br><span class="line">       <span class="keyword">int</span> cnt; <span class="comment">//质数对应的个数</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> factor[] handle_primer(<span class="keyword">int</span> n,<span class="keyword">int</span>[] primer_tb,<span class="keyword">int</span> p_num)&#123; <span class="comment">//primer_tb是收集好的质数数组,p_num是对应的个数。</span></span><br><span class="line">       factor[] factors = <span class="keyword">new</span> factor[<span class="number">10</span>];</span><br><span class="line">       <span class="keyword">int</span> num = <span class="number">0</span>,sqr = (<span class="keyword">int</span>)Math.sqrt(n);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; p_num &amp;&amp; primer_tb[i] &lt;= sqr;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(n%primer_tb[i] == <span class="number">0</span>)&#123;</span><br><span class="line">               factors[num].x = primer_tb[i];  <span class="comment">//记录该质因子</span></span><br><span class="line">               factors[num].cnt = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">while</span> (n % primer_tb[i] == <span class="number">0</span>)&#123; <span class="comment">//计算质因子primer_tb[i]的个数</span></span><br><span class="line">                   factors[num].cnt++;</span><br><span class="line">                   n/=primer_tb[i];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           num++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(n != <span class="number">1</span>)&#123;</span><br><span class="line">           factors[num].x = n;</span><br><span class="line">           factors[num].cnt = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> factors;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="上取整"><a href="#上取整" class="headerlink" title="上取整"></a>上取整</h3><p>​    在int型计算时候比如 <code>a /b</code>,默认是下取整的,介绍一种常用的上取整的技巧,a/b的上取整结果为<code>(a+b-1)/b</code></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    本文介绍的都是一些简单需要刻意去记忆的一些方法，更详细的内容需要单独摘出来讨论，这里总结的都是便简单的，慢慢的会把所有用到的运算技巧总结在这个地方。</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> MATH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j日志不输出</title>
      <link href="/2022/07/24/%E9%97%AE%E9%A2%98-2022-07-24-log4j%E6%97%A5%E5%BF%97%E4%B8%8D%E8%BE%93%E5%87%BA/"/>
      <url>/2022/07/24/%E9%97%AE%E9%A2%98-2022-07-24-log4j%E6%97%A5%E5%BF%97%E4%B8%8D%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>log4j日志不输出，或者没有按照预定的级别输出</p><h3 id="常见原因"><a href="#常见原因" class="headerlink" title="常见原因"></a>常见原因</h3><p>原因一：配置文件没配置对，这种低级错误就不说了</p><p>原因二：依赖冲突</p><p>​    多半是因为，引入的底层实现类出现了冲突，这样就得排查maven的冲突，那怎么知道哪些冲突了呢？如果</p><p>真是一点一点查，那就麻烦了，注意，一定要看提示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:/Users/qindongliang/.m2/repository/org/apache/logging/log4j/log4j-slf4j-impl/2.3/log4j-slf4j-impl-2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:/Users/qindongliang/.m2/repository/org/slf4j/slf4j-log4j12/1.7.12/slf4j-log4j12-1.7.12.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#multiple_bindings for an explanation.</span></span><br><span class="line">SLF4J: Actual binding is of type [org.apache.logging.slf4j.Log4jLoggerFactory]</span><br></pre></td></tr></table></figure><p>看到吗？提示两个类，一个是来自log4j-slf4j-impl/2.3/log4j-slf4j-impl-2.3.jar!/org/slf4j/impl/</p><p>一个来自org/slf4j/slf4j-log4j12/1.7.12/slf4j-log4j12-1.7.12.jar!/org/slf4j/impl/</p><p>是来自两个jar包，一个是2.x的一个是1.x的slf4j-log4j12，都是StaticLoggerBinder.class 这两个冲突了，然后有目的的去在依赖图里搜索这个jar，一般用的是2.x 把1.x的jar排除掉就可以了</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>看日志提示，看日志，看日志，看日志报错，寻找有用信息，不要盲目猜测</p></li><li><p>学会在maven 依赖中搜索</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trouble Shooting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常见报错</title>
      <link href="/2022/07/24/git-2022-07-24-git%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99/"/>
      <url>/2022/07/24/git-2022-07-24-git%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>错误一：Failed to connect to github.com port 443: Operation timed out</p><p>​    这个多半是由于网络问题，正常情况不会拉取，推送失败，多半是网络原因</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">考虑更换ip（自己没遇到过这个问题）：</span><br><span class="line">1、查询可以用的IP</span><br><span class="line">在https://www.ipaddress.com/上分别搜索</span><br><span class="line">github.com、github.global-ssl.fastly.net</span><br><span class="line">2、修改host文件</span><br><span class="line">     操作：sudo vi /etc/hosts，替换成以下ip即可</span><br><span class="line">151.101.185.194 github.global-ssl.fastly.net</span><br><span class="line">192.30.253.112  github.com</span><br></pre></td></tr></table></figure><p>错误二：LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 60</p><p>​     这个多半是因为自己的git仓库没有配 公钥，配一下即可              </p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PrepareStatement未关闭导致内存泄漏</title>
      <link href="/2022/07/24/%E9%97%AE%E9%A2%98-2022-07-24-PrepareStatement%E6%9C%AA%E5%85%B3%E9%97%AD%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
      <url>/2022/07/24/%E9%97%AE%E9%A2%98-2022-07-24-PrepareStatement%E6%9C%AA%E5%85%B3%E9%97%AD%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>堆内存飙升，GC次数明显提升</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h3><p>第三方的数据库连接池，使用的时候，获取到Connection之后，使用完成，调用的关闭方法（close()） ，并没有将Connection关闭，只是放回到连接池中，如果调用的这个方法，而没有手动关闭PreparedStatement等，则这个PreparedStatement并没有关闭，这样会使得开发的程序内存急速增长，java的内存回收机制可能跟不上速度，最终造成Out of memory Error</p><p>今天，就犯了一个很离谱的错误，ps没关，不断new新的ps，导致堆内存不断飙升，GC就是回收不了，结果OOM～</p><p>GC不掉的原因</p><p>引用百度问答的一段话：</p><p>1.你创建了100个PS的实例，但是你只关闭了最后一个。1楼说的GC会回收另外99个，没错，但GC能自动回收的只是JAVA创建的资源。preparedstatement为jdbc得api，他还会创建跟具体数据库有关的其他资源。close方法就是用来施放那些资源的。如果你没有每个都close，会导致内存泄漏。</p><p>2.不可以。——————补充：当然有非java创建的资源 jdbc可以说是一个和数据库通信的驱动。你建立jdbc的对象，调用它的方法。jdbc会去调用你使用的数据库的api，实现对数据库的操作。那些数据库的api会创建很多资源。java的gc（垃圾回收器）只会释放掉那些java对象所占的内存。无法释放数据库api创建的资源。只有通过jdbc相关的close方法才能释放。你只要记住，所有有close方法的jdbc对象在使用完成后都需要手动释放。另外，就是内存泄漏，相应的资源在内存中没有被引用，而又没有被操作系统回收。对，就是这个意思，除了JDBC还有很多根操作系统api有关的java api都有close方法，他们都是用来释放相应的非java资源的。</p><p>引用几篇文章，了解一下这个ps和现场排查的过程</p><p><a href="https://www.jianshu.com/p/50a33f2046dd" target="_blank" rel="noopener">JDBC：深入理解PreparedStatement和Statement</a></p><p><a href="http://www.jiaqili.me/post/oom-profiling-report-20181121/" target="_blank" rel="noopener"><strong>故障分析报告 - Java应用PS未关闭导致的OOM错误</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trouble Shooting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP拆包与粘包</title>
      <link href="/2022/07/23/network-2022-07-23-TCP%E6%8B%86%E5%8C%85%E4%B8%8E%E7%B2%98%E5%8C%85/"/>
      <url>/2022/07/23/network-2022-07-23-TCP%E6%8B%86%E5%8C%85%E4%B8%8E%E7%B2%98%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h3 id="粘包产生的原因"><a href="#粘包产生的原因" class="headerlink" title="粘包产生的原因"></a>粘包产生的原因</h3><p>如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这就是TCP协议中经常会遇到的粘包以及拆包的问题。</p><h4 id="传输层的UDP协议是否会发生粘包或者拆包问题？"><a href="#传输层的UDP协议是否会发生粘包或者拆包问题？" class="headerlink" title="传输层的UDP协议是否会发生粘包或者拆包问题？"></a>传输层的UDP协议是否会发生粘包或者拆包问题？</h4><p>​    不会。UDP是基于报文发送的，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。</p><h4 id="传输层的TCP协议是否会发生粘包或者拆包问题？"><a href="#传输层的TCP协议是否会发生粘包或者拆包问题？" class="headerlink" title="传输层的TCP协议是否会发生粘包或者拆包问题？"></a>传输层的TCP协议是否会发生粘包或者拆包问题？</h4><p>会。原因有以下两点：</p><ol><li><p>TCP是基于字节流的，虽然应用层和传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；</p></li><li><p>在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。（翻阅TCP协议）</p></li></ol><h3 id="粘包-拆包的表现形式"><a href="#粘包-拆包的表现形式" class="headerlink" title="粘包/拆包的表现形式"></a>粘包/拆包的表现形式</h3><p>现在假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为三种，现列举如下：</p><p>第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象，此种情况不在本文的讨论范围内。</p><p><img src="1.png" alt="WeChat1864b7a354427497fe010c4845961b18"></p><p>第二种情况，接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p><p><img src="2.png" alt="WeChatda0ba87973b06e3a58eff0a87b7dd23f"></p><p>第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p><p><img src="3.png" alt="WeChat09cb12a8193cdd8f3b06dd8d2bf46e22"></p><h3 id="粘包-拆包发生的原因"><a href="#粘包-拆包发生的原因" class="headerlink" title="粘包/拆包发生的原因"></a>粘包/拆包发生的原因</h3><p>发生TCP粘包或拆包有很多原因，现列出常见的几点：</p><p>1、要发送的数据大于TCP发送缓冲区剩余空间大小[操作系统socket内核缓冲区是tcp协议buffer（滑动窗口）的具体实现]，将会发生拆包。</p><p>2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。</p><p>3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</p><p>4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</p><h3 id="粘包-拆包的解决办法"><a href="#粘包-拆包的解决办法" class="headerlink" title="粘包/拆包的解决办法"></a>粘包/拆包的解决办法</h3><p>通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：</p><ol><li>发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</li><li>发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li><li>可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>贴出来当时测试，包发生粘包的代码，仔细看打的日志</li></ul><p>​        <a href="https://paste.ubuntu.com/p/PxCxHhMH5R/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/PxCxHhMH5R/</a></p><ul><li>注意，一定要注意，协议本身没问题，你也不要考虑协议的什么问题，我觉着主要就是内核缓冲buffer，不一定什么时候发送，一口气发送出去，或者你这个内容太大，给你拆成两个包，结果正好一个包在接收方那端收着了，另一个还没发，这不就是拆包了，或者说，在接收方，迟迟不调接收的buffer，来了一个包的数据进到了buffer，来了一个进来了，应用级别，一读，整个buffer过去了，这不是就是相当于一个包过来的了，就是粘包，没啥好说的，主要就是内核的socket buffer不一定什么时候操作，和内核page cache一个原理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解</title>
      <link href="/2022/07/23/ssm-2022-07-23-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/07/23/ssm-2022-07-23-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    Java 注解是在 JDK5 时引入的新特性，注解（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。注解类型定义指定了一种新的类型，一种特殊的接口类型。 在关键词 interface 前加 @ 符号也就是用 @interface 来区分注解的定义和普通的接口声明。目前大部分框架(如 Spring Boot 等)都通过使用注解简化了代码并提高的编码效率</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><p>提供信息给编译器： 编译器可以利用注解来探测错误和警告信息，如 @Override、@Deprecated。</p></li><li><p>编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html 文档或者做其它相应处理，如 @Param、@Return、@See、@Author 用于生成 Javadoc 文档。</p></li><li><p>运行时的处理： 某些注解可以在程序运行的时候接受代码的提取，值得注意的是，注解不是代码本身的一部分。如Spring 2.5 开始注解配置，减少了配置。</p></li></ul><h3 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h3><ol><li><strong>根据注解参数的个数:</strong></li></ol><ul><li><p>标记注解:一个没有成员定义的Annotation类型被称为标记注解。</p></li><li><p>单值注解:只有一个值</p></li><li><p>完整注解:拥有多个值</p></li></ul><ol><li><strong>根据注解使用方法和用途:</strong></li></ol><ul><li><p>JDK内置系统注解</p></li><li><p>元注解</p></li><li><p>自定义注解</p></li></ul><h3 id="元数据注解"><a href="#元数据注解" class="headerlink" title="元数据注解"></a><strong>元数据注解</strong></h3><p>​    元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解有四个，</p><p>​    (这些类型和它们所支持的类在java.lang.annotation包中可以找到)</p><h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a><strong>@Target</strong></h4><p>​    用于描述注解的使用范围（即：被描述的注解可以用在什么地方）。表示支持注解的程序元素的种类，一些可能的值有TYPE, METHOD, CONSTRUCTOR, FIELD等等。如果Target元注解不存在，那么该注解就可以使用在任何程序元素之上。</p><p>  取值(ElementType)有：</p><ul><li><p>CONSTRUCTOR:用于描述构造器</p></li><li><p>FIELD:用于描述属性</p></li><li>LOCAL_VARIABLE:用于描述局部变量</li><li>METHOD:用于描述方法</li><li>PACKAGE:用于描述包</li><li>PARAMETER:用于描述参数</li><li>TYPE:用于描述类、接口(包括注解类型) 或enum声明</li></ul><p>此时在空注解中加入@Target元注解如: //此注解只能用在方法上 @Target(ElementType.METHOD) @interface TestMethod {}  </p><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a><strong>@Retention</strong></h4><p>​     表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）表示注解类型保留时间的长短。</p><p>​    取值(RetentionPoicy)有：</p><ul><li><p>SOURCE:在源文件中有效（即源文件保留）</p></li><li><p>CLASS:在class文件中有效（即class保留）</p></li><li>RUNTIME:在运行时有效（即运行时保留）</li></ul><p>此时在上述注解中加入@Retention元注解如: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此注解可以用于注解类、接口(包括注解类型) 或enum声明</span></span><br><span class="line"> <span class="meta">@Target</span>(ElementType.TYPE) </span><br><span class="line"><span class="comment">//该注解运行时有效。注解处理器可以通过反射，获取到该注解的属性值，从而去做一些运行时的逻辑处理</span></span><br><span class="line"> <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="meta">@interface</span> TestRn&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a><strong>@Documented</strong></h4><p>​    表示使用该注解的元素应被javadoc或类似工具文档化，它应用于类型声明，类型声明的注解会影响客户端对注解元素的使用。如果一个类型声明添加了Documented注解，那么它的注解会成为被注解元素的公共API的一部分，@Documented是一个标记注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以被例如javadoc此类的工具文档化`</span></span><br><span class="line"><span class="meta">@Documented</span> <span class="meta">@interface</span> TestDoc&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a><strong>@Inherited</strong></h4><p>​    表示一个注解类型会被自动继承，如果用户在类声明的时候查询注解类型，同时类声明中也没有这个类型的注解，那么注解类型会自动查询该类的父类，这个过程将会不停地重复，直到该类型的注解被找到为止，或是到达类结构的顶层（Object）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被子类继承的注解</span></span><br><span class="line"><span class="meta">@Inherited</span> <span class="meta">@interface</span> TestInheri&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a><strong>注解处理器</strong></h3><p>​    说白了，注解就是一种标识，与原程序无关，那既然进行了标识，关键在于解析这些标识，具有什么样的标识，就触发什么样的逻辑。</p><p>   AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息：</p><p>① T getAnnotation(Class annotationClass): 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</p><p> ②Annotation[] getAnnotations():返回该程序元素上存在的所有注解。</p><p> ③boolean isAnnotationPresent(Class annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false.</p><p> ④Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。</p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>以token校验注解为例，看一下自定义注解的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dante</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/1/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TokenCheck &#123;</span><br><span class="line">    <span class="comment">// 是否校验token</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截器进入"</span>);</span><br><span class="line"></span><br><span class="line">        String token = request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TokenException(<span class="string">"token 为空"</span>);</span><br><span class="line"><span class="comment">////         return false;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">        Method method = handlerMethod.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(TokenCheck<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            TokenCheck annotation = method.getAnnotation(TokenCheck<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (annotation.required()) &#123;</span><br><span class="line">                <span class="comment">// 校验token</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    JwtUtil.parseToken(token);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量池</title>
      <link href="/2022/07/23/jvm-2022-07-23-%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
      <url>/2022/07/23/jvm-2022-07-23-%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>提到常量池一直容易混，今天一次性彻底搞定。</p></blockquote><h3 id="class文件常量池（class-constant-pool）"><a href="#class文件常量池（class-constant-pool）" class="headerlink" title="class文件常量池（class constant pool）"></a>class文件常量池（class constant pool）</h3><p>我们都知道，class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的<strong>各种字面量(Literal)和符号引用(Symbolic References)</strong>。字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>这个就是我们在字节码中看到的常量池，存的是字面量和符号引用。这个时候，是编译后的，还没运行呢。</p><h3 id="全局字符串池（string-pool也有叫做string-literal-pool）"><a href="#全局字符串池（string-pool也有叫做string-literal-pool）" class="headerlink" title="全局字符串池（string pool也有叫做string literal pool）"></a>全局字符串池（string pool也有叫做string literal pool）</h3><p>全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（<strong>记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。</strong>）。在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。</p><h3 id="运行时常量池（runtime-constant-pool）"><a href="#运行时常量池（runtime-constant-pool）" class="headerlink" title="运行时常量池（runtime constant pool）"></a>运行时常量池（runtime constant pool）</h3><p>当java文件被编译成class文件之后，也就是会生成我上面所说的class常量池，那么运行时常量池又是什么时候产生的呢？</p><p>jvm在执行某个类的时候，必须经过<strong>加载、连接、初始化</strong>，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</p><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"def"</span>);</span><br><span class="line">String str3 = <span class="string">"abc"</span>;</span><br><span class="line">String str4 = str2.intern();</span><br><span class="line">String str5 = <span class="string">"def"</span>;</span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true</span></span><br><span class="line">System.out.println(str2 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></code></pre><p>上面程序的首先经过编译之后，在该类的class常量池中存放一些符号引用，然后类加载之后，将class常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中str1所指向的”abc”实例对象），然后将这个对象的引用存到全局String Pool中，也就是StringTable中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询StringTable，保证StringTable里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。</p><p>回到上面的那个程序，现在就很容易解释整个程序的内存分配过程了，首先，在堆中会有一个”abc”实例，全局StringTable中存放着”abc”的一个引用值，然后在运行第二句的时候会生成两个实例，一个是”def”的实例对象，并且StringTable中存储一个”def”的引用值，还有一个是new出来的一个”def”的实例对象，与上面那个是不同的实例，当在解析str3的时候查找StringTable，里面有”abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同，str4是在运行的时候调用intern()函数，返回StringTable中”def”的引用值，如果没有就将str2的引用值添加进去，在这里，StringTable中已经有了”def”的引用值了，所以返回上面在new str2的时候添加到StringTable中的 “def”引用值，最后str5在解析的时候就也是指向存在于StringTable中的”def”的引用值，那么这样一分析之后，下面三个打印的值就容易理解了。</p><p><strong>总结</strong></p><ul><li>全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。</li><li>class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。</li><li>运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</li><li>public  String(String string)….. 构造方法，所以new 本身就是一个对象实例，实例只可能存在堆中，这是jvm规范</li><li>class常量池是编译后，字节码中提到的，每个字节码都可能存着一些字符串，这些字符串很多相同的那么这些类在运行时候，难道要在内存中保存相同的内容吗？当然不会所以，有全局字符串常量池，而运行时常量池，主要是这个类的字节码的东西，运行起来的存储，所以一个类，一个运行时常量池。</li></ul>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO实验的一些常用命令总结</title>
      <link href="/2022/07/23/IO-2022-07-23-IO%E5%AE%9E%E9%AA%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/23/IO-2022-07-23-IO%E5%AE%9E%E9%AA%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>必须熟练使用的指令以及注意事项</p><h3 id="stat：可以查看文件的详细信息"><a href="#stat：可以查看文件的详细信息" class="headerlink" title="stat：可以查看文件的详细信息"></a>stat：可以查看文件的详细信息</h3> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat msb.txt</span><br></pre></td></tr></table></figure><h3 id="ln：建立符号连接、硬连接"><a href="#ln：建立符号连接、硬连接" class="headerlink" title="ln：建立符号连接、硬连接"></a>ln：建立符号连接、硬连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln   [s]    已有的    不存在的</span><br></pre></td></tr></table></figure><h3 id="dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换"><a href="#dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换" class="headerlink" title="dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换"></a>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换</h3><blockquote><p><a href="https://www.cnblogs.com/fantasyxo/p/10519662.html" target="_blank" rel="noopener">https://www.cnblogs.com/fantasyxo/p/10519662.html</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;</span><br><span class="line">of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</span><br><span class="line">ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。</span><br><span class="line">obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。</span><br><span class="line">bs=bytes：同时设置读入/输出的块大小为bytes个字节。</span><br><span class="line">cbs=bytes：一次转换bytes个字节，即指定转换缓冲区大小。</span><br><span class="line">skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</span><br><span class="line">seek=blocks：从输出文件开头跳过blocks个块后再开始复制。</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将/dev/hdb全盘数据备份到指定路径的image文件</span><br><span class="line">    heng@me: dd if=/dev/hdb of=/root/image</span><br><span class="line">测试硬盘的读写速度</span><br><span class="line">    heng@me: dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file</span><br><span class="line"> heng@me: dd if=/root/1Gb.file bs=64k | dd of=/dev/null</span><br></pre></td></tr></table></figure><h3 id="losetup"><a href="#losetup" class="headerlink" title="losetup:"></a>losetup:</h3><p>循环设备可把文件虚拟成区块设备，籍以模拟整个文件系统，让用户得以将其视为硬盘驱动器，光驱或软驱等设备，并挂入当作目录来使用</p><blockquote><p><a href="https://www.runoob.com/linux/linux-comm-losetup.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-losetup.html</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">模拟文件系统：</span><br><span class="line">生成文件 floppy.img</span><br><span class="line">mkfs.ext4 loopfile.img</span><br><span class="line">losetup /dev/loop0 floppy.img</span><br><span class="line">mount /dev/loop0 /tmp</span><br><span class="line">结束测试</span><br><span class="line">umount /tmp</span><br><span class="line">losetup -d /dev/loop1</span><br></pre></td></tr></table></figure><h3 id="exec"><a href="#exec" class="headerlink" title="exec:"></a>exec:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell的内建命令exec将并不启动新的shell，而是用要被执行命令替换当前的shell进程，并且将老进程的环境清理掉，而且exec命令后的其它命令将不再执行。 </span><br><span class="line">因此，如果你在一个shell里面，执行exec ls那么，当列出了当前目录后，这个shell就自己退出了，因为这个shell进程已被替换为仅仅执行ls命令的一个进程，执行结束自然也就退出了。为了避免这个影响我们的使用，一般将exec命令放到一个shell脚本里面，用主脚本调用这个脚本，调用点处可以用bash a.sh，（a.sh就是存放该命令的脚本），这样会为a.sh建立一个sub shell去执行，当执行到exec后，该子脚本进程就被替换成了相应的exec的命令。 </span><br><span class="line">source命令或者&quot;.&quot;，不会为脚本新建shell，而只是将脚本包含的命令在当前shell执行。 </span><br><span class="line">不过，要注意一个例外，当exec命令来对文件描述符操作的时候，就不会替换shell，而且操作完成后，还会继续执行接下来的命令。 </span><br><span class="line">  exec 3&lt;&amp;0:这个命令就是将操作符3也指向标准输入</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.exec 命令 ;命令代替shell程序，命令退出，shell 退出；比如 exec ls</span><br><span class="line">2.exec 文件重定向，可以将文件的重定向就看为是shell程序的文件重定向 比如 exec 5&lt;/dev/null;exec 5&lt;&amp;-</span><br><span class="line">另外,这个命令还可以作为find命令的一个选项,如下所示: </span><br><span class="line">(1)在当前目录下(包含子目录)，查找所有txt文件并找出含有字符串"bin"的行 </span><br><span class="line">find ./ -name "*.txt" -exec grep "bin" &#123;&#125; \; </span><br><span class="line">(2)在当前目录下(包含子目录)，删除所有txt文件 </span><br><span class="line">find ./ -name "*.txt" -exec rm &#123;&#125; \; </span><br><span class="line">exec命令                  作用</span><br><span class="line"> </span><br><span class="line">exec ls          在shell中执行ls，ls结束后不返回原来的shell中了</span><br><span class="line">exec &lt;file       将file中的内容作为exec的标准输入</span><br><span class="line">exec &gt;file       将file中的内容作为标准写出 </span><br><span class="line">exec 3&lt;file      将file读入到fd3中 </span><br><span class="line">sort &lt;&amp;3         fd3中读入的内容被分类 </span><br><span class="line">exec 4&gt;file      将写入fd4中的内容写入file中 </span><br><span class="line">ls &gt;&amp;4           Ls将不会有显示，直接写入fd4中了，即上面的file中</span><br><span class="line">exec 5&lt;&amp;4         创建fd4的拷贝fd5 </span><br><span class="line">exec 3&lt;&amp;-         关闭fd3</span><br></pre></td></tr></table></figure><h3 id="lsof："><a href="#lsof：" class="headerlink" title="lsof："></a>lsof：</h3><p>lsof(list open files)是一个列出当前系统打开文件的工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看服务器 8000 端口的占用情况：</span><br><span class="line">lsof -i:8000</span><br><span class="line">使用-p查看指定进程ID已打开的内容</span><br><span class="line">lsof -p[o] PID  :查看进程打开的所有文件，O参数是文件的偏移量</span><br></pre></td></tr></table></figure><h3 id="sysctl-a"><a href="#sysctl-a" class="headerlink" title="sysctl:  -a"></a>sysctl:  -a</h3><p>可以查看所有系统级别的参数</p><p> sysctl -a | grep dirty 可以找到所有page cache相关的参数</p><h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump:"></a>tcpdump:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">采用命令行方式对接口的数据包进行筛选抓取。</span><br><span class="line">不带任何选项的tcpdump ,默认抓取第一个网络接口。只有将tcpdump进程终止，抓包停止</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-c指定抓取包的数量，即最后显示的数量</span><br><span class="line">-i指定tcpdump监听的网卡。未指定，选择系统中最小的以配置端口。</span><br><span class="line">    -i any:监听所有网络端口 </span><br><span class="line">    -i lo:监听lookback接口。</span><br><span class="line">-nn 对监听地址以数字方式呈现，且对端口也以数字方式呈现。如果不指定 ，地址以man 主机名方式呈现，端口以服务名方式呈现</span><br><span class="line">-P指定要抓取的包是流入还是流出 （in out inout[默认]）</span><br><span class="line">-s 设置tcpdump的数据包抓取长度，默认为65535字节。</span><br><span class="line">-e输出的每行都包含数据链路层的头部信息。</span><br><span class="line">-D列出所有可以用于抓包的表达式。</span><br><span class="line">-X显示协议头和包的全部内容。</span><br><span class="line">-F从文件中读取抓包的表达式。</span><br><span class="line">应用示例：</span><br><span class="line">（1）tcpdump -i eth0 host 192.168.1.1 【过滤主机】</span><br><span class="line">         注：抓取所有经过网卡1，目的ip为192.168.1.1</span><br><span class="line">（2）tcpdump -i  eth0 dst port 22 【过滤端口】</span><br><span class="line">       注：抓取所有经过网卡1，目的端口为22的网络数据</span><br><span class="line">（3）tcpdump -i eth0 udp 【过滤协议】</span><br><span class="line">       注；抓取所有经过网卡1，协议为UDP的协议。</span><br><span class="line">（4）tcpdupmp -i lo udp 【抓取本地环路数据包】</span><br><span class="line">（5）特定协议特定端口</span><br><span class="line">           tcpdump udp port 22</span><br><span class="line">（6）抓取特定类型的数据包</span><br><span class="line">          tcpdump -i eth0 'tcp[tcpflags] = tcp-syn' (抓取所有经过网卡1的SYN类型的数据包)</span><br><span class="line">          tcpdump -i eth0 udp dst port 53(抓取经过网卡1的所有DNS数据包)</span><br><span class="line">（7）逻辑语句过滤</span><br><span class="line">          tcpdump -i eth0 '((tcp) and ((dst net 192.168.0) and (not dst host 192.168.0.2)))'</span><br><span class="line">         注：抓取所有经过网卡1，目的网络是192.168.0，但目的主机不是192.168.0.2的TCP数据。   </span><br><span class="line">（8）抓包存取</span><br><span class="line">       tcpdump -i eth0 host 192.168.1.51 and port 22 -w /tmp/tcpdump.cap</span><br><span class="line">       注：抓取所有经过网卡1，目的主机为192.168.1.51的网络数据并存储。</span><br><span class="line"> 常用 ：tcpdump -i lo/eth0 -nn -port xxx</span><br></pre></td></tr></table></figure><h3 id="strace"><a href="#strace" class="headerlink" title="strace:"></a>strace:</h3><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 通过strace可以知道应用程序打开了哪些文件,以及读写了什么内容,包括消耗的时间以及返回值等。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-f 跟踪由fork调用所产生的子进程. </span><br><span class="line">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.</span><br></pre></td></tr></table></figure><blockquote><p>一次排查问题的应用：<a href="https://blog.csdn.net/cs729298/article/details/81906375" target="_blank" rel="noopener">https://blog.csdn.net/cs729298/article/details/81906375</a></p></blockquote><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用strace调试程序：</span><br><span class="line">    我决定采用strace看一下在启动 dcopserver时到底程序做了什么：</span><br><span class="line">    strace -f -F -o ~/dcop-strace.txt dcopserver</span><br><span class="line">解决库依赖问题</span><br><span class="line">限制strace只跟踪特定的系统调用：如果你已经知道你要找什么，你可以让strace只跟踪一些类型的系统调用</span><br><span class="line">    strace -f -o configure-strace.txt -e execve ./configure</span><br><span class="line">常用：strace -ff -o out /usr/java/bin/java TestSocket</span><br></pre></td></tr></table></figure><h3 id="route："><a href="#route：" class="headerlink" title="route："></a>route：</h3><p>Linux系统的route命令用于显示和操作IP路由表（show / manipulate the IP routing table）。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。</p><blockquote><p><a href="https://blog.csdn.net/xiaozhongma/article/details/52945029?locationNum=2&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/xiaozhongma/article/details/52945029?locationNum=2&amp;fps=1</a></p></blockquote><div class="table-container"><table><thead><tr><th>Destination</th><th>目标网段或者主机</th></tr></thead><tbody><tr><td>Gateway</td><td>网关地址，”*” 表示目标是本主机所属的网络，不需要路由</td></tr><tr><td>Genmask</td><td>网络掩码</td></tr><tr><td>Flags</td><td>标记。一些可能的标记如下：</td></tr><tr><td></td><td>U — 路由是活动的</td></tr><tr><td></td><td>H — 目标是一个主机</td></tr><tr><td></td><td>G — 路由指向网关</td></tr><tr><td></td><td>R — 恢复动态路由产生的表项</td></tr><tr><td></td><td>D — 由路由的后台程序动态地安装</td></tr><tr><td></td><td>M — 由路由的后台程序修改</td></tr><tr><td></td><td>! — 拒绝路由</td></tr><tr><td>Metric</td><td>路由距离，到达指定网络所需的中转数（linux 内核中没有使用）</td></tr><tr><td>Ref</td><td>路由项引用次数（linux 内核中没有使用）</td></tr><tr><td>Use</td><td>此路由项被路由软件查找的次数</td></tr><tr><td>Iface</td><td>该路由表项对应的输出接口</td></tr></tbody></table></div><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">实例1：显示当前路由</span><br><span class="line">    route</span><br><span class="line">    route -n</span><br><span class="line">    route -n (-n 表示不解析名字,列出速度会比route 快)</span><br><span class="line">实例2：添加网关/设置网关</span><br><span class="line">    route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0</span><br><span class="line">实例3：屏蔽一条路由</span><br><span class="line">    route add -net 224.0.0.0 netmask 240.0.0.0 reject</span><br><span class="line">实例4：删除路由记录</span><br><span class="line">    route del -net 224.0.0.0 netmask 240.0.0.0</span><br><span class="line">    route del -net 224.0.0.0 netmask 240.0.0.0 reject</span><br><span class="line">实例5：删除和添加设置默认网关</span><br><span class="line">    route del default gw 192.168.120.240</span><br><span class="line">    route add default gw 192.168.120.240</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的8个变量</title>
      <link href="/2022/07/23/mysql-2022-07-23-mysql%E7%9A%848%E4%B8%AA%E5%8F%98%E9%87%8F/"/>
      <url>/2022/07/23/mysql-2022-07-23-mysql%E7%9A%848%E4%B8%AA%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>　本篇会简单介绍在 MySQL 中关于 8个 character_set 变量的基本作用。</p></blockquote><p>　使用下列<a href="https://so.csdn.net/so/search?q=SQL语句&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">SQL语句</a>可以查看 MySQL中8个 character_set 变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE&#39;%char%&#39;;</span><br></pre></td></tr></table></figure><p>8个 character_set 变量：</p><p>　　一、character_set_client</p><p>　　二、character_set_connection</p><p>　　三、character_set_database</p><p>　　四、character_set_filesystem</p><p>　　五、character_set_results</p><p>　　六、character_set_server</p><p>　　七、character_set_system</p><p>　　八、character_sets_dir</p><p><em>一、character_set_client</em></p><p>　　主要用来设置客户端使用的字符集。</p><p><em>二、character_set_connection</em></p><p>　　主要用来设置连接数据库时的字符集，如果程序中没有指明连接数据库使用的字符集类型则按照这个字符集设置。</p><p><em>三、character_set_database</em></p><p>　　主要用来设置默认创建数据库的编码格式，如果在创建数据库时没有设置编码格式，就按照这个格式设置。</p><p><em>四、character_set_filesystem</em></p><p>　　文件系统的编码格式，把操作系统上的文件名转化成此字符集，即把 character_set_client转换character_set_filesystem， 默认binary是不做任何转换的。</p><p><em>五、character_set_results</em></p><p>　　数据库给客户端返回时使用的编码格式，如果没有指明，使用服务器默认的编码格式。</p><p><em>六、character_set_server</em></p><p>　　服务器安装时指定的默认编码格式，这个变量建议由系统自己管理，不要人为定义。</p><p><em>七、character_set_system</em></p><p>　　数据库系统使用的编码格式，这个值一直是utf8，不需要设置，它是为存储系统元数据的编码格式。</p><p><em>八、character_sets_dir</em></p><p>　　这个变量是字符集安装的目录。</p><p><em>在启动mysql后，我们只关注下列变量是否符合我们的要求</em></p><ul><li>character_set_client</li><li>character_set_connection</li><li>character_set_database</li><li>character_set_results</li><li>character_set_server</li></ul><p><em>下列三个系统变量我们不需要关心，不会影响乱码等问题</em></p><ul><li>character_set_filesystem</li><li>character_set_system</li><li>character_sets_dir</li></ul><p><strong>更改以上字符集直接 set character_set_XXX = “gbk”;（XXX是写以上的变量名）</strong></p><p><em>借助网上的一个完整的用户请求的字符集转换流程来更好的理解上述几个变量：</em></p><ol><li>mysql Server收到请求时将请求数据从 <strong>character_set_client</strong> 转换为 <strong>character_set_connection</strong></li><li>进行内部操作前将请求数据从 <strong>character_set_connection</strong> 转换为内部操作字符集,步骤如下</li></ol><p>　　A. 使用每个数据字段的 <strong>CHARACTER SET</strong> 设定值；</p><p>　　B. 若上述值不存在，则使用对应数据表的字符集设定值</p><p>　　C. 若上述值不存在，则使用对应数据库的字符集设定值；</p><p>　　D. 若上述值不存在，则使用 <strong>character_set_server</strong> 设定值。</p><ol><li>最后将操作结果从内部操作字符集转换为 <strong>character_set_results</strong></li></ol><p><img src="1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql编码错进错出解释</title>
      <link href="/2022/07/23/mysql-2022-07-23-mysql%E7%BC%96%E7%A0%81%E9%94%99%E8%BF%9B%E9%94%99%E5%87%BA%E8%A7%A3%E9%87%8A/"/>
      <url>/2022/07/23/mysql-2022-07-23-mysql%E7%BC%96%E7%A0%81%E9%94%99%E8%BF%9B%E9%94%99%E5%87%BA%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h3 id="相关变量"><a href="#相关变量" class="headerlink" title="相关变量"></a>相关变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET character_set_client &#x3D; charset_name;</span><br><span class="line">SET character_set_results &#x3D; charset_name;</span><br><span class="line">SET character_set_connection &#x3D; charset_name;</span><br></pre></td></tr></table></figure><h3 id="过程复现及原理解释"><a href="#过程复现及原理解释" class="headerlink" title="过程复现及原理解释"></a>过程复现及原理解释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先假设客户端bash都是utf8</span><br><span class="line">SET character_set_client &#x3D; gbk;</span><br><span class="line">SET character_set_results &#x3D; gbk;</span><br></pre></td></tr></table></figure><ol><li><strong>客户端发送’你好’，使用utf8编码</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select hex(convert(&#39;你好&#39; using utf8));</span><br><span class="line">+-----------------------------------+</span><br><span class="line">| hex(convert(&#39;你好&#39; using utf8))   |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">| E4BDA0E5A5BD                      |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><ol><li><strong>服务端按照gbk错误解码,解出，3个字符’浣犲ソ’，由引擎进行语法解析</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select convert(0xE4BDA0E5A5BD using gbk);</span><br><span class="line">+-----------------------------------+</span><br><span class="line">| convert(0xE4BDA0E5A5BD using gbk) |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">| 浣犲ソ                            |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ol><li><strong>解析完之后，server端需要先判断 character_set_client与character_set_connection是否一致，若不一致需要编码转换（但注意最终存储是按照table的chartset 编码方式进行的）</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select hex(convert(&#39;浣犲ソ&#39; using utf8));</span><br><span class="line">+--------------------------------------+</span><br><span class="line">| hex(convert(&#39;浣犲ソ&#39; using utf8))    |</span><br><span class="line">+--------------------------------------+</span><br><span class="line">| E6B5A3E78AB2E382BD                   |</span><br><span class="line">+--------------------------------------+</span><br></pre></td></tr></table></figure><ol><li><strong>转换完成之后，准备进行存储了，再判断表的charset是什么编码，进行转换，表我们用utf8，编码一致，最终存储即 E6B5A3E78AB2E382BD，代表字符 ‘浣犲ソ’</strong></li><li>当进行查询时候，server按照character_set_results 进行编码返回，存储的是utf8，所以需要编码转换，<font color = red>注意，编码转换不是错误解码，并不是对这个二进制按照gbk解码，而是说，对‘浣犲ソ’ ，转换成在gbk编码方式下的二进制存储（这也意味着两种编码方式的字库表一定是都包含这几个字符，不然怎么转换编码？实际上，utf8兼容gbk对应编码，gbk是字库表是字符集）</font></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select hex(convert(&#39;浣犲ソ&#39; using gbk));</span><br><span class="line">+-------------------------------------+</span><br><span class="line">| hex(convert(&#39;浣犲ソ&#39; using gbk))    |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">| E4BDA0E5A5BD                        |</span><br><span class="line">+-------------------------------------+</span><br></pre></td></tr></table></figure><ol><li><strong>此时客户端收到E4BDA0E5A5BD ，在gbk编码下代表’浣犲ソ’，但是此时bash用了utf8,所以我们用了错误的编码方式</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select convert(0xE4BDA0E5A5BD using utf8);</span><br><span class="line">+------------------------------------+</span><br><span class="line">| convert(0xE4BDA0E5A5BD using utf8) |</span><br><span class="line">+------------------------------------+</span><br><span class="line">| 你好                               |</span><br><span class="line">+------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><p>character_set_client 和 character_set_results 是一定要和客户端一致，不要依赖于负负得正，character_set_connection 设置和character_set_client 不一致，有丢失数据的风险，所以尽量也一致，总之这3个值就是要一样，还要和客户端一致，所以才有了 set names 这个快捷命令。</p></li><li><p>只要保证set nams的3个变量 以及客户端bash编码一致，就不会乱码,在加上表编码也是utf8，保证这4样都是utf8，肯定不会乱码。注意表的charset要是latin1，由于支持不了中文，不如utf8字符集大，会出现有损转换，千万注意。</p></li></ol><blockquote><p>参考：<a href="https://blog.csdn.net/czh500/article/details/86665509" target="_blank" rel="noopener">https://blog.csdn.net/czh500/article/details/86665509</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解和解决MySQL乱码问题</title>
      <link href="/2022/07/23/mysql-2022-07-23-%E7%90%86%E8%A7%A3%E5%92%8C%E8%A7%A3%E5%86%B3MySQL%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/07/23/mysql-2022-07-23-%E7%90%86%E8%A7%A3%E5%92%8C%E8%A7%A3%E5%86%B3MySQL%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载网络好文:<a href="http://cenalulu.github.io/mysql/mysql-mojibake/" target="_blank" rel="noopener">http://cenalulu.github.io/mysql/mysql-mojibake/</a></p><p>本文将详细介绍MySQL乱码的成因和具体的解决方案</p><p>在阅读本文之前，强烈建议对字符集编码概念还比较模糊的同学 阅读下博主之前对相关概念的一篇科普：<a href="http://cenalulu.github.io/linux/character-encoding/" target="_blank" rel="noopener">十分钟搞清字符集和字符编码</a></p></blockquote><h2 id="MySQL出现乱码的原因"><a href="#MySQL出现乱码的原因" class="headerlink" title="MySQL出现乱码的原因"></a>MySQL出现乱码的原因</h2><p>要了解为什么会出现乱码，我们就先要理解：从客户端发起请求，到MySQL存储数据，再到下次从表取回客户端的过程中，哪些环节会有编码/解码的行为。为了更好的解释这个过程，博主制作了两张流程图，分别对应存入和取出两个阶段。</p><h4 id="存入MySQL经历的编码转换过程"><a href="#存入MySQL经历的编码转换过程" class="headerlink" title="存入MySQL经历的编码转换过程"></a>存入MySQL经历的编码转换过程</h4><p><img src="http://cenalulu.github.io/images/mysql/mojibake/flow.png" alt="mysqlflow"> 上图中有3次编码/解码的过程（红色箭头）。三个红色箭头分别对应：客户端编码，MySQL Server解码，Client编码向表编码的转换。其中Terminal可以是一个Bash，一个web页面又或者是一个APP。本文中我们假定Bash是我们的Terminal，即用户端的输入和展示界面。图中每一个框格对应的行为如下：</p><ul><li>在terminal中使用输入法输入</li><li>terminal根据字符编码转换成二进制流</li><li>二进制流通过MySQL客户端传输到MySQL Server</li><li>Server通过character-set-client解码</li><li>判断character-set-client和目标表的charset是否一致</li><li>如果不一致则进行一次从client-charset到table-charset的一次字符编码转换</li><li>将转换后的字符编码二进制流存入文件中</li></ul><h4 id="从MySQL表中取出数据经历的编码转换过程"><a href="#从MySQL表中取出数据经历的编码转换过程" class="headerlink" title="从MySQL表中取出数据经历的编码转换过程"></a>从MySQL表中取出数据经历的编码转换过程</h4><p><img src="http://cenalulu.github.io/images/mysql/mojibake/flow2.png" alt="mysqlflow"> 上图有3次编码/解码的过程（红色箭头）。上图中三个红色箭头分别对应：客户端解码展示，MySQL Server根据<code>character-set-client</code>编码，表编码向<code>character-set-client</code>编码的转换。</p><ul><li>从文件读出二进制数据流</li><li>用表字符集编码进行解码</li><li>将数据转换为character-set-client的编码</li><li>使用character-set-client编码为二进制流</li><li>Server通过网络传输到远端client</li><li>client通过bash配置的字符编码展示查询结果</li></ul><h4 id="造成MySQL乱码的原因"><a href="#造成MySQL乱码的原因" class="headerlink" title="造成MySQL乱码的原因"></a>造成MySQL乱码的原因</h4><p><em>1. 存入和取出时对应环节的编码不一致</em> 这个会造成乱码是显而易见的。我们把存入阶段的三次编解码使用的字符集编号为C1,C2,C3（图一从左到右）；取出时的三个字符集依次编号为C1’,C2’,C3’（从左到右）。那么存入的时候bash <code>C1</code>用的是UTF-8编码，取出的时候,<code>C1&#39;</code>我们却使用了windows终端（默认是GBK编码），那么结果几乎一定是乱码。又或者存入MySQL的时候<code>set names utf8</code>(<code>C2</code>)，而取出的时候却使用了<code>set names gbk</code>(<code>C2&#39;</code>)，那么结果也必然是乱码</p><p><em>2. 单个流程中三步的编码不一致</em> 即上面任意一幅图中的同方向的三步中，只要两步或者两部以上的编码有不一致就有可能出现编解码错误。如果差异的两个字符集之间无法进行无损编码转换（下文会详细介绍），那么就一定会出现乱码。例如：我们的shell是UTF8编码，MySQL的<code>character-set-client</code>配置成了GBK，而表结构却又是<code>charset=utf8</code>，那么毫无疑问的一定会出现乱码。 这里我们就简单演示下这种情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; create table charset_test_utf8 (id int primary key auto_increment, char_col varchar(50)) charset &#x3D; utf8;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; set names gbk;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; insert into charset_test_utf8 (char_col) values (&#39;中文&#39;);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; show warnings;</span><br><span class="line">+---------+------+---------------------------------------------------------------------------+</span><br><span class="line">| Level   | Code | Message                                                                   |</span><br><span class="line">+---------+------+---------------------------------------------------------------------------+</span><br><span class="line">| Warning | 1366 | Incorrect string value: &#39;\xAD\xE6\x96\x87&#39; for column &#39;char_col&#39; at row 1 |</span><br><span class="line">+---------+------+---------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; select id,hex(char_col),char_col from charset_test_utf8;</span><br><span class="line">+----+----------------+----------+</span><br><span class="line">| id | hex(char_col)  | char_col |</span><br><span class="line">+----+----------------+----------+</span><br><span class="line">|  1 | E6B6933FE69E83 | �?��        |</span><br><span class="line">+----+----------------+----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><h4 id="关于MySQL的编-解码"><a href="#关于MySQL的编-解码" class="headerlink" title="关于MySQL的编/解码"></a>关于MySQL的编/解码</h4><p>既然系统之间是按照二进制流进行传输的，那直接把这串二进制流直接存入表文件就好啦。为什么在存储之前还要进行两次编解码的操作呢？</p><ul><li>Client to Server的编解码的原因是MySQL需要对传来的二进制流做语法和词法解析。如果不做编码解析和校验，我们甚至没法知道传来的一串二进制流是<code>insert</code>还是<code>update</code>。</li><li>File to Engine的编解码是为知道二进制流内的分词情况。举个简单的例子：我们想要从表里取出某个字段的前两个字符，执行了一句形如<code>select left(col,2) from table</code>的语句，存储引擎从文件读入该column的值是<code>E4B8ADE69687</code>。那么这个时候如果我们按照GBK把这个值分割成<code>E4B8</code>,<code>ADE6</code>,<code>9687</code>三个字，并那么返回客户端的值就应该是<code>E4B8ADE6</code>；如果按照UTF8分割成<code>E4B8AD</code>,<code>E69687</code>，那么就应该返回<code>E4B8ADE69687</code>两个字。可见，如果在从数据文件读入数据后，不进行编解码的话在存储引擎内部是无法进行字符级别的操作的。</li></ul><hr><h2 id="关于错进错出"><a href="#关于错进错出" class="headerlink" title="关于错进错出"></a>关于错进错出</h2><p>在MySQL中最常见的乱码问题的起因就是把<code>错进错出</code>神话。所谓的错进错出就是，客户端(web或shell)的字符编码和最终表的字符编码格式不同，但是只要保证存和取两次的字符集编码一致就仍然能够获得没有乱码的输出的这种现象。但是，错进错出并不是对于任意两种字符集编码的组合都是有效的。我们假设客户端的编码是C，MySQL表的字符集编码是S。那么为了能够错进错出，需要满足以下两个条件</p><blockquote><p>MySQL接收请求时，从C编码后的二进制流在被S解码时能够无损 MySQL返回数据是，从S编码后的二进制流在被C解码时能够无损</p></blockquote><h4 id="编码无损转换"><a href="#编码无损转换" class="headerlink" title="编码无损转换"></a>编码无损转换</h4><p>那么什么是有损转换，什么是无损转换呢？假设我们要把用编码A表示的字符X，转化为编码B的表示形式，而编码B的字形集中并没有X这个字符，那么此时我们就称这个转换是有损的。那么，为什么会出现两个编码所能表示字符集合的差异呢？如果大家看过博主之前的那篇 <a href="http://cenalulu.github.io/linux/character-encoding/" target="_blank" rel="noopener">十分钟搞清字符集和字符编码</a>，或者对字符编码有基础理解的话，就应该知道每个字符集所支持的字符数量是有限的，并且各个字符集涵盖的文字之间存在差异。UTF8和GBK所能表示的字符数量范围如下</p><ul><li>GBK单个字符编码后的取值范围是：<code>8140</code> - <code>FEFE</code> 其中不包括<code>**7E</code>，总共字符数在27000左右</li><li>UTF8单个字符编码后，按照字节数的不同，取值范围如下表：</li></ul><p><img src="http://cenalulu.github.io/images/mysql/mojibake/utf8.png" alt="img"></p><p>由于UTF-8编码能表示的字符数量远超GBK。那么我们很容易就能找到一个从UTF8到GBK的有损编码转换。我们用字符映射器（见下图）找出了一个明显就不在GBK编码表中的字符，尝试存入到GBK编码的表中。并再次取出查看有损转换的行为 字符信息具体是：<code>ਅ GURMUKHI LETTER A Unicode: U+0A05, UTF-8: E0 A8 85</code></p><p><img src="http://cenalulu.github.io/images/mysql/mojibake/charset.png" alt="img"></p><p>在MySQL中存储的具体情况如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; create table charset_test_gbk (id int primary key auto_increment, char_col varchar(50)) charset &#x3D; gbk;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; set names utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; insert into charset_test_gbk (char_col) values (&#39;ਅ&#39;);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.01 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; show warnings;</span><br><span class="line">+---------+------+-----------------------------------------------------------------------+</span><br><span class="line">| Level   | Code | Message                                                               |</span><br><span class="line">+---------+------+-----------------------------------------------------------------------+</span><br><span class="line">| Warning | 1366 | Incorrect string value: &#39;\xE0\xA8\x85&#39; for column &#39;char_col&#39; at row 1 |</span><br><span class="line">+---------+------+-----------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; select id,hex(char_col),char_col,char_length(char_col) from charset_test_gbk;</span><br><span class="line">+----+---------------+----------+-----------------------+</span><br><span class="line">| id | hex(char_col) | char_col | char_length(char_col) |</span><br><span class="line">+----+---------------+----------+-----------------------+</span><br><span class="line">|  1 | 3F            | ?        |                     1 |</span><br><span class="line">+----+---------------+----------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>出错的部分是在编解码的第3步时发生的。具体见下图 <img src="http://cenalulu.github.io/images/mysql/mojibake/flow3.png" alt="flow2"></p><p>可见MySQL内部如果无法找到一个UTF8字符所对应的GBK字符时，就会转换成一个错误mark（这里是问号）。而每个字符集在程序实现的时候内部都约定了当出现这种情况时的行为和转换规则。例如：UTF8中无法找到对应字符时，如果不抛错那么就将该字符替换成<code>�</code>(U+FFFD)</p><p>那么是不是任何两种字符集编码之间的转换都是有损的呢？并非这样，转换是否有损取决于以下几点：</p><ul><li>被转换的字符是否同时在两个字符集中</li><li>目标字符集是否能够对不支持字符，保留其原有表达形式</li></ul><p>关于第一点，刚才已经通过实验来解释过了。这里来解释下造成有损转换的第二个因素。从刚才的例子我们可以看到由于GBK在处理自己无法表示的字符时的行为是：用<code>错误标识</code>替代，即<code>0x3F</code>。而有些字符集（例如latin1）在遇到自己无法表示的字符时，会保留原字符集的编码数据，并跳过忽略该字符进而处理后面的数据。如果目标字符集具有这样的特性，那么就能够实现这节最开始提到的<code>错进错出</code>的效果。 我们来看下面这个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; create table charset_test (id int primary key auto_increment, char_col varchar(50)) charset &#x3D; latin1;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; set names latin1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; insert into charset_test (char_col) values (&#39;中文&#39;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; select id,hex(char_col),char_col from charset_test;</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">| id | hex(char_col) | char_col |</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">|  2 | E4B8ADE69687  | 中文     |</span><br><span class="line">+----+---------------+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>具体流程图如下。可见在被MySQL Server接收到以后实际上已经发生了编码不一致的情况。但是由于Latin1字符集对于自己表述范围外的字符不会做任何处理，而是保留原值。这样的行为也使得错进错出成为了可能。 <img src="http://cenalulu.github.io/images/mysql/mojibake/flow4.png" alt="flow4"></p><hr><h2 id="如何避免乱码"><a href="#如何避免乱码" class="headerlink" title="如何避免乱码"></a>如何避免乱码</h2><p>理解了上面的内容，要避免乱码就显得很容易了。只要做到“三位一体”，即客户端，MySQL character-set-client，table charset三个字符集完全一致就可以保证一定不会有乱码出现了。而对于已经出现乱码，或者已经遭受有损转码的数据，如何修复相对来说就会有些困难。下一节我们详细介绍具体方法。</p><h2 id="如何修复已经编码损坏的数据"><a href="#如何修复已经编码损坏的数据" class="headerlink" title="如何修复已经编码损坏的数据"></a>如何修复已经编码损坏的数据</h2><p>在介绍正确方法前，我们先科普一下那些网上流传的所谓的“正确方法”可能会造成的严重后果。</p><h4 id="错误方法一"><a href="#错误方法一" class="headerlink" title="错误方法一"></a>错误方法一</h4><p>无论从语法还是字面意思来看：<code>ALTER TABLE ... CHARSET=xxx</code> 无疑是最像包治乱码的良药了！而事实上，他对于你已经损坏的数据一点帮助也没有，甚至连已经该表已经创建列的默认字符集都无法改变。我们看下面这个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; show create table charset_test;</span><br><span class="line">+--------------+--------------------------------+</span><br><span class="line">| Table        | Create Table                   |</span><br><span class="line">+--------------+--------------------------------+</span><br><span class="line">| charset_test | CREATE TABLE &#96;charset_test&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;char_col&#96; varchar(50) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;3 DEFAULT CHARSET&#x3D;latin1 |</span><br><span class="line">+--------------+--------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; alter table charset_test charset&#x3D;gbk;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; show create table charset_test;</span><br><span class="line">+--------------+--------------------------------+</span><br><span class="line">| Table        | Create Table                   |</span><br><span class="line">+--------------+--------------------------------+</span><br><span class="line">| charset_test | CREATE TABLE &#96;charset_test&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;char_col&#96; varchar(50) CHARACTER SET latin1 DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;3 DEFAULT CHARSET&#x3D;gbk |</span><br><span class="line">+--------------+--------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可见该语法紧紧修改了表的默认字符集，即只对以后创建的列的默认字符集产生影响，而对已经存在的列和数据没有变化。</p><h4 id="错误方法二"><a href="#错误方法二" class="headerlink" title="错误方法二"></a>错误方法二</h4><p><code>ALTER TABLE … CONVERT TO CHARACTER SET …</code>的相较于方法一来说杀伤力更大，因为从 <a href="http://dev.mysql.com/doc/refman/5.1/en/alter-table.html" target="_blank" rel="noopener">官方文档的解释</a> 他的作用就是用于对一个表的数据进行编码转换。下面是文档的一小段摘录：</p><blockquote><p>To change the table default character set and all character columns (CHAR, VARCHAR, TEXT) to a new character set, use a statement like this: ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name [COLLATE collation_name];</p></blockquote><p><strong>而实际上，这句语法只适用于当前并没有乱码，并且不是通过<code>错进错出</code>的方法保存的表。</strong>。而对于已经因为错进错出而产生编码错误的表，则会带来更糟的结果。我们用一个实际例子来解释下，这句SQL实际做了什么和他会造成的结果。假设我们有一张编码是latin1的表，且之前通过错进错出存入了UTF-8的数据，但是因为通过terminal仍然能够正常显示。即上文错进错出章节中举例的情况。一段时间使用后我们发现了这个错误，并打算把表的字符集编码改成UTF-8并且不影响原有数据的正常显示。这种情况下使用<code>alter table convert to character set</code>会有这样的后果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; create table charset_test_latin1 (id int primary key auto_increment, char_col varchar(50)) charset &#x3D; latin1;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; set names latin1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; insert into charset_test_latin1 (char_col) values (&#39;这是中文&#39;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; select id,hex(char_col),char_col,char_length(char_col) from charset_test_latin1;</span><br><span class="line">+----+--------------------------+--------------+-----------------------+</span><br><span class="line">| id | hex(char_col)            | char_col     | char_length(char_col) |</span><br><span class="line">+----+--------------------------+--------------+-----------------------+</span><br><span class="line">|  1 | E8BF99E698AFE4B8ADE69687 | 这是中文     |                    12 |</span><br><span class="line">+----+--------------------------+--------------+-----------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; alter table charset_test_latin1 convert to character set utf8;</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; set names utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">master [localhost] &#123;msandbox&#125; (test) &gt; select id,hex(char_col),char_col,char_length(char_col) from charset_test_latin1;</span><br><span class="line">+----+--------------------------------------------------------+-----------------------------+-----------------------+</span><br><span class="line">| id | hex(char_col)                                          | char_col                    | char_length(char_col) |</span><br><span class="line">+----+--------------------------------------------------------+-----------------------------+-----------------------+</span><br><span class="line">|  1 | C3A8C2BFE284A2C3A6CB9CC2AFC3A4C2B8C2ADC3A6E28093E280A1 | è¿™æ˜¯ä¸­æ–‡                |                    12 |</span><br><span class="line">+----+--------------------------------------------------------+-----------------------------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>从这个例子我们可以看出，对于已经错进错出的数据表，这个命令不但没有起到“拨乱反正”的效果，还会彻底将数据糟蹋，连数据的二进制编码都改变了。</p><h4 id="正确的方法一-Dump-amp-Reload"><a href="#正确的方法一-Dump-amp-Reload" class="headerlink" title="正确的方法一 Dump &amp; Reload"></a>正确的方法一 Dump &amp; Reload</h4><p>这个方法比较笨，但也比较好操作和理解。简单的说分为以下三步：</p><ol><li>通过错进错出的方法，导出到文件</li><li>用正确的字符集修改新表</li><li>将之前导出的文件导回到新表中</li></ol><p>还是用上面那个例子举例，我们用UTF-8将数据“错进”到latin1编码的表中。现在需要将表编码修改为UTF-8可以使用以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; mysqldump -u root -p -t --skip-set-charset --default-character-set&#x3D;utf8 test charset_test_latin1 &gt; data.sql</span><br><span class="line">#确保导出的文件用文本编辑器在UTF-8编码下查看没有乱码</span><br><span class="line">shell&gt; mysql -uroot -p -e &#39;create table charset_test_latin1 (id int primary key auto_increment, char_col varchar(50)) charset &#x3D; utf8&#39; test</span><br><span class="line">shell&gt; mysql -uroot -p  --default-character-set&#x3D;utf8 test &lt; data.sql</span><br></pre></td></tr></table></figure><h4 id="正确的方法二-Convert-to-Binary-amp-Convert-Back"><a href="#正确的方法二-Convert-to-Binary-amp-Convert-Back" class="headerlink" title="正确的方法二 Convert to Binary &amp; Convert Back"></a>正确的方法二 Convert to Binary &amp; Convert Back</h4><p>这种方法比较取巧，用的是将二进制数据作为中间数据的做法来实现的。由于，MySQL再将有编码意义的数据流，转换为无编码意义的二进制数据的时候并不做实际的数据转换。而从二进制数据准换为带编码的数据时，又会用目标编码做一次编码转换校验。通过这两个特性就相当于在MySQL内部模拟了一次“错出”，将乱码“拨乱反正”了。</p><p>还是用上面那个例子举例，我们用UTF-8将数据“错进”到latin1编码的表中。现在需要将表编码修改为UTF-8可以使用以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE charset_test_latin1 MODIFY COLUMN char_col VARBINARY(50);</span><br><span class="line">mysql&gt; ALTER TABLE charset_test_latin1 MODIFY COLUMN char_col varchar(50) character set utf8;</span><br></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ol><li><a href="http://www.psce.com/blog/2015/03/03/mysql-character-encoding-part-2/" target="_blank" rel="noopener">http://www.psce.com/blog/2015/03/03/mysql-character-encoding-part-2/</a></li><li><a href="http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php" target="_blank" rel="noopener">http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php</a></li><li><a href="http://zh.wikipedia.org/wiki/汉字内码扩展规范" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/%E6%B1%89%E5%AD%97%E5%86%85%E7%A0%81%E6%89%A9%E5%B1%95%E8%A7%84%E8%8C%83</a></li><li><a href="http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php" target="_blank" rel="noopener">http://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php</a></li><li><a href="http://blog.csdn.net/ws84643557/article/details/6905167" target="_blank" rel="noopener">http://blog.csdn.net/ws84643557/article/details/6905167</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字库表、编码字符集、字符编码</title>
      <link href="/2022/07/23/mysql-2022-07-23-%E5%AD%97%E5%BA%93%E8%A1%A8%E3%80%81%E7%BC%96%E7%A0%81%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%81%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
      <url>/2022/07/23/mysql-2022-07-23-%E5%AD%97%E5%BA%93%E8%A1%A8%E3%80%81%E7%BC%96%E7%A0%81%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%81%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p><strong>字库表（character repertoire）</strong>：相当于一个 <strong>所有</strong> 可读或者可显示字符的数据库（可读的字符不一定能够直观的显示出来，如回车）。其决定了编码字符集能够展示的字符的范围。每一种编码字符集，应该都对应着一个字库表。例如 ASCII 字符集，对应的字库表就是由换行、回车等控制字符，和数字、大小写字母、英文标点符号等 128 个字符组成的。且这 128 个字符，是按照一定顺序来排列的。<strong>这里需要注意，字库表本身只包含按照顺序排序的字符，而不包含标记字符位置的序号。</strong></p><p><strong>编码字符集（coded character set）</strong>：是字库表中所有字符以及对应的编码的集合（这里的 “编码”，是名词）。每一个编码（Code Point），都是一个二进制代码（因为计算机的底层就是基于二进制的），且都对应着字库表中的一个字符（就类似于摩斯电码，A 对应的代码为 ·-）。而该编码，一般取值为字符在字库表中的位置序号。</p><p>从某种形式上来说，编码字符集是字库表的扩展。</p><p><strong>字符编码</strong>：（这里的 “编码”，是动词）是一种映射规则，通过这种规则，就可以把存储二进制的数据转换成对应的字符，或者把字符转换为用于存储的二进制数据。而不是直接将编码字符集中的编码进行存储，不依照规则，则可能出现乱码。</p><p>因为字符集只规定了字符的二进制代码，却没有规定这个二进制代码如何存储。因此，就需要 “字符编码” 来处理了，即参考某一规则，将原始的二进制代码进行加工，才能进行存储。反过来，也需要根据这一规则将存储的内容进行解码，才能。另外，一个编码字符集，可以对应多种不同的字符编码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编码字符集 Unicode，有 UTF-8、UTF-16、UTF-32 等多种字符编码。</span><br><span class="line"></span><br><span class="line">编码字符集 ASCII，即对应着 ASCII 字符编码。</span><br><span class="line"></span><br><span class="line">编码字符集 CB2312，只有 EUC-CN 一种字符编码。</span><br></pre></td></tr></table></figure><p>以 Unicode 字符集举例，它对世界上大部分的文字系统进行了整理、编码，使得计算机可以用更为简单的方式来呈现和处理文字。</p><p>UTF-8 是其常用的字符编码之一。它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p><p>（1）比如 大写字母 A，其在 Unicode 字符集中对应的编码为 1000001（二进制）。经过 UTF-8 字符编码后，为 01000001。</p><p>其中 1000001 为原始 Unicode 字符集的二进制编码，01000001 为在计算器中存储时的二进制代码。这两者是要进行区别的。</p><p>（2）对于汉字 严，其在 Unicode 字符集中对应的编码为 100111000100101（二进制）。经过 UTF-8 字符编码后，为 11100100 10111000 10100101。（参考自：<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a>）</p><p>至于具体的 UTF-8 的编码规则，也可以参考 <a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p><blockquote><p><strong>参考文章：</strong></p><p>1、<a href="http://cenalulu.github.io/linux/character-encoding/" target="_blank" rel="noopener">十分钟搞清字符集和字符编码</a></p><p>2、<a href="https://blog.csdn.net/qq_29028175/article/details/52959551" target="_blank" rel="noopener">字符编码与字符集的区别</a></p><p>3、<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>screen命令</title>
      <link href="/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-screen%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-screen%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Screen简介"><a href="#Screen简介" class="headerlink" title="Screen简介"></a>Screen简介</h3><p>在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。</p><p><strong>简而言之：</strong></p><p>远程服务器的时候，断网或者手误关掉了远程终端，会导致会话中断，程序终止。</p><p>而Screen连接的终端，会话独立运行，程序会一直进行。而且会话可以恢复，还可以自行删除。</p><h3 id="常用screen命令"><a href="#常用screen命令" class="headerlink" title="常用screen命令"></a>常用screen命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">screen -S yourname           # 新建一个叫yourname的session</span><br><span class="line">screen -ls                   # 列出当前所有的session</span><br><span class="line">screen -r yourname           # 回到yourname这个session</span><br><span class="line">screen -d yourname           # 远程detach某个session    # detach快捷键 ctrl a + d</span><br><span class="line">screen -d -r yourname        # 结束当前session并回到yourname这个session</span><br><span class="line">screen -S yourname -X quit   # 删除叫yourname的session</span><br></pre></td></tr></table></figure><h4 id="恢复会话"><a href="#恢复会话" class="headerlink" title="恢复会话"></a>恢复会话</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r session_name</span><br></pre></td></tr></table></figure><p><strong>如果不能恢复：</strong></p><p>对于已经Attached Session则不能直接screen -r，需要先screen -d，然后才能screen -r</p><p>用screen -ls可以查看所有的session的状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">先 screen -d session_name</span><br><span class="line">再 screen -r session_name</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S session_name -X quit</span><br></pre></td></tr></table></figure><p><strong>重命名怎么删，如下图：</strong></p><p>​    <img src="1.png" alt=""></p><ol><li><p>没有重命名的直接可以screen -S session_name -X quit</p></li><li><p>重命名的，需要带上id删，screen -S id.session_name -X quit                              </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> linux下 bin和 usr bin和 usr local bin的区别</title>
      <link href="/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-linux%E4%B8%8B-bin%E5%92%8C-usr-bin%E5%92%8C-usr-local-bin%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-linux%E4%B8%8B-bin%E5%92%8C-usr-bin%E5%92%8C-usr-local-bin%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/bin 是所有用户都可以访问并执行的可执行程序。包括超级用户及一般用户。</span><br><span class="line">/usr/bin 是系统安装时自带的一些可执行程序。即系统程序，轻易不要去动里面的东西，容易入坑。</span><br><span class="line">/usr/local/bin 是用户自行编译安装时默认的可执行程序的安装位置，这个不小心误删点什么，不会影响大局。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux不同版本的服务管理</title>
      <link href="/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-linux%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-linux%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Rhel6 用 service 和 chkconfig 来管理服务，它是 SystemV 架构下的一个工具。</p><p>Rhel7 是用 systemctl 来管理服务，它融合了之前的 service 和 chkconfig 的功能于一体。可以使用它永久性或只在当前会话中启用/禁用服务。systemctl 是 systemd 架构下的一个工具。</p><div class="table-container"><table><thead><tr><th>动作</th><th>Rhel6 旧指令</th><th>Rhel7新指令</th></tr></thead><tbody><tr><td>启动某服务</td><td>service httpd start</td><td>systemctl start httpd</td></tr><tr><td>停止某服务</td><td>service httpd stop</td><td>systemctl stop httpd</td></tr><tr><td>重启某服务</td><td>service httpd restart</td><td>systemctl restart httpd</td></tr><tr><td>检查服务状态</td><td>service httpd status</td><td>systemctl status httpd</td></tr><tr><td>删除某服务</td><td>chkconfig —del httpd</td><td>停掉应用，删除其配置文件</td></tr><tr><td>使服务开机自启动</td><td>chkconfig —level 5 httpd on</td><td>systemctl enable httpd</td></tr><tr><td>使服务开机不自启动</td><td>chkconfig —level 5 httpd off</td><td>systemctl disable httpd</td></tr><tr><td>显示所有已启动的服务</td><td>chkconfig —list</td><td>systemctl list-unit-files \</td><td>grep enabled</td></tr><tr><td>加入自定义服务</td><td>chkconfig —add test</td><td>systemctl load test</td></tr><tr><td>查询服务是否开机自启</td><td>chkconfig —list \</td><td>grep httpd</td><td>systemctl is-enabled httpd</td></tr><tr><td>查看启动失败的服务</td><td></td><td>systemctl —failed</td></tr></tbody></table></div><p>systemd的一些常用命令：</p><p>列出所有可用单元 ： systemctl list-unit-files</p><p>列出所有运行的单元： systemctl list-unit-files | grep enabled </p><p>列出所有可用服务： systemctl list-unit-files —type=service</p><p>列出所有运行的服务： systemctl list-unit-files —type=service | grep enabled </p><p>屏蔽httpd服务：systemctl mask httpd</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim的查找替换总结</title>
      <link href="/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-vim%E7%9A%84%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-vim%E7%9A%84%E6%9F%A5%E6%89%BE%E6%9B%BF%E6%8D%A2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>vim的查找替换操作如果能运用熟练是非常提高效率的，我们来重新梳理一下查找与替换的一些操作，方便更好的记忆 。</p></blockquote><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>在normal模式下按下/即可进入查找模式，输入要查找的字符串并按下回车。 Vim会跳转到第一个匹配。按下n查找下一个，按下N查找上一个。</p><ul><li>Vim查找支持正则表达式 <code>/vim$</code>匹配行尾的”vim”。</li><li>需要查找特殊字符需要转义，例如<code>/vim\$</code>匹配”vim$”。</li></ul><h3 id="大小写敏感查找"><a href="#大小写敏感查找" class="headerlink" title="大小写敏感查找"></a>大小写敏感查找</h3><p>在查找模式中加入\c表示大小写不敏感查找，\C表示大小写敏感查找。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/foo\c</span><br></pre></td></tr></table></figure><h3 id="大小写敏感配置"><a href="#大小写敏感配置" class="headerlink" title="大小写敏感配置"></a>大小写敏感配置</h3><p>Vim 默认采用大小写敏感的查找，为了方便我们常常将其配置为大小写不敏感：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置默认进行大小写不敏感查找 set ignorecase</span><br><span class="line">如果有一个大写字母，则切换到大小写敏感查找 set smartcase</span><br></pre></td></tr></table></figure><blockquote><p>将上述设置粘贴到你的~/.vimrc，重新打开Vim即可生效</p></blockquote><h3 id="查找当前单词"><a href="#查找当前单词" class="headerlink" title="查找当前单词"></a>查找当前单词</h3><p>在normal模式下按下*即可查找光标所在单词（word）， 要求每次出现的前后为空白字符或标点符号。</p><p>例如当前为foo， 可以匹配foo bar中的foo，但不可匹配foobar中的foo。 这在查找函数名、变量名时非常有用。</p><p>按下g*即可查找光标所在单词的字符序列，每次出现前后字符无要求。 即foo bar和foobar中的foo均可被匹配到。</p><h3 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h3><p>:s（substitute）命令用来查找和替换字符串。语法如下：</p><p><code>:{作用范围}s/{目标}/{替换}/{替换标志}</code>          </p><ul><li>%s/foo/bar/g会在全局范围(%)查找foo并替换为bar，所有出现都会被替换（g）</li></ul><h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><p>作用范围分为当前行、全文、选区等等。</p><ol><li>当前行：</li></ol><p>（g 看似为全局 (global) 的含义，容易让人误以为 g 标志位是用于实现在整个文件范围内进行替换操作，但实际上，g 仅表示<strong>当前一整行</strong>范围。由于 Vim 直接继承自 “行编辑器 ed”，对于行编辑器而言，全局的范围就是一行，这就是 g 标志位命令的由来）</p><font color = green>也就是说，不加g，在扫描范围内，只会替换对所有扫描到行的第一个！</font><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/foo/bar/g</span><br></pre></td></tr></table></figure><ol><li>全文：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/foo/bar/g</span><br></pre></td></tr></table></figure><ol><li><p>选区</p><p>选区，在Visual模式下选择区域后输入:，Vim即可自动补全为 :’&lt;,’&gt;。</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:'&lt;,'&gt;s/foo/bar/g</span><br></pre></td></tr></table></figure><ol><li><p>指定行:</p><ol><li>5-12行 </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:5,12s/foo/bar/g</span><br></pre></td></tr></table></figure><ol><li>当前行.与接下来两行+2：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:.,+2s/foo/bar/g</span><br></pre></td></tr></table></figure></li></ol><h3 id="替换标志"><a href="#替换标志" class="headerlink" title="替换标志"></a>替换标志</h3><p>上文中命令结尾的g即是替换标志之一，表示全局global替换（即替换目标的所有出现）。 还有很多其他有用的替换标志：</p><ol><li>空替换标志表示只替换从光标位置开始，目标的第一次出现：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/foo/bar</span><br></pre></td></tr></table></figure><ol><li>i表示大小写不敏感查找，I表示大小写敏感</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/foo/bar/i# 等效于模式中的\c（不敏感）或\C（敏感）:%s/foo\c/bar</span><br></pre></td></tr></table></figure><ol><li>c表示需要确认，例如全局查找”foo”替换为”bar”并且需要确认：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/foo/bar/gc</span><br></pre></td></tr></table></figure><p>回车后Vim会将光标移动到每一次”foo”出现的位置，并提示</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace with bar (y/n/a/q/l/^E/^Y)?</span><br></pre></td></tr></table></figure><p>按下y表示替换，n表示不替换，a表示替换所有，q表示退出查找模式， l表示替换当前位置并退出。<code>^E</code>与<code>^Y</code>是光标移动快捷键.</p><p>参考： <a href="http://harttle.com/2015/11/07/vim-cursor.html" target="_blank" rel="noopener">Vim中如何快速进行光标移</a></p><p>（行首:shfit+4($)、行尾:shfit+6(^)）</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三剑客常用命令-初级</title>
      <link href="/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-%E4%B8%89%E5%89%91%E5%AE%A2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E5%88%9D%E7%BA%A7/"/>
      <url>/2022/07/23/LINUX%E8%BF%90%E7%BB%B4-2022-07-23-%E4%B8%89%E5%89%91%E5%AE%A2%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E5%88%9D%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>grep、sed、awk号称三剑客，这三条命令对文本处理特别有用，今天来小结一下常用的基础操作，日后再来总结比较难的操作</p></blockquote><h3 id="grep-查找"><a href="#grep-查找" class="headerlink" title="grep-查找"></a><strong>grep-查找</strong></h3><ol><li><p>查询hello.txt中以字母a开头的内容，这样写也是可以的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep ^a hello.txt</span><br></pre></td></tr></table></figure></li><li><p>查看test.log中包含http的所有行(-i忽略大小写）</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i "http" ./test.log</span><br></pre></td></tr></table></figure><ol><li>查询出来对应字符串所在的行号</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i ABC -n hello.txt</span><br></pre></td></tr></table></figure><ol><li>查找进程，去掉错觉</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java | grep -v grep</span><br></pre></td></tr></table></figure><ol><li>查看test.log中包含http的所有行，并显示前后行</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat -n test.log | grep -C 5 "http" (匹配到的前后5行)</span><br><span class="line"></span><br><span class="line">cat -n test.log | grep -B 5 "http"  (前5行)</span><br><span class="line"></span><br><span class="line">cat -n test.log | grep -A 5 "http" (后5行)</span><br></pre></td></tr></table></figure><h3 id="sed-编辑"><a href="#sed-编辑" class="headerlink" title="sed-编辑"></a><strong>sed-编辑</strong></h3><p>都是一个模式类似的，{作用范围}命令[\或者/]操作数</p><ol><li>sed命令向文件中添加一行内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed '2a\haha' hello.txt （append）</span><br><span class="line">sed '1i\haha' hello.txt  (insert)</span><br><span class="line">sed '$a\haha' hello.txt （append）  $代表最后一行</span><br><span class="line">sed '$i\haha' hello.txt  (insert)</span><br></pre></td></tr></table></figure><ol><li>删除最后一行</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '$d' hello.txt</span><br></pre></td></tr></table></figure><ol><li>替换操作：sed后面的参数格式为[address]s/pattern/replacement/ﬂags</li></ol><p>​    和vim的substitute命令一样，再复习一下</p><p>​        这里的address 表示指定要操作的具体行，是一个可选项</p><p>​        s 表示替换操作;</p><p>​        pattern 指的是需要替换的内容;</p><p>​        replacement 指的是要替换的新内;</p><p>​        ﬂags有多种用法，我们挑两种说一下</p><ul><li><p>第一种就是ﬂags可以表示为1~512之间的任意一个数字，表示指定要替换的字符串在这一行中出现第几 次时才进行替换</p></li><li><p>第二种就是ﬂags可以直接表示为g，这样的意思就是对每一行数据中所有匹配到的内容全部进行替换</p></li></ul><p>​    如果ﬂags位置的值为空，则只会在第一次匹配成功时做替换操作</p><p>​    替换源文件修改        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#39;2s&#x2F;l&#x2F;a&#x2F;g&#39; hello.txt</span><br></pre></td></tr></table></figure><ol><li>SED 查看某时间段日志</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n '/2022-06-02 13:10:30/,/2022-06-02 13:10:40/p' test.log</span><br></pre></td></tr></table></figure><p>补充: 命令选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">-e ：直接在命令列模式上进行 sed 的动作编辑；</span><br><span class="line">-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；</span><br><span class="line">-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)</span><br><span class="line">-i ：直接修改读取的文件内容，而不是输出到终端。</span><br></pre></td></tr></table></figure><h3 id="awk-分析"><a href="#awk-分析" class="headerlink" title="awk-分析"></a><strong>awk-分析</strong></h3><p>简单来说awk就是把文件逐行的读入，以空白字符为默认分隔符将每行内容切片，切开的 部分再进行各种分析处理。</p><p>awk的基本格式：awk [option] programe ﬁle</p><p>这里的option是一个可选项，一般在这里来指定文件中数据的字段分隔符</p><p>programe 是具体的处理逻辑;</p><p>ﬁle表示我们要操作的文件;</p><p>在具体使用awk之前我们还需要掌握awk的一个特性，就是awk在处理文本数据的时候，它会自动给每行变量从1开始，</p><p>​    $1表示是文本中的第1个数据字段</p><p>​    $2表示是文本中的第2个数据字段</p><p>以此类推。</p><p>还有一个特殊的 $0 它代表整个文本行的内容</p><p>那下面我们来操作一下hello.txt这个文件</p><p>这个文件的字段中间默认是空格</p><ol><li><p>简单打印</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;print $1&#125;' hello.txt  打印第一列</span><br><span class="line">awk '&#123;print $2&#125;' hello.txt  打印第二列</span><br><span class="line">awk '&#123;print $0&#125;' hello.txt  打印全文</span><br></pre></td></tr></table></figure></li><li><p>在option里面指定字段分隔符，通过-F 参数</p><pre><code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: ‘&#123;print $1&#125;’ /etc/passwd</span><br></pre></td></tr></table></figure></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看磁盘和目录空间df和du</title>
      <link href="/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%92%8C%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4df%E5%92%8Cdu/"/>
      <url>/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%92%8C%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4df%E5%92%8Cdu/</url>
      
        <content type="html"><![CDATA[<h3 id="du和df的区别："><a href="#du和df的区别：" class="headerlink" title="du和df的区别："></a><strong>du和df的区别：</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间(最常见的就是文件已经删除，但是程序并没有释放空间)。</span><br><span class="line">du命令是面向文件的，只会计算文件或目录占用的</span><br></pre></td></tr></table></figure><h3 id="查看磁盘整体情况"><a href="#查看磁盘整体情况" class="headerlink" title="查看磁盘整体情况"></a><strong>查看磁盘整体情况</strong></h3><h4 id="查看整体挂载情况"><a href="#查看整体挂载情况" class="headerlink" title="查看整体挂载情况"></a>查看整体挂载情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="WeChat069a76a447ca86aad5fec1408ef2fbde"></p><h4 id="查看指定目录"><a href="#查看指定目录" class="headerlink" title="查看指定目录"></a>查看指定目录</h4>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h /opt/data/</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="WeChatfddb958643be29daa7380f9e2a7f2ab3"></p><h3 id="查看文件夹的占用情况"><a href="#查看文件夹的占用情况" class="headerlink" title="查看文件夹的占用情况"></a><strong>查看文件夹的占用情况</strong></h3><h4 id="查看当前目录每个文件夹的情况。"><a href="#查看当前目录每个文件夹的情况。" class="headerlink" title="查看当前目录每个文件夹的情况。"></a>查看当前目录每个文件夹的情况。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du --max-depth=1 -h</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="WeChatfddb958643be29daa7380f9e2a7f2ab3"></p><h4 id="指定目录"><a href="#指定目录" class="headerlink" title="指定目录"></a>指定目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du --max-depth=1 -h  /opt/data/</span><br></pre></td></tr></table></figure><p><img src="4.png" alt="WeChat0e80cc2a684da5f972f3d507563465d2"></p><h4 id="计算文件夹大小"><a href="#计算文件夹大小" class="headerlink" title="计算文件夹大小"></a>计算文件夹大小</h4><p>(<strong>为了快算显示，同时也只是想查看目录整体占用大小。可以直接使用du -sh 命令，如果想查看指定目录，直接在命令后根目录即可</strong>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh /usr/</span><br></pre></td></tr></table></figure><p><img src="5.png" alt="WeChat0dadf840b9fa7087478e4c7700ef1761"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其中df -h和du -sh使用的比较多，一个统计整体磁盘情况，一个看单独目录点用情况，而命令du —max-depth=1 -h查看了目录下文件夹占用情况，使用比较少，可以用du -sh代替，而且命令较长，当然并不是说它没用。</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yum换源的详细操作</title>
      <link href="/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-yum%E6%8D%A2%E6%BA%90%E7%9A%84%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-yum%E6%8D%A2%E6%BA%90%E7%9A%84%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure><p><strong>备份原来的源</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bk</span><br></pre></td></tr></table></figure><p><strong>下载阿里源</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.dsudo wget -nc http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><p> <strong>更改阿里yum源为默认源</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv Centos-7.repo CentOS-Base.repo</span><br></pre></td></tr></table></figure><p><strong>更新本地yum缓存</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum clean all # 全部清除</span><br><span class="line">sudo yum list # 更新列表 </span><br><span class="line">sudo yum makecache# 缓存yum包信息到本机，提高搜索速度</span><br></pre></td></tr></table></figure><p><strong>国内yum源</strong></p><p>阿里yum源:<a href="http://mirrors.aliyun.com/repo/" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/</a></p><p>163(网易)yum源: <a href="http://mirrors.163.com/.help/" target="_blank" rel="noopener">http://mirrors.163.com/.help/</a></p><p>中科大的Linux安装镜像源：<a href="http://centos.ustc.edu.cn/" target="_blank" rel="noopener">http://centos.ustc.edu.cn/</a></p><p>搜狐的Linux安装镜像源：<a href="http://mirrors.sohu.com/" target="_blank" rel="noopener">http://mirrors.sohu.com/</a></p><p>北京首都在线科技：<a href="http://mirrors.yun-idc.com/" target="_blank" rel="noopener">http://mirrors.yun-idc.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yum源解释</title>
      <link href="/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-yum%E6%BA%90%E8%A7%A3%E9%87%8A/"/>
      <url>/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-yum%E6%BA%90%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载他人的文章主要说明下如何配置linux上的本地yum源，主要关于一些原理上的说明。</p></blockquote><h3 id="yum是什么，yum源又是什么"><a href="#yum是什么，yum源又是什么" class="headerlink" title="yum是什么，yum源又是什么"></a>yum是什么，yum源又是什么</h3><p>   在windows上安装一个软件，我们可以通过360管家。因为360管家提供了软件的安装，卸载，并且解决了软件之间的依赖等相关问题，使得我们能够一键安装。在linux上有一个提供了和360管家类似功能的工具，叫做yum。使用yum我们就可以做到一个命令安装软件，并且不同的发行linux有不同工具，例如红帽（read hat）linux就使用的rpm全称就是read hat package manager 红帽软件包管理工具。</p><p>   yum源是什么呢？我们安装软件的时候需要下载软件，将很多软件放在一起就是源。软件安装包的来源。所以yum源就是软件安装包来源。如果我们是在线的，他会在网上给你下载安装包，如果是离线的没有网络。那么就只能配置本地的yum源了。</p><h3 id="本地yum源是什么呢？"><a href="#本地yum源是什么呢？" class="headerlink" title="本地yum源是什么呢？"></a>本地yum源是什么呢？</h3><p>   上面说过yum源就是软件安装包的来源，但是这些安装包哪里有呢？其实在linux的安装镜像中就有的，linux已经将常见的安装包放到了linux镜像中。如果你使用压缩文件打开linux的iso镜像文件，你会发现在根目录下有个文件夹：packages</p><p><img src="1.png" alt="WeChat40190bf3ee24416d2daacfa56f1f172d"></p><p>   上图就是使用压缩软件打开的系统盘内部情况，比如我们常用的工具vim，就是在这里面的。所以说： 系统的安装镜像就可以当作yum源。</p><h3 id="与yum源相关的配置文件"><a href="#与yum源相关的配置文件" class="headerlink" title="与yum源相关的配置文件"></a>与yum源相关的配置文件</h3><p> <img src="2.png" alt="WeChat5b86da0c7a3647cb6d31f02d5c5e2cbe"></p><p>   上图就是yun源相关的配置，在路径/etc/yum.repos.d/目录下，一共4个文件，说下两个常用的。</p><p>   CentOS-Base.repo：有网的环境下默认使用这个，这个是第一优先级。因为没网，所以修改文件名，设置成备份文件。这样系统就会使用第二优先级的文件。</p><p>   CentOS-Media.repo：没网的环境下使用这个，在上图中会发现他默认配置了4个路径，第4个yumsource是我自己加的。意思是说，如果系统检测yum使用了离线安装，那么会从上到下从这4个路径中查找安装软件。所以我们只要把光盘挂载在这四个目录下的任意一个目录即可。同时，该配置文件默认是不启用的，如果想使用需要 修改倒数第二行的enabled为1，否则该文件无效。</p><h3 id="media目录与mnt目录"><a href="#media目录与mnt目录" class="headerlink" title="media目录与mnt目录"></a>media目录与mnt目录</h3><p>   挂载光盘或者u盘等使用的mount命令，但是你百度所有会说有挂在media目录下，也有挂载在mnt目录下的。这两个目录区别是什么呢？</p><p>   media：挂载一些移动设备，例如光盘，U盘等。</p><p>   mnt：挂载一些硬盘等设备。所以我们的光盘应该挂载在media目录下，从yum给的默认配置文件也能看出。</p><h3 id="挂载光盘到系统上"><a href="#挂载光盘到系统上" class="headerlink" title="挂载光盘到系统上"></a>挂载光盘到系统上</h3><p>  <img src="3.png" alt="WeChatbc41627d35f3138e31bd97db231c8a8d"></p><p>   如上图，首先执行df -h命令发现当前系统没有光盘信息，然后挂载目录之后，在查看就发现我们把光盘挂载到了系统上，光盘大小4.2G。</p><p>-o loop ：指定挂载文件类型，说简单点就是我要挂载的是光盘这种设备。</p><h3 id="卸载光盘"><a href="#卸载光盘" class="headerlink" title="卸载光盘"></a>卸载光盘</h3><p><img src="4.png" alt="WeChat418e1c2e32e31f4f22bcc4d12f0e5b33"></p><p>   执行df -h发现光盘是挂载的，然后执行umount命令之后，在查看发现设备被卸载了</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>top命令的Load average 含义及性能参考基值</title>
      <link href="/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-top%E5%91%BD%E4%BB%A4%E7%9A%84Load-average-%E5%90%AB%E4%B9%89%E5%8F%8A%E6%80%A7%E8%83%BD%E5%8F%82%E8%80%83%E5%9F%BA%E5%80%BC/"/>
      <url>/2022/07/22/LINUX%E8%BF%90%E7%BB%B4-2022-07-22-top%E5%91%BD%E4%BB%A4%E7%9A%84Load-average-%E5%90%AB%E4%B9%89%E5%8F%8A%E6%80%A7%E8%83%BD%E5%8F%82%E8%80%83%E5%9F%BA%E5%80%BC/</url>
      
        <content type="html"><![CDATA[ <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">uptime</span></span><br><span class="line">11:12:26 up3:44,4users,load average:0.38,0.31,0.19</span><br></pre></td></tr></table></figure><p>系统平均负载被定义为在特定时间间隔内运行队列中的平均进程树。如果一个进程满足以下条件则其就会位于运行队列中：</p><ul><li>它没有在等待I/O操作的结果</li><li>它没有主动进入等待状态(也就是没有调用’wait’)</li><li>没有被停止(例如：等待终止)</li></ul><p>上面的输出，load average后面分别是1分钟、5分钟、15分钟的负载情况。数据是每隔5秒钟检查一次活跃的进程数，然后根据这个数值算出来的。如果这个数除以CPU 的数目，结果高于5的时候就表明系统在超负荷运转了。</p><p>Linux系统Load average负载详细解释 　我们知道判断一个系统的负载可以使用top，uptime等命令去查看，它分别记录了一分钟、五分钟、以及十五分钟的系统平均负载</p><p>　　例如我的某台服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> uptime  　09:50:21 up 200 days, 15:07, 1 user, load average: 0.27, 0.33, 0.37</span></span><br></pre></td></tr></table></figure><p>　　大部分的人都认为这个数字越小越好，其实有很多关联的提示信息，今天看到这个好文，应该可以给大家说清楚很多问题，转一下：</p><p>　　原文链接： <a href="http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages" target="_blank" rel="noopener">http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages</a></p><p>　　你可能对于 Linux 的负载均值（load averages）已有了充分的了解。负载均值在 uptime 或者 top 命令中可以看到，它们可能会显示成这个样子：</p><pre><code>         <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load average: 0.09, 0.05, 0.01</span><br></pre></td></tr></table></figure></code></pre><p>　　很多人会这样理解负载均值：三个数分别代表不同时间段的系统平均负载（一分钟、五 分钟、以及十五分钟），它们的数字当然是越小越好。数字越高，说明服务器的负载越 大，这也可能是服务器出现某种问题的信号。</p><p>　　而事实不完全如此，是什么因素构成了负载均值的大小，以及如何区分它们目前的状况是 “好”还是“糟糕”？什么时候应该注意哪些不正常的数值？</p><p>　　回答这些问题之前，首先需要了解下这些数值背后的些知识。我们先用最简单的例子说明， 一台只配备一块单核处理器的服务器。</p><p>　　行车过桥</p><p>　　一只单核的处理器可以形象得比喻成一条单车道。设想下，你现在需要收取这条道路的过桥 费 — 忙于处理那些将要过桥的车辆。你首先当然需要了解些信息，例如车辆的载重、以及 还有多少车辆正在等待过桥。如果前面没有车辆在等待，那么你可以告诉后面的司机通过。 如果车辆众多，那么需要告知他们可能需要稍等一会。</p><p>　　因此，需要些特定的代号表示目前的车流情况，例如：</p><p>　　0.00 表示目前桥面上没有任何的车流。 实际上这种情况与 0.00 和 1.00 之间是相同的，总而言之很通畅，过往的车辆可以丝毫不用等待的通过。</p><p>　　1.00 表示刚好是在这座桥的承受范围内。 这种情况不算糟糕，只是车流会有些堵，不过这种情况可能会造成交通越来越慢。</p><p>　　超过 1.00，那么说明这座桥已经超出负荷，交通严重的拥堵。 那么情况有多糟糕？ 例如 2.00 的情况说明车流已经超出了桥所能承受的一倍，那么将有多余过桥一倍的车辆正在焦急的等待。3.00 的话情况就更不妙了，说明这座桥基本上已经快承受不了，还有超出桥负载两倍多的车辆正在等待。</p><p>　　上面的情况和处理器的负载情况非常相似。一辆汽车的过桥时间就好比是处理器处理某线程 的实际时间。Unix 系统定义的进程运行时长为所有处理器内核的处理时间加上线程 在队列中等待的时间。</p><p>　　和收过桥费的管理员一样，你当然希望你的汽车（操作）不会被焦急的等待。所以，理想状态 下，都希望负载平均值小于 1.00 。当然不排除部分峰值会超过 1.00，但长此以往保持这 个状态，就说明会有问题，这时候你应该会很焦急。</p><p>　　“所以你说的理想负荷为 1.00 ？”</p><p>　　嗯，这种情况其实并不完全正确。负荷 1.00 说明系统已经没有剩余的资源了。在实际情况中 ，有经验的系统管理员都会将这条线划在<font color = red> 0.70</font>：</p><p>　　<font color = green>“需要进行调查法则”</font>： 如果长期你的系统负载在 0.70 上下，那么你需要在事情变得更糟糕之前，花些时间了解其原因。</p><p>　　<font color = green>“现在就要修复法则”</font>：1.00 。 如果你的服务器系统负载长期徘徊于 1.00，那么就应该马上解决这个问题。否则，你将半夜接到你上司的电话，这可不是件令人愉快的事情。</p><p>　　<font color = green>“凌晨三点半锻炼身体法则”</font>：5.00。 如果你的服务器负载超过了 5.00 这个数字，那么你将失去你的睡眠，还得在会议中说明这情况发生的原因，总之千万不要让它发生。</p>]]></content>
      
      
      <categories>
          
          <category> LINUX运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用docker部署hadoop集群的记录</title>
      <link href="/2022/07/22/docker-2022-07-22-%E5%88%A9%E7%94%A8docker%E9%83%A8%E7%BD%B2hadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/07/22/docker-2022-07-22-%E5%88%A9%E7%94%A8docker%E9%83%A8%E7%BD%B2hadoop%E9%9B%86%E7%BE%A4%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>计划部署五个docker容器，node1 为主节点，部署hdfs的namenode，yarn的resourcemager，redis的master等节点，目的就是拿docker当虚拟机用。</strong></p><p><strong>理想很丰满，现实很骨干，问题重重,现把遇到的问题记录下，做相应的知识补充，也防止下次再次掉坑。</strong></p><p>启动容器：</p><ol><li><p>启动就退出，需要让容器内启动一个进程，否则没有服务 就退掉了</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it /bin/bash</span><br></pre></td></tr></table></figure></li><li><p>拿docker容器部署多个服务，所以只能用最基础的centos 镜像，docker容器内的内核是受限制的，默认不能使用sytemctl命令，启动时候，要允许使用特权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">报错:</span><br><span class="line">    [root@4decd9c3c3aa /]# systemctl start sshd</span><br><span class="line">    Failed to get D-Bus connection: Operation not permitted</span><br><span class="line">报错： </span><br><span class="line">  System has not been booted with systemd as init system (PID 1). Can't operate.    </span><br><span class="line">  Failed to connect to bus: Host is down</span><br><span class="line">解决：</span><br><span class="line"> docker run -itd   --privileged --name myCentos centos /usr/sbin/init</span><br></pre></td></tr></table></figure></li></ol><p>3.docker 部署的多个容器肯定是要通信的，可以直接建立一个桥接网络，启动容器时候，加入到网络中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --privileged --name t4 --network docker_net hub.c.163.com/library/centos  /usr/sbin/init bash</span><br></pre></td></tr></table></figure><p>4.节点间肯定是要传数据的，可以使用docker cp 实现宿主机和容器的互传，使用scp依赖ssh服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">安装完以后报如下的错:</span><br><span class="line">    The authenticity of host 'oradb24 (192.168.1.24)' can't be established.</span><br><span class="line">RSA key fingerprint is e0:fb:fb:67:a0:fc:cd:a5:dc:c8:bc:68:67:b1:93:3f.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added 'oradb24,192.168.1.24' (RSA) to the list of known hosts.</span><br><span class="line">root@oradb24's password: </span><br><span class="line">bash: scp: command not found</span><br><span class="line">lost connection</span><br><span class="line">注意，拷贝文件的双方服务器都要安装ssh服务，并且服务端和客户端都要安装完整才行</span><br><span class="line">yum install -y openssh-server</span><br><span class="line">yum install -y openssh-clients</span><br><span class="line">systemctl restart sshd #启动ssh服务</span><br></pre></td></tr></table></figure><ol><li><p>一些常用的命令，直接yum安装不行，不是直接的命令，是在一个包下，会提示找不到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat、telnet 命令</span><br><span class="line">    yum install net-tools</span><br><span class="line">pstree 命令</span><br><span class="line">    yum install psmisc -y</span><br><span class="line">    </span><br><span class="line">有时候不一定什么样，学会搜学，学会通用的本领</span><br><span class="line">yum list | grep telnet</span><br></pre></td></tr></table></figure></li><li><p>scp装完之后，想要用的话，是需要登陆账户的，默认root账户密码，你自己是不知道的，修改文件太麻烦，所以，注意启动容器第一件事就是先修改root密码</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@06e23c44de37 /]# passwd root</span><br><span class="line">Changing password for user root.</span><br><span class="line">New password: </span><br><span class="line">BAD PASSWORD: The password is shorter than 8 characters</span><br><span class="line">Retype new password: </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><ol><li>在一台节点上，装好所有的服务，做好一个容器，保存为一个镜像，然后，利用这个镜像启动多个容器，注意启动时候的命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a &quot;zhangxiaodong&quot; -m &quot;bigdata centos7&quot; 5d8e05402c40  mycentos:v1</span><br></pre></td></tr></table></figure><ol><li>防止出现意外，把镜像提交到docker.hub仓库中去</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一：网易镜像仓库，但是现在需要企业认证才让推，坑爹</span><br><span class="line">二：官方的hub.docker</span><br><span class="line">    docker tag masternode:v1  12345678900100/masternode:v1  #这一步是重新标记镜像，得按照 注册用户名/镜像名  这个规范来才能推送上去</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOCKER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器互访三种方式</title>
      <link href="/2022/07/22/docker-2022-07-22-Docker%E5%AE%B9%E5%99%A8%E4%BA%92%E8%AE%BF%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/07/22/docker-2022-07-22-Docker%E5%AE%B9%E5%99%A8%E4%BA%92%E8%AE%BF%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>我们都知道docker容器之间是互相隔离的，不能互相访问，但如果有些依赖关系的服务要怎么办呢。下面介绍三种方法解决容器互访问题。</p><h3 id="方式一、虚拟ip访问"><a href="#方式一、虚拟ip访问" class="headerlink" title="方式一、虚拟ip访问"></a><strong>方式一、虚拟ip访问</strong></h3><p>安装docker时，docker会默认创建一个内部的桥接网络docker0，每创建一个容器分配一个虚拟网卡，容器之间可以根据ip互相访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@33fcf82ab4dd &#x2F;]# [root@CentOS ~]# ifconfig</span><br><span class="line">......</span><br><span class="line">docker0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::42:35ff:feac:66d8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:35:ac:66:d8  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 4018  bytes 266467 (260.2 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 4226  bytes 33935667 (32.3 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>运行一个centos镜像， 查看ip地址得到：172.17.0.7</p><pre><code>          <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS ~]# docker run -it --name centos-1 docker.io/centos:latest</span><br><span class="line">[root@6d214ff8d70a /]# ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.7  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::42:acff:fe11:7  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:ac:11:00:07  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 16  bytes 1296 (1.2 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 8  bytes 648 (648.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></code></pre><p>以同样的命令再起一个容器，查看ip地址得到：172.17.0.8</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS ~]# docker run -it --name centos-2 docker.io/centos:latest</span><br><span class="line">[root@33fcf82ab4dd /]# ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.8  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::42:acff:fe11:8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:ac:11:00:08  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 8  bytes 648 (648.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 8  bytes 648 (648.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>容器内部ping测试结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@33fcf82ab4dd /]# ping 172.17.0.7</span><br><span class="line">PING 172.17.0.7 (172.17.0.7) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.7: icmp_seq=1 ttl=64 time=0.205 ms</span><br><span class="line">64 bytes from 172.17.0.7: icmp_seq=2 ttl=64 time=0.119 ms</span><br><span class="line">64 bytes from 172.17.0.7: icmp_seq=3 ttl=64 time=0.118 ms</span><br><span class="line">64 bytes from 172.17.0.7: icmp_seq=4 ttl=64 time=0.101 ms</span><br></pre></td></tr></table></figure><p>这种方式必须知道每个容器的ip，在实际使用中并不实用。</p><p><strong>方式二、link</strong></p><p>运行容器的时候加上参数link</p><p>运行第一个容器</p><pre><code>      <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS ~]# docker run -it --name centos-1 docker.io/centos:latest</span><br></pre></td></tr></table></figure></code></pre><p>运行第二个容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS ~]# docker run -it --name centos-2--link centos-1:centos-1 docker.io/centos:latest</span><br></pre></td></tr></table></figure><p>—link：参数中第一个centos-1是<strong>容器名</strong>，第二个centos-1是定义的<strong>容器别名</strong>（使用别名访问容器），为了方便使用，一般别名默认容器名。</p><p>测试结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@e0841aa13c5b /]# ping centos-1</span><br><span class="line">PING centos-1 (172.17.0.7) 56(84) bytes of data.</span><br><span class="line">64 bytes from centos-1 (172.17.0.7): icmp_seq=1 ttl=64 time=0.210 ms</span><br><span class="line">64 bytes from centos-1 (172.17.0.7): icmp_seq=2 ttl=64 time=0.116 ms</span><br><span class="line">64 bytes from centos-1 (172.17.0.7): icmp_seq=3 ttl=64 time=0.112 ms</span><br><span class="line">64 bytes from centos-1 (172.17.0.7): icmp_seq=4 ttl=64 time=0.114 ms</span><br></pre></td></tr></table></figure><p> 此方法对容器创建的顺序有要求，如果集群内部多个容器要互访，使用就不太方便。</p><p><strong>方式三、创建bridge网络</strong></p><p>1.安装好docker后，运行如下命令创建bridge网络：docker network create testnet</p><p>查询到新创建的bridge testnet。</p><p>   <img src="1.png" alt="WeChat314744afd88365f3f0d8d8c97c8544e9"></p><p>2.运行容器连接到testnet网络。</p><p>使用方法：docker run -it —name &lt;容器名&gt; —-network —network-alias &lt;网络别名&gt; &lt;镜像名&gt;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS ~]# docker run -it --name centos-1 --network testnet --network-alias centos-1 docker.io/centos:latesta</span><br><span class="line">[root@CentOS ~]# docker run -it --name centos-2 --network testnet --network-alias centos-2 docker.io/centos:latest</span><br></pre></td></tr></table></figure><p>3.从一个容器ping另外一个容器，测试结果如下：</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@fafe2622f2af /]# ping centos-1</span><br><span class="line">PING centos-1 (172.20.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from centos-1.testnet (172.20.0.2): icmp_seq=1 ttl=64 time=0.158 ms</span><br><span class="line">64 bytes from centos-1.testnet (172.20.0.2): icmp_seq=2 ttl=64 time=0.108 ms</span><br><span class="line">64 bytes from centos-1.testnet (172.20.0.2): icmp_seq=3 ttl=64 time=0.112 ms</span><br><span class="line">64 bytes from centos-1.testnet (172.20.0.2): icmp_seq=4 ttl=64 time=0.113 ms</span><br></pre></td></tr></table></figure><p>4.若访问容器中服务，可以使用这用方式访问 &lt;网络别名&gt;：&lt;服务端口号&gt; </p><p>推荐使用这种方法，自定义网络，因为使用的是网络别名，可以不用顾虑ip是否变动，只要连接到docker内部bright网络即可互访。bridge也可以建立多个，隔离在不同的网段。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOCKER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker启动后自动停止的原因及解决</title>
      <link href="/2022/07/22/docker-2022-07-22-docker%E5%90%AF%E5%8A%A8%E5%90%8E%E8%87%AA%E5%8A%A8%E5%81%9C%E6%AD%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
      <url>/2022/07/22/docker-2022-07-22-docker%E5%90%AF%E5%8A%A8%E5%90%8E%E8%87%AA%E5%8A%A8%E5%81%9C%E6%AD%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>centos 启动一个容器添加了-d 参数，但是docker ps 或者docker ps -a查看却已经退出了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centosa44b2b88559b68a2221c9574490a0e708bff49d88ca21f9e59d3eb245c7c0547</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="WeChat497baa8def4c0ee1d65fa1d8a7b1e555"></p><h3 id="退出原因"><a href="#退出原因" class="headerlink" title="退出原因"></a>退出原因</h3><ol><li><p>docker容器运行必须有一个前台进程， 如果没有前台进程执行，容器认为空闲，就会自行退出</p></li><li><p>容器运行的命令如果不是那些一直挂起的命令（ 运行top，tail、循环等），就是会自动退出</p></li><li><p>这个是 docker 的机制问题</p></li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h5 id="方案1："><a href="#方案1：" class="headerlink" title="方案1："></a>方案1：</h5><p>网上有很多介绍，就是起一个死循环进程，让他不停的循环下去，前台永远有进程执行，那么容器就不会退出了,以centos为例</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos /bin/sh -c "while true; do echo hello world; sleep 1; done"</span><br></pre></td></tr></table></figure><p>缺点： 命令太冗长了，还占用一个终端</p><h5 id="方案2："><a href="#方案2：" class="headerlink" title="方案2："></a>方案2：</h5> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit centos /bin/bash</span><br></pre></td></tr></table></figure><p>添加-it 参数交互运行</p><p>添加-d 参数后台运行</p><p>这样就能启动一个一直停留在后台运行的Centos了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>容器运行起来了               <img src="2.png" alt="WeChatf6376383dead7cd5df001a7f289d65d8"></p><p>进入容器的方法：</p><p>使用exec，不要使用attach命令</p><p>attach命令就是使用现有终端，如果你要退出容器操作，那么bash结束，容器也就退出了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it /bin/bash //新建一个bash</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="WeChat7921d95cf39d8ef42a04cf42d1d5d5e3"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOCKER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker tag命令解释</title>
      <link href="/2022/07/22/docker-2022-07-22-docker-tag%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A/"/>
      <url>/2022/07/22/docker-2022-07-22-docker-tag%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br></pre></td></tr></table></figure><h3 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h3><ol><li>比如我现在有一个 centos 镜像：</li></ol><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE </span><br><span class="line">centos              latest              <span class="number">1</span>e1148e4cc2c        <span class="number">2</span> weeks ago         <span class="number">202</span>MB</span><br></pre></td></tr></table></figure><ol><li>我对 centos 进行开发，开发了第一个版本，我就可以对这个版本打标签，打完标签后会生成新的镜像：</li></ol><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ docker tag centos centos:v1</span><br><span class="line">[root@localhost ~]$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE </span><br><span class="line">centos              latest              <span class="number">1</span>e1148e4cc2c        <span class="number">2</span> weeks ago         <span class="number">202</span>MB</span><br><span class="line">centos              v1                  <span class="number">1</span>e1148e4cc2c        <span class="number">2</span> weeks ago         <span class="number">202</span>MB</span><br></pre></td></tr></table></figure><ol><li>我继续对 centos 进行开发，开发了第二个版本，继续打标签：</li></ol><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ docker tag centos centos:v2</span><br><span class="line">[root@localhost ~]$ docker images </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              <span class="number">1</span>e1148e4cc2c        <span class="number">2</span> weeks ago         <span class="number">202</span>MB</span><br><span class="line">centos              v1                  <span class="number">1</span>e1148e4cc2c        <span class="number">2</span> weeks ago         <span class="number">202</span>MB</span><br><span class="line">centos              v2                  <span class="number">1</span>e1148e4cc2c        <span class="number">2</span> weeks ago         <span class="number">202</span>MB</span><br></pre></td></tr></table></figure><ol><li>以此类推，每开发一个版本打一个标签，如果以后我想回滚版本，就可以使用指定标签的镜像来创建容器：</li></ol><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ docker <span class="keyword">run</span><span class="bash"> -itd centos:v1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOCKER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 常用命令记录</title>
      <link href="/2022/07/22/docker-2022-07-22-docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/07/22/docker-2022-07-22-docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<pre><code>### 查看镜像/容器</code></pre> <figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker images 查看镜像信息列表 镜像是静态的</span><br><span class="line">docker ps -a 查看运行中的所有容器</span><br><span class="line">docker pull  [images]:[version]从dockerhub拉取指定镜像</span><br><span class="line">docker rm [containerID] 删除容器</span><br><span class="line">docker rmi [imageID] 删除镜像</span><br><span class="line">docker cp [YourHostFilePath] [containerID]:[DockerPath]  将宿主机内的指定文件传输至容器内部的指定地址。</span><br></pre></td></tr></table></figure><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -p 8000:80 -tdi --privileged [imageID] [<span class="built_in">command</span>]  </span></span><br><span class="line">后台启动docker,并指定宿主机端口和docker映射端口。</span><br><span class="line">    -i:以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">    -d:后台运行容器，并返回容器ID；</span><br><span class="line">    -t:为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br><span class="line">    --privileged 容器将拥有访问主机所有设备的权限</span><br><span class="line">    通常情况下 [command] 填下 /bin/bash 即可。</span><br><span class="line">    特殊情况下，如需要在centos镜像中使用systemctl . 则应添加--privileged 并设置[command ]为 init。</span><br><span class="line">当镜像通过<span class="keyword">run</span><span class="bash"> 启动后，便会载入到一个动态的container(容器)中运行，此时若需要进入终端交互模式：</span></span><br><span class="line">sudo docker exec -it [containerID] /bin/bash</span><br><span class="line">交互模式中，使用ctrl+p+q退出交互 保持运行,使用 exit命令退出并停止容器。</span><br><span class="line">非交互模式中 docker  start/stop 命令启动/停止已部署的容器服务。</span><br></pre></td></tr></table></figure><h3 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker commit [containerID] [ImageName]:[Version] 将修改后的容器重新打包成镜像</span><br><span class="line">docker commit -a <span class="string">"runoob.com"</span> -m <span class="string">"my apache"</span> a404c6c174a2 mymysql:v1 将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</span><br><span class="line">    -a :提交的镜像作者；</span><br><span class="line">    -c :使用Dockerfile指令来创建镜像；</span><br><span class="line">    -m :提交时的说明文字；</span><br><span class="line">    -p :在commit时，将容器暂停。</span><br><span class="line">docker push [ImageID] [repertory_address]提交镜像到云仓库</span><br></pre></td></tr></table></figure><h3 id="修改景象名称"><a href="#修改景象名称" class="headerlink" title="修改景象名称"></a>修改景象名称</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pujh/centos         tomcat-centos       <span class="number">70</span>ff7873d7cd        About an hour ago   <span class="number">612</span> MB</span><br><span class="line">docker.io/centos    latest              <span class="number">9</span>f38484d220f        <span class="number">11</span> days ago         <span class="number">202</span> MB</span><br><span class="line">[root@localhost ~]<span class="comment"># docker tag 70ff7873d7cd my_centos:tomcat-centos</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOCKER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet过滤器与SpringMVC拦截器</title>
      <link href="/2022/07/22/ssm-2022-07-22-Servlet%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8ESpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
      <url>/2022/07/22/ssm-2022-07-22-Servlet%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8ESpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架中的三种配置方式</title>
      <link href="/2022/07/22/ssm-2022-07-22-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/07/22/ssm-2022-07-22-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>前言:</strong></p><blockquote><p>java中对配置的方式有三种，配置文件（xml、properties、yml等）、注解式配置、代码配置类，配置文件配置不用修改源码，并且适合模块的划分管理，一般适合大型项目，不好处就是配置文件太多，尤其像ssm的xml整合配置等，冗杂繁琐，对程序员极其不友好，于是有了注解式配置，注解配置对开发人员友好，但是不好处就是改注解相当于改代码，改代码就得重新编译、部署，但对于程序员来说，可能更注重体验感，现在注解用的更多些，至于代码类配置，在spring-boot程序中用分较多一些。**</p></blockquote><p><strong>下面以Filter为例，详细解释三种配置的注意点</strong></p><ul><li><strong>注解式配置</strong></li></ul><p>​    <strong>注意</strong>使用内嵌容器时，可以使用 @ServletComponentScan 启用带 @WebServlet、@WebFilter 和 @WebListener 注解的类自动注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"myfilter"</span>,urlPatterns = <span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myfilter</span> <span class="keyword">extends</span> <span class="title">HttpFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"过滤器进入"</span>);</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        System.out.println(<span class="string">"过滤器离开"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置类配置</li></ul><p>​    使用代码配置类配置的时候，要把配置类对象注入容器，使用@Bean注解，注意参数Filter对象，既然使用容器，就都是容器内的对象，要保证在容器内有这个AdminFilter对象，可以使用@Bean像如下方法一样，注入容器，或者在AdminFilter类上使用@Component注解，在容器中初始化对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public AdminFilter adminFilter() &#123;</span></span><br><span class="line"><span class="comment">//        return new AdminFilter();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"loginFilterConf"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">loginFilterConfig</span><span class="params">(AdminFilter filter)</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        filterRegistrationBean.setFilter(filter);</span><br><span class="line"><span class="comment">//        filterRegistrationBean.setEnabled(false);</span></span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">"/admin/category/*"</span>);</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">"/admin/product/*"</span>);</span><br><span class="line">        filterRegistrationBean.setName(<span class="string">"loginFilterConf"</span>);</span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置文件配置</li></ul><p>​    以前的单体项目，传统的web开发，使用web.xml配置时候经常用这种配置，现在的ssm的spring mvc 也还用得到。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingfilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.my.app.EncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingfilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视图解析与模版引擎</title>
      <link href="/2022/07/21/ssm-2022-07-21-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/"/>
      <url>/2022/07/21/ssm-2022-07-21-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p><strong>ModelAndView</strong></p><ul><li><p>ModelAndView对象是指”模型(数据)与视图(界面)”对象</p></li><li><p>通过ModelAndView可将包含数据对象与模板引擎进行绑定</p></li><li><p>SpringMVC中默认的View是JSP,也可以配置其他模板引擎</p></li></ul><p><strong>视图解析器作用</strong></p><p>一般地视图解析器配置如下：      </p><p>假如Controller类中返回值为hello，那么根据视图解析器可得将要跳转的页面路径为：/WebContent/jsp/hello.jsp</p><p><strong>注意：</strong></p><p>视图解析器的作用是只对Controller类中每个函数返回值那里的String类型前后加路径，而不对@RequestMapping处加路径，对@RequestMapping处无影响！</p><p><strong>模版引擎</strong></p><ul><li><p>模板引擎的目标是”数据+模板=结果”</p></li><li><p>模板引擎将数据与展现有效”解耦”</p></li></ul><p>​    <img src="1.png" alt="0"></p><p>  常见的模版引擎像jsp、freemarker、Thymeleaf等。</p><p>  <strong>小结：</strong></p><ul><li>​    SpringMVC的MAV，实际就是把数据和视图绑定在一起，程序员写逻辑出数据，前端写对应的视图页面，</li></ul><p>用MAV绑定在一起，跳到模版引擎，比如jsp，它能调用java代码，就可以拿到后端写的数据进行展示，这样就可以进行数据的渲染</p><ul><li>视图解析器和模版引擎是配合使用的，默认的InternalResourceViewResolver只解析成jsp页面，Freemarker和Velocity的视频解析器：FreemarkerViewResolver和VelocityViewResolver</li></ul>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC用Map接收请求参数分析</title>
      <link href="/2022/07/21/ssm-2022-07-21-SpringMVC%E7%94%A8Map%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/"/>
      <url>/2022/07/21/ssm-2022-07-21-SpringMVC%E7%94%A8Map%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="第一种情况，什么也不设置，无参数传递"><a href="#第一种情况，什么也不设置，无参数传递" class="headerlink" title="第一种情况，什么也不设置，无参数传递"></a><strong>第一种情况</strong>，什么也不设置，无参数传递</h3><p>注解为 @Controller @RequestMapping</p><p><img src="1.png" alt="img"></p><p>可以看到传递的为SpringMVC的BindingAwareModelMap类型，SpringMVC中的隐含模型就是这个类型，其作用域等价于 request 域，当添加Model、ModelMap参数时，SpringMVC实际传入的就是这个隐含模型；向这个隐含模型种设置值后，在返回的页面中就能通过request域取值。</p><h3 id="第二种情况，加个参数试试-gt-…-testmap-test1-2342"><a href="#第二种情况，加个参数试试-gt-…-testmap-test1-2342" class="headerlink" title="第二种情况，加个参数试试 =&gt; …/testmap?test1=2342"></a><strong>第二种情况</strong>，加个参数试试 =&gt; …/testmap?test1=2342</h3><p>结果类型还是一样，且参数不会被传入，当然使用request肯定能取出来。</p><p><img src="2.png" alt="img"> </p><h3 id="第三种情况，给Map参数添加-RequestParam注解"><a href="#第三种情况，给Map参数添加-RequestParam注解" class="headerlink" title="第三种情况，给Map参数添加@RequestParam注解"></a><strong>第三种情况</strong>，给Map参数添加@RequestParam注解</h3><p>　　1、Get请求 =&gt; <a href="http://localhost:8080/ssm/v2/testmap?test1=234234" target="_blank" rel="noopener">http://localhost:8080/ssm/v2/testmap?test1=234234</a></p><p>　　成功传入了参数，注意这个Map类型为LinkedHashMap，而不是隐含模型了</p><p><img src="3.png" alt="img"></p><p>　　再添加个Model参数看看，隐含模型中依然没有值</p><p>　　所以添加@RequestParam注解后，SpringMVC会将 Get 请求中封装进对应的参数中，如果参数是Map就封装称LinkedHashMap而不再传入隐含模型</p><p><img src="4.png" alt="img"></p><p>　　2、Post请求， 再测试测试Post请求</p><p>　　与Get的结果一致：参数无@RequestParam注解时，Map接收隐含模型；添加@RequestParam注解时，Map接收LinkedHashMap；隐含模型中无值。</p><p><img src="5.png" alt="img"></p><h3 id="第四种情况，给Map参数添加-RequestBody注解，且请求方式为Post"><a href="#第四种情况，给Map参数添加-RequestBody注解，且请求方式为Post" class="headerlink" title="第四种情况，给Map参数添加@RequestBody注解，且请求方式为Post"></a><strong>第四种情况</strong>，给Map参数添加@RequestBody注解，且请求方式为Post</h3><p>出乎意料的也成功传入了，与@RequestParam注解结果类似，也是LinkedHashMap</p><p><img src="6.png" alt="img"></p><p><img src="7.png" alt="img"></p><p>复杂点的Json数据也能解析接收成功</p><p><img src="8.png" alt="img"> <img src="9.png" alt="img"> </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><p>SpringMVC处理请求用Map类型接收参数时，如果参数无注解，则会传入BindingAwareModelMap类型，等价于Model、ModelMap参数；</p></li><li><p>参数添加@RequestParam注解时，会将参数包装称LinkedHashMap对象，参数的key为Map的key，参数值为Map的key，支持Get、Post方法（应该支持Put、Delete，没有测，俩方法与Post类似）；</p></li><li><p>添加@RequestBody注解时，接收Json类型数据，也会包装成LinkedHashMap对象，该注解不支持Get请求，Get请求没有请求体不能传Json。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> @requestParam与@Param</title>
      <link href="/2022/07/21/ssm-2022-07-21-requestParam%E4%B8%8E-Param/"/>
      <url>/2022/07/21/ssm-2022-07-21-requestParam%E4%B8%8E-Param/</url>
      
        <content type="html"><![CDATA[<p><strong>@RequestParam</strong> 用于controller层，是Spring的注解</p><p>解决前台参数名称与后台接收参数变量名称不一致的问题，等价于request.getParam</p><ul><li>value：参数名字，即入参的请求参数名字，如username表示请求的参数区中的name为username的参数的值将传入；</li><li>required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；</li><li>defaultValue：默认值，表示如果请求中没有同名参数时的默认值，默认值可以是SpEL表达式，如<code>“#{systemProperties[&#39;java.vm.version&#39;]}”</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(@RequestParam(value = <span class="string">"username"</span>)</span> <span class="keyword">final</span> String username,</span></span><br><span class="line"><span class="function">                        @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"password"</span>,required = <span class="keyword">false</span>)</span> <span class="keyword">final</span> String password,</span></span><br><span class="line"><span class="function">                        @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"valcode"</span>,required = <span class="keyword">false</span>)</span> <span class="keyword">final</span> String valcode) </span>&#123;</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure><p><strong>@Param</strong> 用于dao层，是mybatis中的注解</p><p>使得mapper.xml中的参数与后台的参数对应上，也增强了可读性</p><p>如果两者参数名一致得话，spring会自动进行封装，不一致的时候就需要手动去使其对应上。</p><p>即：用注解来简化xml配置的时候,@Param注解的作用是给参数命名,参数命名后就能根据名字得到参数值,正确的将参数传入sql语句中 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span> </span>&#123; </span><br><span class="line">   </span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select s_id id,s_name name,class_id classid"</span>+ </span><br><span class="line">        <span class="string">"from student where  s_name= #&#123;aaaa&#125; and class_id = #&#123;bbbb&#125;"</span>) </span><br><span class="line"> <span class="function"><span class="keyword">public</span> Student <span class="title">select</span><span class="params">(@Param(<span class="string">"aaaa"</span>)</span> String name,@<span class="title">Param</span><span class="params">(<span class="string">"bbbb"</span>)</span><span class="keyword">int</span> class_id)</span>;  </span><br><span class="line">   </span><br><span class="line"><span class="meta">@Delete</span>...... </span><br><span class="line"></span><br><span class="line"><span class="meta">@Insert</span>...... </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在dao层，用来给参数命名，在Mybatis的mapper中加上该注解，传递的参数与Sql中的字段名一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt;getAllEmployeeByPage(<span class="meta">@Param</span>(<span class="string">"page"</span>) Integer page,</span><br><span class="line"> <span class="meta">@Param</span>(<span class="string">"size"</span>) Integer size);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springmvc Controller 页面跳转</title>
      <link href="/2022/07/21/ssm-2022-07-21-springmvc-Controller-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/"/>
      <url>/2022/07/21/ssm-2022-07-21-springmvc-Controller-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>如果返回值为</strong>ModelAndView<strong>，在处理方法中，返回</strong>null<strong>时，默认跳转的视图名称为请求名。跳转结果会根据视图解析器来跳转。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello================"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> <strong>结果：</strong> <img src="1.png" alt="0"></p><ul><li><strong>如果返回值为</strong>ModelAndView,<strong>在处理方法中，指定视图名称，那么将跳转到指定的视图名。跳转结果会根据视图解析器来跳转。</strong>——-<font face = "黑体" color = green><strong>使用最多</strong></font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello================"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"index"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong><img src="2.png" alt="0"></p><ul><li><strong>返回值为</strong>void<strong>，在处理方法中，默认跳转的视图名称为请求名。跳转结果会根据视图解析器来跳转。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello================"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong> <img src="3.png" alt=""></p><ul><li><strong>返回值为</strong>void,<strong>在处理方法中通过</strong>ServletAPI<strong>来进行跳转：</strong>—-<strong><font color=green>不用视图解析器</font></strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(HttpServletRequest req,HttpServletResponse resp)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello================"</span>);</span><br><span class="line">        req.getRequestDispatcher(<span class="string">"hello.jsp"</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong> <img src="4.png" alt="0"></p><ul><li><p><strong>返回值为</strong>String,默认情况下，将会以返回值为视图名通过视图解析器来找到跳转的页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello================"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>结果：</strong> <img src="5.png" alt="0">)</p><ul><li>返回值为<strong>String</strong>，在处理方法中，返回<strong>null</strong>时，默认跳转的视图名称为请求名。跳转结果会根据视图解析器来跳转。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello================"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong>： <img src="6.png" alt="0"></p><ul><li>返回值为<strong>String,</strong>为返回值加上前缀<strong>”redirect:”或者”forward:”那么将会根据返回值去进行转发或重定向，</strong><font color = green>不使用视图解析器：</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello================"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"forward:/index.jsp"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果：<img src="7.png" alt="0"></p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvcc原理解释</title>
      <link href="/2022/07/21/mysql-2022-07-21-mvcc%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A/"/>
      <url>/2022/07/21/mysql-2022-07-21-mvcc%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p><img src="1.png" alt="img"></p><p>MVCC实现原理也是一道非常高频的面试题,自己在整理这篇文章的时候,感觉到网上的资料在讲这块知识点上写的五花八门,好像大家的理解并没有一致。</p><p>这里将自己所理解的做一个总结,个人会觉得这是一篇含金量挺高的一篇文章(哈哈),<strong>所以请你坚持认真的看下去</strong>,一定会对你有收获。</p><p>如果文章中哪里没有理解,或者认为我讲的不对的地方，都欢迎留言一起交流哈。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一些基本概念我这里不在做阐述了。好比什么是事务? 事务的ACID? 四大隔离级别?</p><p>有关事务并发存在的问题之前有写过一篇文章:<a href="https://mp.weixin.qq.com/s/LcdorR-oldsm3FEYAAnisQ" target="_blank" rel="noopener">一文详解脏读、不可重复读、幻读</a></p><p>如果你还不清楚不可重复读和幻读的区别，非常建议看完上面这篇文章。因为好多人会把不可重复读和幻读搞在一起。</p><p>所以会认为MVCC能解决幻读，其实MVCC解决的不是幻读，而是不可重复读,下面会用实际例子来证明这一点。</p><h2 id="一、什么是MVCC"><a href="#一、什么是MVCC" class="headerlink" title="一、什么是MVCC"></a>一、什么是MVCC</h2><p><strong>多版本控制</strong>: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，<strong>只有写写之间相互阻塞</strong>，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。</p><p>在内部实现中，InnoDB通过undo log保存每条数据的多个版本，并且能够找回数据历史版本提供给用户读，每个事务读到的数据版本可能是不一样的。在同一个事务中，用户只能看到该事务创建快照之前已经提交的修改和该事务本身做的修改。</p><p>MVCC只在<code>已提交读</code>（Read Committed）和<code>可重复读</code>（Repeatable Read）两个隔离级别下工作，其他两个隔离级别和MVCC是不兼容的。因为未提交读，总数读取最新的数据行，而不是读取符合当前事务版本的数据行。而串行化（Serializable）则会对读的所有数据多加锁。</p><p>MVCC的实现原理主要是依赖<strong>每一行记录中两个隐藏字段，undo log，ReadView</strong></p><h2 id="二、MVCC相关的一些概念"><a href="#二、MVCC相关的一些概念" class="headerlink" title="二、MVCC相关的一些概念"></a>二、MVCC相关的一些概念</h2><p>这里我们先来理解下有关MVCC相关的一些概念，这些概念都理解后，我们会通过实际例子来演示MVCC的具体工作流程是怎么样的。</p><h4 id="1、事务版本号"><a href="#1、事务版本号" class="headerlink" title="1、事务版本号"></a>1、事务版本号</h4><blockquote><p>事务每次开启时，都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。这就是事务版本号。</p></blockquote><p>也就是每当begin的时候,首选要做的就是从数据库获得一个自增长的事务ID,它也就是当前事务的事务ID。</p><h4 id="2、隐藏字段"><a href="#2、隐藏字段" class="headerlink" title="2、隐藏字段"></a>2、隐藏字段</h4><p>对于InnoDB存储引擎，每一行记录都有两个隐藏列<strong>trx_id</strong>、<strong>roll_pointer</strong>,如果数据表中存在主键或者非NULL的UNIQUE键时不会创建row_id,否则InnoDB会自动生成单调递增的隐藏主键row_id。</p><div class="table-container"><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">是否必须</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">row_id</td><td style="text-align:left">否</td><td style="text-align:left">单调递增的行ID，不是必需的，占用6个字节。 这个跟MVCC关系不大</td></tr><tr><td style="text-align:left">trx_id</td><td style="text-align:left">是</td><td style="text-align:left">记录操作该行数据事务的事务ID</td></tr><tr><td style="text-align:left">roll_pointer</td><td style="text-align:left">是</td><td style="text-align:left">回滚指针，指向当前记录行的undo log信息</td></tr></tbody></table></div><p>这里的记录操作，指的是insert|update|delete。对于delete操作而已，InnoDB认为是一个update操作，不过会更新一个另外的删除位，将行表示为deleted,并非真正删除。</p><h4 id="3、undo-log"><a href="#3、undo-log" class="headerlink" title="3、undo log"></a>3、undo log</h4><p><strong>undo log可以理解成回滚日志,它存储的是老版本数据</strong>。在表记录修改之前，会先把原始数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据。或者如果当前记录行不可见，可以顺着undo log链找到满足其可见性条件的记录行版本。</p><p>在insert/update/delete(本质也是做更新，只是更新一个特殊的删除位字段)操作时，都会产生undo log。</p><p>在InnoDB里，undo log分为如下两类：</p><p>1）<strong>insert undo log</strong> : 事务对insert新记录时产生的undo log, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</p><p>2）<strong>update undo log</strong> : 事务对记录进行delete和update操作时产生的undo log，不仅在事务回滚时需要，快照读也需要，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被删除。</p><p>undo log有什么用途呢？</p><blockquote><p>1、事务回滚时，保证原子性和一致性。<br>2、如果当前记录行不可见，可以顺着undo log链找到满足其可见性条件的记录行版本(用于MVCC快照读)。</p></blockquote><h4 id="4、版本链"><a href="#4、版本链" class="headerlink" title="4、版本链"></a>4、版本链</h4><p>多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为<strong>版本链</strong>。如下：</p><p><img src="2.png" alt="img"></p><h4 id="5、快照读和当前读"><a href="#5、快照读和当前读" class="headerlink" title="5、快照读和当前读"></a>5、快照读和当前读</h4><p><strong>快照读</strong>： 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的select语句都是快照读,如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>当前读</strong>：读取的是记录数据的最新版本，显式加锁的都是当前读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br></pre></td></tr></table></figure><h4 id="6、ReadView"><a href="#6、ReadView" class="headerlink" title="6、ReadView"></a>6、ReadView</h4><blockquote><p>ReadView是事务在进行快照读的时候生成的记录快照, 可以帮助我们解决可见性问题的</p></blockquote><p>如果一个事务要查询行记录，需要读取哪个版本的行记录呢？ ReadView 就是来解决这个问题的。 ReadView 保存了<strong>当前事务开启时所有活跃的事务列表</strong>。换个角度，可以理解为: <strong>ReadView 保存了不应该让这个事务看到的其他事务 ID 列表。</strong></p><p>ReadView是如何保证可见性判断的呢？我们先看看 ReadView 的几个重要属性</p><ul><li><strong>trx_ids</strong>: 当前系统中那些活跃(未提交)的读写事务ID, 它数据结构为一个List。(<code>重点注意</code>:这里的trx_ids中的活跃事务，<strong>不包括当前事务自己</strong>和已提交的事务，这点非常重要)</li><li><strong>low_limit_id</strong>: 目前出现过的最大的事务ID+1，即下一个将被分配的事务ID。</li><li><strong>up_limit_id</strong>: 活跃事务列表trx_ids中最小的事务ID，如果trx_ids为空，则up_limit_id 为 low_limit_id。</li><li><strong>creator_trx_id</strong>: 表示生成该 ReadView 的事务的 事务id</li></ul><p>访问某条记录的时候如何判断该记录是否可见,具体规则如下：</p><ul><li>如果被访问版本的 <code>事务ID = creator_trx_id</code>，那么表示当前事务访问的是自己修改过的记录，那么该版本对当前事务可见；</li><li>如果被访问版本的 <code>事务ID &lt; up_limit_id</code>，那么表示生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 <code>事务ID &gt; low_limit_id</code> 值，那么表示生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的 <code>事务ID在 up_limit_id和m_low_limit_id</code> 之间，那就需要判断一下版本的事务ID是不是在 trx_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；<br>如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p>画张图来理解下</p><p><img src="3.png" alt="img"></p><p>这里需要思考的一个问题就是 <code>何时创建ReadView？</code></p><p>上面说过,ReadView是来解决一个事务需要读取哪个版本的行记录的问题的。那么说明什么？只有在select的时候才会创建ReadView。但在不同的隔离级别是有区别的:</p><blockquote><p>在RC隔离级别下，是每个select都会创建最新的ReadView；而在RR隔离级别下，则是当事务中的第一个select请求才创建ReadView(下面会详细举例说明)。</p></blockquote><p>那insert/update/delete操作呢？</p><p>这样操作不会创建ReadView。但是这些操作在事务开启(begin)且其未提交的时候，那么它的事务ID,会存在在其它存在查询事务的ReadView记录中，也就是trx_ids中。</p><h2 id="三、MVCC实现原理分析"><a href="#三、MVCC实现原理分析" class="headerlink" title="三、MVCC实现原理分析"></a>三、MVCC实现原理分析</h2><h4 id="1、如何查询一条记录"><a href="#1、如何查询一条记录" class="headerlink" title="1、如何查询一条记录"></a>1、如何查询一条记录</h4><ol><li>获取事务自己事务ID,即trx_id。(这个也不是select的时候获取的，而是这个事务开启的时候获取的 也就是begin的时候)</li><li>获取ReadView(这个才是select的时候才会生成的)</li><li>数据库表中如果查询到数据，那就到ReadView中的事务版本号进行比较。</li><li>如果不符合ReadView的可见性规则， 即就需要Undo log中历史快照,直到返回符合规则的数据;</li></ol><p>InnoDB 实现MVCC，是通过<code>ReadView+ Undo Log</code> 实现的，Undo Log 保存了历史快照，ReadView可见性规则帮助判断当前版本的数据是否可见。</p><h4 id="2、MVCC是如何实现读已提交和可重复读的呢？"><a href="#2、MVCC是如何实现读已提交和可重复读的呢？" class="headerlink" title="2、MVCC是如何实现读已提交和可重复读的呢？"></a>2、MVCC是如何实现读已提交和可重复读的呢？</h4><p>其实其它流程都是一样的，读已提交和可重复读唯一的区别在于：在RC隔离级别下，是每个select都会创建最新的ReadView；而在RR隔离级别下，则是当事务中的第一个select请求才创建ReadView。</p><p>看完下面这个例子你应该就明白了。</p><p><img src="4.png" alt="img"></p><h2 id="四、经典面试题-MVCC能否解决了幻读问题呢？"><a href="#四、经典面试题-MVCC能否解决了幻读问题呢？" class="headerlink" title="四、经典面试题:MVCC能否解决了幻读问题呢？"></a>四、经典面试题:MVCC能否解决了幻读问题呢？</h2><p>有关这个问题查了很多资料,有的说能解决，有的说不能解决，也有人说能解决部分幻读场景。这里部分解决指的是能解决快照读的幻读问题，不能解决当前读的幻读问题。</p><p>具体可以看下面这篇文章</p><p>面试题之：MVCC能否解决幻读？<a href="https://blog.csdn.net/qq_35590091/article/details/107734005" target="_blank" rel="noopener">https://blog.csdn.net/qq_35590091/article/details/107734005</a></p><p>先说我的结论:</p><blockquote><p>MVCC能解决不可重复读问题,但是不能解决幻读问题，不论是快照读和当前读都不能解决。RR级别解决幻读靠的是锁机制,而不是MVCC机制。</p></blockquote><p>既然网上那么多人说，MVCC解决能解决快照读下的幻读问题， 那这里通过举示例来说明,MVCC解决不了快照读的幻读问题。</p><p>假设有张用户表,这张表的 id 是主键。表中一开始有4条数据。</p><p><img src="5.png" alt="img"></p><p>这里是在RR级别下研究(可重复读)。</p><p><img src="6.png" alt="img"></p><p>1、事务A,查询是否存在 id=5 的记录，没有则插入，这是我们期望的正常业务逻辑。</p><p>2、这个时候 事务B 新增的一条 id=5 的记录，并提交事务。</p><p>3、事务A,再去查询 id=5 的时候,发现还是没有记录。</p><p>上面的文章是这样来举例说明,事务A第一次和第二次读到的是一样的，所以认为解决了幻读。我不认为这个是解决了幻读，而是解决了不可能重复读。它保证了第一次和第二次所读到的结果是一样的。</p><p>解决幻读了吗？显然没有，因为这个时候如果事务A执行一条插入操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`pwd`</span>) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">'田七'</span>, <span class="string">'fff'</span>);</span><br></pre></td></tr></table></figure><p><img src="7.png" alt="img"></p><p>最终 事务A 提交事务，发现报错了。这就很奇怪，查的时候明明没有这条记录，但插入的时候 却告诉我 主键冲突，这就好像幻觉一样。这才是幻读问题。</p><p>所以说MVCC是不能解决的，要想解决还是需要锁。</p><p>这里事务A能正常的插入的前提就是其它事务不能插入id=5并提交成功。要解决这个问题也很简单，就是事务A先获得id=5这个排它锁。</p><p>我们可以在事务A第一次查询的时候加一个排他锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span> <span class="string">`user`</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>那么事务B的插入动作永远属于堵塞状态，直到事务A插入成功，并提交。那么最终是事务B报主键冲突而回滚。但事务A不会因为查询的时候没有这条记录，插入失败。也就解决了幻读问题。</p><p>所以说 RR级别下解决幻读问题靠的是锁机制，而不是MVCC机制。</p><blockquote><p>转载公众号：后端元宇宙</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解脏读、不可重复读、幻读</title>
      <link href="/2022/07/21/mysql-2022-07-21-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB/"/>
      <url>/2022/07/21/mysql-2022-07-21-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在MySQL的众多存储引擎中，只有InnoDB支持事务，所有这里说的事务隔离级别指的是InnoDB下的事务隔离级别。</p></blockquote><p>MySQL 是支持多事务并发执行的。否则来一个事务处理一个请求，处理一个人请求的时候，其它事务都等着，那估计都没人敢用MySQL作为数据库,因为用户体验太差，估计都要砸键盘了。</p><p>既然事务可以并发操作,这里就有一些问题：一个事务在写数据的时候，另一个事务要读这行数据，该怎么处理？一个事务在写数据，另一个数据也要写这行数据，又该怎么处理这个冲突？</p><p>这就是并发事务所产生的一些问题。具体来说就是：<code>脏读</code>、<code>不可重复读</code>和<code>幻读</code>。</p><h2 id="一、概念说明"><a href="#一、概念说明" class="headerlink" title="一、概念说明"></a>一、概念说明</h2><p>以下几个概念是事务隔离级别要实际解决的问题，所以需要搞清楚都是什么意思。</p><h4 id="1、脏读"><a href="#1、脏读" class="headerlink" title="1、脏读"></a>1、脏读</h4><p>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</p><p><img src="1.png" alt="img"></p><p>脏读最大的问题就是可能会读到不存在的数据。比如在上图中，事务B的更新数据被事务A读取，但是事务B回滚了，更新数据全部还原，也就是说事务A刚刚读到的数据并没有存在于数据库中。</p><p><strong>从宏观来看，就是事务A读出了一条不存在的数据，这个问题是很严重的。</strong></p><h4 id="2、不可重复读"><a href="#2、不可重复读" class="headerlink" title="2、不可重复读"></a>2、不可重复读</h4><p>不可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据出现不一致的情况。</p><p><img src="2.png" alt="img"></p><p><strong>事务 A 多次读取同一数据，但事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</strong></p><h4 id="3、幻读"><a href="#3、幻读" class="headerlink" title="3、幻读"></a>3、幻读</h4><p>脏读、不可重复读上面的图文都很好的理解，对于幻读网上有很多文章都是这么解释的</p><p><strong>幻读错误的理解</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">说幻读是 事务A 执行两次 <span class="keyword">select</span> 操作得到不同的数据集，即 <span class="keyword">select</span> <span class="number">1</span> 得到 <span class="number">10</span> 条记录，<span class="keyword">select</span> <span class="number">2</span> 得到 <span class="number">15</span> 条记录。</span><br><span class="line">这其实并不是幻读，既然第一次和第二次读取的不一致，那不还是不可重复读吗，所以这是不可重复读的一种。</span><br></pre></td></tr></table></figure><p><strong>正确的理解应该是</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 <span class="built_in">select</span> 操作得到的结果所表征的数据状态无法支撑后续的业务操作。</span><br><span class="line">更为具体一些：<span class="built_in">select</span> 某记录是否存在，不存在，准备插入此记录，但执行 <span class="built_in">insert</span> 时发现此记录已存在，无法插入，此时就发生了幻读。</span><br><span class="line">举例</span><br></pre></td></tr></table></figure><p>假设有张用户表,这张表的 id 是主键。表中一开始有4条数据。</p><p><img src="3.png" alt="img"></p><p>我们再来看下出现 幻读 的场景</p><p><img src="4.png" alt="img"></p><p>这里是在RR级别下研究(可重复读),因为 RU / RC 下还会存在脏读、不可重复读，故我们就以 RR 级别来研究 幻读，排除其他干扰。</p><p>1、事务A,查询是否存在 id=5 的记录，没有则插入，这是我们期望的正常业务逻辑。</p><p>2、这个时候 事务B 新增的一条 id=5 的记录，并提交事务。</p><p>3、事务A,再去查询 id=5 的时候,发现还是没有记录（因为这里是在RR级别下研究(可重复读)，所以读到依然没有数据）</p><p>4、事务A,插入一条 id=5 的数据。</p><p>最终 事务A 提交事务，发现报错了。这就很奇怪，查的时候明明没有这条记录，但插入的时候 却告诉我 主键冲突，这就好像幻觉一样。这才是所有的幻读。</p><p><strong>不可重复读侧重表达 读-读，幻读则是说 读-写，用写来证实读的是鬼影</strong>。</p><h2 id="二、事务的隔离级别"><a href="#二、事务的隔离级别" class="headerlink" title="二、事务的隔离级别"></a>二、事务的隔离级别</h2><p>上述所说的”脏读”，”不可重复读”，”幻读”这些问题，其实就是数据库读一致性问题，必须由数据库提供的事务隔离机制来进行解决。</p><p><img src="5.png" alt="img"></p><p>首先说读未提交，它是性能最好，也可以说它是最野蛮的方式，因为它压根儿就不加锁，所以根本谈不上什么隔离效果，可以理解为没有隔离。</p><p>再来说串行化。串行化就相当于上面所说的，处理一个人请求的时候，别的人都等着。读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读。</p><p>最后说读提交和可重复读。这两种隔离级别是比较复杂的，既要允许一定的并发，又想要兼顾的解决问题。MySQL默认事务隔离级别为可重复读(RR),oracle默认事务隔离级别为读已提交(RC),</p><p>数据库的事务隔离越严格，并发副作用越小，但付出的代价越大；因为事务隔离本质就是使事务在一定程度上处于串行状态，这本身就是和并发相矛盾的。</p><p>同时，不同的应用对读一致性和事务隔离级别是不一样的，比如许多应用对数据的一致性没那么个高要求，相反，对并发有一定要求。</p><blockquote><p>公众号：后端的名字一文，解释的不错，特地转载。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的操作规范</title>
      <link href="/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E6%93%8D%E4%BD%9C%E8%A7%84%E8%8C%83/"/>
      <url>/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E6%93%8D%E4%BD%9C%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天来看一下，比较通用的规范操作。</p><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>1.1、表名建议使用有业务意义的英文词汇，必要时可加数字和下划线，并以英文字母开头；</p><p>1.2、库、表、字段全部采用小写；</p><p>MySQL 在 Linux 下默认是区分大小写的，而在 Windows 下不区分大小写。因此，防止出现问题，建议都设置为小写。</p><p>1.3、避免用 MySQL 的保留字， MySQL 保留字请参考<a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html" target="_blank" rel="noopener">官方手册：9.3 Keywords and Reserved Words</a>；</p><p>1.4、命名（包括表名、列名）禁止超过 30 个字符；</p><p>1.5、临时库、表名必须以 tmp 为前缀，并以日期为后缀，如：tmp_shop_info_20190404；</p><p>1.6、备份库、表必须以 bak 为前缀，并以日期为后缀，如：bak_shop_info_20190404；</p><p>1.7、索引命名：</p><ul><li>非唯一索引必须按照“idx_字段名称”进行命名；</li><li>唯一索引必须按照“uniq_字段名称”进行命名。</li></ul><h2 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h2><ol><li>主键：</li></ol><ul><li>表必须有主键；</li><li>不使用更新频繁的列做主键；</li><li>尽量不选择字符串列做主键；</li><li>不使用 UUID MD5 HASH 做主键；</li><li>默认使用非空的唯一键。</li></ul><ol><li><p>如无特殊要求，建议都使用 InnoDB 引擎；</p></li><li><p>默认使用 utf8mb4 字符集，数据排序规则使用 utf8mb4_general_ci；</p></li></ol><p>原因：utf8mb4 为万国码，无乱码风险；与 utf8 编码相比，utf8mb4 能支持 Emoji 表情。</p><ol><li>所有表、字段都需要增加 comment 来描述此表、字段所表示的含义；</li></ol><p>比如：data_status TINYINT NOT NULL DEFAULT ‘1’ COMMENT ‘1代表记录有效，0代表记录无效’。</p><ol><li><p>、如无说明，表必须包含 create_time 和 update_time 字段，即表必须包含记录创建时间和修改时间的字段；</p></li><li><p>用尽量少的存储空间来存数一个字段的数据：</p></li></ol><ul><li>能用 int 的就不用 char 或者 varchar；</li><li>能用 tinyint 的就不用 int；</li><li>使用 UNSIGNED 存储非负数值；</li><li>只存储年使用 YEAR 类型；</li><li>只存储日期使用 DATE 类型。</li></ul><ol><li>存储精确浮点数必须使用 DECIMAL 替代 FLOAT 和 DOUBLE；</li></ol><p>原因：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。</p><ol><li>尽可能不使用 TEXT、BLOB 类型；</li></ol><p>原因：会浪费更多的磁盘和内存空间，非必要的大量大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能。如果实在有某个字段过长需要使用 TEXT、BLOB 类型，则建议独立出来一张表，用主键来对应，避免影响原表的查询效率。</p><ol><li><p>禁止在数据库中存储明文密码；</p></li><li><p>索引设计规范：</p></li></ol><ul><li><p>需要添加索引的字段</p><ul><li><p>UPDATE、DELETE 语句的 WHERE 条件列；</p></li><li><p>ORDER BY、GROUP BY、DISTINCT 的字段（原因可复习<a href="https://www.imooc.com/read/43/article/686" target="_blank" rel="noopener">第 6 节</a>）；</p></li><li><p>多表 JOIN 的字段（原因可复习<a href="https://www.imooc.com/read/43/article/688" target="_blank" rel="noopener">第 8 节</a>）。</p></li></ul></li><li><p>单表索引建议控制在 5 个以内；</p></li><li><p>适当配置联合索引；</p></li></ul><p>比如方便查询能走覆盖索引，或者几个字段同时作为条件的概率很高时，当然还有其他很多种情况可以设置联合索引.</p><ul><li>业务上具有唯一性的字段，添加成唯一索引；</li></ul><p>遇到过几次字段在业务场景上要求唯一，但是该字段在数据库里的数据却出现了重复。因此在代码层考虑外，还需要在 MySQL 上的对应字段添加唯一索引。</p><ul><li>在 varchar 字段上建立索引时，建议根据实际文本区分度指定索引长度；</li></ul><p>原因：可以降低索引所占用的空间，并且很多时候，比如字符串基本是长度大于 20，但是只要建立长度为 20 的索引，就已经有很高的区分度了。可以使用 count(distinct left(列名, 索引长度))/count(*) 的区分度来确定。</p><ul><li><p>索引禁忌：</p><ul><li><p>不在低基数列上建立索引，例如：性别字段。</p></li><li><p>不在索引列进行数学运算和函数运算（原因，做函数操作可能会导致使用不了索引）</p></li></ul></li></ul><ol><li>不建议使用外键；</li></ol><p>原因：外键会导致表与表之间耦合，update 与 delete 操作都会涉及相关联的表，十分影响 sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能。</p><ol><li>禁止使用存储过程、视图、触发器、Event ；</li></ol><p>原因：高并发的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性。</p><ol><li><p>单表列数目建议小于 30；</p></li><li><p>表示例：</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_info (</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line"> stu_name <span class="built_in">VARCHAR</span> (<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line"> stu_class <span class="built_in">VARCHAR</span> (<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'班级'</span>,</span><br><span class="line"> stu_num <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'学号'</span>,</span><br><span class="line"> stu_score <span class="built_in">SMALLINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'总分'</span>,</span><br><span class="line"> tuition <span class="built_in">DECIMAL</span> (<span class="number">5</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'学费'</span>,</span><br><span class="line"> phone_number <span class="built_in">VARCHAR</span> (<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'电话号码'</span>,</span><br><span class="line"> create_time datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'记录创建时间'</span>,</span><br><span class="line"> update_time datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'记录更新时间'</span>,</span><br><span class="line"> <span class="keyword">status</span> <span class="built_in">TINYINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'1代表记录有效，0代表记录无效'</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line"> <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> uniq_stu_num (stu_num),</span><br><span class="line"> <span class="keyword">KEY</span> idx_stu_score (stu_score),</span><br><span class="line"> <span class="keyword">KEY</span> idx_update_time_tuition (update_time, tuition)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">charset</span> = utf8mb4 <span class="keyword">COMMENT</span> <span class="string">'学生信息表'</span>;</span><br></pre></td></tr></table></figure><h2 id="SQL语句规范"><a href="#SQL语句规范" class="headerlink" title="SQL语句规范"></a>SQL语句规范</h2><ol><li>避免隐式转换；</li></ol><p>具体原因可以看一下前文。</p><ol><li>尽量不使用select *,只 select 需要的字段 ；</li></ol><p>原因：读取不需要的列会增加 CPU、IO、NET 消耗，并且不能有效的利用覆盖索引。使用 SELECT * 容易在增加或者删除字段后导致程序报错。</p><ol><li>禁止使用 INSERT INTO t_xxx VALUES (xxx)，必须显示指定插入的列属性 ；</li></ol><p>原因：容易在增加或者删除字段后导致程序报错。</p><ol><li>尽量不使用负向查询；</li></ol><p>比如 not in/like。</p><ol><li>禁止以 % 开头的模糊查询。</li></ol><p>原因：使用不了索引</p><ol><li><p>禁止单条 SQL 语句同时更新多个表；</p></li><li><p>统计记录数使用 select count(*)，而不是 select count(primary_key)或者 select count(普通字段名)；</p></li></ol><p>原因：可能会导致走的索引不是最优的或者导致统计数字不准确。</p><ol><li><p>建议将子查询转换为关联查询；</p></li><li><p>建议应用程序捕获 SQL 异常，并有相应处理；</p></li><li><p>SQL 中不建议使用 sleep()，如特殊需求需要用到 sleep()，请提前告知 DBA；</p></li><li><p>避免大表的 join。</p></li></ol><h2 id="行为规范"><a href="#行为规范" class="headerlink" title="行为规范"></a>行为规范</h2><ol><li><p>批量导入、导出数据必须提前通知 DBA 协助观察；</p></li><li><p>有可能导致 MySQL QPS 上升的活动，提前告知DBA；</p></li><li><p>同一张表的多个 alter 合成一次操作；</p></li><li><p>不在业务高峰期批量更新、查询数据库；</p></li><li><p>删除表或者库要求尽量先 rename，观察几天，确定对业务没影响，再 drop。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了 MySQL 的一些操作规范，主要讲解了下面这些场景的规范：</p><ol><li>命名规范；</li><li>设计规范；</li><li>SQL 语句规范；</li><li>行为规范。</li></ol><p>当然，各个公司可能都有自己独有的 MySQL 使用规范，因此这篇文章仅供参考。</p><p>当制定出合理的 MySQL 使用规范，并严格按照规范操作，很多问题都可以在源头上避免掉。</p><blockquote><p>参考资料</p><p>《MySQL 工作笔记》第 4 章：SQL 开发规范和基础</p><p>《阿里巴巴Java开发手册》第五章：MySQL 数据库</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层的优化点总结</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E4%BC%98%E5%8C%96%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E4%BC%98%E5%8C%96%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    对于数据库的使用，我们不仅仅要考虑 MySQL 本身的优化，还需要考虑应用层的优化。因为有些线上问题，就是由于应用层设置不合理导致的。下面看一下常见的优化点。</p><h2 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h2><p>MySQL 如果频繁创建和断开连接，那 MySQL 的开销会比较大，可能会占用过多的服务器内存资源，甚至导致响应时间变慢。此时就可以考虑使用连接池来改进性能。</p><p>连接池可以理解为：创建一些持久连接的“池”，新的请求可以使用这些连接池，减少创建和断开连接的次数。</p><p>其大致原理是：</p><ol><li>当进程启动时，创建相应的数据库连接池对象；</li><li>如果程序需要请求数据库，则直接从连接池获取到一个连接；</li><li>数据库请求完成后，释放数据库连接池。</li></ol><p><strong>那么连接池会不会导致服务器连接过多呢？</strong></p><p>通常情况下，连接池不会导致服务器连接过多，因为它们会在进程间排队和共享连接。</p><blockquote><p>在《高性能 MySQL》第 14 章：应用层优化中就提到：当遇到连接池完全占满时，应该将连接请求进行排队，而不是扩展连接池。这样可以避免将压力都转到 MySQL 上而导致 MySQL 连接数过多。</p></blockquote><h2 id="减少对-MySQL-的访问"><a href="#减少对-MySQL-的访问" class="headerlink" title="减少对 MySQL 的访问"></a>减少对 MySQL 的访问</h2><p>避免对同一行数据做重复检索，比如查询某个用户信息。</p><p>首先查出这个用户的联系方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> phone <span class="keyword">from</span> user_info <span class="keyword">where</span> user_id=<span class="number">111</span>;</span><br></pre></td></tr></table></figure><p>然后再查出这个用户的姓名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> user_info <span class="keyword">where</span> user_id=<span class="number">111</span>;</span><br></pre></td></tr></table></figure><p>显然上面的方式并不是最优的，可以将两条 SQL 合并成一条：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> phone,<span class="keyword">name</span>  <span class="keyword">from</span> user_info <span class="keyword">where</span> user_id=<span class="number">111</span>;</span><br></pre></td></tr></table></figure><p>然后返回给客户端。这样跟数据库建立连接的次数从 2 次降低到 1 次，从而节省了部分建立连接所花费的内存和时间。</p><h2 id="增加-Redis-缓存层"><a href="#增加-Redis-缓存层" class="headerlink" title="增加 Redis 缓存层"></a>增加 Redis 缓存层</h2><p>在很多业务场景，Redis 充当着不可或缺的角色。这里介绍几种通过 Redis 环境 MySQL 压力的场景：</p><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>当统计数增加，则在 Redis 中执行下面的命令让计数器加 1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR t1_count</span><br></pre></td></tr></table></figure><p>通过这种方式缓解在 MySQL 中执行 update 的压力。</p><h3 id="K-V-数据缓存"><a href="#K-V-数据缓存" class="headerlink" title="K-V 数据缓存"></a>K-V 数据缓存</h3><p>在 MySQL 中，如果某个字段会被频繁查询，而该字段内容变化的概率又不是很大，就可以考虑使用 Redis 缓存。比如电商业务，查看上个季度某类型商品的销量排行，如果这一个功能放在主页，点击量可能会非常高，因此可以考虑放在 Redis 中。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Redis 中可以非常方便的使用消息队列。</p><p>生产者通过 lpush 将消息放在 list 中，消费者通过 rpop 取出该消息。</p><p>比如使用 Redis 实现短信消息队列。如果用户在 APP 上点击注册用户名密码，需要填下手机号验证，程序会将该用户的手机号放在 Redis 的 list 中，然后另外一个程序一直去消费 list 中的手机号，取出手机后，则调用第三方短信接口，发送手机短信息给到用户。</p><h2 id="单表过大及时归档"><a href="#单表过大及时归档" class="headerlink" title="单表过大及时归档"></a>单表过大及时归档</h2><p>比如单张表过大，可能有下面这些影响：</p><ol><li>在修改表结构时导致长时间主从延迟；</li><li>备份时间过久；</li><li>查询速度可能也会变慢。</li></ol><p>因此，可以考虑对历史数据归档（比如日志数据），控制单表的数据量。</p><h2 id="代码层读写分离"><a href="#代码层读写分离" class="headerlink" title="代码层读写分离"></a>代码层读写分离</h2><p>在配置了 MySQL 主从环境的情况下，可以考虑使用读写分离，通过程序配置的这种方式，在专栏<a href="https://www.imooc.com/read/43/article/707" target="_blank" rel="noopener">第 27 节</a>有提到过。更新走主库，查询走从库。</p><p>当然，主从同步可能因为大事务或者网络等原因导致同步延迟，在使用读写分离是也需要考虑到延迟这一点。</p><h2 id="表的索引提前规划"><a href="#表的索引提前规划" class="headerlink" title="表的索引提前规划"></a>表的索引提前规划</h2><p>当开发或者 DBA 在创建新表时，就应该考虑在表的条件字段添加合适索引。这样可以避免业务上线后，数据量一上来就出现大量慢查询而导致 MySQL 服务器高负载。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了使用 MySQL 时，应用层的一些优化。</p><p>提到了以下几点优化方案：</p><p>1、使用连接池；</p><p>2、减少对 MySQL 的访问；</p><p>3、增加 Redis 缓存层；</p><p>4、单表过大及时归档；</p><p>5、代码层读写分离；</p><p>6、表的索引提前规划；</p><p>······</p><p>实际工作中也是，不单单 DBA 要去优化 MySQL，开发也应该考虑在应用层去做一些优化，以保证业务稳定高效。</p><blockquote><p>参考资料</p><p>《深入浅出 MySQL》第 23 章：应用优化</p><p>《高性能 MySQL》第 14 章：应用层优化</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除大量数据的经验</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E5%88%A0%E9%99%A4%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E5%88%A0%E9%99%A4%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了防止单张表过大，很多情况下，我们需要对历史数据做归档或者删除操作。那么如何高效删除大量无用数据呢？今天就来总结一下。</p><p>在聊数据删除前，我们先来看看 MySQL 的共享表空间和独立表空间。</p><h2 id="共享表空间和独立表空间"><a href="#共享表空间和独立表空间" class="headerlink" title="共享表空间和独立表空间"></a>共享表空间和独立表空间</h2><p>InnoDB 数据是按照表空间进行存放的，其表空间分为共享表空间和独立表空间。</p><h3 id="共享表空间"><a href="#共享表空间" class="headerlink" title="共享表空间"></a>共享表空间</h3><p>共享表空间：表的数据放在系统共享表空间，也就是跟数据字典放一起。文件名为 ibdata1。可以通过参数 innodb_data_file_path 进行设置。在 my.cnf 中配置，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path = ibdata1:1G;ibdata2:1G:autoextend</span><br></pre></td></tr></table></figure><p>表示用两个文件（ibdata1 和 ibdata2）组成表空间，文件 ibdata1 的大小为 1G，文件 ibdata2 的大小为 1G，autoextend 表示用完 1G 可以自动增长。</p><h3 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h3><p>独立表空间：每个 InnoDB 表数据存储在一个以 .idb 为后缀的文件中。</p><p>由参数 innodb_file_per_table 控制。</p><p>设置为 on 表示使用独立表空间；</p><p>设置为 off 表示使用共享表空间。</p><blockquote><p><strong>经验分享</strong></p><p>一般情况下建议设置为独立表空间，原因是：如果某张表被 drop 掉，会直接删除该表对应的文件，如果放在共享表空间中，即使执行了 drop table 操作，空间还是不能回收。</p></blockquote><p>基于上面的经验分享，因此建议使用独立表空间，而本节后面提到的几种删除数据的情况，都是基于独立表空间的情况。</p><h2 id="几种数据删除形式"><a href="#几种数据删除形式" class="headerlink" title="几种数据删除形式"></a>几种数据删除形式</h2><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>如果是某张表（假如表名为 t29）的数据和表结构都不需要使用了，那么可以考虑 drop 掉。出于安全考虑，建议的步骤如下：</p><ul><li>1、首先将表名改为 t29_bak_20191011：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t29 <span class="keyword">rename</span> t29_bak_20191011;</span><br></pre></td></tr></table></figure><ul><li>2、然后等待半个月，观察是否有程序因为找不到表 t29 而报错；</li><li>3、如果没有跟表 t29 相关的报错，则半个月后直接 drop 掉 t29_bak_20191011：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t29_bak_20191011;</span><br></pre></td></tr></table></figure><h3 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h3><p>如果是某张表（假如表名为 t29）的历史数据不需要使用了，要做一次清空，则可以考虑使用 truncate。</p><p>建议的步骤如下：</p><p>1、创建一张与 t29 表结构相同的临时表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t29_bak_20191011 <span class="keyword">like</span> t29;</span><br></pre></td></tr></table></figure><p>2、并将数据拷贝到临时表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_bak_20191011  <span class="keyword">select</span> * <span class="keyword">from</span> t29;</span><br></pre></td></tr></table></figure><p>3、再清空该表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> t29;</span><br></pre></td></tr></table></figure><p>4、如果空间不够，观察半个月后，考虑转移 t29_bak_20191011 的数据到备份机器上。然后删除表 t29_bak_20191011：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t29_bak_20191011;</span><br></pre></td></tr></table></figure><blockquote><p><strong>经验分享</strong></p><p>我不止一次遇到类似的情况：需要清空表而使用 delete from table_name，导致主从延迟和磁盘 IO 跑满的情况。 原因是 binlog 为行模式的情况下，执行全表 delete 会生成每一行对应的删除操作，因此可能导致单个删除事务非常大。而 truncate 可以理解为 drop + create，在 binlog 为 row 模式的情况下，也只会产生一行 truncate 操作。所以，建议清空表时使用 truncate 而不使用 delete。</p></blockquote><h3 id="非分区表删除部分记录"><a href="#非分区表删除部分记录" class="headerlink" title="非分区表删除部分记录"></a>非分区表删除部分记录</h3><p>实际更多的情况，我们是需要删除表中一部分数据，在没有配置分区表的情况下，就只能用 delete 了。也许我们有时会发现，在 delete 很多数据后，实际表文件大小没变化。这是什么原因呢？</p><p>原因是，如果通过 delete 删除某条记录，InnoDB 引擎会把这条记录标记为删除，但是磁盘文件的大小并不会缩小。如果之后要在这中间插入一条数据，则可以复用这个位置，如果一直没有数据插入，就会形成一个 “空洞”。因此 delete 命令是不能回收空间的，这也是 delete 后表文件大小没变化的原因。</p><p>对于非分区表删除部分记录（比如删除 2017 年之前的数据，语句为：delete from table_name where date&lt;‘2017-01-01’;），建议的步骤是：</p><ul><li>1、首先备份全表；</li><li>2、确保 date 字段有索引，如果没有索引，则需要添加索引（目的是避免执行删除命令时，全表扫描）；</li><li>3、如果要删除的数据比较多，建议写一个循环，每次删除满足条件记录的 1000 条（目的是避免大事务），删完为止：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="built_in">date</span>&lt;<span class="string">'2017-01-01'</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><ul><li>4、最后重建表（目的是释放表空间，但是会锁表，建议在业务低峰执行）：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optimize</span> <span class="keyword">table</span> student;</span><br></pre></td></tr></table></figure><h3 id="分区表删除部分分区"><a href="#分区表删除部分分区" class="headerlink" title="分区表删除部分分区"></a>分区表删除部分分区</h3><p>从 MySQL 5.1 开始，支持分区。MySQL 分区是指将一张表按照某种规则（比如时间范围或者哈希等），划分为多个区块，各个区块所属的数据文件是相互独立的。</p><p>比如对于一些日志表，我们可以创建成分区表，建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t29_log ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t29_log (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">log_info <span class="built_in">VARCHAR</span> (<span class="number">100</span>),</span><br><span class="line"><span class="built_in">date</span> datetime</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(<span class="built_in">date</span>))(</span><br><span class="line"><span class="keyword">PARTITION</span> p2016</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line"><span class="keyword">less</span> <span class="keyword">THAN</span> (<span class="number">2017</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p2017</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line"><span class="keyword">less</span> <span class="keyword">THAN</span> (<span class="number">2018</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p2018</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line"><span class="keyword">less</span> <span class="keyword">THAN</span> (<span class="number">2019</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在上表的分区表中，表示：</p><ul><li>当日期的年份小于 2017 时，则数据存放在 p2016 分区；</li><li>当日期的年份大于等于 2017 小于 2018 时，则数据存放在 p2017 分区；</li><li>当日期的年份大于等于 2018 小于 2019 时，则数据存放在 p2018 分区。</li></ul><p>对于分区表，其物理文件是由建立分区时的各个分区 idb 文件组成，如下：</p><p><img src="1.png" alt="图片描述"></p><p>这里写入几条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_log <span class="keyword">select</span> <span class="number">1</span>,<span class="string">'aaa'</span>,<span class="string">'2016-01-01'</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_log <span class="keyword">select</span> <span class="number">2</span>,<span class="string">'bbb'</span>,<span class="string">'2016-06-01'</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_log <span class="keyword">select</span> <span class="number">3</span>,<span class="string">'ccc'</span>,<span class="string">'2017-01-01'</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t29_log <span class="keyword">select</span> <span class="number">4</span>,<span class="string">'ddd'</span>,<span class="string">'2018-01-01'</span>;</span><br></pre></td></tr></table></figure><p>因为表 t29_log 是根据 date 来分区的，因此数据是根据 date 值的范围存放在不同的物理文件中，可以通过 information_schema 库下的 partitions 表来查看各个分区的具体信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> TABLE_SCHEMA,TABLE_NAME,PARTITION_NAME,TABLE_ROWS <span class="keyword">from</span> information_schema.partitions <span class="keyword">where</span> table_schema=<span class="string">'muke'</span> <span class="keyword">and</span> table_name=<span class="string">'t29_log'</span>;</span><br></pre></td></tr></table></figure><p><img src="/2.png" alt="图片描述"><br>TABLE_ROWS 表示每个分区中的记录数。</p><p>我们查询下 t29_log 全表的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t29_log;</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="图片描述"><br>比如上面例子中 t29_log 需要删除 2016 年全年的数据，那么可以直接把 p2016 分区 drop 掉：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t29_log <span class="keyword">drop</span> <span class="keyword">partition</span> p2016;</span><br></pre></td></tr></table></figure><p><img src="4.png" alt="图片描述"></p><p>相对慢慢 delete，这种方式删除历史数据效率高很多。</p><p>因此，对于要经常删除历史数据的表，建议配置成分区表。以方便后续历史数据删除。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节首先提到了共享表空间和独立表空间，考虑到独立表空间的情况下，如果 drop 一张表，空间可以回收。因此一般建议设置为独立表空间。</p><p>如果要清空表，建议使用 truncate，而不使用 delete。</p><p>原因是 binlog 为行模式的情况下，执行全表 delete 会生成每一行对应的删除操作，因此可能导致单个删除事务非常大。而 truncate 可以理解为 drop + create，在 binlog 为 row 模式的情况下，也只会产生一行 truncate 操作。所以，建议清空表时使用 truncate 而不使用 delete。</p><p>本节提到了几种常见删除数据的情况，并提供了一些方法，其核心是删除前，需要备份数据。以防万一，另外就是尽可能的去避免删除数据时产生大事务。</p><p>考虑到非分区表删除部分记录会比较麻烦，因此如果知道某张表（比如日志类表）会进程删除几年前的数据，那么建议设置成分区表，删除历史数据将非常方便高效。</p><blockquote><p>参考资料</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-tablespaces.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-tablespaces.html</a></p><p>《MySQL 技术内幕：InnoDB 存储引擎》3.6.1 表空间文件、4.8 分区表</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的分库分表</title>
      <link href="/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>使用数据库时，我们经常会聊到分库分表，那么分库分表有哪些方式？什么情况应该考虑分库分表呢？这次我们来看下这些问题。</p><p>MySQL 分库分表是指：把 MySQL 数据库物理地拆分到多个实例或者机器上去。从而降低单台 MySQL 实例的负载。那么这里讲的拆分究竟以什么方式实现的呢？这里就先来看看 MySQL 分库分表的拆分方法：</p><h2 id="MySQL-分库分表拆分方法"><a href="#MySQL-分库分表拆分方法" class="headerlink" title="MySQL 分库分表拆分方法"></a>MySQL 分库分表拆分方法</h2><p>MySQL 分库分表拆分方法分为：垂直拆分和水平拆分。</p><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><p>垂直拆分一般是指下面几种情况：</p><ul><li>有多个业务，每个业务单独分到一个实例里面。</li><li>在一个实例中有多个库，把这些库分别放到单独的实例中。</li><li>在一个库中存在过多的表，把这些表拆分到多个库中。</li><li>把字段过多的表拆分成多个表，每张表包含一部分字段。</li></ul><p>比如一个电商网站，他的用户信息（userinfo）、商品信息（productinfo）、订单信息（orderinfo) 垂直拆分在三个实例中，如下图所示：</p><p><img src="1.png" alt="图片描述"></p><h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><p>如果通过垂直拆分，表数据量仍然很大，那就可以考虑使用水平拆分了。</p><p>所谓水平拆分，就是把同一张表分为多张表结构相同的表，每张表里存储一部分数据。而拆分的算法也比较多，常见的就是取模、范围、和全局表等。</p><p>还是拿上面电商网站的例子，比如业务会考虑做一次活动，预计注册用户会暴涨。那么就应该考虑对用户表进行水平拆分了，如下图：</p><p><img src="2.png" alt="图片描述"></p><p>这里使用的是取模分片，用户 ID 对 3 取模，如果余数是 0，则数据存放在 userinfo01 库的 user 表中；如果余数是 1，则数据存放在 userinfo02 库的 user 表中；如果余数是 2，则数据存放在 userinfo03 库的 user 表中。</p><h2 id="哪些情况需要考虑分库分表？"><a href="#哪些情况需要考虑分库分表？" class="headerlink" title="哪些情况需要考虑分库分表？"></a>哪些情况需要考虑分库分表？</h2><p>都在提分库分表，那么哪些情况应该考虑分库分表呢？这里总结了几个需要考虑分库分表的场景：</p><h3 id="数据量过大，影响了运维操作"><a href="#数据量过大，影响了运维操作" class="headerlink" title="数据量过大，影响了运维操作"></a>数据量过大，影响了运维操作</h3><p>如果数据量比较大，其对数据库影响也会比较大，最常见的比如：影响备份、大表 DDL 导致主从长时间延迟等。下面仔细讲讲这两种情况：</p><p>备份：如果单张表或者单个实例数据量太大，那备份可能需要占用大量的 IO 和磁盘空间，并且持续时间还会比较久。曾经听说过有公司的单个实例的备份从凌晨持续到当天下午的情况，这种场景下，尽管在从库备份，如果开启了读写分离，对业务的影响也是比较大的。</p><p>DDL 导致主从长时间延迟：大表执行 DDL 不但会产生 MDL 写锁（MDL 的风险可以看前文），并且还会导致主从延迟。</p><blockquote><p><strong>直接执行大表 DDL，为什么会导致主从延迟？</strong></p><p>原因是主库执行完 DDL 后，才会写入到 binlog 里，然后传输到从库执行，而又因为从库 SQL 线程是单线程的，因此，需要等到这条 DDL 在从库执行完成，其他事务才能继续执行，而从库执行 DDL 这段时间，主从都是延迟的。</p></blockquote><h3 id="把修改频繁的字段拆分出来"><a href="#把修改频繁的字段拆分出来" class="headerlink" title="把修改频繁的字段拆分出来"></a>把修改频繁的字段拆分出来</h3><p>比如电商业务场景的用户表，这张表可能包含了用户唯一标识 ID，用户名，昵称，联系方式，性别，出生日期，注册时间，积分等等。这些字段中，其实也只有积分会变更的比较频繁，因此可以把积分字段独立出来，然后加上用户唯一标识 ID。这样，用户表的更新次数就大大降低了。</p><h3 id="把大字段拆分出去"><a href="#把大字段拆分出去" class="headerlink" title="把大字段拆分出去"></a>把大字段拆分出去</h3><p>比如电商业务的商品表，表里可能包含了商品的价格，生产日期，产地，供应商，商品详情和使用说明等。我们会发现商品详情和使用说明的字段特别大，可能字段类型需要配置成 text 或 blob，类似的字段占用的磁盘空间也是比较大。维护起来会比较麻烦，因此这种情况下，建议把这类大字段水平拆分出来。</p><h3 id="增长比较快的"><a href="#增长比较快的" class="headerlink" title="增长比较快的"></a>增长比较快的</h3><p>还是拿电商业务举例，比如订单表，如果预估未来增长速度会比较快，那么可以考虑提前对订单表进行分库分表。防止单表增长过快。</p><h3 id="降低不同库或者表的相互影响"><a href="#降低不同库或者表的相互影响" class="headerlink" title="降低不同库或者表的相互影响"></a>降低不同库或者表的相互影响</h3><p>电商业务会涉及多个模块，比如会员，订单，库存等。比如搞了一个活动，扫码送会员积分，如果会员相关的表和订单相关的表在一个库中，那么很可能会员的活动会影响到订单业务。因此可以考虑将这些模块对应的表拆分到不同的库中。避免不同业务表或者库的相互影响。</p><h2 id="分库分表的实现"><a href="#分库分表的实现" class="headerlink" title="分库分表的实现"></a>分库分表的实现</h2><h3 id="通过程序"><a href="#通过程序" class="headerlink" title="通过程序"></a>通过程序</h3><p>如我已经通过垂直拆分，将不同业务表放在不同的业务库中。这种情况，程序只要每个业务配置不同的 database 即可。</p><p>如果是水平拆分，业务可以通过程序实现，比如按照用户名首字母分，讲不同首字母的名字过来的请求放在不同的库中。</p><h3 id="通过数据库中间件"><a href="#通过数据库中间件" class="headerlink" title="通过数据库中间件"></a>通过数据库中间件</h3><p>目前比较常见的就是通过数据库中间件，比如 MyCAT。这种对业务程序来说就比较友好了，某个业务库，程序端只要连逻辑库，而后端是通过 MyCAT，将这一个逻辑库指向多个物理库。然后通过分片字段，决定数据应该放在哪个分片里。如本节 1.2 所讲的水平分割的示意图。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了 MySQL 分库分表。</p><p>一般情况下，MySQL 分库分表可以分为：</p><ul><li>垂直拆分。</li><li>水平拆分。</li></ul><p>在本节总结了需要考虑分库分表的场景：</p><ul><li>数据量过大。</li><li>某个字段更新过于频繁。</li><li>存在大字段。</li><li>表数据增长比较快。</li><li>不同库表之间性能相互影响了。</li></ul><p>最后介绍了两种分库分表的实现方式：</p><ul><li>通过程序。</li><li>通过数据库。</li></ul><blockquote><p>参考资料</p><p>《MySQL 运维内参》第 24 节：MySQL 分库分表</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读写分离注意问题</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%B3%A8%E6%84%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于高访问量的业务场景，MySQL 读写分离显得格外重要。</p><p>通常我们说的 MySQL 读写分离是指：对于修改操作在主库上执行，而对于查询操作，在从库上执行。主要目的是分担主库的压力。</p><p>但是读写分离有时也会存在问题，比如：主从延迟时，读取的从库数据不是最新的，对应的业务场景比如：</p><p>你网购的一个商品，付完款之后，因为主从延迟，第一时间还查询不到订单（查询的从库），即使等一段时间能看到订单，但是相信这种情况很多用户是不能接受的。</p><p>接下里就一起来讨论一下：读写分离需要注意哪些问题。</p><p>通常情况下，读写分离都是依赖主从复制，因此，我们先来看看主从复制的原理，也能方便我们理解为什么会出现主从延迟的现象。</p><h2 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h2><h3 id="MySQL-异步复制"><a href="#MySQL-异步复制" class="headerlink" title="MySQL 异步复制"></a>MySQL 异步复制</h3><p>传统的 MySQL 主从复制是异步的，因此也称为异步复制，MySQL 异步复制的原理如下：</p><ul><li>在主库开启 binlog 的情况下</li><li>如果主库有增删改的语句，会记录到 binlog 中</li><li>主库通过 IO 线程把 binlog 里面的内容传给从库的中继日志（relay log）中</li><li>主库给客户端返回 commit 成功（这里不会管从库是否已经收到了事务的 binlog）</li><li>从库的 SQL 线程负责读取它的 relay log 里的信息并应用到从库数据库中</li></ul><p>实现原理如下图：<br><img src="1.png" alt="图片描述"><br>在上图中，有一个地方不能忽视：</p><p><strong>在主库上并行运行的更新 SQL，由于从库只有单个 SQL 线程去消化 relay log，因此更新的 SQL 在从库只能串行执行。这也是很多情况下，会出现主从延迟的原因。</strong></p><p>当然，从 5.6 开始，MySQL 支持了每个库可以配置单独的 SQL 线程来消化 relay log，在 5.7 又增加了基于组提交的并行复制，大大改善了主从延迟的问题。</p><h3 id="MySQL-半同步复制"><a href="#MySQL-半同步复制" class="headerlink" title="MySQL 半同步复制"></a>MySQL 半同步复制</h3><p>在 MySQL 异步复制的基础上，又出现了一种改进的复制方式，称为：半同步复制。其原理如下：</p><ul><li>在主库开启 binlog 的情况下</li><li>如果主库有增删改的语句，会记录到 binlog 中</li><li>主库通过 IO 线程把 binlog 里面的内容传给从库的中继日志（relay log）中</li><li><strong>从库收到 binlog 后，发送给主库一个 ACK，表示收到了</strong></li><li><strong>主库收到这个 ACK 以后，才能给客户端返回 commit 成功</strong></li><li>从库的 SQL 线程负责读取它的 relay log 里的信息并应用到从库数据库中</li></ul><p>实现原理如下图：<br><img src="2.png" alt="图片描述">跟传统的异步复制相比，半同步复制保证了所有给客户端发送过确认提交的事务，从库都已经收到这个日志了。</p><h2 id="常见的读写分离方式"><a href="#常见的读写分离方式" class="headerlink" title="常见的读写分离方式"></a>常见的读写分离方式</h2><h3 id="通过程序"><a href="#通过程序" class="headerlink" title="通过程序"></a>通过程序</h3><p>开发通过配置程序来决定修改操作走主库，查询操作走从库。这种方式直连数据库，优点是性能会好点，缺点是配置麻烦。</p><p>但是需要注意的是：从库需要设置为 read_only，防止配置错误在从库写入了数据。</p><blockquote><p>这里提醒一点：</p><p>程序连接的用户建议不要给 super 权限，因为 super 权限的用户，即使整个库设置了 read_only ，也能写入数据。</p></blockquote><h3 id="2-2、通过中间件"><a href="#2-2、通过中间件" class="headerlink" title="2.2、通过中间件"></a>2.2、通过中间件</h3><p>通过中间件实现读写分离，目前算是一种主流的方式。拿 MyCAT 举例：</p><p>在 schema.xml 文件中，dataHost 标签 balance 属性的值，决定了是否启用读写分离。</p><p>balance 各个值及对应的读写方法如下：</p><ul><li>0：不开启读写分离，读操作发送到 writehost</li><li>1：全部的 readhost 与 stand by writehost 参与 select 语句的负载均衡</li><li>2：所有读操作都随机在 writehost、readhost上分发</li><li>3：所有读请求随机分发到 writerhost 对应的 readhost 执行，writehost 不负担读压力</li></ul><p>因此可以根据实际情况选择上面合适的读写分离策略。</p><h2 id="什么情况下会出现主从延迟"><a href="#什么情况下会出现主从延迟" class="headerlink" title="什么情况下会出现主从延迟"></a>什么情况下会出现主从延迟</h2><p>我们说到，对于读写分离场景，最大的问题就是：主从延迟。那么在哪些情况下会出现主从延迟呢？这里大致总结一下可能导致主从延迟的场景：</p><ul><li>大表 DDL</li><li>大事务</li><li>主库 DML 并发大</li><li>从库配置差</li><li>表上无主键</li><li>等等</li></ul><p>因此，如果存在读写分离的情况，应尽量避免上诉情况在业务高峰出现。</p><p>当然，我们不能完全杜绝主从延迟。因此再介绍几种读写分离场景下应对延迟的方法。</p><h2 id="读写分离怎样应对主从延迟"><a href="#读写分离怎样应对主从延迟" class="headerlink" title="读写分离怎样应对主从延迟"></a>读写分离怎样应对主从延迟</h2><p>读写分离场景应该怎样应对主从延迟呢？这里来讨论一下几种常见的应对主从延迟的方法：</p><h3 id="判断主从是否延迟"><a href="#判断主从是否延迟" class="headerlink" title="判断主从是否延迟"></a>判断主从是否延迟</h3><p>有些业务场景，如果所有请求都落在主库，主库压力会很大，但是在读写分离的情况，又不希望主从存在延迟的时候去读取从库。这种情况，就可以考虑查询时，先判断主从是否存在延迟，如果存在延迟，则查询落在主库，如果没延迟，则查询语句落在从库。</p><p>这里介绍几种判断主从延迟的方法：</p><p>第一种方法：判断 Seconds_Behind_Master 是否等于 0。</p><p>如果 Seconds_Behind_Master =0，则查询从库，如果大于 0，则查询主库。</p><blockquote><p>这里补充一下 Seconds_Behind_Master。</p><p>Seconds_Behind_Master 是在从库上执行 show slave status 时返回的其中一项，表示从库延迟的秒数。</p><p>其计算方法是：</p><p>从库服务器当前的时间戳与二进制日志中的事件的时间戳（在主库上的写入时间）相对比得到的。</p></blockquote><p>但是某些情况下，Seconds_Behind_Master 并不一定准确。比如网络中断时，Seconds_Behind_Master = 0 ，并不能代表主从无延迟。因此，有比这个更准确的一种方法：对比位点或 GTID。</p><p>第二种方法：对比位点或 GTID</p><p>如果 Master_Log_File 跟 Relay_Master_Log_File 相等，</p><p>并且 Read_Master_Log_Pos 跟 Exec_Master_Log_Pos 相等，</p><p>则可以把读请求放到从库，否则读请求放到主库。</p><blockquote><p><strong>补充一下上面几个参数的意义：</strong></p><p>几个参数均是通过 show slave status 返回的参数，用来查询主从复制的状态。</p><p>Master_Log_File：IO 线程正在读取的主库 binlog 文件名</p><p>Relay_Master_Log_File：SQL 线程最近执行的事务对应的主库 binlog 文件名</p><p>Read_Master_Log_Pos ：IO 线程正在读取的主库 binlog 文件中的位点</p><p>Exec_Master_Log_Pos ：SQL 线程最近读取和执行的事务对应的主库 binlog 文件中的位点</p></blockquote><p>如果开启了 GTID 复制，则可以对比 Retrieved_Gtid_Set 和 Executed_Gtid_Set 是否相等，相等则把读请求放到从库，有差异则读请求放到主库。</p><blockquote><p><strong>同样补充下两个参数的意义：</strong></p><p>前提是需要开启 GTID 两个参数才会有值，解释如下：</p><p>Retrieved_Gtid_Set：从库收到的所有日志的 GTID 集合</p><p>Executed_Gtid_Set：从库已经执行完的 GTID 集合</p></blockquote><h3 id="采用半同步复制"><a href="#采用半同步复制" class="headerlink" title="采用半同步复制"></a>采用半同步复制</h3><p>在本节的前面，我们讲解了半同步复制的原理，跟传统的异步复制相比，半同步复制保证了所有给客户端发送过确认提交的事务，从库都已经收到这个日志了。因此出现延迟的概率会小很多，当然实际生产应用时，建议结合上面讲的位点或 GTID 判断。</p><h3 id="等待同步完成"><a href="#等待同步完成" class="headerlink" title="等待同步完成"></a>等待同步完成</h3><p>依然采用 4.1 中介绍的几种判断是否有延迟的方法，只是应对方式不一样，比如存在延迟，则将情况反馈给程序，在前端页面提醒用户数据未完全同步，如果没有延迟，则查询从库。</p><p>有人可能会觉得：这种方式谁会用啊？实际可以应用在内部人员看的报表业务上。因为报表可能涉及的 SQL 都比较复杂，存在延迟就考虑去查询主库，可能会对其它线上业务有影响，因此可以等待从库同步完成，再查询从库。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲了读写分离，由于能分担主库的压力，很多情况会考虑读写分离。但是在使用时，就应该考虑到一些问题，其中最主要的就是主从延迟。</p><p>这个就看业务是否能接受延迟了。</p><p>如果不能接受延迟，建议采用半同步复制并且加上延迟判断。存在延迟则把读请求放到主库，没延迟就读从库。</p><p>如果业务能接受延迟，可以等数据同步完成，再去从库进行查询。</p><blockquote><p>参考资料</p><p>《MyCAT 权威指南》第 1 版：6.6.4 balance 属性</p><p>《MySQL 5.7 官方手册》 14.7.5.34 SHOW SLAVE STATUS Syntax</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的QC</title>
      <link href="/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84QC/"/>
      <url>/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84QC/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从 MySQL 4.1 开始，增加了查询缓存（Query Cache，简称 QC）的功能，它会存储 select 语句的文本以及发送到客户端的结果。如果下一次收到一个相同的查询，就会从查询缓存中获得查询结果。</p><blockquote><p>关于 QC 的详细定义，可以查询 <a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="noopener">MySQL 5.7 官方手册</a></p></blockquote><p>那么是不是只要开启查询缓存就能提升查询速度呢？今天就一起探讨这一话题。</p><h2 id="认识-QC"><a href="#认识-QC" class="headerlink" title="认识 QC"></a>认识 QC</h2><p>QC 需要缓存最新数据结果，因此表数据发生任何变化（insert、update、delete 等操作时），都会导致 QC 被刷新。</p><p>查询缓存相关的参数主要有：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">"%query_cache%"</span>;</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="图片描述"></p><blockquote><p><strong>这里解释一下上面几个参数</strong></p><p>have_query_cache：服务器在安装时是否已经配置了高速缓存<br>query_cache_limit：单条查询能够使用的缓存区大小<br>query_cache_min_res_unit：查询缓存分配内存块的最小单位<br>query_cache_size：缓存区的大小，单位为 MB<br>query_cache_type：缓存类型，有三个值可选：</p><ul><li>0 或者 off：关闭缓存</li><li>1 或者 on：打开缓存</li><li>2 或者 demand：只缓存带有 sql_cache 的 select 语句。</li></ul><p>query_cache_wlock_invalidate：如果某个数据表被其它的连接锁住，是否仍然从查询缓存中返回结果</p></blockquote><p>通过下面命令，可以监视查询缓存的使用情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">"qcache%"</span>;</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="图片描述"></p><blockquote><p><strong>这里解释一下各个参数的意义</strong></p><p>Qcache_free_blocks：查询缓存中的空闲内存块的数目</p><p>Qcache_free_memory：查询缓存的空闲内存总数</p><p>Qcache_hits：缓存命中次数</p><p>Qcache_inserts：被加入到缓存中的查询数目</p><p>Qcache_lowmem_prunes：因为缺少内存而从缓存中删除的查询数目</p><p>Qcache_not_cached：没有被缓存的查询数目</p><p>Qcache_queries_in_cache：在缓存中已注册的查询数目</p><p>Qcache_total_blocks：查询缓存中的块的总数目</p></blockquote><h2 id="QC-的优劣"><a href="#QC-的优劣" class="headerlink" title="QC 的优劣"></a>QC 的优劣</h2><p>在讲到底要不要开启 QC 之前，我们先聊聊 QC 的优劣。</p><p>QC 优势：</p><ul><li>提高查询速度：使用查询缓存在单行数据的表中搜索要比不使用查询缓存快 238%（数据来源：<a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="noopener">MySQL 5.7 官方手册</a>）。</li></ul><p>劣势：</p><ul><li>比如执行的 SQL 都很简单（比如从只有一行的表中查询数据），但每次查询都不一样的话，打开 QC 后，额外的开销为 13% 左右；</li><li>如果表数据发生了修改，使用该表的所有缓存查询都将实效，并且从缓存中删除；</li><li>QC 要求前后两次请求的 SQL 完全一样，不同数据库、不同协议版本或不同默认字符集的查询，都会被认为是不同的查询。甚至包括大小写，比如下面两条 SQL ，查询缓存就会认为是两个不同的查询：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> tbl_name</span><br></pre></td></tr></table></figure><ul><li>每次更新 QC 的内存块都需要进行锁定；</li><li>可能会导致 SQL 查询时间不稳定，比如<a href="https://www.percona.com/blog/2012/09/05/write-contentions-on-the-query-cache/" target="_blank" rel="noopener">这个例子</a>。</li></ul><h2 id="是否需要开启-QC"><a href="#是否需要开启-QC" class="headerlink" title="是否需要开启 QC"></a>是否需要开启 QC</h2><p>通过上面讲解的 QC 优劣，对于是否需要开启 QC 这个问题，我们大概能总结出：</p><p>如果线上环境中 99% 以上都是只读，很少更新，可以考虑全局开启 QC，也就是设置 query_cache_type 为 1。</p><p>很多时候，我们希望缓存的是几张更新频率很低的表，其它表不考虑使用查询缓存，就可以考虑将 query_cache_type 设置成 2 或者 DEMAND，这样就只缓存下面这类 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sql_cache</span> ......;</span><br></pre></td></tr></table></figure><p>结合前面讲的 QC 的劣势，其它情况就不建议开启 QC 了。</p><h2 id="4-怎样开启和关闭-QC"><a href="#4-怎样开启和关闭-QC" class="headerlink" title="4 怎样开启和关闭 QC"></a>4 怎样开启和关闭 QC</h2><p>全局开启 QC：</p><p>在配置文件 my.cnf 中设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type = 1</span><br><span class="line">query_cache_size = 50M</span><br></pre></td></tr></table></figure><p>只开启部分表的 QC：</p><p>在配置文件 my.cnf 中设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type = 2</span><br><span class="line">query_cache_size = 50M</span><br></pre></td></tr></table></figure><p>前面也提到了，这种情况，如果要使用 QC，查询语句需要加上 select sql_cache。</p><p>关闭 QC：</p><p>在配置文件 my.cnf 中设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type = 0</span><br><span class="line">query_cache_size = 0</span><br></pre></td></tr></table></figure><p>或者源码编译安装 MySQL 的话，编译时增加参数 —without-query-cache 即可。</p><h2 id="开启-QC-的注意事项"><a href="#开启-QC-的注意事项" class="headerlink" title="开启 QC 的注意事项"></a>开启 QC 的注意事项</h2><p>如果要开启 QC，建议不要设置过大，通常几十兆就好。如果设置过大，会增加维护缓存所需要的开销。</p><p>另外要注意一些即使开启 QC 也不能使用 QC 的场景（这里参考的是 MySQL 5.7 官方手册第 8.10.3.1 节： <a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-operation.html" target="_blank" rel="noopener">How the Query Cache Operates</a> ）：</p><ul><li>分区表不支持，如果涉及分区表的查询，将自动禁用查询缓存</li><li>子查询或者外层查询</li><li>存储过程、触发器中使用的 SQL</li><li>读取系统库时</li><li>类似下面 SQL 时：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><ul><li>用到临时表</li><li>产生了 warning 的查询</li><li>显示增加了 SQL_NO_CACHE 关键字的</li><li>如果没有全部库、表的 select 权限，则也不会使用 QC</li><li>使用了一些函数：比如 now ()，user ()，password () 等</li></ul><p>了解上面的场景，我们就能知道：开了查询缓存，前后 SQL 一模一样，为什么后面这一次执行也使用不了缓存的原因了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查询环境会存储 select 语句的文本以及发送到客户端的结果。</p><p>如果使用查询缓存在单行数据的表中搜索要比不使用查询缓存快 238%。</p><p>如果线上环境中 99% 以上都是只读，很少更新，可以考虑全局开启 QC。如果希望缓存的是几张更新频率很低的表，其它表不考虑使用查询缓存，就可以考虑将 query_cache_type 设置成 2，这些需要使用查询缓存的表，使用时加上 select sql_cache 即可。</p><p>但是考虑到 QC 存在下面这些缺点，因此，其它情况就不建议开启 QC 了。</p><ul><li>每次查询不一样，会额外增加开销</li><li>需要前后两条 SQL 完全一样才能使用</li><li>只要存在更新，就会清空这张表的查询缓存</li><li>等等</li></ul><p>当然开启 QC 的情况下，部分查询是无法走 QC 的，需要留意到这些场景。</p><blockquote><p>参考资料</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/query-cache.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-operation.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/query-cache-operation.html</a></p><p><a href="https://www.percona.com/blog/2012/09/05/write-contentions-on-the-query-cache/" target="_blank" rel="noopener">https://www.percona.com/blog/2012/09/05/write-contentions-on-the-query-cache/</a></p><p>《深入浅出 MySQL》第 2 版：23.2.2 使用查询缓存}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置自增主键的好处</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%A5%BD%E5%A4%84/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>mysql默认都带有一个id的自增主键，这么做的原因是神马，今天研究一下。</p><h2 id="关于自增主键"><a href="#关于自增主键" class="headerlink" title="关于自增主键"></a>关于自增主键</h2><p>当我们创建表时，可以定义主键为自增的，具体方法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t25`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`b`</span> <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>空表情况下，我们不指定 id 字段写入数据时，id 字段会自动获取到值 1，如下：</p><p>首先写入一条数据，没指定 id 的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t25(a,b) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'hi'</span>);</span><br></pre></td></tr></table></figure><p>再进行查询时，发现 id 字段自动获取到值 1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t25;</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="图片描述"><br>这里我们查询一下表 t25 的表结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t25;</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="图片描述"><br>发现表结构中包含 AUTO_INCREMENT=2，在下一次执行未指定 id 字段的 insert 语句时， 主键 id 会自动获取到这个值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t25(a,b) <span class="keyword">values</span> (<span class="number">2</span>,<span class="string">'ha'</span>);</span><br></pre></td></tr></table></figure><p>select * from t25;<br><img src="3.png" alt="图片描述"><br>发现新写入的数据 id 自动获取到 2 这个值。也就是，如果不指定，则会写入当前最大 ID 加 1 的值。</p><h2 id="主键和聚集索引的关系"><a href="#主键和聚集索引的关系" class="headerlink" title="主键和聚集索引的关系"></a>主键和聚集索引的关系</h2><p>很多同学会把主键和聚集索引弄混，这里先简单聊聊它们的区别：</p><ul><li>在 InnoDB 中，聚集索引不一定是主键，但是主键一定是聚集索引：原因是如果没有定义主键，聚集索引可能是第一个不允许为 null 的唯一索引，如果也没有这样的唯一索引，InnoDB 会选择内置 6 字节长的 ROWID 作为隐含的聚集索引。</li><li>我们知道 InnoDB 的数据是按照主键顺序存放的，而聚集索引就是按照每张表的主键构造一颗 B+ 树，它的叶子节点存放的是整行数据。</li><li>每张 InnoDB 表都有一个聚集索引，但是不一定有主键。</li></ul><h2 id="主键是否需要设置为自增"><a href="#主键是否需要设置为自增" class="headerlink" title="主键是否需要设置为自增"></a>主键是否需要设置为自增</h2><p>现在来讨论本节的重点：主键是否需要设置为自增？</p><p>通过上面的学习，我们知道了聚集索引是按照每张表的主键构造一颗 B+ 树的，而 B+ 树中，所有记录节点都是按键值的大小顺序存放在同一层叶子节点上。</p><p>如果每次插入的数据都是在聚集索引树的后面，聚集索引不需要分裂就可以存入数据。</p><p>但是如果插入的数据值在聚集索引树的中间部分，由于要保证插入后叶子节点中的记录依然排序，就可能需要聚集索引树分裂来保证键值的有序性。如下（这里省略了叶子节点之间的指针）：<br><img src="4.png" alt="图片描述"><br>如上图，Leaf Page（叶子节点数据页)已经满的情况下，如果写入的值是聚集索引树的中间部分，则会进行一次页分裂，以保证叶子节点上的记录有序和 B+ 树的平衡。并且分裂后，有些数据页没被用满，导致页空间浪费。</p><p><strong>因此如果业务输入的主键都是随机数字，那么写入数据时很可能会导致数据页频繁分裂，从而影响写入效率。</strong></p><p><strong>而如果设置主键是自增，那么每一次都是在聚集索引的最后增加，当一页写满，就会自动开辟一个新页，不会有聚集索引树分裂这一步，效率会比随机主键高很多。这也是很多建表规范要求主键自增的原因。</strong></p><blockquote><p>经验分享：</p><p>除了要求主键自增外，最好主键也要无业务意义，原因是防止主键更新而导致页分裂的情况。</p></blockquote><p>当然也不是所有的情况主键都需要设置为自增，比如可以用程序写入增长的主键值，保证了新写入数据的主键值比之前大，也可以避免聚集索引树频繁分裂。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讨论了自增主键的使用方式，并讲解了主键与聚集索引的关系。</p><p>通过本节学习，<strong>如果主键是随机的，那么写入数据时很可能会导致数据页频繁分裂，从而导致写入效率低和页空间浪费。</strong></p><p><strong>而如果设置主键是自增，那么每一次都是在聚集索引的最后增加，当一页写满，就会自动开辟一个新页，不会有聚集索引树分裂这一步，效率会比随机主键高很多。</strong></p><p>当然也不是所有的表都需要设置为自增，如果通过业务逻辑给到表主键的值是增长的（不一定连续），保证了新写入数据的主键值比之前大，也可以避免聚集索引树频繁分裂。这种方式也是可以选择的。</p><blockquote><p>参考资料</p><p>《MySQL 技术内幕：InnoDB 存储引擎》第 2 版 5.3.1 B+ 树的插入操作 和 5.4.3 B+ 树索引的分裂</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入攻击和预防</title>
      <link href="/2022/07/19/mysql-2022-07-19-sql%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%92%8C%E9%A2%84%E9%98%B2/"/>
      <url>/2022/07/19/mysql-2022-07-19-sql%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%92%8C%E9%A2%84%E9%98%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多时候，我们关心的是程序是否能实现我们的预期功能，而忽视了 SQL 安全，这就存在 SQL 注入的风险，本节就一起来聊聊 SQL 注入及防御。</p><h2 id="认识-SQL-注入"><a href="#认识-SQL-注入" class="headerlink" title="认识 SQL 注入"></a>认识 SQL 注入</h2><p>SQL 注入是利用某些数据库的外部接口将用户数据插入到实际的数据库操作语句中，从而达到入侵数据库乃至操作系统的目的。</p><p>SQL 注入产生的主要原因是：程序对用户输入的数据没有进行严格的过滤，导致非法数据库查询语句的执行。</p><p>SQL 注入具有很大的危害，可能会导致攻击者非法入侵系统，或者盗取数据，甚至清空数据等。</p><h2 id="如何进行-SQL-注入攻击"><a href="#如何进行-SQL-注入攻击" class="headerlink" title="如何进行 SQL 注入攻击"></a>如何进行 SQL 注入攻击</h2><p>为了方便理解 SQL 注入，我们来用实验模拟一下 SQL 注入攻击。</p><p>我们模拟一个用户登录验证的场景，首先创建用户表，并录入几个用户，语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists t24;</span><br><span class="line">CREATE TABLE &#96;t24&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;username&#96; varchar(20) DEFAULT NULL,</span><br><span class="line">  &#96;password&#96; varchar(20) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB CHARSET&#x3D;utf8mb4;</span><br><span class="line"></span><br><span class="line">insert into t24(username,password) values (&#39;mt&#39;,&#39;aaa&#39;),(&#39;gg&#39;,&#39;bbb&#39;),(&#39;mm&#39;,&#39;ccc&#39;);</span><br></pre></td></tr></table></figure><p>验证用户登录的 PHP 代码（PHP 版本：7.0.33）：</p><p>文件名：index.php</p><p>内容如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername=<span class="string">"127.0.0.1"</span>;</span><br><span class="line">$dbuser=<span class="string">"muke_user"</span>;</span><br><span class="line">$dbpassword=<span class="string">"9Gcag71Gaa"</span>;</span><br><span class="line">$dbname=<span class="string">"muke"</span>;</span><br><span class="line"></span><br><span class="line">$mysqli = <span class="keyword">new</span> mysqli($servername,$dbuser,$dbpassword,$dbname); <span class="comment">//配置MySQL连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($mysqli-&gt;connect_error)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'connect error:'</span>.$mysqli-&gt;connect_errno);</span><br><span class="line">&#125;</span><br><span class="line">$mysqli-&gt;set_charset(<span class="string">'UTF-8'</span>); <span class="comment">// 设置数据库字符集</span></span><br><span class="line">$username = <span class="keyword">isset</span>($_GET[<span class="string">'username'</span>]) ? $_GET[<span class="string">'username'</span>] : <span class="string">''</span>;</span><br><span class="line">$password = <span class="keyword">isset</span>($_GET[<span class="string">'password'</span>]) ? $_GET[<span class="string">'password'</span>] : <span class="string">''</span>;</span><br><span class="line">$sql = <span class="string">"select * from t24 where username='$username' and password= '$password'"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$sql&lt;br/&gt;"</span>;</span><br><span class="line">$result = $mysqli-&gt;query(<span class="string">"$sql"</span>);</span><br><span class="line"></span><br><span class="line">$data = $result-&gt;fetch_all(); <span class="comment">// 从结果集中获取所有数据</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($data))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"登录失败"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"登录成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">print_r($data);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>正常情况下，我们提交如下 URL，如果用户名密码正确的话，就可以使用 mt 这个用户登录系统了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=aaa</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887cb0001b39908610178.png" alt="图片描述"></p><p>如果不知道密码情况下乱输入一个密码，将无法登录通过验证：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=abc</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887be00014eb008600184.png" alt="图片描述"></p><p>但是可以通过 SQL 注入的方式，让攻击者不知道密码的情况也可以通过验证，如下：</p><p>把 URL 改成：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt' or '1=1</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887af0001c0c709390182.png" alt="图片描述"><br>显然我们不希望能通过这种方式登录系统，这就是一个 SQL 注入的例子。</p><p>这个例子中，甚至可以通过 SQL 注入捞取到所有用户信息，如下 URL：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=aaa' or username&lt;&gt;'mt</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d88879c0001313a17420198.png" alt="图片描述"><br>从上面截图中可以看到，URL 获取到表里所有用户的信息了。如果是生产环境，用户表有这种漏洞，可想而知他的危害有多大。</p><h2 id="如何预防-SQL-注入"><a href="#如何预防-SQL-注入" class="headerlink" title="如何预防 SQL 注入"></a>如何预防 SQL 注入</h2><h3 id="控制输入变量的格式"><a href="#控制输入变量的格式" class="headerlink" title="控制输入变量的格式"></a>控制输入变量的格式</h3><p>如上面例子中的 PHP 代码，可以优化成如下效果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername=<span class="string">"127.0.0.1"</span>;</span><br><span class="line">$dbuser=<span class="string">"muke_user"</span>;</span><br><span class="line">$dbpassword=<span class="string">"9Gcag71Gaa"</span>;</span><br><span class="line">$dbname=<span class="string">"muke"</span>;</span><br><span class="line"></span><br><span class="line">$mysqli = <span class="keyword">new</span> mysqli($servername,$dbuser,$dbpassword,$dbname); <span class="comment">//配置MySQL连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($mysqli-&gt;connect_error)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'connect error:'</span>.$mysqli-&gt;connect_errno);</span><br><span class="line">&#125;</span><br><span class="line">$mysqli-&gt;set_charset(<span class="string">'UTF-8'</span>); <span class="comment">// 设置数据库字符集</span></span><br><span class="line">$username = <span class="keyword">isset</span>($_GET[<span class="string">'username'</span>]) ? $_GET[<span class="string">'username'</span>] : <span class="string">''</span>;</span><br><span class="line">$password = <span class="keyword">isset</span>($_GET[<span class="string">'password'</span>]) ? $_GET[<span class="string">'password'</span>] : <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加对输入用户名密码的判断，如果不是字母或者数字，就直接提示格式错误而退出。</span></span><br><span class="line"><span class="keyword">if</span>( !preg_match(<span class="string">"/^[a-zA-Z0-9]&#123;1,&#125;$/"</span>,$username) || !preg_match(<span class="string">"/^[a-zA-Z0-9]&#123;1,&#125;$/"</span>,$password) ) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">"You input username and password  format error "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"select * from t24 where username='$username' and password= '$password'"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$sql&lt;br/&gt;"</span>;</span><br><span class="line">$result = $mysqli-&gt;query(<span class="string">"$sql"</span>);</span><br><span class="line"></span><br><span class="line">$data = $result-&gt;fetch_all(); <span class="comment">// 从结果集中获取所有数据</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($data))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"登录失败"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"登录成功"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">print_r($data);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>增加了对输入信息的判断，过滤掉一些带特殊字符的输入，我们再验证一下是否还会出现上面我们测试的 SQL 注入情况：</p><p>首先看这个 URL：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt' or '1=1</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d88876a0001d7f309240113.png" alt="图片描述"><br>发现会提示输入格式有问题，无法登录系统。</p><p>在看下上面能获取整张用户表数据的 SQL 注入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=aaa' or username&lt;&gt;'mt</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887590001e63712140133.png" alt="图片描述"></p><p>发现同样提示输入格式有问题，无法查询到任何数据。</p><h3 id="转义特殊字符"><a href="#转义特殊字符" class="headerlink" title="转义特殊字符"></a>转义特殊字符</h3><p>有时，我们程序是允许输入信息带特殊字符的，这种情况就可以使用转义的方式，防止 SQL 注入。</p><p>我们来实验下，在原始代码中，修改定义 sql 这一行为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql = <span class="string">"select * from t24 where username='"</span> . addslashes($username) . <span class="string">"' and password= '"</span> . addslashes($password) . <span class="string">"'"</span>;</span><br></pre></td></tr></table></figure><p>我们再输入前面会导致 SQL 注入的 URL：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt' or '1=1</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d8887420001ee7f09300195.png" alt="图片描述"></p><p>将传输的变量转义后，避免了 SQL 注入，发现登录失败。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.16.4.15/index.php?username=mt&amp;password=aaa' or username&lt;&gt;'mt</span><br></pre></td></tr></table></figure><p><img src="https://img.mukewang.com/5d88872d0001a28912040188.png" alt="图片描述"><br>转义后，无法查询到整张用户表的信息了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了 SQL 注入。</p><p>产生的原因：程序对用户输入的数据没有进行严格的过滤，导致攻击者增加一些特殊字符，从而改变传输到 MySQL 中的 SQL。</p><p>SQL 注入危害：会导致攻击者非法入侵系统，或者盗取数据，甚至清空数据等。</p><p>本节讲解了 SQL 注入攻击的方法，目的是让我们能认识到会导致 SQL 注入的一些漏洞，从而优化我们的代码，比如控制输入变量的格式或者转义特殊字符，从而避免程序被 SQL 注入。</p><blockquote><p>参考资料</p><p>《深入浅出 MySQL》第 2 版 第 15 章 SQL 中的安全问题</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的分布式事务</title>
      <link href="/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/07/19/mysql-2022-07-19-mysql%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天我们看一下mysql提供的分布式事务，有关分布式事务的更多详细解释以及更多的解决方案，可以看博客的其它文章。</p><h2 id="认识分布式事务"><a href="#认识分布式事务" class="headerlink" title="认识分布式事务"></a>认识分布式事务</h2><p>分布式事务是指一个大的事务由很多小操作组成，小操作分布在不同的服务器上或者不同的应用程序上。分布式事务需要保证这些小操作要么全部成功，要么全部失败。MySQL 从 5.0.3 开始支持分布式事务。</p><p>分布式事务使用两阶段提交协议：</p><ul><li>第一阶段：所有分支事务都开始准备，告诉事务管理器自己已经准备好了；</li><li>第二阶段：确定是 rollback 还是 commit，如果有一个节点不能提交，则所有节点都要回滚。</li></ul><p>与本地事务不同点在于：分布式事务需要多一次 prepare 操作，等收到所有节点的确定信息后，再进行 commit 或者 rollback。</p><p>上面买书的例子，就可以放到一个分布式事务里，保证增加订单和减库存操作有原子性，要么全部成功，要么全部失败。</p><p>MySQL 中分布式事务按实现方式可以分为两种：MySQL 自带的分布式事务和结合中间件实现分布式事务。下面来详细介绍一下这两种分布式事务。</p><h2 id="MySQL-自带的分布式事务"><a href="#MySQL-自带的分布式事务" class="headerlink" title="MySQL 自带的分布式事务"></a>MySQL 自带的分布式事务</h2><p>MySQL 有自带的分布式事务实现方法，具体语法如下：</p><p>启动分支事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">start</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>‘a’,‘a_1’ 表示 xid，</p><p>a 表示 gtrid，为分布式事务标识符，相同的分布式事务使用相同的 gtrid。</p><p>a_1 表示 bqual，为分支限定符，分布式事务中的每一个分支事务的 bqual 必须不同。</p></blockquote><p>结束分支事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">end</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><p>进入准备状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">prepare</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><p>提交分支事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">commit</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><p>回滚分支事务：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa <span class="keyword">rollback</span> <span class="string">'a'</span>,<span class="string">'a_1'</span>;</span><br></pre></td></tr></table></figure><p>返回当前数据库中处于 prepare 状态的分支事务的详细信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xa recover;</span><br></pre></td></tr></table></figure><p>我们来看一个具体例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">use muke1;</td><td style="text-align:left">use muke2;</td></tr><tr><td style="text-align:left">create table t23_1(id int);</td><td style="text-align:left">create table t23_2(id int);</td></tr><tr><td style="text-align:left">xa start ‘test’,‘muke1’;</td><td style="text-align:left">xa start ‘test’,‘muke2’;</td></tr><tr><td style="text-align:left">insert into t23_1 select 1;</td><td style="text-align:left">insert into t23_2 select 1;</td></tr><tr><td style="text-align:left">xa end ‘test’,‘muke1’;</td><td style="text-align:left">xa end ‘test’,‘muke2’;</td></tr><tr><td style="text-align:left">xa prepare ‘test’,‘muke1’;</td><td style="text-align:left">xa prepare ‘test’,‘muke2’;</td></tr><tr><td style="text-align:left">xa recover \G</td><td style="text-align:left">xa recover \G</td></tr><tr><td style="text-align:left">xa commit ‘test’,‘muke1’;</td><td style="text-align:left">xa commit ‘test’,‘muke2’;</td></tr></tbody></table></div><p>上面的例子就演示了一个分布式事务，事务在 muke1 库中的 t23_1 表中插入一条记录，同时在 muke2 库中的 t23_2 表中插入一条记录，两个操作作为同一个事务提交。在进入准备状态之前，如果 session2 中某一步没执行成功而回滚了，则 session1 和 session2 整个分布式事务的操作都会回滚。</p><p>但是 MySQL 5.7 之前的版本，自带的分布式事务存在以下问题：</p><p>比如某个分支事务到达 prepare 状态时，此时数据库断电，重启后，可以继续对分支事务进行提交或者回滚，但是提交的事务不会写 binlog，如果有从库，会导致主从数据不一致的情况。</p><p>如果分支事务的客户端连接异常中止，那么数据库会自动回滚当前分支未完成的事务，如果此时分支事务已经到 prepare 状态，那么这个分布式事务的其他分支可能已经成功提交，如果这个分支回滚，可能导致分布式事务的不完整，丢失部分分支事务的内容。</p><p>还有一种情况，如果分支事务在执行到 prepare 状态时，数据库出现故障，并且无法启动，需要使用全备和 binlog 来恢复数据，那么这些在 prepare 状态的分支事务因为没有记录到 binlog，所以也不能通过binlog 进行恢复，在数据库恢复后，将丢失这部分数据。</p><p>所以，MySQL 5.7 之前的版本自带的分布式事务还存在比较严重的缺陷，在有些场景下，会导致数据丢失。如果业务对数据完整性要求不改，可以考虑使用，如果对数据完整性要求比较高，需要考虑先升级到 5.7 版本。</p><h2 id="结合中间件实现分布式"><a href="#结合中间件实现分布式" class="headerlink" title="结合中间件实现分布式"></a>结合中间件实现分布式</h2><p>上面说了 MySQL 自带的分布式事务，这里再介绍一下借助中间件实现分布式的情况。</p><p>具体实现方式可以拿上面网上购书的例子来说：</p><p>订单业务程序处理完增加订单的操作后，将减库存操作发送到消息队列中间件中（比如：Rocketmq），订单业务程序完成提交。然后库存业务程序检查到消息队列有减对应商品库存的信息，就开始执行减库存操作。库存业务执行完减库存操作，再发送一条消息给消息队列中间件：内容是已经减掉库存。具体步骤如下：<br><img src="/Users/james/blogs/blog/source/_posts/2022-07-19-mysql的分布式事务/1.png" alt="图片描述"><br>当然，为了确定最终已经完成减库存操作，还可以加一步对数据库中该商品库存的判断。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了分布式事务，所谓分布式事务，是指一个大的事务由很多小操作组成，小操作分布在不同的服务器上或者不同的应用程序上。分布式事务需要保证这些小操作要么全部成功，要么全部失败。</p><p>本节讲解了两种分布式方式：</p><ul><li>MySQL 自带的分布式事务</li><li>结合中间件实现分布式</li></ul><p>当然，目前主流的分布式实现还是结合中间件实现分布式处理的，本节也举例说明了使用 MQ 实现分布式的例子。</p><blockquote><p>参考资料</p><p>《高性能 MySQL》第 3 版 7.11 分布式（XA）事务</p><p>《深入浅出 MySQL》第 2 版 14.3 分布式事务的使用</p><p>《MySQL 技术内幕：InnoDB存储引擎》第 2 版 7.7 分布式事务)</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>有关事务的使用习惯</title>
      <link href="/2022/07/19/mysql-2022-07-19-%E6%9C%89%E5%85%B3%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%A0%E6%83%AF/"/>
      <url>/2022/07/19/mysql-2022-07-19-%E6%9C%89%E5%85%B3%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%A0%E6%83%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时好的事务习惯也影响着业务访问速度。接下来我们看一下事务的使用习惯。</p><p>我们先来看看一些不好的事务习惯：</p><h2 id="不好的事务习惯"><a href="#不好的事务习惯" class="headerlink" title="不好的事务习惯"></a>不好的事务习惯</h2><h3 id="在循环中提交"><a href="#在循环中提交" class="headerlink" title="在循环中提交"></a>在循环中提交</h3><p>在大多数情况下，MySQL 都是开启自动提交的，如果遇到循环执行 SQL，则相当于每个循环中都会进行一次提交，实际这算一个不好的事务习惯了。下面我创建一张测试表，并定义两个循环写入数据的存储过程：一个是自动提交，另一个是在循环前开启一个事务，在循环后一次性提交。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke; <span class="comment">/* 使用muke这个database */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t22; <span class="comment">/* 如果表t22存在则删除表t22 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t22`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_a`</span> (<span class="string">`a`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_b`</span> (<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> <span class="keyword">if</span> <span class="keyword">exists</span> insert_t22_1; <span class="comment">/* 如果存在存储过程insert_t22_1，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t22_1() <span class="comment">/* 创建存储过程insert_t22_1 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="built_in">int</span>; <span class="comment">/* 声明变量i */</span></span><br><span class="line"><span class="keyword">set</span> i=<span class="number">1</span>; <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line">while(i&lt;=10000)do /* 对满足i&lt;=10000的值进行while循环 */</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t22(a,b,c,d) <span class="keyword">values</span>(i,i,i,i); <span class="comment">/* 写入表t22中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line"><span class="keyword">set</span> i=i+<span class="number">1</span>; <span class="comment">/* 将i加1 */</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ; <span class="comment">/* 创建批量写入10000条数据到表t22的存储过程insert_t22_1 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> <span class="keyword">if</span> <span class="keyword">exists</span> insert_t22_2; <span class="comment">/* 如果存在存储过程insert_t22_2，则删除 */</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_t22_2() <span class="comment">/* 创建存储过程insert_t22_2 */</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> i <span class="built_in">int</span>; <span class="comment">/* 声明变量i */</span></span><br><span class="line"><span class="keyword">set</span> i=<span class="number">1</span>; <span class="comment">/* 设置i的初始值为1 */</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">while(i&lt;=10000)do /* 对满足i&lt;=10000的值进行while循环 */</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t22(a,b,c,d) <span class="keyword">values</span>(i,i,i,i); <span class="comment">/* 写入表t22中a、b两个字段，值都为i当前的值 */</span></span><br><span class="line"><span class="keyword">set</span> i=i+<span class="number">1</span>; <span class="comment">/* 将i加1 */</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ; <span class="comment">/* 创建批量写入10000条数据到表t22的存储过程insert_t22_2 */</span></span><br></pre></td></tr></table></figure><p>我们来对比两个存储过程的速度：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> insert_t22_1(); <span class="comment">/* 运行存储过程insert_t22_1 */</span></span><br></pre></td></tr></table></figure><p><img src="/Users/james/blogs/blog/source/_posts/2022-07-19-有关事务的使用习惯/1.png" alt="图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> insert_t22_2(); <span class="comment">/* 运行存储过程insert_t22_2 */</span></span><br></pre></td></tr></table></figure><p><img src="/Users/james/blogs/blog/source/_posts/2022-07-19-有关事务的使用习惯/2.png" alt="图片描述">明显第二种方式快的多。因为 insert_t22_1 每一次提交都要写一次重做日志，实际写了 10000 次重做日志，而存储过程 insert_t22_2 只写了 1 次重做日志。</p><p>因此，在类似这种循环写入的情况，如果循环次数不是太多，建议在循环前开启一个事务，循环结束后统一提交。</p><h3 id="不关注同一个事务里语句顺序"><a href="#不关注同一个事务里语句顺序" class="headerlink" title="不关注同一个事务里语句顺序"></a>不关注同一个事务里语句顺序</h3><p>比如 A 在超市购买 100 元的商品，付款操作可以简化为：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">操作</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">A 的账户中扣除 100</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">超市的账户增加 100</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">在超市系统中记录一条日志</td></tr></tbody></table></div><p>很多时候我们会按上面的 SQL 步骤放入一个事务里执行，不关注里面语句的顺序。实际可以优化的。</p><p>根据两阶段锁，整个事务里面涉及的锁，需要等到事务提交时才会释放。因此我们在<strong>同一个事务中，可以把没锁或者锁范围小的语句放在事务前面执行，而锁定范围大的语句放在后面执行。</strong></p><blockquote><p>这里来回顾一下第 16 节中提到的两阶段锁：锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。在执行语句的时候加上锁，但并不是语句执行完就立刻释放锁，而是要等到事务结束时才释放。</p></blockquote><p>因此上面 A 购买商品的例子中，可能很多人同时在超市付款，那么存在锁竞争的最可能是超市账户增加 100 元的操作。</p><p>那么付款操作可以这么优化：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">操作</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">在超市系统中记录一条日志</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">A 的账户中扣除 100</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">超市的账户增加 100</td></tr></tbody></table></div><p>把可能存在锁竞争的操作放在最后执行，从而优化整个事务。</p><p>因此在写程序时，应该去关注事务里的语句顺序。</p><h3 id="不关注不同事务访问资源的顺序"><a href="#不关注不同事务访问资源的顺序" class="headerlink" title="不关注不同事务访问资源的顺序"></a>不关注不同事务访问资源的顺序</h3><p>不同事务访问资源顺序也会导致产生死锁，我们来回顾一下：</p><ul><li>不同线程并发访问同一张表的多行数据，未按顺序访问导致死锁。</li><li>不同线程并发访问多个表时，未按顺序访问导致死锁。</li></ul><p>如果不关注并发访问的不同事务中访问资源的顺序，就会增大出现死锁的概率。</p><p>因此，为了降低死锁，我们需要去关注不同事务访问资源的顺序。</p><h3 id="不关注事务隔离级别"><a href="#不关注事务隔离级别" class="headerlink" title="不关注事务隔离级别"></a>不关注事务隔离级别</h3><p>不同事务隔离级别加锁的情况也是不同的。</p><p>如果完全不关注自己业务使用的 MySQL 是什么隔离级别，可能会降低程序的并发能力或者导致死锁。</p><p>比如业务场景完全能接受幻读，如果要求更高的 QPS，使用 RR 隔离级别显然不是最好的选择，因此可以改为 RC 隔离级别。</p><p>而如果业务使用的是 RR 隔离级别，可能由于间隙锁导致死锁，因此也应该在程序编写时关注 RR 隔离级别下是否会有间隙锁。</p><p>因此，为了更高的并发和降低死锁概率，在创建事务前，也应该去关注自己业务的数据库是什么事务隔离级别。</p><h3 id="在事务中混合使用存储引擎"><a href="#在事务中混合使用存储引擎" class="headerlink" title="在事务中混合使用存储引擎"></a>在事务中混合使用存储引擎</h3><p>在事务中混合使用事务型（比如 InnoDB）和非事务型（比如 MyISAM）表，如果是正常提交，到没什么问题。</p><p>但是，如果该事务回滚了，事务型的表可以正常回滚，而非事务型的表的变更就无法回滚了。这种情况就会导致数据不正常，并且事务最终的结果也难以确定。</p><p>因此，在事务中混合使用存储引擎也是一个不好的事务习惯。</p><blockquote><p>值得一提的是：如果开启 GTID，那么当同一个事务中使用不同存储引擎的表时，会出现如下报错：</p><p>ERROR 1785 (HY000): Statement violates GTID consistency: Updates to non-transactional tables can only be done in either autocommitted statements or single-statement transactions, and never in the same statement as updates to transactional tables.</p><p>因此，开启 GTID 的情况，可以避免同一个事务中混合使用存储引擎的情况。</p></blockquote><h2 id="总结一下好的事务习惯"><a href="#总结一下好的事务习惯" class="headerlink" title="总结一下好的事务习惯"></a>总结一下好的事务习惯</h2><p>在本节中，我们列举了几种不好的事务习惯，这里总结一下好的事务习惯：</p><ul><li>循环写入的情况，如果循环次数不是太多，建议在循环前开启一个事务，循环结束后统一提交。</li><li>优化事务里的语句顺序，减少锁时间。</li><li>关注不同事务访问资源的顺序。</li><li>创建事务之前，关注事务隔离级别。</li><li>在事务中不要混合使用存储引擎。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《MySQL 技术内幕》第 2 版 7.8 不好的事务习惯</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvcc实现</title>
      <link href="/2022/07/18/mysql-2022-07-18-mvcc%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/07/18/mysql-2022-07-18-mvcc%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    本节跟大家一起聊聊 MVCC。</p><h2 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a>什么是 MVCC？</h2><p>在说 MVCC 之前，大家先看看下面这个例子。</p><p>首先创建表并写入测试数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t20;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t20`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t20(a,b) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>进行实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">select * from t20; <img src="/Users/james/blogs/blog/source/_posts/mysql/2022-07-18-mvcc实现/1.png" alt="图片描述"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">begin;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">update t20 set b=666 where a=1;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"></td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"></td><td style="text-align:left">select * from t20; <img src="/Users/james/blogs/blog/source/_posts/mysql/2022-07-18-mvcc实现/2.png" alt="图片描述"></td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">commit;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"></td><td style="text-align:left">select * from t20; <img src="/Users/james/blogs/blog/source/_posts/mysql/2022-07-18-mvcc实现/3.png" alt="图片描述"></td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"></td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>在 session1 更新了 a=1 这行记录，但还没提交的情况下，在 session2 中，满足 a=1 这条记录，b 的值还是原始值 1，而不是 session 1 更新之后的 666，那么在数据库层面，这是怎么实现的呢？</p><p>其实 InnoDB 就是通过 MVCC 和 UNDO LOG 来实现的。</p><p>什么是 MVCC 呢？</p><p>MVCC， 即多版本并发控制。MVCC 的实现，是通过保存数据在某个时间点的快照来实现的，也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><p>也就是上面实验第 6 步中，为什么 session2 查询的结果还是 session1 修改之前的记录。</p><p>MCCC 只在 RC 和 RR 两个隔离级别下工作。因此在上面的实验中，改成 RR 隔离级别，第 6 步中，得到的结果还是 session1 修改之前的记录（但是在第 8 步，结果不一样哦，感兴趣的可以把上面操作放在 RR 隔离级别下实验一下）</p><p>上面提到了 undo log，那么什么是 undo log 呢？</p><h2 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h2><p>上节我们讲到了 redo log，它记录了事务操作变化。但是事务有时是需要回滚的，这时，undo log 就发挥了作用。undo log 是逻辑日志，将数据库逻辑地恢复到原来的样子，所有修改都被逻辑地取消了。</p><p>也就是如果是 insert 操作，其对应的回滚操作就是 delete；</p><p>如果是 delete，则对应的回滚操作是 insert；</p><p>如果是 update，则对应的回滚操作是一个反向的 update 操作。</p><p>除了回滚操作，undo log 的另一个作用是 MVCC，InnoDB 存储引擎中 MVCC 的实现是通过 undo 来完成的。当用户读取一行记录时，若该记录已经被其它事务占用，当前事务可以通过 undo log 读取之前的行版本信息，以此实现非锁定读取。</p><h2 id="MVCC-的实现原理"><a href="#MVCC-的实现原理" class="headerlink" title="MVCC 的实现原理"></a>MVCC 的实现原理</h2><p>InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本（存放在 UNDO LOG 中）。</p><p><img src="/Users/james/blogs/blog/source/_posts/mysql/2022-07-18-mvcc实现/4.png" alt="图片描述"><br>如图，执行 update t20 set b=666 where a=1; 时，会将原记录放到 undo 表空间中，并通过隐藏的回滚指针指向该记录。在本节开始的实验中的第 6 步中，session2 查询的结果是 session1 修改之前的记录，这个记录就是来自 undo log 中。</p><h2 id="MVCC-的优势"><a href="#MVCC-的优势" class="headerlink" title="MVCC 的优势"></a>MVCC 的优势</h2><p>MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。</p><p>通过 MVCC，保证了事务 ACID 中的 （隔离性）特性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 RC 和 RR 隔离级别下，如果需要查询一些被其它事务正在更新的行，看到的是这些记录被更新之前的值。而这就是用 MVCC 实现的。</p><p>MVCC 实现的原理大致是：</p><p><strong>InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。</strong></p><p>MVCC 最大的好处是读不加锁，读写不冲突，极大的增加了 MySQL 的并发性，通过 MVCC，也保证了事务 ACID 中的 (隔离性)特性。</p><blockquote><p>参考</p><p>《MySQL 技术内幕》第 2 版：7.2.2 undo</p><p>《高性能 MySQL》第 3 版：1.4 多版本并发控制</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务与事务持久化</title>
      <link href="/2022/07/18/mysql-2022-07-18-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2022/07/18/mysql-2022-07-18-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 思考两个问题，数据库突然断电会丢失数据吗？数据库中的事务是如何记录的？带着两个疑问，我们继续往下看。</p><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>根据《高性能 MySQL》第 3 版 1.3 事务一节中定义：</p><blockquote><p>事务就是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。</p></blockquote><p>看上面的文字可以稍微抽象了一点，可以结合生活中的一个例子：</p><p>比如你给朋友转账 100 元，其大致过程是：从你的账户扣除 100 元，然后再到你朋友的账户中增加 100 元，试想，如果在这中间，因为网络问题或者程序问题，导致在你的账户中扣除了，但是没有在你朋友的账户中增加，那岂不是乱套了。</p><p>所以，类似这种情况，就可以把这两个步骤放到一个事务里面。要么全部成功，也就是从你的账户扣除之后，然后在你朋友账户中新增；要么全部失败，比如在中间出现问题，会回滚这中间所有的变更。大致操作步骤如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">步骤</th><th style="text-align:left">对应的语句</th></tr></thead><tbody><tr><td style="text-align:left">开始一个事务</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">从你的账户扣除 100 元</td><td style="text-align:left">update money_info set balance = balance - 100 where user_id=1;</td></tr><tr><td style="text-align:left">在你朋友的账户中增加 100 元</td><td style="text-align:left">update money_info set balance = balance + 100 where user_id=2;</td></tr><tr><td style="text-align:left">事务结束</td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>一个良好的事务处理系统，必须具备 ACID 特性：</p><ul><li>atomicity（原子性） ：要么全执行，要么全都不执行；</li><li>consistency（一致性）：在事务开始和完成时，数据都必须保持一致状态；</li><li>isolation（隔离性） ：事务处理过程中的中间状态对外部是不可见的；</li><li>durability（持久性） ：事务完成之后，它对于数据的修改是永久性的。</li></ul><p>InnoDB 采用 redo log 机制来保证事务更新的一致性和持久性。什么是 redo log？下面来一起看下：</p><h2 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h2><p>Redo log 称为重做日志，用于记录事务操作变化，记录的是数据被修改之后的值。</p><p>Redo log 由两部分组成：</p><ul><li>内存中的重做日志缓冲（redo log buffer）</li><li>重做日志文件（redo log file）</li></ul><p>每次数据更新会先更新 redo log buffer，然后根据 innodb_flush_log_at_trx_commit 来控制 redo log buffer 更新到 redo log file 的时机。innodb_flush_log_at_trx_commit 有三个值可选：</p><ul><li><p>0：事务提交时，在事务提交时，每秒触发一次 redo log buffer 写磁盘操作，并调用操作系统 fsync 刷新 IO 缓存。</p></li><li><p>1：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，并调用操作系统 fsync 刷新 IO 缓存；</p></li><li><p>2：事务提交时，InnoDB 立即将缓存中的 redo 日志写到日志文件中，但不是马上调用 fsync 刷新 IO 缓存，而是每秒只做一次磁盘 IO 缓存刷新操作。</p></li></ul><p>innodb_flush_log_at_trx_commit 参数的默认值是 1，也就是每个事务提交的时候都会从 log buffer 写更新记录到日志文件，而且会刷新磁盘缓存，这完全满足事务持久化的要求，是最安全的，但是这样会有比较大的性能损失。</p><p>将参数设置为 0 时，如果数据库崩溃，最后 1秒钟的 redo log 可能会由于未及时写入磁盘文件而丢失，这种方式尽管效率最高，但是最不安全。</p><p>将参数设置为 2 时，如果数据库崩溃，由于已经执行了重做日志写入磁盘的操作，只是没有做磁盘 IO 刷新操作，因此，只要不发生操作系统奔溃，数据就不会丢失，这种方式是对性能和安全的一种折中处理。</p><h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><p>二进制日志（binlog）记录了所有的 DDL（数据定义语句）和 DML（数据操纵语句），但是不包括 select 和 show 这类操作。Binlog 有以下几个作用：</p><ul><li>恢复：数据恢复时可以使用二进制日志</li><li>复制：通过传输二进制日志到从库，然后进行恢复，以实现主从同步</li><li>审计：可以通过二进制日志进行审计数据的变更操作</li></ul><p>可以通过参数 sync_binlog 来控制累积多少个事务后才将二进制日志 fsync 到磁盘。</p><ul><li>sync_binlog=0，表示每次提交事务都只write，不fsync</li><li>sync_binlog=1，表示每次提交事务都会执行fsync</li><li>sync_binlog=N(N&gt;1)，表示每次提交事务都write，累积N个事务后才fsync</li></ul><p>比如要加快写入数据的速度或者机器磁盘 IO 瓶颈时，可以将 sync_binlog 设置成大于 1 的值，<strong>但是如果设置为 N(N&gt;1)时，如果数据库崩溃，可能会丢失最近 N 个事务的 binlog。</strong></p><h2 id="怎样确保数据库突然断电不丢数据？"><a href="#怎样确保数据库突然断电不丢数据？" class="headerlink" title="怎样确保数据库突然断电不丢数据？"></a>怎样确保数据库突然断电不丢数据？</h2><p>通过上面的讲解，只要 innodb_flush_log_at_trx_commit 和 sync_binlog 都为 1（通常称为：双一），就能确保 MySQL 机器断电重启后，数据不丢失。</p><p>因此建议在比较重要的库，比如涉及到钱的库，设置为双一，而你的测试环境或者正式业务不那么重要的库（比如日志库）可以将 innodb_flush_log_at_trx_commit 设置为0，sync_binlog 设置成大于100 的数值，提高更新效率。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了什么是事务？</p><p>所谓事务：是指一组原子性的 SQL 查询，事务里的 SQL 要么全部执行成功，要么全部执行失败。</p><p>一个良好的事务处理系统，必须具备 ACID 特性： atomicity（原子性）、consistency（一致性）、 isolation（隔离性）、 durability（持久性）。</p><p>另外讲解了 Redo log 和 Binlog：</p><ul><li>Redo log：称为重做日志，用于记录事务操作变化，记录的是数据被修改之后的值</li><li>Binlog：记录了所有变更操作，其作用有：恢复、复制、审计等</li></ul><p>如果想要数据库达到最安全的状态，可以将 innodb_flush_log_at_trx_commit 和 sync_binlog 都设置为 1。</p><blockquote><p>参考资料</p><p>《高性能 MySQL》第 3 版：1.3 事务</p><p>《MySQL 技术内幕》第 2 版：7.2 事务的实现</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql死锁的发生与解决</title>
      <link href="/2022/07/18/mysql-2022-07-18-mysql%E6%AD%BB%E9%94%81%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
      <url>/2022/07/18/mysql-2022-07-18-mysql%E6%AD%BB%E9%94%81%E7%9A%84%E5%8F%91%E7%94%9F%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有了锁的基础之后，我们来了解一下死锁的产生和解决。</p><h2 id="认识死锁"><a href="#认识死锁" class="headerlink" title="认识死锁"></a>认识死锁</h2><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</p><p>InnoDB 中解决死锁问题有两种方式：</p><ol><li>检测到死锁的循环依赖，立即返回一个错误（这个报错内容请看下面的实验），将参数 innodb_deadlock_detect 设置为 on 表示开启这个逻辑；</li><li>等查询的时间达到锁等待超时的设定后放弃锁请求。这个超时时间由 innodb_lock_wait_timeout 来控制。默认是 50 秒。</li></ol><blockquote><p>一般线上业务都建议使用的第 1 种策略，因为第 2 种策略锁等待时间是 50 秒，对于高并发的线上业务是不能接受的。</p><p>但是第 1 种策略，也会有死锁检测时的额外 CPU 开销的，比如电商中的秒杀场景。这种情况就可以根据业务开发商量优化程序，如果可以确保业务一定不会出现死锁，可以临时把死锁检测关掉，以提高并发效率。</p></blockquote><h2 id="为什么会产生死锁"><a href="#为什么会产生死锁" class="headerlink" title="为什么会产生死锁"></a>为什么会产生死锁</h2><p>我们通过几个实验来构造几种产生死锁的情况，首先创建测试表并写入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t18;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t18`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t18(a,b,c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t18_1;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t18_1  <span class="keyword">like</span> t18;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t18_1 <span class="keyword">select</span> * <span class="keyword">from</span> t18;</span><br></pre></td></tr></table></figure><h3 id="同一张表中"><a href="#同一张表中" class="headerlink" title="同一张表中"></a>同一张表中</h3><p>不同线程并发访问同一张表的多行数据，未按顺序访问导致死锁。</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">select * from t18 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left">select * from t18 where a=2 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left">select * from t18 where a=2 for update;/* SQL1 */ （等待）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>（session2 提示死锁回滚后，SQL1 成功返回结构）</strong></td><td style="text-align:left">select * from t18 where a=1 for update; <strong>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>session1 在等待 session2 释放 a=2 的行锁，而 session2 在等待 session1 释放 a=1 的行锁。两个 session 互相等待对方释放资源，就进入了死锁状态。</p><p>因此，在上面的例子中，如果 session1 中的事务提交之后，再执行 session2 中的事务，就可以避免这次死锁的发生了。</p><p><strong>所以对于程序多个并发访问同一张表时，如果事先确保每个线程按固定顺序来处理记录，可以降低死锁的概率。</strong></p><h3 id="不同表之间"><a href="#不同表之间" class="headerlink" title="不同表之间"></a>不同表之间</h3><p>不同线程并发访问多个表时，未按顺序访问导致死锁：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">select * from t18 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left">select * from t18_1 where a=1 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left">select * from t18_1 where a=1 for update;/* SQL2 */ 等待</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>（session2 提示死锁回滚后，SQL1 成功返回结构）</strong></td><td style="text-align:left">select * from t18 where a=1 for update; <strong>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>与 同一张表类似，但是这个例子涉及到两张表，如果上例中，之前就约定好 session1 中的事务执行完毕后，再执行 session2 的事务，则可以避免死锁的产生。</p><p>因此，<strong>不同程序并发访问多个表时，应尽量约定以相同的顺序来访问表，可大大降低并发操作不同表时死锁发生的概率</strong>。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>RR 隔离级别下，由于间隙锁导致死锁：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’; /* 设置会话隔离级别为 RR */</td><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’; /* 设置会话隔离级别为 RR */</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left">select * from t18 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left">select * from t18 where a=2 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left">insert into t18(a,b,c) values (2,3,3);/* SQL3 */ 等待</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><strong>（session2 提示死锁回滚后，SQL1 成功返回结构）</strong></td><td style="text-align:left">insert into t18(a,b,c) values (1,4,4);/* SQL4 */ ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>有之前的索引知识可以知道 SQL3 需要等待 a=2 获得的间隙锁，而 SQL4 需要等待 a=1 获得的间隙锁，两个 session 互相等待对方释放资源，就进入了死锁状态。</p><p>类似这种情况，可以考虑将隔离级别改成 RC（这里各位读者可以尝试在 RC 隔离级别下，做上面的实验），降低死锁的概率（当然RC 隔离级别可能会导致幻读，因此需要确定是否可以改成 RC。）</p><h2 id="如何降低死锁概率"><a href="#如何降低死锁概率" class="headerlink" title="如何降低死锁概率"></a>如何降低死锁概率</h2><p>那么应该怎样降低出现死锁的概率呢？这里总结了如下一些经验：</p><ol><li>更新 SQL 的 where 条件尽量用索引；</li><li>基于 primary 或 unique key 更新数据；</li><li>减少范围更新，尤其非主键、非唯一索引上的范围更新；</li><li>加锁顺序一致，尽可能一次性锁定所有需要行；</li><li>将 RR 隔离级别调整为 RC 隔离级别。</li></ol><h2 id="分析死锁的方法"><a href="#分析死锁的方法" class="headerlink" title="分析死锁的方法"></a>分析死锁的方法</h2><p>尽管在上面介绍了降低死锁概率的方法，但是在实际工作中，死锁很难完全避免。因此，捕获并处理死锁也是一个好的编程习惯。</p><p>InnoDB 中，可以使用 SHOW INNODB STATUS 命令来查看最后一个死锁的信息。我们可以尝试用下这个命令获取一些死锁信息，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span>\G</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="图片描述">如上面的图片，就是事务隔离级别例子中的死锁情况，在最后显示回滚了事务 2，也就是对应实验中的 session2。</p><p>另外设置 innodb_print_all_deadlocks = on 可以在 err log 中记录全部死锁信息。</p><p>因此我们可以通过上面两种方式捕获死锁信息，从而进行优化。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节聊了死锁相关的内容。通过具体实验列举了几种出现死锁的情况：</p><ul><li>不同线程并发访问同一张表的多行数据，未按顺序访问导致死锁；</li><li>不同线程并发访问多个表时，未按顺序访问导致死锁；</li><li>RR 隔离级别下，由于间隙锁导致死锁。</li></ul><p>后面提供了几种降低死锁概率的方法。</p><p>由于死锁不能完全杜绝，因此，在最后提供了捕获死锁信息的方法，在工作中我们可以把死锁信息记录下来，如果出现频率过高，就应该考虑去优化程序了。</p><blockquote><p>参考资料</p><p>《深入浅出 MySQL》第 2 版：20.3.9 关于死锁</p><p>《高性能 MySQL》第 3 版：1.3.2 死锁</p><p>《MySQL 技术内幕》第 2 版：6.7 死锁</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql锁机制-间隙锁</title>
      <link href="/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E9%97%B4%E9%9A%99%E9%94%81/"/>
      <url>/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E9%97%B4%E9%9A%99%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    上节我们聊到了 RC 隔离级别的各种情况的锁，这节我们就来一起看看 RR 隔离级别各种情况下的锁，同时揭晓间隙锁的意义。</p><h2 id="RC下的幻读"><a href="#RC下的幻读" class="headerlink" title="RC下的幻读"></a>RC下的幻读</h2><p>下面我们来做一个实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t16 where c=3 for update; <img src="6.png" alt="图片描述"></td></tr><tr><td style="text-align:left">use muke; insert into t16(a,b,c) values (5,5,3); Query OK, 1 row affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select * from t16 where c=3 for update; <img src="7.png" alt="图片描述"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">commit;</td></tr></tbody></table></div><p>我们看一下上面的实验结果，在 session2 中，同一个事务中，按相同的查询条件重新读取以前检索过的数据，却发现了 session1 插入的满足查询条件的新数据，这也就是上一节讲到的幻读情况。</p><p>为什么上面的实验中会出现幻读呢？</p><p>我们来看看下面这张图：<br><img src="1.png" alt="图片描述">从图中可以看出，RC 隔离级别下，只锁住了满足 c=3 的当前行，而不会对后面的位置（或者说间隙)加锁，因此导致 session1 的写入语句能正常执行并提交。</p><p>那么应该怎样避免幻读呢？</p><p>从上面的分析我们可以知道，产生幻读的原因是：行锁只能锁住当前行，但是新插入的记录，是在被锁住记录之前的间隙。因此，为了解决幻读问题，InnoDB 在 RR 隔离级别下配置了间隙锁（Gap Lock）。</p><h2 id="RR-隔离级别下的非唯一索引查询"><a href="#RR-隔离级别下的非唯一索引查询" class="headerlink" title="RR 隔离级别下的非唯一索引查询"></a>RR 隔离级别下的非唯一索引查询</h2><p>我们继续看上面的实验，这里不同点是我们把隔离级别设置成 RR。</p><p>我们再单独建一张表，表结构与上节的表结构一致，为了方便后面分析，数据稍微有改动，语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t17;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t17`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uniq_a`</span> (<span class="string">`a`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t17(<span class="keyword">id</span>,a,b,c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>开始 RR 隔离级别下的实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left">begin;</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t17 where c=4 for update; <img src="2.png" alt="图片描述"></td></tr><tr><td style="text-align:left">use muke; insert into t17(a,b,c) values (7,7,4); /* SQL1 */ <strong>（等待）</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select *\ from t17 where c=4 for update; <img src="3.png" alt="图片描述"></td></tr><tr><td style="text-align:left">insert into t17(a,b,c) values (7,7,4); /* SQL1 */ Query OK, 1 row affected (20.73 sec) <strong>（等 session2 执行 commit; 后，SQL1 马上返回结果）</strong></td><td style="text-align:left">commit;</td></tr><tr><td style="text-align:left">commit;</td></tr></tbody></table></div><p>根据实验情况，我们在 session2 中，对满足条件 c=4 的数据加上了排他锁，然后在 session1 写入一条 c=4 的记录，此时会出现等待，直到 session2 对事务进行提交后，session1 才会执行成功。这是为什么呢？我们来看下图：<br><img src="4.png" alt="图片描述">与 RC 隔离级别下的图相似，但是有个比较大的区别是：RR 隔离级别多了 GAP 锁。</p><p>如上图，首先需要考虑哪些位置可以插入新的满足条件 c=4 的项：</p><ul><li>由于 B+ 树索引是有序的，因此 [2,2]（代表 c 和 id 的值，后面就不一一说明了）前面的记录，不可能插入 c=4 的记录了；</li><li>[2,2] 与 [4,4] 之间可以插入 [4,3]；</li><li>[4,4] 与 [4,6] 之间可以插入 [4,5]；</li><li>[4,6] 之后，可以插入的值就很多了：<a href="其中 n&gt;6">4,n</a> ；</li></ul><p>为了保证这几个区间不会插入新的满足条件 c=4 的记录，MySQL RR 隔离级别选择了 GAP 锁，将这几个区间锁起来。</p><p>而上面实验中，语句 insert into t17 (a,b,c) values (7,7,4) 其对应插入 c 和 id 的值为 [4,7]，是在最后这个被 GAP Lock 锁住的区间，因此如上面实验，insert 操作会等待。</p><h2 id="RR-隔离级别下的非索引字段查询"><a href="#RR-隔离级别下的非索引字段查询" class="headerlink" title="RR 隔离级别下的非索引字段查询"></a>RR 隔离级别下的非索引字段查询</h2><p>上一节中，我们测试了 RC 隔离级别下，非索引字段做条件的当前读会对所有记录都加锁。</p><p>这一节，我们测试一下 RR 隔离级别下，非索引字段做条件的当前读加锁情况。</p><p>首先对 t17 表中的数据做初始化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t17;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t17`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uniq_a`</span> (<span class="string">`a`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t17(<span class="keyword">id</span>,a,b,c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td><td style="text-align:left">set session transaction_isolation=‘REPEATABLE-READ’;/* 设置会话隔离级别为 RR*/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; select * from t17 where b=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t17 where b=2 for update; <strong>（等待）</strong></td><td style="text-align:left">insert into t17(a,b,c) values (10,10,10); <strong>（等待）</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select * from t17 where b=2 for update; … 1 row in set (31.51 sec) <strong>（session1 提交后，马上返回结果）</strong></td><td style="text-align:left">insert into t17(a,b,c) values (10,10,10); Query OK, 1 row affected (8.08 sec) <strong>（session1 提交后，马上写入）</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></div><p>可能你会问？为什么 session3 的 insert 会出现等待？</p><p>我们看看下图：<br><img src="5.png" alt="图片描述"><br>如图，所有记录都有 X 锁，除此之外，每个 GAP 也被加上了 GAP 锁。因此这张表在执行完 select * from t17 where b=1 for update; 到 commit 之前，除了不加锁的快照读，其它任何加锁的 SQL，都会等待，如果这是线上业务表，那就是件非常恐怖的事情了。</p><p>总结：<strong>RR 隔离级别下，非索引字段做条件的当前读不但会把每条记录都加上 X 锁，还会把每个 GAP 加上 GAP 锁。再次说明，条件字段加索引的重要性。</strong></p><h2 id="RR-隔离级别下的唯一索引当前读是否会用到-GAP-锁"><a href="#RR-隔离级别下的唯一索引当前读是否会用到-GAP-锁" class="headerlink" title="RR 隔离级别下的唯一索引当前读是否会用到 GAP 锁"></a>RR 隔离级别下的唯一索引当前读是否会用到 GAP 锁</h2><p>GAP 锁的目的是：为了防止同一事务两次当前读，出现幻读的情况。如果能确保索引字段唯一，那其实一个等值查询，最多就返回一条记录，而且相同索引记录的值，一定不会再新增，因此不会出现 GAP 锁。</p><p>因此以唯一索引为条件的当前读，不会有 GAP 锁。所以 RR 隔离级别下的唯一索引当前读加锁情况与 RC 隔离级别下的唯一索引当前读加锁情况一致。这里就不再实验了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了 RC 隔离级别出现幻读的情况，而 RR 通过 GAP 锁解决了幻读，但是 RR 隔离级别相对于 RC，锁的范围可能更大了，特别是对没有索引的字段进行当前读（比如增、删、改或者 select … for update）时，会阻塞除快照读以外所有的并发 SQL。</p><p>而后面我们又聊了以唯一索引做为条件的当前读不会用到 GAP 锁，因为根据唯一索引查询最多就一条记录，而且相同索引记录的值，一定不会再新增。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql锁机制-行锁</title>
      <link href="/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E8%A1%8C%E9%94%81/"/>
      <url>/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E8%A1%8C%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>MySQL 5.5 之前的默认存储引擎是 MyISAM，5.5 之后改成了 InnoDB。InnoDB 后来居上最主要的原因就是：</p><ul><li>InnoDB 支持事务：适合在并发条件下要求数据一致的场景。</li><li>InnoDB 支持行锁：有效降低由于删除或者更新导致的锁定。</li></ul><p>本节就一起来探讨 InnoDB 的行锁。</p><p>在讲解行锁之前，我们首先来看一下两阶段锁协议。</p><h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><p>传统的关系型数据库加锁的一个原则是：两阶段锁原则。</p><p>两阶段锁：锁操作分为两个阶段，加锁阶段和解锁阶段，并且保证加锁阶段和解锁阶段不相交。</p><p>我们可以通过下面这张表理解两阶段锁：</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">MySQL 操作</th><th style="text-align:left">解释</th><th style="text-align:left">锁阶段</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">begin;</td><td style="text-align:left">事务开始</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">insert into …;</td><td style="text-align:left">加 insert 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">update table …;</td><td style="text-align:left">加 update 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">delete from …;</td><td style="text-align:left">加 delete 对应的锁</td><td style="text-align:left">加锁阶段</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">commit;</td><td style="text-align:left">事务结束，同时释放 2、3、4 步骤中加的锁</td><td style="text-align:left">解锁阶段</td></tr></tbody></table></div><h2 id="InnoDB-行锁模式"><a href="#InnoDB-行锁模式" class="headerlink" title="InnoDB 行锁模式"></a>InnoDB 行锁模式</h2><p>InnoDB 实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁；</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>对于普通 select 语句，InnoDB 不会加任何锁，事务可以通过以下语句显式给记录集加共享锁或排他锁：</p><ul><li>共享锁（S）：select * from table_name where … lock in share mode;</li><li>排他锁（X）：select * from table_name where … for update。</li></ul><h2 id="InnoDB-行锁算法"><a href="#InnoDB-行锁算法" class="headerlink" title="InnoDB 行锁算法"></a>InnoDB 行锁算法</h2><p>InnoDB 行锁的三种算法：</p><ul><li>Record Lock：单个记录上的索引加锁。</li><li>Gap Lock：间隙锁，对索引项之间的间隙加锁，但不包括记录本身。</li><li>Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身。</li></ul><p>InnoDB 行锁实现特点意味着：如果不通过索引条件检索数据，那么 InnoDB 将对表中所有记录加锁，实际效果跟表锁一样。</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>不同事务隔离级别对应的行锁也是不一样的，因此在讲解行锁的锁定范围之前，先简单聊聊事务隔离级别。事务隔离级别的详细介绍放在下一章。</p><p>MySQL 的 4 种隔离级别：</p><ul><li>Read uncommitted（读未提交）: 在该隔离级别，所有事务都可以看到其它未提交事务的执行结果。可能会出现脏读。</li><li>Read Committed（读已提交，简称： RC）：一个事务只能看见已经提交事务所做的改变。因为同一事务的其它实例在该实例处理期间可能会有新的 commit，所以可能出现幻读。</li><li>Repeatable Read（可重复读，简称：RR）：这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。消除了脏读、不可重复读，默认也不会出现幻读。</li><li>Serializable（串行）：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。</li></ul><blockquote><p>这里解释一下脏读和幻读：</p><ul><li>脏读：读取未提交的事务。</li><li>幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。</li></ul></blockquote><h2 id="RC-隔离级别下的行锁实验"><a href="#RC-隔离级别下的行锁实验" class="headerlink" title="RC 隔离级别下的行锁实验"></a>RC 隔离级别下的行锁实验</h2><p>有时我们可能会思考，某条语句（类似 select * from table_name where a=… for update;）是怎么加锁的？</p><p>要想分析某条 SQL 是怎么加锁的，如果其他信息都不知道，那就得分几种情况了，不同情况加锁的方式也各不一样，比较常见的一些情况如下：</p><ul><li>RC 隔离级别，a 字段没索引。</li><li>RC 隔离级别，a 字段有唯一索引。</li><li>RC 隔离级别，a 字段有非唯一索引。</li><li>RR 隔离级别，a 字段没索引。</li><li>RR 隔离级别，a 字段有唯一索引。</li><li>RR 隔离级别，a 字段有非唯一索引。</li><li>…</li></ul><blockquote><p>Read uncommitted 和 Serializable 这两种隔离级别在生产环境基本不用，就不做分析了。</p></blockquote><p>我们先验证 RC 隔离级别下的几种情况，RR 隔离级别的实验放在下节：</p><p>首先创建测试表及写入数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t16`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uniq_a`</span> (<span class="string">`a`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t16(a,b,c) <span class="keyword">values</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>让我们开始实验吧！</p><h3 id="通过非索引字段查询"><a href="#通过非索引字段查询" class="headerlink" title="通过非索引字段查询"></a>通过非索引字段查询</h3><p>我们首先来看一下条件字段不使用索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/<em> 设置会话隔离级别为 RC\</em>/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; select * from t16 where b=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select <em> from t16 where b=2 for update; <em>*（等待）</em></em></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select * from t16 where b=2 for update; … 1 row in set (6.81 sec) <strong>（session1 执行 commit 后立马返回结果）</strong></td></tr></tbody></table></div><blockquote><p><strong>这里解释一下为什么要用 for update？</strong></p><p>我们常使用的查询语句，比如 select * from t16 where b=1 属于快照读，是不会看到别的事务插入的数据的。</p><p>而在查询语句后面加了 for update 显式给记录集加了排他锁，也就让查询变成了当前读。插入、更新、删除操作，都属于当前读。其实也就可以理解 select … for update 是为了让普通查询获得插入、更新、删除操作时所获得的锁。</p></blockquote><p>表面看起来 session1 只给了 b=1 这一行加了排他锁，但 session2 在请求其它行的排他锁时，却出现了锁等待。看下图：<br><img src="1.png" alt="图片描述">由于 b 字段没有索引，因此只能走聚簇索引，进行全表扫描。从上图中可以看到，满足条件的记录有一条，但是聚簇索引上的所有记录，都被加上了 X 锁。</p><p>为什么不是只在满足条件的记录上加锁呢？</p><p>这是因为在 MySQL 中，如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由 server 层进行过滤。因此也就把所有记录都锁上了。</p><blockquote><p>当然 MySQL 在这里有一些改进的，在 server 层过滤掉不满足条件的数据后，会把不满足条件的记录放锁。保证了最后只会持有满足条件的锁，但是每条记录的加锁操作还是不会省略。</p></blockquote><p>总结：<strong>没有索引的情况下，InnoDB 的当前读会对所有记录都加锁。所以在工作中应该特别注意 InnoDB 这一特性，否则可能会产生大量的锁冲突。</strong></p><h3 id="通过唯一索引查询"><a href="#通过唯一索引查询" class="headerlink" title="通过唯一索引查询"></a>通过唯一索引查询</h3><p>我们再来看一下条件字段有唯一索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td></tr><tr><td style="text-align:left">begin; use muke; select * from t16 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t16 where a=2 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select * from t16 where a=1 for update; <strong>（等待）</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select * from t16 where a=1 for update; … 1 row in set (4.70 sec) <strong>（session1 提交后，马上返回结果）</strong></td></tr></tbody></table></div><p>session1 给了 a=1 这一行加了排他锁，在 session2 中请求其他行的排他锁时，不会发生等待；但是在 session2 中请求 a=1 这一行的排他锁时，会发生等待。看下图：<br><img src="2.png" alt="图片描述"></p><p>由于 a 是唯一索引，因此 select * from t16 where a=1 for update；(后面称为 SQL2) 语句会选择走 a 列的索引进行条件过滤，在找到 a=1 的记录后，会将唯一索引上 a=1 索引记录上加 X 锁，同时，会根据读取到的 id 列，回到聚簇索引，然后将 id=1 对应的聚簇索引项加 X 锁。</p><p>为什么聚簇索引上的记录也要加锁呢？</p><p>比如，并发的一条 SQL，是通过主键索引来更新：update t16 set b=10 where id =1; 如果 SQL2 没有将主键索引上的记录加锁，那么并发的 update 并不知道 SQL2 在执行，所以如果 update 执行了，就违背了同一记录上的更新或者删除需要串行执行的约束。</p><p>总结：<strong>如果查询的条件是唯一索引，那么 SQL 需要在满足条件的唯一索引上加锁，并且会在对应的聚簇索引上加锁。</strong></p><h3 id="通过非唯一索引查询"><a href="#通过非唯一索引查询" class="headerlink" title="通过非唯一索引查询"></a>通过非唯一索引查询</h3><p>我们再来看一下条件字段有非唯一索引的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td><td style="text-align:left">set session transaction_isolation=‘READ-COMMITTED’;/* 设置会话隔离级别为 RC*/</td></tr><tr><td style="text-align:left">begin;</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">use muke; select * from t16 where c=3 for update; … 2 rows in set (0.00 sec)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">use muke; select * from t16 where a=1 for update; … 1 row in set (0.00 sec)</td><td style="text-align:left">use muke; select * from t16 where a=2 for update; … 1 row in set (0.00 sec)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">select * from t16 where a=3 for update; <strong>(等待)</strong></td><td style="text-align:left">select * from t16 where a=4 for update; <strong>(等待)</strong></td></tr><tr><td style="text-align:left">commit;</td><td style="text-align:left">select * from t16 where a=3 for update; … <strong>(session1 提交后，马上返回结果)</strong></td><td style="text-align:left">select * from t16 where a=4 for update; … <strong>(session1 提交后，马上返回结果)</strong></td></tr></tbody></table></div><p>我们在满足条件 c=3 的数据上加了排他锁，如上面结果，就是第 3、4 行。因此第 1、2 行的数据没被锁，而 3、4 行的数据被锁了。如下图：<br><img src="3.png" alt="图片描述">通过上图可以看到，在 a 字段的非唯一索引上，满足 c=3 的所有记录，都被加了锁。同时，对应的主键索引上的记录也都加上了锁。与通过唯一索引查询的情况相比，唯一索引查询最多有一行记录被锁，而非唯一索引将会把满足条件的所有记录都加上锁。</p><p>总结：<strong>如果查询的条件是非唯一索引，那么 SQL 需要在满足条件的非唯一索引上都加上锁，并且会在它们对应的聚簇索引上加锁。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们聊了一下 InnoDB 行锁，这是 InnoDB 替代 MyISAM（只支持表锁）的一个比较重要的原因。</p><p>在文稿的开始，跟大家讲解了两阶段锁、行锁模式、行锁算法以及事务隔离级别等。</p><p>我们做了 RC 隔离级别下不同场景的行锁实验，比较重要的一点是：在更新数据时，如果条件字段没索引，则表中所有记录都会被加上 X 锁。所以在工作中应该尽可能的让查询走索引。</p><blockquote><p>参考资料</p><p>何登成的 github：<a href="https://github.com/hedengcheng/tech/tree/master/database/MySQL。" target="_blank" rel="noopener">https://github.com/hedengcheng/tech/tree/master/database/MySQL。</a></p><p>《深入浅出 MySQL》（第 2 版）：20.3.4 InnoDB 行锁实现方式。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql锁机制-全局锁与表锁</title>
      <link href="/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E5%85%A8%E5%B1%80%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81/"/>
      <url>/2022/07/18/mysql-2022-07-18-mysql%E9%94%81%E6%9C%BA%E5%88%B6-%E5%85%A8%E5%B1%80%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>mysql有两大类内存一块是索引，主要是提高检索查询能力，另一大块就是锁，MySQL 中，锁就是协调多个用户或者客户端并发访问某一资源的机制，保证数据并发访问时的一致性和有效性。</p><p>本章就来介绍一下不同场景下的锁机制。</p><p>根据加锁的范围，MySQL 中的锁可分为三类：</p><ul><li>全局锁</li><li>表级锁</li><li>行锁</li></ul><p>本节来重点讲解一下全局锁和表锁。</p><h2 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1 全局锁"></a><strong>1 全局锁</strong></h2><p>MySQL 全局锁会关闭所有打开的表，并使用全局读锁锁定所有表。其命令为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">TABLES</span> <span class="keyword">WITH</span> <span class="keyword">READ</span> <span class="keyword">LOCK</span>;</span><br></pre></td></tr></table></figure><p>简称：FTWRL，可以使用下面命令解锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure><p>我们来通过实验理解一下全局锁：</p><p>首先创建测试表，并写入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> muke;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> t14;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t14`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t14(a,b) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>进行 FTWRL 实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">FLUSH TABLES WITH READ LOCK; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select * from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td><td style="text-align:left">select * from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td></tr><tr><td style="text-align:left">insert into t14(a,b) values(2,2); ERROR 1223 (HY000): Can’t execute the query because you have a conflicting read lock <strong>（报错）</strong></td><td style="text-align:left">insert into t14(a,b) values(2,2);/*sql1*/ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">UNLOCK TABLES;</td><td style="text-align:left">insert into t14(a,b) values(2,2);/* sql1 */ Query OK, 1 row affected (5.73 sec) <strong>（session1 解锁后，在等待的 sql1 马上执行成功）</strong></td></tr></tbody></table></div><p>上面的实验中，当 session1 执行 FTWRL 后，本线程 session1 和其它线程 session2 都可以查询，本线程和其它线程都不能更新。</p><p>原因是：<strong>当执行 FTWRL 后，所有的表都变成只读状态，数据更新或者字段更新将会被阻塞。</strong></p><p>那么全局锁一般什么时候会用到呢？</p><p>全局锁一般用在整个库（包含非事务引擎表）做备份（mysqldump 或者 xtrabackup）时。也就是说，在整个备份过程中，整个库都是只读的，其实这样风险挺大的。如果是在主库备份，会导致业务不能修改数据；而如果是在从库备份，就会导致主从延迟。</p><p>好在 mysqldump 包含一个参数 —single-transaction，可以在一个事务中创建一致性快照，然后进行所有表的备份。因此增加这个参数的情况下，备份期间可以进行数据修改。但是需要所有表都是事务引擎表。所以这也是建议使用 InnoDB 存储引擎的原因之一。</p><p>而对于 xtrabackup，可以分开备份 InnoDB 和 MyISAM，或者不执行 —master-data，可以避免使用全局锁。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁有两种：表锁和元数据锁。</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表锁使用场景：</p><ol><li>事务需要更新某张大表的大部分或全部数据。如果使用默认的行锁，不仅事务执行效率低，而且可能造成其它事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高事务执行速度；</li><li>事务涉及多个表，比较复杂，可能会引起死锁，导致大量事务回滚，可以考虑表锁避免死锁。</li></ol><p>其中表锁又分为表读锁和表写锁，命令分别是：</p><p>表读锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> t14 <span class="keyword">read</span>;</span><br></pre></td></tr></table></figure><p>表写锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> t14  write;</span><br></pre></td></tr></table></figure><p>下面我们分别用实验验证表读锁和表写锁。</p><p>表读锁实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">lock tables t14 read; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select id,a,b from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td></tr><tr><td style="text-align:left">insert into t14(a,b) values(3,3); ERROR 1099 (HY000): Table ‘t14’ was locked with a READ lock and can’t be updated <strong>（报错）</strong></td><td style="text-align:left">insert into t14(a,b) values(3,3);/* sql2 */ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left">insert into t14(a,b) values(3,3);/* sql2 */ Query OK, 1 row affected (10.97 sec) <strong>（session1 解锁后，sql2 立马写入成功）</strong></td></tr></tbody></table></div><p>从上面的实验我们可以看出，在 session1 中对表 t14 加表读锁，session1 和 session2 都可以查询表 t14 的数据；而 session1 执行更新会报错，session2 执行更新会等待（直到 session1 解锁后才更新成功）。</p><p>总结：<strong>对表执行 lock tables xxx read （表读锁）时，本线程和其它线程可以读，本线程写会报错，其它线程写会等待。</strong></p><p>我们再来看一下表写锁实验：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th></tr></thead><tbody><tr><td style="text-align:left">lock tables t14 write; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select id,a,b from t14 limit 1; … 1 row in set (0.00 sec) <strong>（能正常返回结果）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/* sql3 */ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; Query OK, 0 rows affected (0.01 sec)</td><td style="text-align:left">select id,a,b from t14 limit 1;/* sql3 */ … 1 row in set (7.16 sec) <strong>（session1 解锁后，sql3 马上返回查询结果）</strong></td></tr><tr><td style="text-align:left">lock tables t14 write; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">delete from t14 limit 1; Query OK, 1 row affected, 1 warning (0.00 sec) <strong>（能正常执行删除语句）</strong></td><td style="text-align:left">delete from t14 limit 1;/<em> sql4 </em>/ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">unlock tables; Query OK, 0 rows affected (0.00 sec)</td><td style="text-align:left">delete from t14 limit 1;/* sql4 */ Query OK, 1 row affected, 1 warning (14.94 sec) <strong>（session1 解锁后，sql4 立马执行成功）</strong></td></tr></tbody></table></div><p>总结：<strong>对表执行 lock tables xxx write （表写锁）时，本线程可以读写，其它线程读写都会阻塞。</strong></p><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>在 MySQL 中，DDL 是不属于事务范畴的。如果事务和 DDL 并行执行同一张表时，可能会出现事务特性被破坏、binlog 顺序错乱等 bug（比如 <a href="https://bugs.mysql.com/bug.php?id=989" target="_blank" rel="noopener">bug#989</a>）。为了解决这类问题，从 MySQL 5.5.3 开始，引入了元数据锁（Metadata Locking，简称：MDL 锁）（这段内容参考《淘宝数据库内核月报》<a href="http://mysql.taobao.org/monthly/2015/11/04/" target="_blank" rel="noopener">MySQL · 特性分析 · MDL 实现分析</a>）。</p><p>从上面我们知道，MDL 锁的出现解决了同一张表上事务和 DDL 并行执行时可能导致数据不一致的问题。</p><p>但是，我们在工作中，很多情况需要考虑 MDL 的存在，否则可能导致长时间锁等待甚至连接被打满的情况。如下例：</p><div class="table-container"><table><thead><tr><th style="text-align:left">session1</th><th style="text-align:left">session2</th><th style="text-align:left">session3</th></tr></thead><tbody><tr><td style="text-align:left">select id,a,b,sleep(100) from t14 limit 1;/<em> sql5 </em>/</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">alter table t14 add column c int;/* sql6 */ <strong>（等待）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/* sql7 */ <strong>（等待）</strong></td></tr><tr><td style="text-align:left">select id,a,b,sleep(100) from t14 limit 1;/* sql5 */ … 1 row in set (1 min 40.00 sec) <strong>（100秒后 sql5 返回结果）</strong></td><td style="text-align:left">alter table t14 add column c int;/* sql6 */ Query OK, 0 rows affected (1 min 33.98 sec) Records: 0 Duplicates: 0 Warnings: 0 <strong>（session1 的查询语句执行完成后，sql6 立马执行完毕）</strong></td><td style="text-align:left">select id,a,b from t14 limit 1;/* sql7 */ … 1 row in set (1 min 26.65 sec) <strong>（session1 的查询语句执行完成后，sql7 立马执行完毕）</strong></td></tr></tbody></table></div><p>上面的实验中，我们在 session1 查询了表 t14 的数据，其中使用了 sleep(100) ，表示在 100 秒后才会返回结果；然后在 session2 执行 DDL 操作时会等待（原因是 session1 执行期间会对表 t14 加一个 MDL，而 session2 又会跟 session1 争抢 MDL）；而 session3 执行查询时也会继续等待。因此如果 session1 的语句一直没结束，其它所有的查询都会等待。这种情况下，如果这张表查询比较频繁，很可能短时间把数据库的连接数打满，导致新的连接无法建立而报错，如果是正式业务，影响是非常恐怖的。</p><p>当然如果出现这种情况，假如你还有 session 连着数据库，可以 kill 掉 session1 中的语句或者终止 session2 中的 DDL 操作，可以让业务恢复。但是出现这种情况的根源其实是：session1 中有长时间未提交的事务。<strong>因此对于开发来说，在工作中应该尽量避免慢查询、尽量保证事务及时提交、避免大事务等，当然对于 DBA 来说，也应该尽量避免在业务高峰执行 DDL 操作。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节讲解了全局锁和表锁。</p><p>其中<strong>全局锁会让所有的表变成只读状态，所有更新操作都会被阻塞。</strong></p><p>而表级锁分为表锁和元数据锁。</p><p>表锁又提到了表读锁和表写锁，并都进行了实验。两者的区别是：</p><p><strong>表读锁：本线程和其它线程可以读，本线程写会报错，其它线程写会等待。</strong></p><p><strong>表写锁：本线程可以读写，其它线程读写都会阻塞。</strong></p><p>为了保证事务和 DDl 并行执行数据一致，在 MySQL 5.5.3 引入了 MDL 锁。通过本节讲解的 MDL 锁机制，应该注意的几个点是：</p><ul><li>尽量避免慢查询</li><li>事务要及时提交</li><li>避免大事务</li><li>避免在业务高峰执行 DDL 操作</li></ul><blockquote><p>参考资料</p><p>《深入浅出 MySQL》第二版：20.3.8 什么时候使用表锁</p><p>《MySQL 5.7 参考手册》：<a href="https://dev.mysql.com/doc/refman/5.7/en/flush.html#flush-tables-with-read-lock" target="_blank" rel="noopener">13.7.6.3 FLUSH Syntax</a></p><p>《淘宝数据库内核月报》：<a href="http://mysql.taobao.org/monthly/2015/11/04/" target="_blank" rel="noopener">MySQL · 特性分析 · MDL 实现分析</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解红黑树性质与实现</title>
      <link href="/2022/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-16-%E8%AF%A6%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%A7%E8%B4%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-16-%E8%AF%A6%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%A7%E8%B4%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文将从2-3树与红黑树的联系入手，详细解释红黑树的性质与代码实现，让各位清楚红黑树为何如此定义以及性质是如何推导出来的。本文需要前章2-3树的知识</p><p>[红黑树等价树2-3树]: <a href="http://www.icanfly.tech/2022/07/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AD%89%E4%BB%B7%E6%A0%912-3%E6%A0%91/" target="_blank" rel="noopener">http://www.icanfly.tech/2022/07/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AD%89%E4%BB%B7%E6%A0%912-3%E6%A0%91/</a></p></blockquote><h3 id="初见红黑树"><a href="#初见红黑树" class="headerlink" title="初见红黑树"></a>初见红黑树</h3><p>引用&lt;&lt;算法导论&gt;&gt;一书，原文如下:</p><p>A red-black tree is a binary tree that satisfies the following red-black properties:</p><ol><li><strong>Every node is either red or black.</strong></li><li><strong>The root is black.</strong></li><li><strong>Every leaf (NIL) is black.</strong></li><li><strong>If a node is red, then both its children are black.</strong></li><li><strong>For each node, all simple paths from the node to descendant leaves contain the<br>same number of black nodes.</strong></li></ol><p>红黑树的性质网上一搜一堆，包括操作也是，但关键是 这性质是怎么推得呢？为什么有这样的性质呢？我可以先记下这些性质，耐心往下看。</p><h3 id="红黑树与2-3树的联系"><a href="#红黑树与2-3树的联系" class="headerlink" title="红黑树与2-3树的联系"></a>红黑树与2-3树的联系</h3><p>让我们先回顾一下 2-3树 添加新元素时要注意的地方:<br>    <strong>或者添加进2-节点，形成一个3-节点</strong><br>    <strong>或者添加进3-节点，暂时形成一个4-节点</strong>    </p><p>我们可以看到，插入的新元素一定要先插入到叶子节点上，如果超过了3节点，再去调整，红黑树也是一颗树，它本质上上实在模仿2-3树，因为2-3这种插入及调整能保证绝对的平衡，红黑树也想实现这种类似的平衡，我们假设红黑树插入的元素，每次也是要插入到一个元素身上，再去考虑调整。</p><p>​    我们将2-3树与红黑树做一下类比:</p><p>​    <img src="1.png" alt=""></p><p>​    我们观察此图，当在2-3树中插入第一个元素时，对应红黑树，也是插入一个元素，此元素默认颜色为黑色。当我们插入第二个元素时，我们说2-3树中，每插入一个元素，都是要插在一个元素身上的，对应红黑树，红黑树也想表达这种3节点的，但红黑树是用在内存的结构，也是基于BST的，一个节点只能有一个元素，那它怎么办，它只能拆分，并且这个地方定义，小的元素在下，拆在我的左孩子(这是定义，你要是不喜欢，可以定义一个红黑树2，让大的元素在小元素的右孩子身上)拆分之后，为了能表示 他们是处于在2-3树中同一个3节点的身份，可以让树枝是红色的来特殊标识一下，表示此节点与父亲节共同组成3节点，但实际上我们写过BST代码就知道了，其实树枝在代码里面就是那个next指针代替了，是没有具体实现类的，所以从实现的角度讲，从节点标识更容易实现，所以我们不妨将小元素节点来标识成红色，至此，一个简单的对应关系就出来了，我们看一下完整的一棵树</p><p><img src="2.png" alt=""></p><p>看完上图，是不是有一恍然大悟的感觉？我们再回过头来，看一下算法导论中提到的性质 ：</p><pre><code>1. 每个节点要么黑，要么红，显然，对应2-3树中的2节点以及3节点中的右面那个元素是黑，3节点中小的那个是红的。1. 跟元素是黑的，这个也简单，因为红元素的节点一定是有一个黑色节点的父亲，那根节点自然是父亲了。1. 叶节点是黑的，这个地方是定义的关系，它把null定义为叶节点，这个不影响理解。1. 如果一个节点是红色，则它的两个孩子是黑的。so easy，因为在2-3树中，一个3节点的孩子要么是2节点（一个元素，黑色代表）要么是3节点（父亲是黑，左孩子是红）。1. 其实说的是，从根节点到任意一个叶节点(我们还是习惯的将最后一个非空节点视为叶节点 )路径上黑色节点的个数是固定的。我们对比2-3树就知道了，把红黑树看成一颗假象的2-3树，2-3树绝对平衡的，层数是固定的，而黑色节点恰巧代表了层数，所以这个路径上黑色节点树固定也不难理解哦。</code></pre><h3 id="插入调整"><a href="#插入调整" class="headerlink" title="插入调整"></a>插入调整</h3><p>接下来我们考虑如何进行调整?，首先我们知道，插入的一个新元素，一定要先附着于一个叶子节点元素上，然后再去调整，因为相当于每个元素都要经过调整，我们可以先假设插入的新元素都是红色的节点，去调整。类似AVL的旋转操作，我们看一下红黑树的基本旋转操作，这些操作是红黑树的数据结构的基本操作。</p><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li><p>左旋转</p><p>左旋转要做的事情如下 ：</p></li></ul><p>​            <img src="3.png" alt="">    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node.right = x.left</span><br><span class="line">x.left = node</span><br><span class="line">x.color = node.color</span><br><span class="line">node.color = RED</span><br></pre></td></tr></table></figure><p><img src="4.png" alt=""></p><p>了解过AVL旋转实现的话，这个代码就很简单了。    </p><ul><li>颜色翻转</li></ul><p>左旋转实际是插入到一个2节点身上，下面我们重点看插入到3节点身上的形态及调整。</p><p>​    <img src="5.png" alt=""></p><p>在42、37插入完成之后，我们又插入了66，对应如图，插入的元素因为要和叶节点绑定，所以默认插入为红色。红色代表与父亲元素是同一个节点，但此时在2-3树中是一个临时的4节点的状态，2-3树中要分裂调整如图示的结构，同理红黑树，我们也对应的表示成2-3树分裂后的结构即可,也就是3个2节点。</p><p><img src="6.png" alt=""></p><p>但要注意一点，虽然都是2节点，但是分裂出来之后父亲是划到上层去了，也是一个结合的节点，所以要标识为红色。红色就代表要调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node.color = RED</span><br><span class="line">node.left.color = BLACK</span><br><span class="line">node.right.color = BLACK</span><br></pre></td></tr></table></figure><ul><li>右旋转</li></ul><p>右旋转也是插入到3节点中出现某种状态时需要调整的操作.</p><p>假设在插入42、37之后再插入一个12元素，显然这是一种临时的4节点状态，需要调整，目标是如图中的3节点状态，我们可先做一个右旋转操作（AVL中常规操作）</p><p><img src="7.png" alt=""></p><p>此时只是简单的右旋，还没到目标结构，但是注意看，这不正是颜色翻转要调整的状态吗？所以此时再调一次颜色翻转的操作即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node.left = x.right</span><br><span class="line">x.right = node</span><br><span class="line">x.color = node.color</span><br><span class="line">node.color = RED</span><br></pre></td></tr></table></figure><h4 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h4><p>我们取一种最麻烦的状态做示例，来回顾整个调整过程，假设向一个3节点中插入一个中间大小的元素</p><p><img src="8.png" alt=""></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            color = RED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RBTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断节点node的颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> BLACK;</span><br><span class="line">        <span class="keyword">return</span> node.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node x = node.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左旋转</span></span><br><span class="line">        node.right = x.left;</span><br><span class="line">        x.left = node;</span><br><span class="line"></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node x = node.left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右旋转</span></span><br><span class="line">        node.left = x.right;</span><br><span class="line">        x.right = node;</span><br><span class="line"></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 颜色翻转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        node.color = RED;</span><br><span class="line">        node.left.color = BLACK;</span><br><span class="line">        node.right.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向红黑树中添加新的元素(key, value)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>&#123;</span><br><span class="line">        root = add(root, key, value);</span><br><span class="line">        root.color = BLACK; <span class="comment">// 最终根节点为黑色节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向以node为根的红黑树中插入元素(key, value)，递归算法</span></span><br><span class="line">    <span class="comment">// 返回插入新节点后红黑树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            size ++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value); <span class="comment">// 默认插入红色节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">            node.left = add(node.left, key, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span>)</span><br><span class="line">            node.right = add(node.right, key, value);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line">            node.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left))</span><br><span class="line">            node = leftRotate(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left))</span><br><span class="line">            node = rightRotate(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right))</span><br><span class="line">            flipColors(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根节点的二分搜索树中，key所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key.equals(node.key))</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> getNode(node.left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// if(key.compareTo(node.key) &gt; 0)</span></span><br><span class="line">            <span class="keyword">return</span> getNode(node.right, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(root, key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span></span>&#123;</span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key + <span class="string">" doesn't exist!"</span>);</span><br><span class="line"></span><br><span class="line">        node.value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以node为根的二分搜索树的最小值所在的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除掉以node为根的二分搜索树中的最小节点</span></span><br><span class="line">    <span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size --;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.left = removeMin(node.left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从二分搜索树中删除键为key的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node node = getNode(root, key);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = remove(root, key);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, K key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">            node.left = remove(node.left , key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key.compareTo(node.key) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            node.right = remove(node.right, key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;   <span class="comment">// key.compareTo(node.key) == 0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Node rightNode = node.right;</span><br><span class="line">                node.right = <span class="keyword">null</span>;</span><br><span class="line">                size --;</span><br><span class="line">                <span class="keyword">return</span> rightNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Node leftNode = node.left;</span><br><span class="line">                node.left = <span class="keyword">null</span>;</span><br><span class="line">                size --;</span><br><span class="line">                <span class="keyword">return</span> leftNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">            <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">            Node successor = minimum(node.right);</span><br><span class="line">            successor.right = removeMin(node.right);</span><br><span class="line">            successor.left = node.left;</span><br><span class="line"></span><br><span class="line">            node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树性质解释"><a href="#红黑树性质解释" class="headerlink" title="红黑树性质解释"></a>红黑树性质解释</h3><p> 前面已经解释性质来，这就不重复了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    我们通过插入操作讲解了红黑树的调整及性质的推导，删除操作其实也是在BST操作之上添加调整，可能要更复杂一些但大致原理类似，调整的基础操作也是上面讲到的，相信仔细读完本篇之后对红黑树有一定的感觉了，接下来我们将红黑树、BST、AVL综合对比一下：</p><ol><li>对于完全随机的数据，普通的二分搜索树很好用! 缺点:极端情况退化成链表(或者高度不平衡)</li><li>对于查询较多的使用情况，AVL树很好用!</li><li>红黑树牺牲了平衡性(21ogn的高度) 但是 统计性能更优(综合增删改查所有的操作)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 - 经典数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的回退操作</title>
      <link href="/2022/07/15/git-2022-07-14-git%E7%9A%84%E5%9B%9E%E9%80%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/07/15/git-2022-07-14-git%E7%9A%84%E5%9B%9E%E9%80%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="查看提交的log日志"><a href="#查看提交的log日志" class="headerlink" title="查看提交的log日志"></a>查看提交的log日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><h3 id="回退提交点"><a href="#回退提交点" class="headerlink" title="回退提交点"></a>回退提交点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commidId</span><br></pre></td></tr></table></figure><h3 id="显示所有提交点"><a href="#显示所有提交点" class="headerlink" title="显示所有提交点"></a>显示所有提交点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><blockquote><p>有时候回退回去，还想回退回来，这时候 git log 就已经删除了所有commit id了，只能用这个命令，这个日志 包括所有的 分之合并等提交点都会显示，但是注意，只是显示本地进行的操作，如果从git拉取下来后，不是在本地进行的提交，直接回退后，可能 git reflog 也不显示提交点，这时候直接用 git pull 拉取下来就行了，然后到你指定的位移.</p></blockquote><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自建项目上传github常用操作</title>
      <link href="/2022/07/15/git-2022-07-14-%E8%87%AA%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0github%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/07/15/git-2022-07-14-%E8%87%AA%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0github%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>在idea 初始化本地项目后</strong></p><ol><li><p>在github创建仓库</p></li><li><p>添加git远程仓库绑定:git remote add origin <a href="https://github.com/zzzzxd/xxxx" target="_blank" rel="noopener">https://github.com/zzzzxd/xxxx</a> 当前没有追踪远程分支,拉取时候绑定远程分支:git pull origin master </p></li></ol><p><strong>常见的其他操作</strong></p><ul><li><ul><li>删除项目当前分支对远程分支的关联</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></li><li><ul><li>项目以http方式重新关联</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin http://gitlab.xxxxxxxx.cn:xxxx/xxxxxx/mall.git</span><br></pre></td></tr></table></figure><ul><li><ul><li>项目中本地分支和远程分支关联</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull git branch --set-upstream-to=origin/de</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase 数据倾斜原因及解决方案</title>
      <link href="/2022/07/15/hbase-2022-07-15-Hbase-%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/07/15/hbase-2022-07-15-Hbase-%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近公司在做ip维度表，数据量比较大，上亿条数据了，拿hbase存储，进行实时关联。发现ip存到region上倾斜的比较严重，考虑到基数比较大，后期增量相对比较少，可以做一个预分区，使数据分布均衡，借此机会，从网上搜集了一下资料，总结一下常见的解决方案。</p></blockquote><h3 id="热点与数据倾斜"><a href="#热点与数据倾斜" class="headerlink" title="热点与数据倾斜"></a><strong>热点与数据倾斜</strong></h3><p><strong>热点：</strong></p><p>​    热点发生在大量的client直接访问集群的一个或极少数个节点（访问可能是读，写或者其他操作。</p><p>​    大量访问会使热点region所在的单个机器超出自身承受能力，引起性能下降甚至region不可用，这也会影响同一个RegionServer上的其他region，由于主机无法服务其他region的请求，造成资源浪费。设计良好的数据访问模式以使集群被充分，均衡的利用。</p><p><strong>数据倾斜：         </strong></p><p>​    Hbase可以被划分为多个Region，但是默认创建时只有一个Region分布在集群的一个节点上，数据一开始时都集中在这个Region，也就是集中在这一个节点上，就算region存储达到临界值时被划分，数据也是存储在少数节点上。这就是数据倾斜。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ul><li>HBase中的行是按照rowkey的字典顺序排序的，这种设计优化了scan操作，可以将相关的行以及会被一起读取的行存取在临近位置，便于scan。</li><li><strong>rowkey设计是热点的源头</strong>。</li><li><p>HBase中，表会被划分为1…n个Region，被托管在RegionServer中。Region有二个重要的属性: StartKey与EndKey</p><p>表示这个Region维护的rowKey范围，当我们要读/写数据时，如果rowKey落在某个start-end key范围内，那么就会定位到目标        region并且读/写到相关的数据。</p></li><li><p>默认的情况下，创建一张表是，只有1个region，</p><pre><code>  start-end key没有边界，所有数据都在这个region里装，然而，当数据越来越多，region的size越来越大时，大到一定的阀值，hbase认为再往这个region里塞数据已经不合适了，就会找到一个midKey将region一分为二，成为2个region,这个过程称为分裂(region-split)。而midKey则为这二个region的临界（这个中间值这里不作讨论是如何被选取的）。 此时，我们假设假设rowkey小于midKey则为阴被塞到1区，大于等于midKey则会被塞到2区，如果 rowkey还是顺序增大的，那数据就总会往2区里面写数据，而1区现在处于一个被冷落的状态，而且是半满的。2区的数据满了 会被再次分裂成2个区，如此不断产生被冷落而且不满的Region，当然，这些region有提供数据查询的功能。</code></pre><p>这种设计是分布式系统一个很大的弊端，而且这样导致数据倾斜和热点问题，从而导致集群的资源得不到很好的利用。</p></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="预分区"><a href="#预分区" class="headerlink" title="预分区"></a><strong>预分区</strong></h4><h5 id="预分区的必要性"><a href="#预分区的必要性" class="headerlink" title="预分区的必要性"></a><strong>预分区的必要性</strong></h5><p>HBase默认建表时有一个region，这个region的rowkey是没有边界的，即没有startkey和endkey，在数据写入时，所有数据都会写入这个默认的region，当一个region中数据超过阈值时（默认10G），此region已经不能承受不断增长的数据量，会进行split，分成2个region。在此过程中，会产生两个问题：</p><ul><li><ul><li><ol><li>我们的数据会不断的往一个region上写,会有写热点问题。</li></ol></li><li><ol><li>region split会消耗宝贵的集群I/O资源。如果在任务执行时region分裂，会导致任务失败</li></ol></li></ul></li></ul><p>基于此我们可以控制在建表的时候，创建多个空region，并确定每个region的起始和终止rowky，这样只要我们的rowkey设计能均匀的命中各个region，就不会存在写热点问题。自然split的几率也会大大降低。当然随着数据量的不断增长，该split的还是要进行split。像这样预先创建hbase表分区的方式，称之为预分区</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h5><p>首先看没有预分区的：</p><p>一个region里面就保存了7000w（虽然7000w对hbase来说是小case）的数据，读写压力全在这一个region上，会很容易造成热点问题</p><p>​    <img src="1.png" alt="0"></p><h5 id="使用Hbase-shell进行预分区"><a href="#使用Hbase-shell进行预分区" class="headerlink" title="使用Hbase shell进行预分区"></a><strong>使用Hbase shell进行预分区</strong></h5><p>前面说到了rowkey的排列是根据字典排序，所以rowkey寻址的时候是和startkey、endkey进行比较，在字典排序在哪个region的startkey、endkey之间，就落在哪个region</p><p>​                create ‘t1’,’f1’,SPLITS =&gt; [‘10’,’20’,’30’]              </p><p>​    <img src="2.png" alt="0"></p><p>四个分区，rowkey如果是‘0232534’，就落在第一个分区，‘13003424’落在第二个分区</p><p>​                 hbase&gt;create ‘t14’,’f’,SPLITS_FILE=&gt;’splits.txt’              </p><p>​    <img src="3.png" alt="0"></p><p>​    <img src="4.png" alt="0"></p><h4 id="rowkey设计避免热点"><a href="#rowkey设计避免热点" class="headerlink" title="rowkey设计避免热点"></a><strong>rowkey设计避免热点</strong></h4><h5 id="常用手段"><a href="#常用手段" class="headerlink" title="常用手段"></a><strong>常用手段</strong></h5><ul><li>⽣成随机数、hash、散列值</li></ul><p>​                ⽐如: 原本rowKey为1001的，SHA1后变成：dd01903921ea24941c26a48f2cec24e0bb0e8cc7       原本rowKey为3001的，SHA1后变成：49042c54de64a1e9bf0b33e00245660ef92dc7bd      原本rowKey为5001的，SHA1后变成：7b61dec07e02c188790670af43e717f0f46e8913      在做此操作之前，⼀般我们会选择从数据集中抽取样本，来决定什么样的rowKey来Hash后作为每个分区的临 界值。              </p><ul><li>字符串反转</li></ul><p>​                以手机号为rowkey，可以将手机号反转后的字符串作为rowkey，这样的就避免了以手机号那样比较固定开头导致热点问题    例如：20191124000001转成10000042119102           20191124000002转成20000042119102              </p><ul><li>加盐</li></ul><p>​                这里所说的加盐不是密码学中的加盐，而是在rowkey的前面增加随机数，具体就是给rowkey分配一个随机前缀以使得它和之前的rowkey的开头不同。 分配的前缀种类数量应该和你想使用数据分散到不同的region的数量一致。 加盐之后的rowkey就会根据随机生成的前缀分散到各个region上，以避免热点              </p><p>还有其他方案、具体情况具体分析。</p>]]></content>
      
      
      <categories>
          
          <category> Hbase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式AKF拆分原则</title>
      <link href="/2022/07/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-07-15-%E5%88%86%E5%B8%83%E5%BC%8FAKF%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99/"/>
      <url>/2022/07/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1-2022-07-15-%E5%88%86%E5%B8%83%E5%BC%8FAKF%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载 :<a href="https://blog.csdn.net/tomcosin/article/details/119332084" target="_blank" rel="noopener">https://blog.csdn.net/tomcosin/article/details/119332084</a></p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    当我们需要分布式系统提供更强的性能时，该怎样扩展系统呢？什么时候该加机器？什么时候该重构代码？扩容时，究竟该选择哈希算法还是最小连接数算法，才能有效提升性能？</p><p>在面对 Scalability 可伸缩性问题时，我们必须有一个系统的方法论，才能应对日益复杂的分布式系统。这一讲我将介绍 AKF 立方体理论，它定义了扩展系统的 3 个维度，我们可以综合使用它们来优化性能。</p><h3 id="什么是AKF"><a href="#什么是AKF" class="headerlink" title="什么是AKF"></a>什么是AKF</h3><p>AKF 立方体也叫做scala cube，它在《The Art of Scalability》一书中被首次提出，旨在提供一个系统化的扩展思路。AKF 把系统扩展分为以下三个维度：</p><ul><li>X 轴：直接水平复制应用进程来扩展系统。</li><li>Y 轴：将功能拆分出来扩展系统。</li><li>Z 轴：基于用户信息扩展系统。</li></ul><p>如下图所示：</p><p>​    <img src="1.png" alt="0"></p><h3 id="如何基于-AKF-X-轴扩展系统？"><a href="#如何基于-AKF-X-轴扩展系统？" class="headerlink" title="如何基于 AKF X 轴扩展系统？"></a><strong>如何基于 AKF X 轴扩展系统？</strong></h3><p>我们日常见到的各种系统扩展方案，都可以归结到 AKF 立方体的这三个维度上。而且，我们可以同时组合这 3 个方向上的扩展动作，使得系统可以近乎无限地提升性能。为了避免对 AKF 的介绍过于抽象，下面我用一个实际的例子，带你看看这 3 个方向的扩展到底该如何应用。</p><p>假定我们开发一个博客平台，用户可以申请自己的博客帐号，并在其上发布文章。最初的系统考虑了 MVC 架构，将数据状态及关系模型交给数据库实现，应用进程通过 SQL 语言操作数据模型，经由 HTTP 协议对浏览器客户端提供服务，如下图所示：</p><p>​    <img src="2.png" alt="0"></p><p>在这个架构中，处理业务的应用进程属于无状态服务，用户数据全部放在了关系数据库中。因此，当我们在应用进程前加 1 个负载均衡服务后，就可以通过部署更多的应用进程，提供更大的吞吐量。而且，初期增加应用进程，RPS 可以获得线性增长，很实用，如下图：</p><p>​    <img src="3.png" alt="0"></p><p>这就叫做沿 AKF X 轴扩展系统。这种扩展方式最大的优点，就是开发成本近乎为零，而且实施起来速度快！在搭建好负载均衡后，只需要在新的物理机、虚拟机或者微服务上复制程序，就可以让新进程分担请求流量，而且不会影响事务 Transaction 的处理。</p><p>当然，AKF X 轴扩展最大的问题是只能扩展无状态服务，当有状态的数据库出现性能瓶颈时，X 轴是无能为力的。例如，当用户数据量持续增长，关系数据库中的表就会达到百万、千万行数据，SQL 语句会越来越慢，这时可以沿着 AKF Z 轴去分库分表提升性能。又比如，当请求用户频率越来越高，那么可以把单实例数据库扩展为主备多实例，沿 Y 轴把读写功能分离提升性能。下面我们先来看 AKF Y 轴如何扩展系统。</p><h3 id="如何基于-AKF-Y-轴扩展系统？"><a href="#如何基于-AKF-Y-轴扩展系统？" class="headerlink" title="如何基于 AKF Y 轴扩展系统？"></a><strong>如何基于 AKF Y 轴扩展系统？</strong></h3><p>当数据库的 CPU、网络带宽、内存、磁盘 IO 等某个指标率先达到上限后，系统的吞吐量就达到了瓶颈，此时沿着 AKF X 轴扩展系统，是没有办法提升性能的。</p><p>在现代经济中，更细分、更专业的产业化、供应链分工，可以给社会带来更高的效率，而 AKF Y 轴与之相似，当遇到上述性能瓶颈后，拆分系统功能，使得各组件的职责、分工更细，也可以提升系统的效率。比如，当我们将应用进程对数据库的读写操作拆分后，就可以扩展单机数据库为主备分布式系统，使得主库支持读写两种 SQL，而备库只支持读 SQL。这样，主库可以轻松地支持事务操作，且它将数据同步到备库中也并不复杂，如下图所示：</p><p>​    <img src="4.png" alt="0"></p><p>当然，上图中如果读性能达到了瓶颈，我们可以继续沿着 AKF X 轴，用复制的方式扩展多个备库，提升读 SQL 的性能，可见，AKF 多个轴完全可以搭配着协同使用。</p><p>拆分功能是需要重构代码的，它的实施成本比沿 X 轴简单复制扩展要高得多。在上图中，通常关系数据库的客户端 SDK 已经支持读写分离，所以实施成本由中间件承担了，这对我们理解 Y 轴的实施代价意义不大，所以我们再来看从业务上拆分功能的例子。</p><p>当这个博客平台访问量越来越大时，一台主库是无法扛住所有写流量的。因此，基于业务特性拆分功能，就是必须要做的工作。比如，把用户的个人信息、身份验证等功能拆分出一个子系统，再把文章、留言发布等功能拆分到另一个子系统，由无状态的业务层代码分开调用，并通过事务组合在一起，如下图所示：</p><p>​    <img src="5.png" alt="0"></p><p>这样，每个后端的子应用更加聚焦于细分的功能，它的数据库规模会变小，也更容易优化性能。比如，针对用户登录功能，你可以再次基于 Y 轴将身份验证功能拆分，用 Redis 等服务搭建一个基于 LRU 算法淘汰的缓存系统，快速验证用户身份。</p><p>然而，沿 Y 轴做功能拆分，实施成本非常高，需要重构代码并做大量测试工作，上线部署也很复杂。比如上例中要对数据模型做拆分（如同一个库中的表拆分到多个库中，或者表中的字段拆到多张表中），设计组件之间的 API 交互协议，重构无状态应用进程中的代码，为了完成升级还要做数据迁移，等等。</p><p>解决数据增长引发的性能下降问题，除了成本较高的 AKF Y 轴扩展方式外，沿 Z 轴扩展系统也很有效，它的实施成本更低一些，下面我们具体看一下。</p><p><strong>如何基于 AKF Z 轴扩展系统？</strong></p><p>不同于站在服务角度扩展系统的 X 轴和 Y 轴，AKF Z 轴则从用户维度拆分系统，它不仅可以提升数据持续增长降低的性能，还能基于用户的地理位置获得额外收益。</p><p>仍然以上面虚拟的博客平台为例，当注册用户数量上亿后，无论你如何基于 Y 轴的功能去拆分表（即“垂直”地拆分表中的字段），都无法使得关系数据库单个表的行数在千万级以下，这样表字段的 B 树索引非常庞大，难以完全放在内存中，最后大量的磁盘 IO 操作会拖慢 SQL 语句的执行。</p><p>这个时候，关系数据库最常用的分库分表操作就登场了，它正是 AKF 沿 Z 轴拆分系统的实践。比如已经含有上亿行数据的 User 用户信息表，可以分成 10 个库，每个库再分成 10 张表，利用固定的哈希函数，就可以把每个用户的数据映射到某个库的某张表中。这样，单张表的数据量就可以降低到 1 百万行左右，如果每个库部署在不同的服务器上（具体的部署方式视访问吞吐量以及服务器的配置而定），它们处理的数据量减少了很多，却可以独占服务器的硬件资源，性能自然就有了提升。如下图所示：</p><p>​    <img src="6.png" alt="0"></p><p>分库分表是关系数据库中解决数据增长压力的最有效办法，但分库分表同时也导致跨表的查询语句复杂许多，而跨库的事务几乎难以实现，因此这种扩展的代价非常高。当然，如果你使用的是类似 MySQL 这些成熟的关系数据库，整个生态中会有厂商提供相应的中间件层，使用它们可以降低 Z 轴扩展的代价。</p><p>再比如，最开始我们采用 X 轴复制扩展的服务，它们的负载均衡策略很简单，只需要选择负载最小的上游服务器即可，比如 RoundRobin 或者最小连接算法都可以达到目的。但若上游服务器通过 Y 轴扩展，开启了缓存功能，那么考虑到缓存的命中率，就必须改用 Z 轴扩展的方式，基于用户信息做哈希规则下的新路由，尽量将同一个用户的请求命中相同的上游服务器，才能充分提高缓存命中率。</p><p>Z 轴扩展还有一个好处，就是可以充分利用 IDC 与用户间的网速差，选择更快的 IDC 为用户提供高性能服务。网络是基于光速传播的，当 IDC 跨城市、国家甚至大洲时，用户访问不同 IDC 的网速就会有很大差异。当然，同一地域内不同的网络运营商之间，也会有很大的网速差。</p><p>例如你在全球都有 IDC 或者公有云服务器时，就可以通过域名为当地用户就近提供服务，这样性能会高很多。事实上，CDN 技术就基于 IP 地址的位置信息，就近为用户提供静态资源的高速访问。</p><p>下图中，我使用了 2 种 Z 轴扩展系统的方式。首先是基于客户端的地理位置，选择不同的 IDC 就近提供服务。其次是将不同的用户分组，比如免费用户组与付费用户组，这样在业务上分离用户群体后，还可以有针对性地提供不同水准的服务。</p><p>​    <img src="7.png" alt="0"></p><p>沿 AKF Z 轴扩展系统可以解决数据增长带来的性能瓶颈，也可以基于数据的空间位置提升系统性能，然而它的实施成本比较高，尤其是在系统宕机、扩容时，一旦路由规则发生变化，会带来很大的数据迁移成本，[第 24 讲] 我将要介绍的一致性哈希算法，其实就是用来解决这一问题的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>这一讲我们介绍了如何基于 AKF 立方体的 X、Y、Z 三个轴扩展系统提升性能。</p><ul><li><p>X 轴扩展系统时实施成本最低，只需要将程序复制到不同的服务器上运行，再用下游的负载均衡分配流量即可。X 轴只能应用在无状态进程上，故无法解决数据增长引入的性能瓶颈。</p></li><li><p>Y 轴扩展系统时实施成本最高，通常涉及到部分代码的重构，但它通过拆分功能，使系统中的组件分工更细，因此可以解决数据增长带来的性能压力，也可以提升系统的总体效率。比如关系数据库的读写分离、表字段的垂直拆分，或者引入缓存，都属于沿 Y 轴扩展系统。</p></li><li><p>Z 轴扩展系统时实施成本也比较高，但它基于用户信息拆分数据后，可以在解决数据增长问题的同时，基于地理位置就近提供服务，进而大幅度降低请求的时延，比如常见的 CDN 就是这么提升用户体验的。但 Z 轴扩展系统后，一旦发生路由规则的变动导致数据迁移时，运维成本就会比较高。</p></li></ul><p>​    当然，X、Y、Z 轴的扩展并不是孤立的，我们可以同时应用这 3 个维度扩展系统。分布式系统非常复杂，AKF 给我们提供了一种自上而下的方法论，让我们能够针对不同场景下的性能瓶颈，以最低的成本提升性能。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解一致性哈希算法</title>
      <link href="/2022/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-2022-07-15-%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2022/07/15/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-2022-07-15-%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载:<a href="https://segmentfault.com/a/1190000021199728" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021199728</a></p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>要了解一致性哈希，首先我们必须了解传统的哈希及其在大规模分布式系统中的局限性。简单地说，哈希就是一个键值对存储，在给定键的情况下，可以非常高效地找到所关联的值。假设我们要根据其邮政编码查找城市中的街道名称。一种最简单的实现方式是将此信息以哈希字典的形式进行存储 <code>&lt;Zip Code，Street Name&gt;</code>。</p><p>当数据太大而无法存储在一个节点或机器上时，问题变得更加有趣，系统中需要多个这样的节点或机器来存储它。比如，使用多个 Web 缓存中间件的系统。<strong>那如何确定哪个 key 存储在哪个节点上？针对该问题，最简单的解决方案是使用哈希取模来确定。</strong> 给定一个 key，先对 key 进行哈希运算，将其除以系统中的节点数，然后将该 key 放入该节点。同样，在获取 key 时，对 key 进行哈希运算，再除以节点数，然后转到该节点并获取值。上述过程对应的哈希算法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_number &#x3D; hash(key) % N # 其中 N 为节点数。</span><br></pre></td></tr></table></figure><p>下图描绘了多节点系统中的传统的哈希取模算法，基于该算法可以实现简单的负载均衡。</p><p><img src="traditional-hashing.png" alt="traditional-hashing"></p><h3 id="一、传统哈希取模算法的局限性"><a href="#一、传统哈希取模算法的局限性" class="headerlink" title="一、传统哈希取模算法的局限性"></a>一、传统哈希取模算法的局限性</h3><p>下面我们来分析一下传统的哈希及其在大规模分布式系统中的局限性。这里我们直接使用我之前所写文章 <a href="https://segmentfault.com/a/1190000021136424" target="_blank" rel="noopener">布隆过滤器你值得拥有的开发利器</a> 中定义的 SimpleHash 类，然后分别对 <strong>semlinker、kakuqo 和 test</strong> 3 个键进行哈希运算并取余，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleHash &#123;</span><br><span class="line">    private int cap;</span><br><span class="line">    private int seed;</span><br><span class="line"></span><br><span class="line">    public SimpleHash(int cap, int seed) &#123;</span><br><span class="line">        this.cap &#x3D; cap;</span><br><span class="line">        this.seed &#x3D; seed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int hash(String value) &#123;</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        int len &#x3D; value.length();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            result &#x3D; seed * result + value.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return (cap - 1) &amp; result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SimpleHash simpleHash &#x3D; new SimpleHash(2 &lt;&lt; 12, 8);</span><br><span class="line">        System.out.println(&quot;node_number&#x3D;hash(\&quot;semlinker\&quot;) % 3 -&gt; &quot; + </span><br><span class="line">          simpleHash.hash(&quot;semlinker&quot;) % 3);</span><br><span class="line">        System.out.println(&quot;node_number&#x3D;hash(\&quot;kakuqo\&quot;) % 3 -&gt; &quot; + </span><br><span class="line">          simpleHash.hash(&quot;kakuqo&quot;) % 3);</span><br><span class="line">        System.out.println(&quot;node_number&#x3D;hash(\&quot;test\&quot;) % 3 -&gt; &quot; + </span><br><span class="line">          simpleHash.hash(&quot;test&quot;) % 3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码成功运行后，在控制台会输出以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node_number&#x3D;hash(&quot;semlinker&quot;) % 3 -&gt; 1</span><br><span class="line">node_number&#x3D;hash(&quot;kakuqo&quot;) % 3 -&gt; 2</span><br><span class="line">node_number&#x3D;hash(&quot;test&quot;) % 3 -&gt; 0</span><br></pre></td></tr></table></figure><p>基于以上的输出结果，我们可以创建以下表格：</p><p><img src="ch-three-nodes-hash.png" alt="ch-three-nodes-hash"></p><h4 id="1-1-节点减少的场景"><a href="#1-1-节点减少的场景" class="headerlink" title="1.1 节点减少的场景"></a>1.1 节点减少的场景</h4><p><strong>在分布式多节点系统中，出现故障很常见。任何节点都可能在没有任何事先通知的情况下挂掉，针对这种情况我们期望系统只是出现性能降低，正常的功能不会受到影响。</strong> 对于原始示例，当节点出现故障时会发生什么？原始示例中有的 3 个节点，假设其中 1 个节点出现故障，这时节点数发生了变化，节点个数从 3 减少为 2，此时表格的状态发生了变化：</p><p><img src="ch-two-nodes-hash.png" alt="ch-two-nodes-hash"></p><p>很明显节点的减少会导致键与节点的映射关系发生变化，这个变化对于新的键来说并不会产生任何影响，但对于已有的键来说，将导致节点映射错误，以 “semlinker” 为例，变化前系统有 3 个节点，该键对应的节点编号为 1，当出现故障时，节点数减少为 2 个，此时该键对应的节点编号为 0。</p><h4 id="1-2-节点增加的场景"><a href="#1-2-节点增加的场景" class="headerlink" title="1.2 节点增加的场景"></a>1.2 节点增加的场景</h4><p><strong>在分布式多节点系统中，对于某些场景比如节日大促，就需要对服务节点进行扩容，以应对突发的流量。</strong> 对于原始示例，当增加节点会发生什么？原始示例中有的 3 个节点，假设进行扩容临时增加了 1 个节点，这时节点数发生了变化，节点个数从 3 增加为 4 个，此时表格的状态发生了变化：</p><p><img src="ch-four-nodes-hash.png" alt="ch-four-nodes-hash"></p><p>很明显节点的增加也会导致键与节点的映射关系发生变化，这个变化对于新的键来说并不会产生任何影响，但对于已有的键来说，将导致节点映射错误，同样以 “semlinker” 为例，变化前系统有 3 个节点，该键对应的节点编号为 1，当增加节点时，节点数增加为 4 个，此时该键对应的节点编号为 2。</p><p>当集群中节点的数量发生变化时，之前的映射规则就可能发生变化。如果集群中每个机器提供的服务没有差别，这不会有什么影响。<strong>但对于分布式缓存这种的系统而言，映射规则失效就意味着之前缓存的失效，若同一时刻出现大量的缓存失效，则可能会出现 “缓存雪崩”，这将会造成灾难性的后果。</strong></p><p><strong>要解决此问题，我们必须在其余节点上重新分配所有现有键，这可能是非常昂贵的操作，并且可能对正在运行的系统产生不利影响。当然除了重新分配所有现有键的方案之外，还有另一种更好的方案即使用一致性哈希算法。</strong></p><h3 id="二、一致性哈希算法"><a href="#二、一致性哈希算法" class="headerlink" title="二、一致性哈希算法"></a>二、一致性哈希算法</h3><p>一致性哈希算法在 1997 年由麻省理工学院提出，是一种特殊的哈希算法，在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式<a href="https://baike.baidu.com/item/哈希表/5981869" target="_blank" rel="noopener">哈希表</a>（Distributed Hash Table，DHT）中存在的动态伸缩等问题 。</p><h4 id="2-1-一致性哈希算法优点"><a href="#2-1-一致性哈希算法优点" class="headerlink" title="2.1 一致性哈希算法优点"></a>2.1 一致性哈希算法优点</h4><ul><li><p>可扩展性。一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少，相比传统哈希算法大大节省了数据移动的开销 。</p></li><li><p>更好地适应数据的快速增长。采用一致性哈希算法分布数据，当数据不断增长时，部分虚拟节点中可能包含很多数据、造成数据在虚拟节点上分布不均衡，此时可以将包含数据多的虚拟节点分裂，这种分裂仅仅是将原有的虚拟节点一分为二、不需要对全部的数据进行重新哈希和划分。</p><p>虚拟节点分裂后，如果物理服务器的负载仍然不均衡，只需在服务器之间调整部分虚拟节点的存储分布。这样可以随数据的增长而动态的扩展物理服务器的数量，且代价远比传统哈希算法重新分布所有数据要小很多。</p></li></ul><h4 id="2-2-一致性哈希算法与哈希算法的关系"><a href="#2-2-一致性哈希算法与哈希算法的关系" class="headerlink" title="2.2 一致性哈希算法与哈希算法的关系"></a>2.2 一致性哈希算法与哈希算法的关系</h4><p>一致性哈希算法是在哈希算法基础上提出的，在动态变化的分布式环境中，哈希算法应该满足的几个条件：平衡性、单调性和分散性。</p><ul><li>平衡性：是指 hash 的结果应该平均分配到各个节点，这样从算法上解决了负载均衡问题。</li><li>单调性：是指在新增或者删减节点时，不影响系统正常运行。</li><li>分散性：是指数据应该分散地存放在分布式集群中的各个节点（节点自己可以有备份），不必每个节点都存储所有的数据。</li></ul><h3 id="三、一致性哈希算法原理"><a href="#三、一致性哈希算法原理" class="headerlink" title="三、一致性哈希算法原理"></a>三、一致性哈希算法原理</h3><p>一致性哈希算法通过一个叫作一致性哈希环的数据结构实现。这个环的起点是 0，终点是 2^32 - 1，并且起点与终点连接，故这个环的整数分布范围是 [0, 2^32-1]，如下图所示：</p><p><img src="hash-ring.png" alt="hash-ring"></p><h4 id="3-1-将对象放置到哈希环"><a href="#3-1-将对象放置到哈希环" class="headerlink" title="3.1 将对象放置到哈希环"></a>3.1 将对象放置到哈希环</h4><p>假设我们有 “semlinker”、”kakuqo”、”lolo”、”fer” 四个对象，分别简写为 o1、o2、o3 和 o4，然后使用哈希函数计算这个对象的 hash 值，值的范围是 [0, 2^32-1]：</p><p><img src="hash-ring-hash-objects.png" alt="hash-ring-hash-objects"></p><p>图中对象的映射关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash(o1) &#x3D; k1; hash(o2) &#x3D; k2;</span><br><span class="line">hash(o3) &#x3D; k3; hash(o4) &#x3D; k4;</span><br></pre></td></tr></table></figure><h4 id="3-2-将服务器放置到哈希环"><a href="#3-2-将服务器放置到哈希环" class="headerlink" title="3.2 将服务器放置到哈希环"></a>3.2 将服务器放置到哈希环</h4><p>接着使用同样的哈希函数，我们将服务器也放置到哈希环上，可以选择服务器的 IP 或主机名作为键进行哈希，这样每台服务器就能确定其在哈希环上的位置。这里假设我们有 3 台缓存服务器，分别为 cs1、cs2 和 cs3：</p><p><img src="/hash-ring-hash-servers.png" alt="hash-ring-hash-servers"></p><p>图中服务器的映射关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(cs1) &#x3D; t1; hash(cs2) &#x3D; t2; hash(cs3) &#x3D; t3; # Cache Server</span><br></pre></td></tr></table></figure><h4 id="3-3-为对象选择服务器"><a href="#3-3-为对象选择服务器" class="headerlink" title="3.3 为对象选择服务器"></a>3.3 为对象选择服务器</h4><p>将对象和服务器都放置到同一个哈希环后，在哈希环上顺时针查找距离这个对象的 hash 值最近的机器，即是这个对象所属的机器。以 o2 对象为例，顺序针找到最近的机器是 cs2，故服务器 cs2 会缓存 o2 对象。而服务器 cs1 则缓存 o1，o3 对象，服务器 cs3 则缓存 o4 对象。</p><p><img src="hash-ring-objects-servers.png" alt="hash-ring-objects-servers"></p><h4 id="3-4-服务器增加的情况"><a href="#3-4-服务器增加的情况" class="headerlink" title="3.4 服务器增加的情况"></a>3.4 服务器增加的情况</h4><p>假设由于业务需要，我们需要增加一台服务器 cs4，经过同样的 hash 运算，该服务器最终落于 t1 和 t2 服务器之间，具体如下图所示：</p><p><img src="http://cdn.semlinker.com/hash-ring-add-server.jpg" alt="hash-ring-add-server"></p><p>对于上述的情况，只有 t1 和 t2 服务器之间的对象需要重新分配。在以上示例中只有 o3 对象需要重新分配，即它被重新到 cs4 服务器。在前面我们已经分析过，如果使用简单的取模方法，当新添加服务器时可能会导致大部分缓存失效，而使用一致性哈希算法后，这种情况得到了较大的改善，因为只有少部分对象需要重新分配。</p><h4 id="3-5-服务器减少的情况"><a href="#3-5-服务器减少的情况" class="headerlink" title="3.5 服务器减少的情况"></a>3.5 服务器减少的情况</h4><p>假设 cs3 服务器出现故障导致服务下线，这时原本存储于 cs3 服务器的对象 o4，需要被重新分配至 cs2 服务器，其它对象仍存储在原有的机器上。</p><p><img src="hash-ring-remove-server.png" alt="hash-ring-remove-server"></p><h4 id="3-6-虚拟节点"><a href="#3-6-虚拟节点" class="headerlink" title="3.6 虚拟节点"></a>3.6 虚拟节点</h4><p>到这里一致性哈希的基本原理已经介绍完了，但对于新增服务器的情况还存在一些问题。新增的服务器 cs4 只分担了 cs1 服务器的负载，服务器 cs2 和 cs3 并没有因为 cs4 服务器的加入而减少负载压力。如果 cs4 服务器的性能与原有服务器的性能一致甚至可能更高，那么这种结果并不是我们所期望的。</p><p><strong>针对这个问题，我们可以通过引入虚拟节点来解决负载不均衡的问题。即将每台物理服务器虚拟为一组虚拟服务器，将虚拟服务器放置到哈希环上，如果要确定对象的服务器，需先确定对象的虚拟服务器，再由虚拟服务器确定物理服务器。</strong></p><p><img src="ch-virtual-nodes.png" alt="ch-virtual-nodes"></p><p>图中 o1 和 o2 表示对象，v1 ~ v6 表示虚拟服务器，s1 ~ s3 表示物理服务器。</p><h3 id="四、一致性哈希算法实现"><a href="#四、一致性哈希算法实现" class="headerlink" title="四、一致性哈希算法实现"></a>四、一致性哈希算法实现</h3><p>这里我们只介绍不带虚拟节点的一致性哈希算法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import java.util.SortedMap;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"></span><br><span class="line">public class ConsistentHashingWithoutVirtualNode &#123;</span><br><span class="line">    &#x2F;&#x2F;待添加入Hash环的服务器列表</span><br><span class="line">    private static String[] servers &#x3D; &#123;&quot;192.168.0.1:8888&quot;, &quot;192.168.0.2:8888&quot;, </span><br><span class="line">      &quot;192.168.0.3:8888&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;key表示服务器的hash值，value表示服务器</span><br><span class="line">    private static SortedMap&lt;Integer, String&gt; sortedMap &#x3D; new TreeMap&lt;Integer, String&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;程序初始化，将所有的服务器放入sortedMap中</span><br><span class="line">    static &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; servers.length; i++) &#123;</span><br><span class="line">            int hash &#x3D; getHash(servers[i]);</span><br><span class="line">            System.out.println(&quot;[&quot; + servers[i] + &quot;]加入集合中, 其Hash值为&quot; + hash);</span><br><span class="line">            sortedMap.put(hash, servers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;得到应当路由到的结点</span><br><span class="line">    private static String getServer(String key) &#123;</span><br><span class="line">        &#x2F;&#x2F;得到该key的hash值</span><br><span class="line">        int hash &#x3D; getHash(key);</span><br><span class="line">        &#x2F;&#x2F;得到大于该Hash值的所有Map</span><br><span class="line">        SortedMap&lt;Integer, String&gt; subMap &#x3D; sortedMap.tailMap(hash);</span><br><span class="line">        if (subMap.isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果没有比该key的hash值大的，则从第一个node开始</span><br><span class="line">            Integer i &#x3D; sortedMap.firstKey();</span><br><span class="line">            &#x2F;&#x2F;返回对应的服务器</span><br><span class="line">            return sortedMap.get(i);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;第一个Key就是顺时针过去离node最近的那个结点</span><br><span class="line">            Integer i &#x3D; subMap.firstKey();</span><br><span class="line">            &#x2F;&#x2F;返回对应的服务器</span><br><span class="line">            return subMap.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用FNV1_32_HASH算法计算服务器的Hash值</span><br><span class="line">    private static int getHash(String str) &#123;</span><br><span class="line">        final int p &#x3D; 16777619;</span><br><span class="line">        int hash &#x3D; (int) 2166136261L;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length(); i++)</span><br><span class="line">            hash &#x3D; (hash ^ str.charAt(i)) * p;</span><br><span class="line">        hash +&#x3D; hash &lt;&lt; 13;</span><br><span class="line">        hash ^&#x3D; hash &gt;&gt; 7;</span><br><span class="line">        hash +&#x3D; hash &lt;&lt; 3;</span><br><span class="line">        hash ^&#x3D; hash &gt;&gt; 17;</span><br><span class="line">        hash +&#x3D; hash &lt;&lt; 5;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果算出来的值为负数则取其绝对值</span><br><span class="line">        if (hash &lt; 0)</span><br><span class="line">            hash &#x3D; Math.abs(hash);</span><br><span class="line">        return hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] keys &#x3D; &#123;&quot;semlinker&quot;, &quot;kakuqo&quot;, &quot;fer&quot;&#125;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; keys.length; i++)</span><br><span class="line">            System.out.println(&quot;[&quot; + keys[i] + &quot;]的hash值为&quot; + getHash(keys[i])</span><br><span class="line">                    + &quot;, 被路由到结点[&quot; + getServer(keys[i]) + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码成功运行后，在控制台会输出以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[192.168.0.1:8888]加入集合中, 其Hash值为1326271016</span><br><span class="line">[192.168.0.2:8888]加入集合中, 其Hash值为1132535844</span><br><span class="line">[192.168.0.3:8888]加入集合中, 其Hash值为115798597</span><br><span class="line"></span><br><span class="line">[semlinker]的hash值为1549041406, 被路由到结点[192.168.0.3:8888]</span><br><span class="line">[kakuqo]的hash值为463104755, 被路由到结点[192.168.0.2:8888]</span><br><span class="line">[fer]的hash值为1677150790, 被路由到结点[192.168.0.3:8888]</span><br></pre></td></tr></table></figure><p>上面我们只介绍了不带虚拟节点的一致性哈希算法实现，如果有的小伙伴对带虚拟节点的一致性哈希算法感兴趣，可以参考 <a href="https://blog.csdn.net/suifeng629/article/details/81567777" target="_blank" rel="noopener">一致性Hash(Consistent Hashing)原理剖析及Java实现</a> 这篇文章。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>​    本文通过示例介绍了传统的哈希取模算法在分布式系统中的局限性，进而在针对该问题的解决方案中引出了一致性哈希算法。一致性哈希算法在 1997 年由麻省理工学院提出，是一种特殊的哈希算法，在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。在介绍完一致性哈希算法的作用和优点等相关知识后，我们以图解的形式生动介绍了一致性哈希算法的原理，最后给出了不带虚拟节点的一致性哈希算法的 Java 实现。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一 致性Hash </tag>
            
            <tag> 分布式算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树等价树2-3树</title>
      <link href="/2022/07/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-14-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AD%89%E4%BB%B7%E6%A0%912-3%E6%A0%91/"/>
      <url>/2022/07/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-2022-07-14-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AD%89%E4%BB%B7%E6%A0%912-3%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote><p>一提到红黑树大家应该都不陌生，jdk集合容器底层大量应用红黑树来实现，是一种高性能应用广泛的数据结构。可是，对于它的性质原理很多人理解起来都比较困难，在&lt;&lt;算法&gt;&gt;本书中，作者也是红黑树的作者，采用2-3树来引入的方式介绍红黑树的原理，所以我们接下来要聊的2-3树是理解红黑树很重要的数据结构，可以这么说，看懂了本篇，再了解红黑树和2-3树的等价关系，就很容易理解红黑树的性质了。</p></blockquote><h3 id="2-3树基本性质"><a href="#2-3树基本性质" class="headerlink" title="2-3树基本性质"></a>2-3树基本性质</h3><ul><li>2-3树是一种绝对平衡的树 即平衡因子为0；</li><li>2-3树也是一种BST，满足二分搜索树的基本性质</li><li>2-3树，只有两种节点，2节点（节点有两个孩子）和3节点（节点有3个孩子）</li><li>2-3树 每插入一个元素，一定是插在叶子节点上，再去进行调整。</li></ul><h3 id="2-3树插入过程"><a href="#2-3树插入过程" class="headerlink" title="2-3树插入过程"></a>2-3树插入过程</h3><p>​    假设你已经具备BST、AVL平衡树的基础，那么基本性质了解以后，我们再看一下插入过程，基本上就搞定2-3树了</p><p>​    以 42、37、12、18、6、11、5 元素插入为例，详细的插入过程如下图:    <img src="1.png" alt=""></p><p>  详细解释一下:</p><pre><code>1. 第一次插入元素42时，整树为空，形成根节点1. 接着插入37，要和根节点先合并，检查是不是形成4节点，没有则无需调整。1. 插入12，此时只有根节点这个叶节点，先合并，检查形成4节点，需要拆分，37成根1. 插入18，和BST一样的插入顺序，来到12点叶节点位置，合并，检查无需拆分。1. 插入6，又来到12点叶节点，形成4节点，拆分。1. 插入11，来到6节点的位置，无需拆分。1. 插入5，此时引起了连锁的拆分反应，最终12成根。</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>可以发现，2-3 树由于这种插入调整的规则，使得它在任何时刻都是绝对平衡，2-3树可能是我们见到的唯一绝对平衡的数据结构。</li><li>2-3树 每次插入一定是插入在叶节点上，再去考虑调整。</li><li>2-3树不难，它的绝对平衡的特性，使得它查找迅速，并且插入速度并不是特别慢</li><li>先牢记插入合并以及拆分的过程，等理解红黑树性质时会有大用。</li></ol><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 算法 - 经典数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化Mysql数据导入的几种方法</title>
      <link href="/2022/07/14/mysql-2022-07-14-%E4%BC%98%E5%8C%96Mysql%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/14/mysql-2022-07-14-%E4%BC%98%E5%8C%96Mysql%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析sql执行效率的方法</title>
      <link href="/2022/07/14/mysql-2022-07-14-%E5%88%86%E6%9E%90sql%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/14/mysql-2022-07-14-%E5%88%86%E6%9E%90sql%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql ONLY_FULL_BY_GROUP_MODE模式</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql-ONLY-FULL-BY-GROUP-MODE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql-ONLY-FULL-BY-GROUP-MODE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>ONLY_FULL_BY_GROUP_MODE</strong></p><p>​    如果此模式不开启，则对mysql的扩展生效 此时与标准sql 有两个明显的区别：</p><p>​    <strong>允许在select list，having condition 和 order by 中使用没有出现在group by 中的字段，此时mysql会随机选择没有出现在group by字段中的值，其效果和使用ANY—VALUE效果是一样的</strong></p><p><strong>允许在having condition 中使用select list 中的alias</strong></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql DateTime与Timestamp区别</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql-DateTime%E4%B8%8ETimestamp%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql-DateTime%E4%B8%8ETimestamp%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 创建用户相关操作常用命令</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>创建用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#39;username&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39;;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#39;dog&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;192.168.1.101_&#39; IDENDIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line">CREATE USER &#39;pig&#39;@&#39;%&#39; IDENTIFIED BY &#39;&#39;;CREATE USER &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure><p><strong>赋予权限</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON test.user TO &#39;pig&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON *.* TO &#39;pig&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON maindataplus.* TO &#39;pig&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure><p><strong>刷新权限</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><strong>删除用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql dump 命令</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql-dump-%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql-dump-%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="命令及解释"><a href="#命令及解释" class="headerlink" title="命令及解释"></a>命令及解释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -ubackup -p123456 -h 192.168.1.2 backup_test &gt; D:\bak\bakcup.sql </span><br><span class="line">在这段命令中：mysqldump 是myqldump的程序名了；</span><br><span class="line">  -u 是数据库的用户名，后面紧跟着用户名backup；</span><br><span class="line">  -p 是数据库的密码，后面同样紧跟着密码，注意是-p和密码之间不能有空格；</span><br><span class="line">  -h 是数据库的地址，如果没有此项表明是备份本地的数据库；</span><br><span class="line">(对我们用的阿里云，就是rds暴露在外的公网地址  xxxx.mysql.rds.aliyuncs.com)</span><br><span class="line">backup_test 要备份的数据库名称；</span><br><span class="line">表明该数据库备份到后面的文件，紧跟当然是备份文件的地址了，注意要用绝对文件路径，文件的后缀也可以用.txt。</span><br><span class="line">一旦执行该命令后，mysqldump立即执行备份操作。远程备份数据库要似乎网络的情况，一般远程备份需要一定的时间的。</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>实际mysql dump记住两条命令就够了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">导入：</span><br><span class="line">mysql -u root -p database &lt; data.sql</span><br><span class="line">导出：</span><br><span class="line">（整个数据库）</span><br><span class="line">mysqldump -u 账户 -p密码 数据库名字 &gt; data.sql</span><br><span class="line">（单个表）</span><br><span class="line">mysqldump  -u 账户 -p密码 数据库名字 表名字 &gt; data.sql</span><br></pre></td></tr></table></figure><blockquote><p>补充：</p><p>导出一个表，只有表结构</p><p>mysqldump -u用户名 -p 密码 -d数据库名 表名&gt; 导出的文件名</p><p>C:\Users\jack&gt; mysqldump -uroot -pmysql -d sva_rec date_rec_drv&gt; e:\date_rec_drv.sql</p><p>导出一个数据库结构</p><p>C:\Users\jack&gt; mysqldump -uroot -pmysql -d sva_rec &gt; e:\sva_rec.sql</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 停止启动mysql常用命令</title>
      <link href="/2022/07/14/mysql-2022-07-14-linux-%E5%81%9C%E6%AD%A2%E5%90%AF%E5%8A%A8mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/14/mysql-2022-07-14-linux-%E5%81%9C%E6%AD%A2%E5%90%AF%E5%8A%A8mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="查看mysql版本"><a href="#查看mysql版本" class="headerlink" title="查看mysql版本"></a>查看mysql版本</h3><p>方法一：status;</p><p>方法二：select version();</p><h3 id="Mysql启动、停止、重启常用命令"><a href="#Mysql启动、停止、重启常用命令" class="headerlink" title="Mysql启动、停止、重启常用命令"></a>Mysql启动、停止、重启常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a、启动方式</span><br><span class="line">1、使用 service 启动：</span><br><span class="line">    [root@localhost &#x2F;]# service mysqld start (5.0版本是mysqld)</span><br><span class="line">    [root@szxdb etc]# service mysql start (5.5.7版本是mysql)</span><br><span class="line">2、使用 mysqld 脚本启动：</span><br><span class="line">    &#x2F;etc&#x2F;inint.d&#x2F;mysqld start</span><br><span class="line">3、使用 safe_mysqld 启动：</span><br><span class="line">    safe_mysqld&amp;</span><br><span class="line">b、停止</span><br><span class="line">    1、使用 service 启动：</span><br><span class="line">    service mysqld stop</span><br><span class="line">    2、使用 mysqld 脚本启动：</span><br><span class="line">    &#x2F;etc&#x2F;inint.d&#x2F;mysqld stop</span><br><span class="line">    3、mysqladmin shutdown</span><br><span class="line">c、重启</span><br><span class="line">    1、使用 service 启动：</span><br><span class="line">    service mysqld restart</span><br><span class="line">    service mysql restart (5.5.7版本命令)</span><br><span class="line">    2、使用 mysqld 脚本启动：</span><br><span class="line">    &#x2F;etc&#x2F;init.d&#x2F;mysqld restart</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql中Binlog常用命令</title>
      <link href="/2022/07/14/mysql-2022-07-14-Mysql%E4%B8%ADBinlog%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/14/mysql-2022-07-14-Mysql%E4%B8%ADBinlog%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Binlog使用场景"><a href="#Binlog使用场景" class="headerlink" title="Binlog使用场景"></a>Binlog使用场景</h3><ul><li>主从数据库复制： Mysql Replication在Master端开启Binlog，Master把日志传递给Slavers，以达到    Master-slavers主从数据同步。</li><li>数据恢复： 使用mysqlbinlog工具来恢复数据</li></ul><h3 id="Binlog常用命令"><a href="#Binlog常用命令" class="headerlink" title="Binlog常用命令"></a>Binlog常用命令</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 查看是否启用Binlog日志</span><br><span class="line">show variables like &#39;log_bin&#39;;</span><br><span class="line"></span><br><span class="line"># 查看详细的日志配置信息</span><br><span class="line">show global variables like &#39;%log%&#39;;</span><br><span class="line"></span><br><span class="line"># Mysql数据存储目录</span><br><span class="line">show variables like &#39;%dir%&#39;;</span><br><span class="line"></span><br><span class="line"># 查看binlog数据目录</span><br><span class="line">show global variables like &#39;%log_bin%&#39;;</span><br><span class="line"></span><br><span class="line">##以下命令需要super权限</span><br><span class="line"># 查看当前服务器binlog文件及大小</span><br><span class="line">show binary logs;</span><br><span class="line"></span><br><span class="line"># 查看 binlog 内容</span><br><span class="line">show binlog events;</span><br><span class="line"></span><br><span class="line"># 查看具体一个binlog文件的内容 （in 后面为binlog的文件名）</span><br><span class="line">show binlog events in &#39;master.000003&#39;;</span><br><span class="line"></span><br><span class="line"># 设置binlog文件保存事件，过期删除，单位天</span><br><span class="line">set global expire_log_days&#x3D;3; </span><br><span class="line"></span><br><span class="line"># 删除当前的binlog文件</span><br><span class="line">reset master; </span><br><span class="line"></span><br><span class="line"># 删除slave的中继日志</span><br><span class="line">reset slave;</span><br><span class="line"></span><br><span class="line"># 删除指定日期前的日志索引中binlog日志文件</span><br><span class="line">purge master logs before &#39;2019-03-12 21:54:00&#39;;</span><br><span class="line"></span><br><span class="line"># 删除指定日志文件</span><br><span class="line">purge master logs to &#39;master.000001&#39;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda、pip、virtualenv的几点区别</title>
      <link href="/2022/07/14/python-2022-07-14-conda%E3%80%81pip%E3%80%81virtualenv%E7%9A%84%E5%87%A0%E7%82%B9%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/07/14/python-2022-07-14-conda%E3%80%81pip%E3%80%81virtualenv%E7%9A%84%E5%87%A0%E7%82%B9%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="conda"><a href="#conda" class="headerlink" title="conda"></a><strong>conda</strong></h3><p>首先，<strong>conda是一个通用的包管理器</strong>，意思是什么语言的包都可以用其进行管理，自然也就包括Python了。在安装Anaconda或者Miniconda时，会对conda进行一同安装。其中Anaconda作为Python的发行版，相当于在Python的基础上自带了常用第三方库，而Miniconda则相当于是一个conda环境的安装程序，只包含了conda及其依赖项，这样就可以减少一些不需要的第三方库的安装，所以Miniconda所占用的空间很小。</p><h3 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h3><p>Pip同conda一样，也是一个包管理器，并且是Python官方认可的包管理器。其中pip的含义是Pip Installs Packages。最常用于安装在Python包索引（PyPI, Python Package Index <a href="https://pypi.python.org/pypi）上发布的包。因此，在通过conda" target="_blank" rel="noopener">https://pypi.python.org/pypi）上发布的包。因此，在通过conda</a> list命令查看当前环境下已安装的包时，通过pip的源是pypi。</p><p>​    <img src="1.png" alt="在这里插入图片描述"></p><h3 id="conda和pip安装库的区别"><a href="#conda和pip安装库的区别" class="headerlink" title="conda和pip安装库的区别"></a>conda和pip安装库的区别</h3><p>在Anaconda中，<strong>无论在哪个环境下</strong>，只要通过conda install xxx的方式安装的库都会放在Anaconda的pkgs目录下，如:E:\python\anaconda\pkgs\numpy-1.18.1-py36h48dd78f_1。这样的好处就是，当在某个环境下已经下载好了某个库，再在另一个环境中还需要这个库时，就可以直接从pkgs目录下将该库复制至新环境（将这个库的Lib\site-packages中的文件复制到当前新环境下Lib中的第三方库中，也即Lib\site-packages中，这个过程相当于通过pip install xxx进行了安装）而不用重复下载。</p><h3 id="conda和pip卸载库的区别"><a href="#conda和pip卸载库的区别" class="headerlink" title="conda和pip卸载库的区别"></a>conda和pip卸载库的区别</h3><p>pip是在<strong>特定的环境</strong>中进行库的安装，所以卸载库也是一样的道理，通过pip uninstall xxx就可以将该环境下Lib\site-packages中对应的库进行卸载了。</p><p>如果通过conda uninstall xxx删除当前环境下某个库时，删除的只是当前环境下site-packages目录中该库的内容，它的效果和通过pip uninstall xxx是一样的。如果再到另一个环境中通过conda install xxx下载这个库，则还是通过将pkgs目录下的库复制到当前环境。若要清空这个pkgs下的已下载库，可以通过命令conda clean -h进行实现。</p><h3 id="conda和virtualenv的区别"><a href="#conda和virtualenv的区别" class="headerlink" title="conda和virtualenv的区别"></a>conda和virtualenv的区别</h3><p>virtualenv和conda都可以做包隔离，类似java中的maven管理，实现一个项目一个独立的环境，简单的包隔离，用virtualenv就可以实现，它本质就是创建一个文件夹，作为一个独立的环境，运行文件夹bin下的激活脚本就进入这个独立的环境，在这个环境中，所有运行的python命令，安装的脚本都是在这个目录下的，是独立全局的python环境的。但有一个缺点就是virtualenv使用哪个版本的pip命令就会安装到当前目录的bin下，那么用virtualenv创建的虚拟环境就是这个版本的环境，是不能实现版本切换的，换句话说创建出的所有环境都是同一个python版本，要想实现多版本的环境就得用conda，很好的工具，可以详细学习一下。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH协议原理及最佳实践</title>
      <link href="/2022/07/07/network-2022-07-07-SSH%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2022/07/07/network-2022-07-07-SSH%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="初识SSH"><a href="#初识SSH" class="headerlink" title="初识SSH"></a>初识SSH</h3><p>​    维基百科是这样描述ssh协议的 ：</p><blockquote><p><strong>Secure Shell</strong>（安全外壳协议，简称<strong>SSH</strong>）是一种加密的<a href="https://zh.m.wikipedia.org/wiki/网络传输协议" target="_blank" rel="noopener">网络传输协议</a>，可在不安全的网络中为网络服务提供安全的传输环境<a href="https://zh.m.wikipedia.org/zh-cn/Secure_Shell#cite_note-rfc4251-1" target="_blank" rel="noopener">[1]</a>。SSH通过在网络中创建<a href="https://zh.m.wikipedia.org/w/index.php?title=安全隧道&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">安全隧道</a>（英语：<a href="https://en.wikipedia.org/wiki/secure_channel" target="_blank" rel="noopener">secure channel</a>）来实现SSH客户端与服务器之间的连接<a href="https://zh.m.wikipedia.org/zh-cn/Secure_Shell#cite_note-rfc4252-2" target="_blank" rel="noopener">[2]</a>。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输<a href="https://zh.m.wikipedia.org/wiki/命令行界面" target="_blank" rel="noopener">命令行界面</a>和远程执行命令。</p></blockquote><p>通常是用来建立一条相对安全的连接，而不是明文传输。</p><h3 id="SSH原理"><a href="#SSH原理" class="headerlink" title="SSH原理"></a>SSH原理</h3><p>同样，SSH协议也要解决三个问题，即</p><ul><li>如何保证信息的保密性？</li><li>如和保证信息的完整性？</li><li>如何识别对方身份？</li></ul><p>其中前两个问题，通过使用对称加密与非对称加密、数字签名可以解决，在之前的HTTPS相关的文章中都有详细的解释，现在我们重点讨论第三个问题，如何识别对方身份？我们知道HTTPS是通过CA机构颁发证书的方式来确认对方的身份，而SSH的公钥和私钥是客户端自己生成，所以没有CA机构认证。SSH协议有两种识别对方身份的方式</p><ul><li>基于口令的认证</li><li>基于公钥认证</li></ul><h4 id="口令认证"><a href="#口令认证" class="headerlink" title="口令认证"></a>口令认证</h4><p>基于口令的认证，我个人认为，实际上基于口令的认证是第一次的时候需要与 “正确的对方”建立连接,次此连接之后给主机生成一个唯一的host_key，相当于”认识“了这台主机，下次建立链接时，如果与一台错误的主机建立链接时，通过host_key便可以识别出来！</p><p> 如下图，第一登陆的时候:</p><p><img src="1.png" alt=""></p><p>图中显是的是，先通过RSA算法对域名+ip这个key结合公钥对应的唯一信息生成加密串,然后做一个hash提取一个比较短的摘要作为指纹（实际上这只是通俗的解释，指纹的生成用到ECDSA算法，这个算法比较复杂，本人也没详细了解就不做过多的介绍了）,询问你是否继续连接</p><p><img src="2.png" alt=""></p><p>其中know hosts用来存放已经接受识别的身份。</p><p>再下一步就是输入密码进行登录了，其实验证是双向的，指纹验证是验证服务器，用户密码就是服务器再验证客户端了。</p><h4 id="公钥认证"><a href="#公钥认证" class="headerlink" title="公钥认证"></a>公钥认证</h4><p>第一种验证方式，再服务器验证客户端的时候，每次都得使用密码来进行验证，所以通过有了第二种方式来进行免密登录。</p><p>具体流程如下:</p><ol><li>Client将自己的公钥存放在Server上，追加在文件authorized_keys中。</li><li>Server端接收到Client的连接请求后，会在authorized_keys中匹配到Client的公钥pubKey，并生成随机数R，用Client的公钥对该随机数进行加密得到pubKey(R)<br> ，然后将加密后信息发送给Client。</li><li>Client端通过私钥进行解密得到随机数R，然后对随机数R和本次会话的SessionKey利用MD5生成摘要Digest1，发送给Server端。</li><li>Server端会也会对R和SessionKey利用同样摘要算法生成Digest2。</li><li>Server端会最后比较Digest1和Digest2是否相同，完成认证过程。</li></ol><p><img src="3.png" alt="img"></p><blockquote><p>在步骤1中，Client将自己的公钥存放在Server上。需要用户手动将公钥copy到server上。这就是在配置ssh的时候进程进行的操作。下图是GitHub上SSH keys设置视图：</p></blockquote><p><img src="4.png" alt=""></p><h3 id="SSH的最佳实践"><a href="#SSH的最佳实践" class="headerlink" title="SSH的最佳实践"></a>SSH的最佳实践</h3><h4 id="SSH生成的文件"><a href="#SSH生成的文件" class="headerlink" title="SSH生成的文件"></a>SSH生成的文件</h4><p><img src="5.png" alt=""></p><ol><li>d_rsa：保存私钥</li><li>id_rsa.pub：保存公钥</li><li>authorized_keys：保存已授权的客户端公钥</li><li>known_hosts：保存已认证的远程主机ID</li></ol><p><img src="6.png" alt=""></p><blockquote><p>需要注意的是：一台主机可能既是Client，也是Server。所以会同时拥有authorized_keys和known_hosts。</p></blockquote><h4 id="有关文件的常见疑问"><a href="#有关文件的常见疑问" class="headerlink" title="有关文件的常见疑问"></a>有关文件的常见疑问</h4><ol><li>known_hosts中存储的内容是什么？</li></ol><p>​    known_hosts中存储是已认证的远程主机host key，每个SSH Server都有一个<strong>secret, unique ID, called a host key</strong>。    </p><ol><li>host key何时加入known_hosts的？</li></ol><p>​    当我们第一次通过SSH登录远程主机的时候</p><ol><li>为什么需要known_hosts？</li></ol><p>​    最后探讨下为什么需要known_hosts，这个文件主要是通过Client和Server的双向认证，从而避免中间人（<strong>man-in-the-middle attack</strong>）攻击，每次Client向Server发起连接的时候，不仅仅Server要验证Client的合法性，Client同样也需要验证Server的身份，SSH client就是通过known_hosts中的host key来验证Server的身份的。</p><blockquote><p>这中方案足够安全吗？当然不，比如第一次连接一个未知Server的时候，known_hosts还没有该Server的host key，这不也可能遭到<strong>中间人</strong>攻击吗？这可能只是安全性和可操作性之间的折中吧。</p></blockquote><h4 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h4><p>记住三步走:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.客户端生成公钥私钥 </span><br><span class="line">ssh-keygen</span><br><span class="line">2.上传公钥到服务器</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.100</span><br><span class="line">3.免密登录</span><br><span class="line">ssh root@192.168.1.100</span><br></pre></td></tr></table></figure><blockquote><p>参考:<a href="https://www.jianshu.com/p/33461b619d53" target="_blank" rel="noopener">https://www.jianshu.com/p/33461b619d53</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> ssh </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS与&quot;中间人攻击&quot;</title>
      <link href="/2022/07/07/network-2022-07-07-HTTPS%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/"/>
      <url>/2022/07/07/network-2022-07-07-HTTPS%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="引导问题"><a href="#引导问题" class="headerlink" title="引导问题"></a>引导问题</h3><ol><li><p>为什么使用Https是安全的？</p></li><li><p>Https的底层原理如何实现？</p></li><li><p>使用Https是绝对安全的吗？</p></li></ol><h3 id="Https实现原理"><a href="#Https实现原理" class="headerlink" title="Https实现原理"></a>Https实现原理</h3><p>Https协议在内容传输上使用的加密是“对称加密”，而“非对称加密”只作用于证书验证阶段。Https的整体实现过程分为“证书验证”和“数据传输”两个阶段，过程如下所示：</p><ul><li>Https协议在内容传输上使用的加密是“对称加密”，而“非对称加密”只作用于证书验证阶段。</li><li>Https的整体实现过程分为“证书验证”和“数据传输”两个阶段，过程如下所示：</li></ul><p>​    <img src="1.png" alt="0"></p><p><strong>证书验证阶段</strong></p><ol><li><p>浏览器发起Https请求；</p></li><li><p>服务器端返回Https证书；</p></li><li><p>浏览器客户端验证证书是否合法，若不合法则提示警告</p></li></ol><p><strong>数据传输阶段</strong></p><ol><li><p>当证书验证合法后，在客户端本地生成随机数；</p></li><li><p>通过公钥加密随机数，并将加密后的随机数传输到服务端；</p></li><li><p>服务端通过私钥对接收到的加密随机数进行解密操作；</p></li><li><p>服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密操作后再进行内容传输。</p></li></ol><h3 id="为什么数据传输是用对称加密？"><a href="#为什么数据传输是用对称加密？" class="headerlink" title="为什么数据传输是用对称加密？"></a>为什么数据传输是用对称加密？</h3><p>首先，非对称加密的加密效率是非常低的，而http的应用场景通常存在着端与端之间的大量数据交互，从效率来说是无法接受的；</p><p>其次，在Https场景中只有服务端保存了私钥，而一对公私钥只能实现单向的加解密（即服务端无法使用私钥对传回浏览器客户端的数据进行加密，只能用于解密），所以Https中内容传输加密采取的是对称加密，而不是非对称加密（此处随机数则是对称加密的介体，即客户端和服务器端所拥有的随机数都是一致的，能够进行双向加解密）。</p><h3 id="为什么需要CA认证机构颁发证书？"><a href="#为什么需要CA认证机构颁发证书？" class="headerlink" title="为什么需要CA认证机构颁发证书？"></a>为什么需要CA认证机构颁发证书？</h3><p>Http协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而Https协议主要就是解决网络传输的安全性问题。</p><p>首先，我们假设不存在认证机构，任何人都可以制作证书，这存在的风险便是经典的“中间人攻击”问题。具体过程如下：</p><p>​    <img src="2.png" alt="0"></p><h3 id="“中间人攻击”原理"><a href="#“中间人攻击”原理" class="headerlink" title="“中间人攻击”原理"></a>“中间人攻击”原理</h3><ol><li><p>客户端请求被劫持（如DNS劫持等），所有的客户端请求均被转发至中间人的服务器；</p></li><li><p>中间人服务器返回中间人伪造的“伪证书”（包含伪公钥）；</p></li><li><p>客户端创建随机数，通过中间人证书的伪公钥对随机数进行加密后传输给中间人，然后凭随机数构造对称加密算法对要进行传输的数据内容进行对称加密后传输；</p></li><li><p>中间人因为拥有客户端生成的随机数，从而能够通过对称加密算法进行数据内容解密；</p></li><li><p>中间人再以“伪客户端”的身份向正规的服务端发起请求；</p></li><li><p>因为中间人与服务器之间的通信过程是合法的，正规服务端通过建立的安全通道返回加密后的数据内容；</p></li><li><p>中间人凭借与正规服务器建立的对称加密算法进行数据内容解密；</p></li><li><p>中间人再通过与客户端建立的对称加密算法对正规服务器返回的数据内容进行加密传输；</p></li><li><p>客户端通过中间人建立的对称加密算法对返回的数据内容进行解密；</p></li></ol><p>由于缺少对证书的真伪性验证，所有客户端即使发起了Https请求，但客户端完全不知道自己发送的请求已经被第三方拦截，导致其中传输的数据内容被中间人窃取。</p><h3 id="浏览器如何确保CA证书的合法性？"><a href="#浏览器如何确保CA证书的合法性？" class="headerlink" title="浏览器如何确保CA证书的合法性？"></a>浏览器如何确保CA证书的合法性？</h3><ol><li>证书包含的主要信息：</li></ol><ul><li>颁发机构信息</li><li>公钥</li><li>公司信息</li><li>域名</li><li>有效期</li><li>指纹</li><li>等等</li></ul><ol><li>证书的合法性依据</li></ol><p>首先，权威机构是需要通过认证的。其次证书的可信性基于信任制，CA认证机构需要对其颁发的证书进行信用担保，只要是CA认证机构颁发的证书，我们就认为是合法的。CA认证机构会对证书申请人的信息进行审核的。</p><ol><li><p>浏览器如何验证证书的合法性？</p><p>浏览器发起https请求时，服务器会返回网站的SSL证书，浏览器需要对证书做以下验证：</p></li></ol><ul><li>验证域名、有效期等信息是否正确；</li><li>判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发的证书进行来源验证；</li><li>判断证书是否被篡改。需要与CA服务器进行对比校验；</li><li>判断证书是否已被吊销。通过CRL(Certificate Revocation List 证书注销列表) 和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中OCSP可用于第3步中以减少与CA服务器的交互，提高验证效率。</li></ul><p>以上任意一步都同时满足的情况下，浏览器才认为证书是合法的。</p><h3 id="只有认证机构可以生产证书吗？"><a href="#只有认证机构可以生产证书吗？" class="headerlink" title="只有认证机构可以生产证书吗？"></a>只有认证机构可以生产证书吗？</h3><p>如果需要浏览器不提示安全风险，那只能通过认证机构签发的证书。但浏览器通常只是会提示安全风险，并不会限制网站的访问，所有从技术上来说，谁都可以生产证书，只要有证书就能够完成网站的https传输。</p><h3 id="客户端的本地随机数被窃取了怎么办？"><a href="#客户端的本地随机数被窃取了怎么办？" class="headerlink" title="客户端的本地随机数被窃取了怎么办？"></a>客户端的本地随机数被窃取了怎么办？</h3><p>其实https并不包含对随机数的安全保证，https保证的只是数据传输过程安全，而随机数存储于本地，本地的安全属于另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。（这也反映了Https协议并不是绝对的安全的）</p><h3 id="使用Https被抓包了会怎样？"><a href="#使用Https被抓包了会怎样？" class="headerlink" title="使用Https被抓包了会怎样？"></a>使用Https被抓包了会怎样？</h3><p>由于Https的数据是加密，常规下抓包工具代理请求后抓到的包内容是加密状态的，无法直接查看。</p><p>但是，浏览器只会提示安全风险，如果用户授权仍然继续访问网站，完成请求。那么，只有客户端是我们自己的终端，我们授权的情况下，便能够建立中间人网络，而抓包工具作为中间人的代理。</p><p>通常， HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。</p><p>即是，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。</p><blockquote><p>引用:<a href="https://blog.csdn.net/Jop_qq/article/details/104362064" target="_blank" rel="noopener">https://blog.csdn.net/Jop_qq/article/details/104362064</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashSet与TreeSet源码解析</title>
      <link href="/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-HashSet%E4%B8%8ETreeSet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-HashSet%E4%B8%8ETreeSet%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TreeMap源码解析</title>
      <link href="/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-TreeMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-TreeMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>TreeMap是一种常用的key有序的数据结构,底层原理主要是用到动态平衡树，之前研究过了HashMap，解决冲突时链表会转化红黑树，同样这里平衡树依然是红黑树,可见这个数据结构的重要性了。如果红黑树原理不熟悉，那么涉及到具体的操作源码 可先跳过，有关红黑树只需要记住一点，红黑树和AVL都是动态平衡树的一种，都是在BST的基础上改进而来，基础的查询操作和BST一模一样，插入元素与删除元素，都是在元素插入或删除之后根据自己的特性取调整节点-“打补丁”以维持平衡。</p></blockquote><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li>结构图</li><li><p>类注释信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较器，如果外部有传进来 Comparator 比较器，首先用外部的</span></span><br><span class="line"><span class="comment">//如果外部比较器为空，则使用 key 自己的 Comparable 的 compareTo 方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"><span class="comment">//红黑树的根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"><span class="comment">//树节点的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//树的版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ol><p>看一下这棵红黑树的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> keyHash = (key==<span class="keyword">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> valueHash = (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">"="</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><ol><li>常用属性</li></ol><h3 id="常用操作源码解析"><a href="#常用操作源码解析" class="headerlink" title="常用操作源码解析"></a>常用操作源码解析</h3><ol><li>添加元素</li><li>查找</li><li>删除</li><li>迭代</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList源码解析</title>
      <link href="/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-LinkList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-LinkList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li><p>整体结构</p><p>LinkedList也是常用的一种数据结构,它和ArrayList在逻辑上都是线性结构，而在物理存储上ArrayList是连续存储，LinkedList是非连续存储。LinkedList实现是一个双向链表。Node节点源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     E item;</span><br><span class="line">     Node&lt;E&gt; next;</span><br><span class="line">     Node&lt;E&gt; prev;</span><br><span class="line">   </span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">         <span class="keyword">this</span>.item = element;</span><br><span class="line">         <span class="keyword">this</span>.next = next;</span><br><span class="line">         <span class="keyword">this</span>.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>只要稍微熟悉点数据结构对这种实现就不陌生，典型的链表结构，整体的图示如下:</p></li></ol><ol><li><p>类注释信息</p><pre><code>    1. 没有实现线程同步，多线程的时候需要外部来做同步。</code></pre><ol><li>ListIterator也是有“fail-fast”机制的。</li></ol></li><li><p>常见属性</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">transient int size &#x3D; 0;</span><br><span class="line">&#x2F;**</span><br><span class="line">     * Pointer to first node.</span><br><span class="line">     * Invariant: (first &#x3D;&#x3D; null &amp;&amp; last &#x3D;&#x3D; null) ||</span><br><span class="line">     *            (first.prev &#x3D;&#x3D; null &amp;&amp; first.item !&#x3D; null)</span><br><span class="line">     *&#x2F;</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">     * Pointer to last node.</span><br><span class="line">     * Invariant: (first &#x3D;&#x3D; null &amp;&amp; last &#x3D;&#x3D; null) ||</span><br><span class="line">     *            (last.next &#x3D;&#x3D; null &amp;&amp; last.item !&#x3D; null)</span><br><span class="line">     *&#x2F;</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h3 id="常用操作解析"><a href="#常用操作解析" class="headerlink" title="常用操作解析"></a>常用操作解析</h3><ol><li><p>添加</p><ol><li><p>从头插入</p><p>因为比较简单，都是最基础的数据结构，就不过多解释了，源码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从头部追加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//头节点赋值给临时变量</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="comment">//新建节点，前一个节点指向null，e是新建节点的值，f 是新建节点的下一个节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">        <span class="comment">//新建节点成为头节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="comment">//头节点为空，就是链表唯恐，头尾节点是一个节点。</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="comment">//上一个头节点的前一个节点就是当前节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>从尾巴插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从尾部开始追加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把尾节点数据暂存</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="comment">//新建新的节点，l 是前一个节点，e 是当前节点的值，后一个节点是 null</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//新建的节点放在尾部</span></span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="comment">//如果链表为空，头部和尾部是同一个节点，都是新建的节点</span></span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="comment">//否则把前尾节点的下一个节点，指向当前尾节点。</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        <span class="comment">//大小和版本更改</span></span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>删除</p><ol><li>从头删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从头删除节点 f 是链表头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拿出头节点的值，作为方法的返回值</span></span><br><span class="line">        <span class="keyword">final</span> E element = f.item;</span><br><span class="line">        <span class="comment">// 拿出头节点的下一个节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        <span class="comment">//帮助 GC 回收头节点</span></span><br><span class="line">        f.item = <span class="keyword">null</span>;</span><br><span class="line">        f.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 头节点的下一个节点成为头节点</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="comment">//如果 next 为空，表明链表为空</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//链表不为空，头节点的前一个节点指向 null</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//修改链表大小和版本</span></span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>从尾巴删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> l == last &amp;&amp; l != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> E element = l.item;</span><br><span class="line">        <span class="comment">//删除之前先保留前一个节点，last前移做准备</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = <span class="keyword">null</span>;</span><br><span class="line">        l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">            first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//修改版本</span></span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代</p><p>有关迭代器相关的知识，在ArrayList文章中已经解释的比较详细了，这里就重点看下源码好了，比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>LinkedList是双向链表，所以实现的接口也是双向迭代器,继承关系如下:</p><p><img src="2.png" alt=""></p><p>接下来我们看下，它的向前，向后的迭代方法</p><ol><li>　向后迭代</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断还有没有下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextIndex &lt; size;<span class="comment">//下一个节点的索引小于链表的大小，就有</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//检查期望版本号有无发生变化</span></span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="keyword">if</span> (!hasNext())<span class="comment">//再次检查</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="comment">// next 是当前节点</span></span><br><span class="line">  lastReturned = next;</span><br><span class="line">  <span class="comment">// next 是下一个节点了，为下次迭代做准备</span></span><br><span class="line">  next = next.next;</span><br><span class="line">  nextIndex++;</span><br><span class="line">  <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>向前</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果上次节点索引位置大于 0，就还有节点可以迭代</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nextIndex &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取前一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  <span class="comment">// next 为空场景：说明是第一次迭代，取尾节点(last)</span></span><br><span class="line">  <span class="comment">// next 不为空场景：说明已经发生过迭代了，直接取前一个节点即可(next.prev)</span></span><br><span class="line">  lastReturned = next = (next == <span class="keyword">null</span>) ? last : next.prev;</span><br><span class="line">  <span class="comment">// 索引位置变化</span></span><br><span class="line">  nextIndex--;</span><br><span class="line">  <span class="keyword">return</span> lastReturned.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>迭代器删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  checkForComodification();</span><br><span class="line">  <span class="comment">// lastReturned 为空，说明没有执行 next 或者 previos，直接报错</span></span><br><span class="line">  <span class="comment">// lastReturned = next() 方法执行的结果</span></span><br><span class="line">  <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  Node&lt;E&gt; lastNext = lastReturned.next;</span><br><span class="line">  <span class="comment">//删除当前节点</span></span><br><span class="line">  unlink(lastReturned);</span><br><span class="line">  <span class="comment">// 从尾到头递归顺序，并且是第一次迭代，并且要删除最后一个元素的情况下</span></span><br><span class="line">  <span class="comment">// 这种情况下，previous 方法里面设置了 lastReturned = next = last。</span></span><br><span class="line">  <span class="comment">// 我们必须把 next 设置成 null，这样在下次递归时，previous 方法才会让队尾最后一个节点赋值给 next</span></span><br><span class="line">  <span class="keyword">if</span> (next == lastReturned)</span><br><span class="line">    next = lastNext;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    nextIndex--;</span><br><span class="line">  lastReturned = <span class="keyword">null</span>;</span><br><span class="line">  expectedModCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    LinkedList无非是链表的封装，使用起来也很简单，它的插入与删除都是O(1) 的复杂度，虽然ArrayList也是O(1)的，但那是在均摊分析下的，LinkedList是真正的O (1)操作，主要是它不需要考虑动态的扩容缩容操作。</p><p>此外，LinkedList也常用来作为DeQueue的实现。Queue接口，我觉得它主要就是拿来做并发用的，有关它的知识点，有机会来介绍一下。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList源码解析</title>
      <link href="/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/07/06/%E6%BA%90%E7%A0%81-jdk-2022-07-06-ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ArrayList几乎是最常用的一种数据结构,本篇就研究一下ArrayList的常用操作的底层实现。通过学习底层实现的细节，帮助自己写出更优秀的代码 。</p></blockquote><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li>结构图</li></ol><p>​    ArrayList实际上就是封装了一个数组 ,代码体现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装的数组</span></span><br><span class="line"><span class="keyword">transient</span>  Object[] elementData;</span><br></pre></td></tr></table></figure><p><img src="1.jpg" alt=""></p><ol><li>类注释信息        </li></ol><ul><li>允许 put null 值，会自动扩容；</li><li>size、isEmpty、get、set、add 等方法时间复杂度都是 O (1)；</li></ul><ol><li>常见属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认数组大小10</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"> <span class="comment">//数组使用的大小</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">transient</span>  Object[] elementData;</span><br></pre></td></tr></table></figure><ul><li>DEFAULT_CAPACITY 表示数组的初始大小，默认是 10，这个数字要记住；</li><li>size 表示当前数组的大小，类型 int，没有使用 volatile 修饰，非线程安全的；</li><li>还有一个特别重要的变量,继承自AbstractList </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>​        这个变量与ArrayList源码注释中提到的”fail-fast”有关，这个变量源码中有详细的解释，翻译过来大致如下 ：</p><blockquote><p>此列表在结构上被修改的次数。结构修改是指改变列表的大小，或以某种方式干扰列表，使正在进行的迭代可能产生不正确的结果。</p><p>该字段由迭代器和列表迭代器方法返回的迭代器和列表迭代器实现使用。如果此字段的值意外更改，迭代器（或列表迭代器）将抛出ConcurrentModificationException，以响应下一个、删除、上一个、设置或添加操作。这提供了快速失效行为，而不是在迭代过程中面对并发修改时的不确定性行为。</p><p>子类使用此字段是可选的。如果子类希望提供故障快速迭代器（和列表迭代器），那么它只需在其add（int，E）和remove（int）方法（以及它覆盖的任何其他导致列表结构修改的方法）中增加该字段。对add（int，E）或remove（int）的单个调用只能向该字段添加一个，否则迭代器（和列表迭代器）将抛出虚假的ConcurrentModificationException。如果实现不希望提供故障快速迭代器，则可以忽略此字段。</p></blockquote><p>什么意思呢，所谓的”fail-fast”就是指如果在迭代时，容器发生结构性的改变，元素减少或者增多（注意更新不算）,那么遍历时会立刻抛出异常结束迭代，而这个”fail-fast”机制就是通过检查modCount变量来实现的，下文在源码中我会再详细解释。 算法导论中 也曾提过 “循环不变性”,是指如果在循环的某一次迭代开始之前是正确的，那么在下一次迭代开始之前，也是正确的，感觉是有一丢丢的联系。在很多框架的实现中也见过类似的操作，对List中的元素，会先copy一份出来，再去迭代，目的就是避免迭代过程中容器发生变更而必须加锁的操作。</p><h3 id="常用操作的源码解析"><a href="#常用操作的源码解析" class="headerlink" title="常用操作的源码解析"></a>常用操作的源码解析</h3><ol><li>初始化</li></ol><p>​        初始化代码有3种:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                         initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  无参数构造器，默认是空数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//指定初始数据初始化</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//elementData 是保存数组的容器，默认为 null</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">//如果给定的集合（c）数据有值，则进行拷贝赋值操作</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">      <span class="comment">//如果集合元素类型不是 Object 类型，才开始拷贝，否则不执行</span></span><br><span class="line">      <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 给定集合（c）无值，则默认空数组</span></span><br><span class="line">      <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意: ArrayList 无参构造器初始化时，默认大小是空数组，并不是10，10 是在第一次 add 的时候扩容的数组值。</p><ol><li>新增与扩容</li></ol><p>​    添加元素的逻辑很简单，首先判断是不是需要扩容，保证容量够用，然后添加元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确保数组大小足够，不够需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//直接赋值，线程不安全的</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>继续看 ensureCapacityInternal()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是空数组，就从最小容量和默认容量10之间取最大值</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">      minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保容积足够</span></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录数组被修改</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 如果我们希望的最小容量大于目前数组的长度，那么就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">      grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最终实际是在grow方法中进行了扩容，并且做了旧值的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老的数组大小2倍，最后把现有数据拷贝到新的数组里面去</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// oldCapacity &gt;&gt; 1 是把 oldCapacity / 2 的意思</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就去 Integer 的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// 通过复制进行扩容</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>添加以及扩容操作也比较简单，有两个细节，需要注意一下</p><ul><li><p>扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是 原来容量的 1.5 倍；</p></li><li><p>ArrayList 中的数组的最大值是 Integer.MAX_VALUE，超过这个值， JVM 就不会给数组 分配内存空间了。</p></li></ul><ol><li>扩容的具体实现</li></ol><p>​    实际上，我们看到最终调用的扩容，不过是用工具类新生成了一个数组，而这个工具类的底层实际调用的也是系统类，进行数组的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Params:</span><br><span class="line">  src – the source array.</span><br><span class="line">  srcPos – starting position in the source array.</span><br><span class="line">  dest – the destination array.</span><br><span class="line">  destPos – starting position in the destination data.</span><br><span class="line">  length – the number of array elements to be copied</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>删除</li></ol><p>​    删除元素有两种，一种是根据下标删除，一种是根据值删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据数组下标去删除</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">      System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                       numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据值去删除</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果值是空的，找到第一个值是空的删除</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">        <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">          fastRemove(index);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 值不为空，找到第一个和入参相等的删除</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">        <span class="comment">// 这里是根据  equals 来判断值相等的</span></span><br><span class="line">        <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">          fastRemove(index);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>迭代器遍历</li></ol><p>​    Iterator我们来详细解释一下，这种遍历的思想在国外的很多企业算法面试题中都有涉及，并且它还是一种设计模式，同时我们再看下上文中提到的modCount是如何来实现“fail-fast”机制的。</p><p>首先看一下ArrayList的iterator方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//源码带注释 * &lt;p&gt;The returned iterator is &lt;a href="#fail-fast"&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际就是返回来一个Iterator接口的实现<code>private class Itr implements Iterator&lt;E&gt;</code></p><p>我们先看一下Iterator接口，再看一下在ArrayList中的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中就这几个方法，其中<code>hasNext()</code>、<code>next()</code>、<code>remove()</code>方法通常是迭代器重点使用的方法,而<code>forEachRemaining()</code>方法我们也看到实际调用的也是迭代器，它是传入的是一个函数式接口, 接下来我们重点关注前三种方法的实现，先看下Iterator在ArrayList中的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 迭代过程中，下一个元素的位置，从 0 开始，用来控制拿下一个元素</span></span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="comment">// 新增时表示上一次迭代过程中，索引的位置，删除成功时为 -1</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="comment">// 迭代过程中期望数组修改版本号</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasNext()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> cursor != size;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>next()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span></span><br><span class="line">      checkForComodification();</span><br><span class="line">      <span class="comment">//本次迭代过程中，元素的索引位置</span></span><br><span class="line">      <span class="keyword">int</span> i = cursor;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      <span class="comment">// 下一次迭代时，元素的位置</span></span><br><span class="line">      cursor = i + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 返回元素值</span></span><br><span class="line">      <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有关这个”fail-fast”,我们看下checkForComodification()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>迭代器一创建出来，就会赋值expectedModCount，然后每次操作前会比较modCount与它的值，用来做检查，而迭代器删除的时候，会重新赋值<code>expectedModCount = modCount</code>,保证可以通过检查，下面我们也会看到。</p><p>remove()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 如果上一次操作时，数组的位置已经小于 0 了，说明数组已经被删除完了</span></span><br><span class="line">      <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">      <span class="comment">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span></span><br><span class="line">      checkForComodification();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        <span class="comment">// -1 表示元素已经被删除，这里也防止重复删除</span></span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 删除元素时 modCount 的值已经发生变化，再此赋值给 expectedModCount</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>​    ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多 个线程对这些变量进行操作时，可能会有值被覆盖的情况。</p><p>类注释中推荐我们使用 Collections#synchronizedList 来保证线程安全，SynchronizedList 是 通过在每个方法上面加上锁来实现，虽然实现了线程安全，但是性能大大降低，具体实现源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">synchronized</span> (mutex) &#123;<span class="comment">// synchronized 是一种 重量级锁，但具有锁升级的概念，mutex 表示一把互斥锁 </span></span><br><span class="line">    <span class="keyword">return</span> c.add(e); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    本文从 ArrayList 整体架构出发，落地到初始化、新增、扩容、删除、迭代等核心源码实现，我 们发现 ArrayList 其实就是围绕底层数组结构，各个 API 都是对数组的操作进行封装，让使用者 无需感知底层实现，只需关注如何使用即可。</p>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdk源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS对称与非对称加密协议</title>
      <link href="/2022/07/06/network-2022-07-06-Httptps%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/07/06/network-2022-07-06-Httptps%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>众所周知，WEB服务存在http和https两种通信方式，http默认采用80作为通讯端口，对于传输采用不加密的方式，https默认采用443，对于传输的数据进行加密传输。本文重点介绍https涉及到的对称加密和非对称加密协议原理。</p></blockquote><p>首先我们先不谈https，先从一个简单的通讯原理图讲起：</p><p>​    <img src="1.png" alt="0"></p><h4 id="http通信原理"><a href="#http通信原理" class="headerlink" title="http通信原理"></a>http通信原理</h4><p>客户端发送一句client hello给服务器端，服务器端返回一句serverhello给客户端，鉴于本文讨论是https的加密主题，我们只讨论信息传输的加密问题实现客户端和服务端发送的信息client hello 和server hello，即使中间的包被窃取了，也无法解密传输的内容</p><p>http：client hello和server hello在通讯的过程中，以明文的形式进行传输，采用wireshark抓包的效果如下图：</p><p>​    <img src="2.png" alt="0"></p><p>有没有感觉这个的信息传输是完全暴露在互联网上面，你请求的所有信息都可以被窥测到，是不是感觉心一凉，不过不用担心，我们的安全信息现在都是采用https的传输，后面讲到https的时候大家心里会顿时轻松。但这不是最关键的，http的传输最大的隐患是信息劫持和篡改，如下图：</p><p>​    <img src="3.png" alt="0"></p><p>可以看到，http的信息传输中，信息很容易被×××给劫持，更有甚者，×××可以伪装服务器将篡改后的信息返回给用户，试想一下，如果×××劫持的是你的银行信息，是不是很可怕。所以对于http传出存在的问题可以总结如下：</p><p>（1）信息篡改：修改通信的内容</p><p>（2）信息劫持：拦截到信息通信的内容</p><p>这些是http不安全的体现，说完http，我们回到本文的主题https，看下人家是怎么保护信息的，所有的请求信息都采用了TLS加密，如果没有秘钥是无法解析传输的是什么信息</p><p>​    <img src="4.png" alt="0"></p><h4 id="对于加密传输存在对称加密和非对称加密"><a href="#对于加密传输存在对称加密和非对称加密" class="headerlink" title="对于加密传输存在对称加密和非对称加密"></a>对于加密传输存在对称加密和非对称加密</h4><h5 id="对称加密-——对称加密传输"><a href="#对称加密-——对称加密传输" class="headerlink" title="对称加密 ——对称加密传输"></a>对称加密 ——对称加密传输</h5><p>​    <img src="5.png" alt="0"></p><p>当客户端发送Hello字符串的时候，在进行信息传输前，采用加密算法（上图中的秘钥S）将hello加密程JDuEW8&amp;*21!@#进行传输，即使中间被×××劫持了，如果没有对应的秘钥S也无法知道传出的信息为何物，在上图中信息的加密和解密都是通过同一个秘钥进行的，对于这种加密我们称之为对称加密，只要A和B之间知道加解密的秘钥，任何第三方都无法获取秘钥S，则在一定条件下，基本上解决了信息通信的安全问题。但在现实的情况下（www），实际的通讯模型远比上图复杂，下图为实际的通信模型</p><p>​    <img src="6.png" alt="0"></p><p>server和所有的client都采用同一个秘钥S进行加解密，但大家思考下，如果这样的话，无异于没有加密，请做下思考</p><p>由于server和所有的client都采用同一个秘钥S，则×××们作为一个client也可以获取到秘钥S，此地无银三百两。所以在实际的通讯中，一般不会采用同一个秘钥，而是采用不同的秘钥加解密，如下图——通过协商的方式获取不同的秘钥</p><p>​    <img src="7.png" alt="0"></p><p>如上图，A和server通信采用对称加密A算法，B和server通信采用对称秘钥B算法，因此可以很好的解决了不同的客户端采用相同的秘钥进行通讯的问题</p><p>那现在又存在问题了，A通过明文传输和server协商采用了加密算法A，但这条信息本身是没有加密的，因此×××们还是可以窃取到秘钥的，整个的通讯仍然存在风险。那该如何处理呢？有人说，把这条信息（协调秘钥的过程）再次加密，那是不是还要协商加密秘钥，如此反复，永无止境。从根本上无法解决信息通讯的安全问题</p><h5 id="如何对协商过程进行加密-（-非对称加密原理图）"><a href="#如何对协商过程进行加密-（-非对称加密原理图）" class="headerlink" title="如何对协商过程进行加密 （ 非对称加密原理图）"></a>如何对协商过程进行加密 （ 非对称加密原理图）</h5><p>​    <img src="8.png" alt="0"></p><p>在密码学跟对称加密一起出现的，应用最广的加密机制“非对称加密”，如上图，特点是私钥加密后的密文，只要是公钥，都可以解密，但是反过来公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。</p><p>基于上述的特点，我们可以得出如下结论：</p><p>（1）公钥是开放给所有人的，但私钥是需要保密的，存在于服务端</p><p>（2）服务器端server向client端（A、B…）的信息传输是不安全的：因为所有人都可以获取公钥</p><p>（3）但client端（A、B…）向server端的信息传输确实安全的：因为私钥只有server端存在</p><p>因此，如何协商加密算法的问题，我们解决了，非对称加密算法进行对称加密算法协商过程。</p><p>​    <img src="9.png" alt="0"></p><h5 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h5><p>信息通信采用http是不安全的，存在信息劫持、篡改的风险，https是加密传输，是安全的通信，对于https加密的过程，我们首先介绍的对称加密，采用对称加密进行通信存在秘钥协商过程的不安全性，因此我们采用了非对称加密算法解决了对协商过程的加密，因此https是集对称加密和非对称加密为一体的加密过程</p><p><strong>安全的获取公钥</strong></p><p>细心的人可能已经注意到了如果使用非对称加密算法，我们的客户端A，B需要一开始就持有公钥，要不没法开展加密行为啊。</p><p>这下，我们又遇到新问题了，如何让A、B客户端安全地得到公钥？</p><p>​    <img src="10.png" alt="0"></p><p>client获取公钥最最直接的方法是服务器端server将公钥发送给每一个client用户，但这个时候就出现了公钥被劫持的问题，如上图，client请求公钥，在请求返回的过程中被×××劫持，那么我们将采用劫持后的假秘钥进行通信，则后续的通讯过程都是采用假秘钥进行，数据库的风险仍然存在。在获取公钥的过程中，我们又引出了一个新的话题：如何安全的获取公钥，并确保公钥的获取是安全的， 那就需要用到终极武器了：SSL 证书（需要购买）和CA机构</p><p>​    <img src="11.png" alt="0"></p><p>如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有证书的颁发机构、有效期、公钥、证书持有者、签名，通过第三方的校验保证了身份的合法，解决了公钥获取的安全性</p><p>以浏览器为例说明如下整个的校验过程：</p><p>（1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验</p><p>（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发</p><p>（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。</p><p>（4）如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密</p><p>（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比</p><p>（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充</p><p>（7）此时浏览器就可以读取证书中的公钥，用于后续加密了</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​        HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。</p><blockquote><p>引用：<a href="https://blog.csdn.net/weixin_42504145/article/details/85207103/" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42504145/article/details/85207103/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> 加密算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS、证书机构（CA）、证书、数字签名、私钥、公钥</title>
      <link href="/2022/07/06/network-2022-07-06-HTTPS%E3%80%81%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84%EF%BC%88CA%EF%BC%89%E3%80%81%E8%AF%81%E4%B9%A6%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E3%80%81%E7%A7%81%E9%92%A5%E3%80%81%E5%85%AC%E9%92%A5/"/>
      <url>/2022/07/06/network-2022-07-06-HTTPS%E3%80%81%E8%AF%81%E4%B9%A6%E6%9C%BA%E6%9E%84%EF%BC%88CA%EF%BC%89%E3%80%81%E8%AF%81%E4%B9%A6%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E3%80%81%E7%A7%81%E9%92%A5%E3%80%81%E5%85%AC%E9%92%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文内容主要来自简书博主olaH的文章，作者对概念之间的联系解释的非常清楚，熟悉这些概念可以对理解SSH协议、Https协议以及证书颁发等打下基础</p><p>原文链接:<a href="https://www.jianshu.com/u/ab311efd67d7" target="_blank" rel="noopener">olaH</a></p></blockquote><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密是指双方持有相同的密钥进行通信，加密速度快，但是有一个安全问题，双方怎样获得相同的密钥？你总不能总是拿着U盘把密钥拷贝给对方吧。</p><p>常见的对称加密算法有DES、3DES、AES等</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密，又称为公开密钥加密，是为了解决对称加密中的安全问题而诞生，一个称为公开密钥(public key)，即公钥，另一个称为私钥(private key)，即私钥。但是它的加密速度相对于对称加密来说很慢。</p><ul><li>公钥(public key)是对外开放的，私钥(private key)是自己拥有的。</li><li>公钥(public key)加密的数据，只能用私钥(private key)解密。</li><li>私钥(private key)加密的数据，只能用公钥(public key)解密。</li></ul><h3 id="信息安全问题"><a href="#信息安全问题" class="headerlink" title="信息安全问题"></a>信息安全问题</h3><p>在信息安全性问题中，我们常常要做到三点才能保证信息的安全：</p><ol><li>信息的保密性</li><li>信息的完整性</li><li>身份识别</li></ol><h4 id="信息的保密性（加密算法）"><a href="#信息的保密性（加密算法）" class="headerlink" title="信息的保密性（加密算法）"></a>信息的保密性（加密算法）</h4><p>信息的保密性我们可以使用对称加密和非对称加密来完成，使用对称加密来完成，速度相对非对称加密很快，但是存在一个安全问题，密钥如何传递？由此通用的方法是使用非对称加密+对称加密来完成。客户端使用公钥对对称加密的密钥进行加密，然后传递给服务端，服务端使用私钥进行解密确认密钥，开始传输数据。</p><p>​    <img src="1.png" alt="0"></p><h4 id="信息的完整性（数字签名）"><a href="#信息的完整性（数字签名）" class="headerlink" title="信息的完整性（数字签名）"></a>信息的完整性（数字签名）</h4><p>信息传输的途中，我们的信息很有可能被第三方劫持篡改，所以我们需要保证信息的完整性，通用方法是使用散列算法如SHA1，MD5将传输内容hash一次获得hash值，即摘要。客户端使用服务端的公钥对摘要和信息内容进行加密，然后传输给服务端，服务端使用私钥进行解密获得原始内容和摘要值，这时服务端使用相同的hash算法对原始内容进行hash，然后与摘要值比对，如果一致，说明信息是完整的。</p><p>​    <img src="2.png" alt="0"></p><p>image.png</p><h4 id="身份识别（数字证书）"><a href="#身份识别（数字证书）" class="headerlink" title="身份识别（数字证书）"></a>身份识别（数字证书）</h4><p>在信息传输的过程中，我们通常需要验证信息的发送方的身份，这时我们转化一下思路就可以完成，把发送端的公钥发送给接收端，发送端通过把自己的内容使用私钥加密然后发送给接收端，接收端只能用发送端的公钥解密，自然就验证了发送端的身份。</p><p>​    <img src="3.png" alt="0"></p><p>image.png</p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>在传输的过程中，客户端如何获得服务器端的公钥呢？当时是服务器分发给客户端，如果一开始服务端发送的公钥到客户端的过程中有可能被第三方劫持，然后第三方自己伪造一对密钥，将公钥发送给客户端，当服务器发送数据给客户端的时候，中间人将信息进行劫持，用一开始劫持的公钥进行解密后，然后使用自己的私钥将数据加密发送给客户端，而客户端收到后使用公钥解密，反过来亦是如此，整个过程中间人是透明的，但信息泄露却不得而知。</p><p>​    <img src="4.png" alt="0"></p><p>image.png</p><p>为了防止这种情况，数字证书就出现了，它其实就是基于上上面所说的私钥加密数据，公钥解密来验证其身份。</p><p>数字证书是由权威的CA（Certificate Authority）机构给服务端进行颁发，CA机构通过服务端提供的相关信息生成证书，证书内容包含了持有人的相关信息，服务器的公钥，签署者签名信息（数字签名）等，最重要的是公钥在数字证书中。</p><p>数字证书是如何保证公钥来自请求的服务器呢？数字证书上由持有人的相关信息，通过这点可以确定其不是一个中间人；但是证书也是可以伪造的，如何保证证书为真呢？</p><p>一个证书中含有三个部分:”证书内容，散列算法，加密密文”，证书内容会被散列算法hash计算出hash值，然后使用CA机构提供的私钥进行RSA加密。</p><p>​    <img src="5.png" alt="0"></p><p>image.png</p><p>当客户端发起请求时，服务器将该数字证书发送给客户端，客户端通过CA机构提供的公钥对加密密文进行解密获得散列值（数字签名），同时将证书内容使用相同的散列算法进行Hash得到另一个散列值，比对两个散列值，如果两者相等则说明证书没问题。</p><p>​    <img src="6.png" alt="0"></p><p>image.png</p><p>一些常见的证书文件类型如下：</p><p>X.509#DER 二进制格式证书，常用后缀.cer .crt</p><p>X.509#PEM 文本格式证书，常用后缀.pem</p><p>有的证书内容是只包含公钥（服务器的公钥），如.crt、.cer、.pem</p><p>有的证书既包含公钥又包含私钥（服务器的私钥），如.pfx、.p12</p><h3 id="HTTPS，TLS-SSL"><a href="#HTTPS，TLS-SSL" class="headerlink" title="HTTPS，TLS/SSL"></a>HTTPS，TLS/SSL</h3><p>Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。</p><p>使用TCP端口默认为443</p><p>TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。</p><p>SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。</p><p>SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。</p><h4 id="对称加密-1"><a href="#对称加密-1" class="headerlink" title="对称加密"></a>对称加密</h4><p>速度高，可加密内容较大，用来加密会话过程中的消息</p><h4 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h4><p>加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</p><p>​    <img src="7.png" alt="0"></p><p>image.png</p><h4 id="HTTPS单向认证"><a href="#HTTPS单向认证" class="headerlink" title="HTTPS单向认证"></a>HTTPS单向认证</h4><p>Https在建立Socket连接之前，需要进行握手，具体过程如下：</p><p>​    <img src="8.png" alt="0"></p><p>image.png</p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息;</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书;</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：</li></ol><ul><li><ul><li>证书是否过期;</li><li>发行服务器证书的CA是否可靠;(通过查询浏览器或本机内的CA证书)</li><li>返回的公钥是否能正确解开返回证书中的数字签名;（通过使用本机或浏览器内置的CA公钥进行解密）</li><li>服务器证书上的域名是否和服务器的实际域名相匹配;</li><li>验证通过后，将继续进行通信，否则，终止通信;</li></ul></li></ul><ol><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择;</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式;</li><li>服务器将选择好的加密方案通过明文方式返回给客户端;</li><li>客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器;</li><li>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥;</li></ol><p>在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全;</p><h4 id="HTTPS双向认证"><a href="#HTTPS双向认证" class="headerlink" title="HTTPS双向认证"></a>HTTPS双向认证</h4><p>双向认证和单向认证类似，它额外增加了服务端对客户端的认证：</p><p>​    <img src="9.png" alt="0"></p><p>image.png</p><ol><li>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息;</li><li>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书;</li><li>客户端使用服务端返回的信息验证服务器的合法性，包括：</li></ol><ul><li><ul><li>证书是否过期;</li><li>发行服务器证书的CA是否可靠;(通过查询浏览器或本机内的CA证书)</li><li>返回的公钥是否能正确解开返回证书中的数字签名;（通过使用本机或浏览器内置的CA公钥进行解密）</li><li>服务器证书上的域名是否和服务器的实际域名相匹配;</li><li>验证通过后，将继续进行通信，否则，终止通信;</li></ul></li></ul><ol><li>服务端要求客户端发送客户端的证书即客户端证书公钥，客户端会将自己的证书发送至服务端；</li><li>验证客户端的证书，通过验证后，会获得客户端的公钥；</li><li>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</li><li>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式;</li><li>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</li><li>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端；</li><li>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全；</li></ol>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 128 整数翻转</title>
      <link href="/2021/03/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-03-01-Problem-128-%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC/"/>
      <url>/2021/03/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-03-01-Problem-128-%E6%95%B4%E6%95%B0%E7%BF%BB%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个32位的有符号整数x<br>返回将x中的数字部分反转后的结果<br>反转后整数超过 32 位的有符号整数的范围就返回0<br>假设环境不允许存储 64 位整数（有符号或无符号）<br>Leetcode题目：<a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-integer/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>注意，给的就是整数,可以进行翻转溢出的提前判断</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> neg = x &lt; <span class="number">0</span>;</span><br><span class="line">        x = neg ? x : -x;   <span class="comment">//溢出是两个方向的，统一变负数处理，可以换成一个方向上 </span></span><br><span class="line">        <span class="keyword">int</span> m = Integer.MIN_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> o = Integer.MIN_VALUE % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res &lt; m || res==m &amp;&amp; x%<span class="number">10</span> &lt; o)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neg ? res : Math.abs(res);  <span class="comment">//理论会有 负数没溢出，转绝对值溢出的情况，所以应该特殊处理，但这个题输入是一个整数，不会出现反转是-2147483647</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 127 两数之和</title>
      <link href="/2021/03/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-03-01-Problem-127-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2021/03/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-03-01-Problem-127-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 nums 和一个整数目标值 target<br>请你在该数组中找出 和为目标值 target  的那两个整数<br>并返回它们的数组下标<br>你可以假设每种输入只会对应一个答案<br>但是数组中同一个元素在答案里不能重复出现<br>你可以按任意顺序返回答案<br>Leetcode题目：<a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>两数之和，题目简单，写出好的代码也不好想,能不能熟练的运用数据机构来优化代码 ？</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="comment">// key 某个之前的数   value 这个数出现的位置</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(target - nums[i]), i &#125;;</span><br><span class="line">&#125;</span><br><span class="line">map.put(nums[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 126 企鹅文化衫问题</title>
      <link href="/2021/02/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-26-Problem-126-%E4%BC%81%E9%B9%85%E6%96%87%E5%8C%96%E8%A1%AB%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-26-Problem-126-%E4%BC%81%E9%B9%85%E6%96%87%E5%8C%96%E8%A1%AB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>企鹅厂活动发文化衫，文化衫有很多种，企鹅们都穿文化衫<br>采访中，企鹅会说还有多少企鹅跟他穿一种文化衫<br>有些企鹅没被采访到<br>将这些回答放在answers数组里，返回活动中企鹅的最少数量<br>Leetcode题目：<a href="https://leetcode.com/problems/rabbits-in-forest/" target="_blank" rel="noopener">https://leetcode.com/problems/rabbits-in-forest/</a></p><p>27</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 125 乐队演出问题</title>
      <link href="/2021/02/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-24-Problem-125-%E4%B9%90%E9%98%9F%E6%BC%94%E5%87%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-24-Problem-125-%E4%B9%90%E9%98%9F%E6%BC%94%E5%87%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>每一个项目都有三个数，[a,b,c]表示这个项目a和b乐队参演，花费为c<br>每一个乐队可能在多个项目里都出现了，但是只能被挑一次<br>nums是可以挑选的项目数量，所以一定会有nums<em>2只乐队被挑选出来<br>返回一共挑nums轮(也就意味着一定请到所有的乐队)，最少花费是多少<br>如果怎么都无法在nums轮请到nums</em>2只乐队且每只乐队只能被挑一次<br>返回-1<br>nums&lt;9，programs长度小于500<br>每组测试乐队的全部数量一定是nums<em>2，且标号一定是0 ~ nums</em>2-1</p><p>27</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 124 表达式添加运算符</title>
      <link href="/2021/02/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-21-Problem-124-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2021/02/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-21-Problem-124-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 : </p><p><a href="https://leetcode.com/problems/expression-add-operators/" target="_blank" rel="noopener">https://leetcode.com/problems/expression-add-operators/</a></p><p>自己可以试试普通递归，优化了计算表达式的过程</p><p>26节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 123 单词搜索II</title>
      <link href="/2021/02/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-20-Problem-123-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II/"/>
      <url>/2021/02/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-20-Problem-123-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 :<br><a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/word-search-ii/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>BFS + Prefix Tree</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        Node root;</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            Node[] nodes;</span><br><span class="line">            <span class="keyword">boolean</span> isWord;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = chars[i]-<span class="string">'a'</span>;</span><br><span class="line">                cur.nodes[index] = cur.nodes[index] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node():cur.nodes[index];</span><br><span class="line">                cur = cur.nodes[index];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] path = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            prefixTree.insert(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                process(res,path,<span class="number">0</span>,i,j,prefixTree.root,board);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; res,<span class="keyword">char</span>[] path,<span class="keyword">int</span> k,<span class="keyword">int</span> i,<span class="keyword">int</span> j,PrefixTree.Node cur,<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index = board[i][j] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.nodes[index] == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">         path[k] = board[i][j];</span><br><span class="line">         board[i][j] = <span class="string">'-'</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur.nodes[index].isWord) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(path,<span class="number">0</span>,k+<span class="number">1</span>));</span><br><span class="line">            cur.nodes[index].isWord = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续以感染的方式 继续检测单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">4</span>;d++)&#123;</span><br><span class="line">            process(res,path,k+<span class="number">1</span>,i+dir_x[d],j+dir_y[d],cur.nodes[index],board);</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = path[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 122 最窄区间变形题</title>
      <link href="/2021/02/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-20-Problem-122-%E6%9C%80%E7%AA%84%E5%8C%BA%E9%97%B4%E5%8F%98%E5%BD%A2%E9%A2%98/"/>
      <url>/2021/02/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-20-Problem-122-%E6%9C%80%E7%AA%84%E5%8C%BA%E9%97%B4%E5%8F%98%E5%BD%A2%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 :<br><a href="https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/</a><br>—最窄区间变形<br>有三个有序数组，分别在三个数组中挑出3个数，x、y、z<br>返回 |x-y| + |y-z| + |z-x|最小是多少？</p><p>26</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 121 单词梯子II</title>
      <link href="/2021/02/19/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-19-Problem-121-%E5%8D%95%E8%AF%8D%E6%A2%AF%E5%AD%90II/"/>
      <url>/2021/02/19/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-19-Problem-121-%E5%8D%95%E8%AF%8D%E6%A2%AF%E5%AD%90II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 :<br><a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">https://leetcode.com/problems/gas-station/</a></p><p>26</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>同单词梯子一</li><li></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 120 单词梯子</title>
      <link href="/2021/02/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-16-Problem-120-%E5%8D%95%E8%AF%8D%E6%A2%AF%E5%AD%90/"/>
      <url>/2021/02/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-16-Problem-120-%E5%8D%95%E8%AF%8D%E6%A2%AF%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 : </p><p><a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">https://leetcode.com/problems/word-ladder/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>只要能反应过来使用图的模型，就能做，只不过要麻烦些而已。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] vToStr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String,Integer&gt; strToMap;</span><br><span class="line">    <span class="comment">//图论的好多东西还是的捡一捡的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = wordList.size()+<span class="number">1</span>;</span><br><span class="line">        vToStr = <span class="keyword">new</span> String[N];</span><br><span class="line">        strToMap =  <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        wordList.add(beginWord);</span><br><span class="line">        <span class="comment">// 处理映射</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            vToStr[i] = wordList.get(i);</span><br><span class="line">            strToMap.put(vToStr[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Integer end = strToMap.get(endWord);</span><br><span class="line">        <span class="keyword">if</span>(end == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; adjectTb = getAdjectTb();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bfs = bfs(adjectTb,N,strToMap.get(beginWord),end);</span><br><span class="line">        <span class="keyword">return</span> bfs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; getAdjectTb()&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vToStr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> String str = vToStr[i];</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; chars.length; i1++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">'a'</span>;k &lt;= <span class="string">'z'</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(chars[i1] == k)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">char</span> tmp = chars[i1];</span><br><span class="line">                    chars[i1] = k;</span><br><span class="line">                    <span class="keyword">final</span> String s = <span class="keyword">new</span> String(chars);</span><br><span class="line">                    <span class="keyword">final</span> Integer con = strToMap.get(s);</span><br><span class="line">                    <span class="keyword">if</span>(con != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        list.add(con);</span><br><span class="line">                    &#125;</span><br><span class="line">                    chars[i1] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; adjectTb ,<span class="keyword">int</span> N,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] queue = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>,rear = <span class="number">0</span>;</span><br><span class="line">        queue[rear++] = begin;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        visited[begin] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (front != rear)&#123;</span><br><span class="line">            <span class="keyword">int</span> next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; batchSize;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = queue[front++];</span><br><span class="line">                <span class="keyword">if</span>(tmp == end)</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">final</span> List&lt;Integer&gt; adjents = adjectTb.get(tmp);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adjents.size(); j++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Integer t = adjents.get(j);</span><br><span class="line">                    <span class="keyword">if</span>(!visited[t])&#123;</span><br><span class="line">                        queue[rear++] = t;</span><br><span class="line">                        visited[t] = <span class="keyword">true</span>;</span><br><span class="line">                        next_batch++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">            batchSize = next_batch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Trie </tag>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 119 加油站问题</title>
      <link href="/2021/02/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-12-Problem-119-%E5%8A%A0%E6%B2%B9%E7%AB%99%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-12-Problem-119-%E5%8A%A0%E6%B2%B9%E7%AB%99%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 : </p><p><a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">https://leetcode.com/problems/gas-station/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>加油站问题比较经典，这里还是介绍比较通俗的做法</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = cost.length;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> gas[<span class="number">0</span>]-cost[<span class="number">0</span>] &gt;= <span class="number">0</span>?<span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            cost[i] = gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; N)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; N &amp;&amp;cost[p1] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p1 &lt; N)&#123;</span><br><span class="line">                <span class="keyword">int</span> p2 = p1,preSum = cost[p1];</span><br><span class="line">                <span class="comment">//窗口增长</span></span><br><span class="line">                <span class="keyword">while</span> ((p2-p1+N)%N+<span class="number">1</span>&lt;N &amp;&amp; preSum &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    p2 = (p2+<span class="number">1</span>)%N;</span><br><span class="line">                    preSum += cost[p2];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(preSum &gt;= <span class="number">0</span> ) <span class="keyword">return</span> p1;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p2 &gt; p1) p1 = p2;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 118 最多的共线点数</title>
      <link href="/2021/02/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-10-Problem-118-%E6%9C%80%E5%A4%9A%E7%9A%84%E5%85%B1%E7%BA%BF%E7%82%B9%E6%95%B0/"/>
      <url>/2021/02/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-10-Problem-118-%E6%9C%80%E5%A4%9A%E7%9A%84%E5%85%B1%E7%BA%BF%E7%82%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 : </p><p><a href="https://leetcode.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">https://leetcode.com/problems/max-points-on-a-line/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>普通计算题，两个点计算出斜率和表达式，验证在直线上的点数，注意精度问题</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line">        <span class="keyword">int</span> N = points.length;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p1 = <span class="number">0</span>; p1 &lt; N - <span class="number">1</span>; p1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = p1 + <span class="number">1</span>; t &lt; N; t++) &#123;</span><br><span class="line">                <span class="comment">//计算斜率及直线表达式</span></span><br><span class="line">                <span class="keyword">double</span> k = points[t][<span class="number">0</span>] - points[p1][<span class="number">0</span>] == <span class="number">0</span> ? Integer.MAX_VALUE : (<span class="keyword">double</span>)(points[t][<span class="number">1</span>] - points[p1][<span class="number">1</span>]) / (points[t][<span class="number">0</span>] - points[p1][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">double</span> b = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (k != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    b = points[p1][<span class="number">1</span>] - k * points[p1][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> tmp_max = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> p2 = t + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 扫描共线点</span></span><br><span class="line">                <span class="keyword">if</span> (k == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (p2 &lt; N) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (points[p2][<span class="number">0</span>] == points[p1][<span class="number">0</span>]) &#123;</span><br><span class="line">                            tmp_max++;</span><br><span class="line">                            res = Math.max(tmp_max, res);</span><br><span class="line">                        &#125;</span><br><span class="line">                        p2++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (p2 &lt; N) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (Math.abs(points[p2][<span class="number">1</span>]-(k * points[p2][<span class="number">0</span>] + b)) &lt; eps) &#123;</span><br><span class="line">                            tmp_max++;</span><br><span class="line">                            res = Math.max(tmp_max, res);</span><br><span class="line">                        &#125;</span><br><span class="line">                        p2++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 117 三数之和问题</title>
      <link href="/2021/02/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-10-Problem-117-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-10-Problem-117-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 : </p><p><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目不难，但可以提示一个小技巧，3个数的和为0 ，如果只是直接找前两个数的组合，然后再去找第三个数，直接查找，可能会出现重复，这时候需要利用set之类数据结构对重复的额外处理，但我们可以事先排序一下，按住三数之中小的去遍历，这样相同的小的数 就可以跳过，直接去重了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> p1 = i+<span class="number">1</span>,p2 = nums.length-<span class="number">1</span>,target = <span class="number">0</span>-nums[i];</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; p2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[p1]+nums[p2] == target)&#123;</span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    tmp.add(nums[i]);</span><br><span class="line">                    tmp.add(nums[p1++]);</span><br><span class="line">                    tmp.add(nums[p2--]);</span><br><span class="line">                    list.add(tmp);</span><br><span class="line">                    <span class="keyword">while</span> (p2 &gt; p1 &amp;&amp; nums[p2] == nums[p2+<span class="number">1</span>]) p2--;</span><br><span class="line">                    <span class="keyword">while</span> (p1 &lt; p2 &amp;&amp; nums[p1] == nums[p1-<span class="number">1</span>]) p1++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[p1]+nums[p2] &lt; target)&#123;</span><br><span class="line">                    p1++;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 116 ip-to-cidr问题</title>
      <link href="/2021/02/09/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-09-Problem-116-ip-to-cidr%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/09/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-09-Problem-116-ip-to-cidr%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 题目 : </p><p><a href="https://leetcode.com/problems/ip-to-cidr/" target="_blank" rel="noopener">https://leetcode.com/problems/ip-to-cidr/</a></p><p>26jie</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 115 移除重复字母</title>
      <link href="/2021/02/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-05-Problem-115-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/"/>
      <url>/2021/02/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-05-Problem-115-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode题目链接：</p><p><a href="https://leetcode.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicate-letters/</a></p><p>24节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 114 字符串包含问题</title>
      <link href="/2021/02/04/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-04-Problem-114-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/04/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-04-Problem-114-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个字符串str1和str2<br>在str1中寻找一个最短子串，能包含str2的所有字符<br>字符顺序无所谓，str1的这个最短子串也可以包含多余的字符<br>返回这个最短包含子串</p><p>Leetcode:  <a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-window-substring/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>滑动窗口+欠债表思想</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] tb = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>]; <span class="comment">//欠债表</span></span><br><span class="line">        <span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] p_str = t.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p_str.length; i++) &#123;</span><br><span class="line">            tb[p_str[i]]++;</span><br><span class="line">            in++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_n = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sloc = <span class="number">0</span>,eloc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;p1 &lt; str.length;p1++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p2 &lt; str.length &amp;&amp; in &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (--tb[str[p2++]] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    in--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(in == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p2 - p1 &lt; min_n)&#123;</span><br><span class="line">                    min_n = p2-p1;</span><br><span class="line">                    sloc = p1;</span><br><span class="line">                    eloc = p2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++tb[str[p1]] &gt; <span class="number">0</span>)&#123; in++; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(sloc,eloc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 113 格子染色问题</title>
      <link href="/2021/02/02/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-02-Problem-113-%E6%A0%BC%E5%AD%90%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/02/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-02-Problem-113-%E6%A0%BC%E5%AD%90%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>N * M的棋盘（N和M是输入参数）<br>每种颜色的格子数必须相同的<br>上下左右的格子算相邻<br>相邻格子染的颜色必须不同<br>所有格子必须染色<br>返回至少多少种颜色可以完成任务</p><p>24节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 112 吉祥里程码问题</title>
      <link href="/2021/02/02/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-02-Problem-112-%E5%90%89%E7%A5%A5%E9%87%8C%E7%A8%8B%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/2021/02/02/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-02-02-Problem-112-%E5%90%89%E7%A5%A5%E9%87%8C%E7%A8%8B%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>正常的里程表会依次显示自然数表示里程<br>吉祥的里程表会忽略含有4的数字而跳到下一个完全不含有4的数<br>正常：1 2 3 4 5 6 7 8   9 10 11 12 13 14 15    X<br>吉祥：1 2 3 5 6 7 8 9 10 11 12 13 15 16 17 … 38 39 50 51 52 53 55<br>给定一个吉祥里程表的数字num(当然这个数字中不含有4)<br>返回这个数字代表的真实里程</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><code>java</code></p>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 111 第k小的数值对</title>
      <link href="/2021/01/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-31-Problem-111-%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%E5%80%BC%E5%AF%B9/"/>
      <url>/2021/01/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-31-Problem-111-%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%E5%80%BC%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>长度为N的数组arr，一定可以组成N^2个数字对<br>例如arr = [3,1,2]，数字对有(3,3) (3,1) (3,2) (1,3) (1,1) (1,2) (2,3) (2,1) (2,2)<br>也就是任意两个数都可以，而且自己和自己也算数字对<br>数字对怎么排序？<br>第一维数据从小到大；第一维数据一样的，第二维数组也从小到大<br>所以上面的数值对排序的结果为：(1,1)(1,2)(1,3)(2,1)(2,2)(2,3)(3,1)(3,2)(3,3)<br>给定一个数组arr，和整数k，返回第k小的数值对</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题挺不错。学会数数，注意有重复数数字的情况。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>方法一：O(N*log(N))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getKmin(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k)&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> N = arr.length;</span><br><span class="line"><span class="comment">//      int d = k/N,f = k % N;</span></span><br><span class="line"><span class="comment">//      int pre = f == 0 ? arr[d - 1] : (d == 0 ? arr[0] : arr[d]);</span></span><br><span class="line">        <span class="keyword">int</span> pre = arr[(k-<span class="number">1</span>)/N];</span><br><span class="line">        <span class="keyword">int</span> preNumSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lessPreNumSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N &amp;&amp; arr[i] &lt;= pre;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; pre)&#123;</span><br><span class="line">                lessPreNumSize++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                preNumSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k -= lessPreNumSize * N;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;pre, arr[(k-<span class="number">1</span>)/preNumSize]&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法二: O(N)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 110 数组切分相等部分</title>
      <link href="/2021/01/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-29-Problem-110-%E6%95%B0%E7%BB%84%E5%88%87%E5%88%86%E7%9B%B8%E7%AD%89%E9%83%A8%E5%88%86/"/>
      <url>/2021/01/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-29-Problem-110-%E6%95%B0%E7%BB%84%E5%88%87%E5%88%86%E7%9B%B8%E7%AD%89%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个正数数组arr，长度一定大于6（&gt;=7）<br>一定要选3个数字做分割点，从而分出4个部分，并且每部分都有数<br>分割点的数字直接删除，不属于任何4个部分中的任何一个。<br>返回有没有可能分出的4个部分累加和一样大<br>如：{3,2,3,7,4,4,3,1,1,6,7,1,5,2}<br>可以分成{3,2,3}、{4,4}、{1,1,6}、{1,5,2}。分割点是不算的！</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>一定从最基础的思路开始。寻找可能性的题目都离不开枚举，关键看如何去枚举。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canSplit</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sum+= arr[i];</span><br><span class="line">            map.put(sum,i);</span><br><span class="line">            set.add(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> part = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length-<span class="number">5</span>;i++)&#123;  <span class="comment">//枚举第一刀的位置 ,至少留5个元素 保证4部分</span></span><br><span class="line">            part += arr[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> cut2Sum = sum - (arr[i] + part * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(set.contains(cut2Sum))&#123;</span><br><span class="line">                <span class="keyword">int</span> cut3Sum = cut2Sum - arr[map.get(cut2Sum)] -  part;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(cut3Sum))&#123;</span><br><span class="line">                    <span class="keyword">int</span> lastPartSum = cut3Sum - arr[map.get(cut3Sum)];</span><br><span class="line">                    <span class="keyword">if</span>(lastPartSum == part)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 109 石头合并的最小代价</title>
      <link href="/2021/01/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-28-Problem-109-%E7%9F%B3%E5%A4%B4%E5%90%88%E5%B9%B6%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/"/>
      <url>/2021/01/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-28-Problem-109-%E7%9F%B3%E5%A4%B4%E5%90%88%E5%B9%B6%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/minimum-cost-to-merge-stones/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-cost-to-merge-stones/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目容易理解。比较难，枚举要求比较高。</li><li>两个优化细节<ul><li>if ((n - 1) % (K - 1) &gt; 0) { return -1; }  通过打表观察可以得出这个规律，其实比较难找，靠程序去猜规律。可以提前过滤</li><li>递归中的mid++ 可以替换成 mid+=K-1 其实就是跳过了无效解。</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeStones</span><span class="params">(<span class="keyword">int</span>[] stones, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[stones.length];</span><br><span class="line">        preSum[<span class="number">0</span>] = stones[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line">            preSum[i] = preSum[i-<span class="number">1</span>] + stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> N = stones.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][N][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process(stones,<span class="number">0</span>,stones.length-<span class="number">1</span>,<span class="number">1</span>,k,preSum,dp);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] stones,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> P,<span class="keyword">int</span> k,<span class="keyword">int</span>[] preSum,<span class="keyword">int</span>[][][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r][P] !=<span class="number">0</span> )&#123; <span class="comment">//0相当于不缓存了</span></span><br><span class="line">            <span class="keyword">return</span> dp[l][r][P];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123; <span class="comment">// arr[L..R]</span></span><br><span class="line">            <span class="keyword">return</span> P == <span class="number">1</span> ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// L ... R 不只一个数</span></span><br><span class="line">        <span class="keyword">if</span> (P == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = process(stones,l, r, k, k, preSum,dp);</span><br><span class="line">            <span class="keyword">if</span> (next == -<span class="number">1</span>) &#123;</span><br><span class="line">                dp[l][r][P] = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[l][r][P] = next + (l==<span class="number">0</span>?preSum[r]:preSum[r] - preSum[l-<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> dp[l][r][P];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> minCost = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid=l;mid &lt; r;mid++)&#123; <span class="comment">// </span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> costl = process(stones, l, mid, <span class="number">1</span>, k, preSum,dp);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> costr = process(stones, mid + <span class="number">1</span>, r, P - <span class="number">1</span>, k, preSum,dp);</span><br><span class="line">                <span class="keyword">if</span>(costl==-<span class="number">1</span> || costr==-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                minCost = Math.min(costl+costr,minCost);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[l][r][P] = minCost==Integer.MAX_VALUE?-<span class="number">1</span>:minCost;</span><br><span class="line">            <span class="keyword">return</span> dp[l][r][P];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 108 超级水王问题</title>
      <link href="/2021/01/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-24-Problem-108-%E8%B6%85%E7%BA%A7%E6%B0%B4%E7%8E%8B%E9%97%AE%E9%A2%98/"/>
      <url>/2021/01/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-24-Problem-108-%E8%B6%85%E7%BA%A7%E6%B0%B4%E7%8E%8B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>超级水王问题</p><p>扩展1：摩尔投票</p><p>扩展2：给定一个正数K，返回所有出现次数&gt;N/K的数</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>水王题目算是比较经典的题目了，题目一和题目二实际上思路是一样的</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMoreKNum</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(arr[i]) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (map.size() &lt; k-<span class="number">1</span>)&#123;</span><br><span class="line">                    map.put(arr[i],<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> Set&lt;Integer&gt; integers = map.keySet();</span><br><span class="line">                    <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(map.get(integer)==<span class="number">1</span>)&#123;</span><br><span class="line">                            map.remove(integer);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            map.put(integer,map.get(integer)-<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(map.size() &lt; k-<span class="number">1</span>)&#123;</span><br><span class="line">                        map.put(arr[i],<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Set&lt;Integer&gt; integers = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] == integer) count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!(count &gt; arr.length/k)) map.remove(integer);</span><br><span class="line">            <span class="keyword">else</span> System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        getMoreKNum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> &#125;,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 107 可整合数组</title>
      <link href="/2021/01/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-24-Problem-107-%E5%8F%AF%E6%95%B4%E5%90%88%E6%95%B0%E7%BB%84/"/>
      <url>/2021/01/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-24-Problem-107-%E5%8F%AF%E6%95%B4%E5%90%88%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>定义什么是可整合数组：<br>一个数组排完序之后，除了最左侧的数外，有arr[i] = arr[i-1]+1<br>则称这个数组为可整合数组<br>比如{5,1,2,4,3}、{6,2,3,1,5,4}都是可整合数组<br>返回arr中最长可整合子数组的长度</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><p>没有思路时，要从最暴力的办法下手 先有路走，再讨论路的好坏。</p></li><li><p>两重循环枚举子数组，判断子数组是不是满足条件的。枚举子数组，枚举开始，结尾 。再做操作。这是三重循环。但实际 O(N^2)即可。</p></li><li><p>学会重新定义题目条件。</p><ul><li><p>可整合数组 判断是不是等差数列，但是不是简单求和就可以判断的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((maxn + minn)*(R-L+<span class="number">1</span>) == sum*<span class="number">2</span>)</span><br><span class="line">    ans = Math.max(ans,R-L+<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>正确的定义确实是，1.无重复 2.最大值与最小值差值等于个数减一</p></li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLIL</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>;L &lt; arr.length;L++)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxn = arr[L];</span><br><span class="line">            <span class="keyword">int</span> minn = arr[L];</span><br><span class="line">            set.clear();</span><br><span class="line">            set.add(arr[L]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> R=L+<span class="number">1</span>;R &lt; arr.length;R++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(R))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                maxn = Math.max(maxn,arr[R]);</span><br><span class="line">                minn = Math.min(minn,arr[R]);</span><br><span class="line">                <span class="keyword">if</span>(maxn - minn == R-L)</span><br><span class="line">                    ans = Math.max(ans,R-L+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 106 数组切分的最大差值</title>
      <link href="/2021/01/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-20-Problem-106-%E6%95%B0%E7%BB%84%E5%88%87%E5%88%86%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/"/>
      <url>/2021/01/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-20-Problem-106-%E6%95%B0%E7%BB%84%E5%88%87%E5%88%86%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组arr，长度为N &gt; 1<br>从中间切一刀，保证左部分和右部分都有数字，一共有N-1种切法<br>如此多的切法中，每一种都有:<br>绝对值(左部分最大值 – 右部分最大值)<br>返回最大的绝对值是多少</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>重点还是在做辅助数组。</li><li>事先准备好右区间的最大值数组，再次遍历时，一边求出左侧的最大值，一边更新答案即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxABS</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] lArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"><span class="keyword">int</span>[] rArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">lArr[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">rArr[arr.length - <span class="number">1</span>] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">lArr[i] = Math.max(lArr[i - <span class="number">1</span>], arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">2</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">rArr[i] = Math.max(rArr[i + <span class="number">1</span>], arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">max = Math.max(max, Math.abs(lArr[i] - rArr[i + <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 105 最近公共祖先的n次查询</title>
      <link href="/2021/01/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-16-Problem-105-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E7%9A%84n%E6%AC%A1%E6%9F%A5%E8%AF%A2/"/>
      <url>/2021/01/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-16-Problem-105-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E7%9A%84n%E6%AC%A1%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定数组father大小为N，表示一共有N个节点<br>father[i] = j 表示点i的父亲是点j， father表示的树一定是一棵树而不是森林<br>queries是二维数组，大小为M*2，每一个长度为2的数组都表示一条查询<br>[4,9], 表示想查询4和9之间的最低公共祖先…<br>[3,7], 表示想查询3和7之间的最低公共祖先…<br>tree和queries里面的所有值，都一定在0~N-1之间<br>返回一个数组ans，大小为M，ans[i]表示第i条查询的答案</p><p>23节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 104 最高广告牌问题</title>
      <link href="/2021/01/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-16-Problem-104-%E6%9C%80%E9%AB%98%E5%B9%BF%E5%91%8A%E7%89%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2021/01/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-16-Problem-104-%E6%9C%80%E9%AB%98%E5%B9%BF%E5%91%8A%E7%89%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/tallest-billboard/" target="_blank" rel="noopener">https://leetcode.com/problems/tallest-billboard/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><p>题意就是挑选两个不同的子集，使得大小相同，求最大值。</p></li><li><p>难点在于，一个元素是如何确定出放进哪个集合的？当然不确定，所以要记录下所有可构成的两个集合，并且不断的缩小其差值并找到最大的那个。</p></li><li><p>代码一的这个bug 可让自己吃了一顿苦头。给自己提醒写代码时脑子要清醒。不然很容易想漏，代码一就是没有判断在构造新集合时 取较大的。再者。也可以直接使用一个map将旧值完全copy过来再操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; cur 内部数据完全和之前map一样</span><br><span class="line">cur &#x3D; new HashMap&lt;&gt;(dp); &#x2F;&#x2F; 先进行拷贝 再枚举</span><br></pre></td></tr></table></figure></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码一（bug）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tallestBillboard</span><span class="params">(<span class="keyword">int</span>[] rods)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rod : rods) &#123;</span><br><span class="line">            <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; new_map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">//map 迭代过程中不能用put方法新增 必须用迭代器</span></span><br><span class="line">            <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">                <span class="keyword">final</span> Integer minValue = map.get(key);</span><br><span class="line">                <span class="keyword">int</span> maxValue = minValue + key;</span><br><span class="line">                <span class="keyword">int</span> new_key = Math.abs((minValue + rod)-maxValue);</span><br><span class="line">                new_map.put(new_key,Math.min(minValue + rod,maxValue));</span><br><span class="line">                new_key = Math.abs((maxValue + rod)-minValue);</span><br><span class="line">                new_map.put(new_key,Math.min(maxValue + rod,minValue));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Integer key: map.keySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(new_map.get(key) == <span class="keyword">null</span> || (map.get(key) != <span class="keyword">null</span> &amp;&amp; map.get(key) &gt; new_map.get(key)))&#123;</span><br><span class="line">                    new_map.put(key,map.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map = new_map;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(<span class="number">0</span>)==<span class="keyword">null</span> ? -<span class="number">1</span> : map.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>纠正:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tallestBillboard</span><span class="params">(<span class="keyword">int</span>[] rods)</span> </span>&#123;</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> rod : rods) &#123;</span><br><span class="line">           <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; new_map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           <span class="comment">//map 迭代过程中不能用put方法新增 必须用迭代器</span></span><br><span class="line">           <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">               Integer minValue = map.get(key);</span><br><span class="line">               <span class="keyword">int</span> maxValue = minValue + key;</span><br><span class="line">               <span class="keyword">int</span> new_key = Math.abs((minValue + rod)-maxValue);</span><br><span class="line">               new_map.put(new_key,Math.max(new_map.getOrDefault(new_key,<span class="number">0</span>),Math.min(minValue + rod,maxValue)));</span><br><span class="line">               new_key = Math.abs((maxValue + rod)-minValue);</span><br><span class="line">               new_map.put(new_key,Math.max(new_map.getOrDefault(new_key,<span class="number">0</span>),Math.min(maxValue + rod,minValue)));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (Integer key: map.keySet()) &#123;</span><br><span class="line">               <span class="keyword">if</span>(new_map.get(key) == <span class="keyword">null</span> || (map.get(key) != <span class="keyword">null</span> &amp;&amp; map.get(key) &gt; new_map.get(key)))&#123;</span><br><span class="line">                   new_map.put(key,map.get(key));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           map = new_map;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> map.get(<span class="number">0</span>)==<span class="keyword">null</span> ? -<span class="number">1</span> : map.get(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 103 山峰对问题</title>
      <link href="/2021/01/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-13-Problem-103-%E5%B1%B1%E5%B3%B0%E5%AF%B9%E9%97%AE%E9%A2%98/"/>
      <url>/2021/01/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-13-Problem-103-%E5%B1%B1%E5%B3%B0%E5%AF%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度<br>比如， {3,1,2,4,5}、{4,5,3,1,2}或{1,2,4,5,3}都代表同样结构的环形山<br>山峰A和山峰B能够相互看见的条件为:<br>1.如果A和B是同一座山，认为不能相互看见<br>2.如果A和B是不同的山，并且在环中相邻，认为可以相互看见<br>3.如果A和B是不同的山，并且在环中不相邻，假设两座山高度的最小值为min。<br>       1)如果A通过顺时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互看见<br>       2)如果A通过逆时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互看见<br>两个方向只要有一个能看见，就算A和B可以相互看见<br>给定一个不含有负数且没有重复值的数组 arr，请返回有多少对山峰能够相互看见。</p><p>进阶问题<br>给定一个不含有负数但可能含有重复值的数组arr，返回有多少对山峰能够相互看见。</p><p>22节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 102 接雨水问题II</title>
      <link href="/2021/01/11/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-11-Problem-102-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98II/"/>
      <url>/2021/01/11/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-11-Problem-102-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/trapping-rain-water-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/trapping-rain-water-ii/</a></p><p>22节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 101 接雨水问题</title>
      <link href="/2021/01/07/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-07-Problem-101-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/"/>
      <url>/2021/01/07/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-07-Problem-101-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">https://leetcode.com/problems/trapping-rain-water/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>接雨水问题，这道题提醒我们可以从单个元素入手，不要急于求整体接的水量，挨个遍历看看每个柱子能接多少，求和则是整体！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        <span class="keyword">int</span> max_n = height[height.length-<span class="number">1</span>];</span><br><span class="line">        right[height.length-<span class="number">1</span>] = max_n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = height.length-<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            max_n = Math.max(height[i],max_n);</span><br><span class="line">            right[i] = max_n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        max_n = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; height.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> expect = Math.min(max_n,right[i+<span class="number">1</span>]);</span><br><span class="line">            res += expect &lt; height[i] ? <span class="number">0</span> : expect-height[i];</span><br><span class="line">            max_n = Math.max(max_n,height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 100 3个不交叉子数组最大和</title>
      <link href="/2021/01/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-05-Problem-100-3%E4%B8%AA%E4%B8%8D%E4%BA%A4%E5%8F%89%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2021/01/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-05-Problem-100-3%E4%B8%AA%E4%B8%8D%E4%BA%A4%E5%8F%89%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目难在能不能想到构造辅助数组。</li><li>看看两个代码 。代码二要更简洁，思路更清晰。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] maxSumOfThreeSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] leftEnum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">//以i开头的K个和</span></span><br><span class="line">        <span class="comment">//left[i],从0~i上,长度为k的,最大子数组,right是从i~N-1上长度为k的最大子数组</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] lrange = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] rrange = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sumK = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; k-<span class="number">1</span>) sumK += nums[i]; <span class="comment">//长度增长</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sumK += nums[i];</span><br><span class="line">                <span class="keyword">if</span>(i-<span class="number">1</span> &lt; <span class="number">0</span> || sumK &gt; left[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    left[i] = sumK;</span><br><span class="line">                    lrange[i] = i-k+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left[i] = left[i-<span class="number">1</span>];</span><br><span class="line">                    lrange[i] = lrange[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                sumK -= nums[i-k+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sumK = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; nums.length-<span class="number">1</span> -k+<span class="number">1</span>)</span><br><span class="line">                sumK += nums[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sumK +=nums[i];</span><br><span class="line">                leftEnum[i] = sumK;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span> &gt; nums.length-<span class="number">1</span> || sumK &gt;= right[i+<span class="number">1</span>])&#123;</span><br><span class="line">                   right[i] = sumK;</span><br><span class="line">                   rrange[i] = i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right[i] = right[i+<span class="number">1</span>];</span><br><span class="line">                    rrange[i] = rrange[i+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                sumK -= nums[i+k-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MIN_VALUE,a = <span class="number">0</span>,b = <span class="number">0</span>,c = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举中间k个长度数组，两边查找最大的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k;i &lt; nums.length-<span class="number">2</span>*k+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmpAns = leftEnum[i] + left[i-<span class="number">1</span>] + right[i+k];</span><br><span class="line">            <span class="keyword">if</span>(tmpAns &gt; ans)&#123;</span><br><span class="line">                a = lrange[i-<span class="number">1</span>];</span><br><span class="line">                b = i;</span><br><span class="line">                c = rrange[i+k];</span><br><span class="line">                ans = tmpAns;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b,c&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>==更优雅的代码==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] maxSumOfThreeSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line"><span class="keyword">int</span> N = nums.length;</span><br><span class="line"><span class="keyword">int</span>[] range = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">// range[i]代表 以i开始的k长度子数组和</span></span><br><span class="line"><span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[N];  <span class="comment">// left[i]代表 从0~i中最大k个长度子数组的开始位置</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line">range[<span class="number">0</span>] = sum;</span><br><span class="line">left[k - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> max = sum;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; N; i++) &#123;</span><br><span class="line">sum = sum - nums[i - k] + nums[i];</span><br><span class="line">range[i - k + <span class="number">1</span>] = sum;</span><br><span class="line">left[i] = left[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (sum &gt; max) &#123;</span><br><span class="line">max = sum;</span><br><span class="line">left[i] = i - k + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= N - k; i--) &#123;</span><br><span class="line">sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line">max = sum;</span><br><span class="line"><span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[N];   <span class="comment">//right[i] 代表 i~length-1 中最大k个长度子数组开始位置</span></span><br><span class="line">right[N - k] = N - k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">sum = sum - nums[i + k] + nums[i];</span><br><span class="line">right[i] = right[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (sum &gt;= max) &#123;</span><br><span class="line">max = sum;</span><br><span class="line">right[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; N - <span class="number">2</span> * k + <span class="number">1</span>; i++) &#123; <span class="comment">// 中间一块的起始点 (0...k-1)选不了 i == N-1</span></span><br><span class="line"><span class="keyword">int</span> part1 = range[left[i - <span class="number">1</span>]];</span><br><span class="line"><span class="keyword">int</span> part2 = range[i];</span><br><span class="line"><span class="keyword">int</span> part3 = range[right[i + k]];</span><br><span class="line"><span class="keyword">if</span> (part1 + part2 + part3 &gt; max) &#123;</span><br><span class="line">max = part1 + part2 + part3;</span><br><span class="line">a = left[i - <span class="number">1</span>];</span><br><span class="line">b = i;</span><br><span class="line">c = right[i + k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; a, b, c &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 99 树链剖分问题</title>
      <link href="/2021/01/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-01-Problem-99-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E9%97%AE%E9%A2%98/"/>
      <url>/2021/01/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2021-01-01-Problem-99-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定数组father，大小为N，表示一共有N个节点<br>father[i] = j 表示点i的父亲是点j， father表示的树一定是一棵树而不是森林<br>给定数组values，大小为N，values[i]=v表示节点i的权值是v<br>实现如下4个方法，保证4个方法都很快！<br>1)让某个子树所有节点值加上v，入参：int head, int v<br>2)查询某个子树所有节点值的累加和，入参：int head<br>3)在树上从a到b的整条链上所有加上v，入参：int a, int b, int v<br>4)查询在树上从a到b的整条链上所有节点值的累加和，入参：int a, int b</p><p>21节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 98 回文子序列个数</title>
      <link href="/2020/12/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-31-Problem-98-%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/12/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-31-Problem-98-%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串str，当然可以生成很多子序列<br>返回有多少个子序列是回文子序列，空序列不算回文<br>比如，str = “aba”<br>回文子序列：{a}、{a}、 {a,a}、 {b}、{a,b,a}<br>返回5</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>定义dp[i][j]表示[i~j]内的回文子序列个数。转移方程为: </li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 97 完美洗牌问题</title>
      <link href="/2020/12/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-29-Problem-97-%E5%AE%8C%E7%BE%8E%E6%B4%97%E7%89%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-29-Problem-97-%E5%AE%8C%E7%BE%8E%E6%B4%97%E7%89%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>完美洗牌问题<br>给定一个长度为偶数的数组arr，假设长度为N*2, 左部分：arr[L1……Ln]    右部分： arr[R1……Rn]<br>请把arr调整成arr[L1,R1,L2,R2,L3,R3,…,Ln,Rn]<br>要求：时间复杂度O(N)，额外空间复杂度O(1)</p><p>20节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 96 公共因子的最大连接数量</title>
      <link href="/2020/12/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-29-Problem-96-%E5%85%AC%E5%85%B1%E5%9B%A0%E5%AD%90%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%87%8F/"/>
      <url>/2020/12/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-29-Problem-96-%E5%85%AC%E5%85%B1%E5%9B%A0%E5%AD%90%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/largest-component-size-by-common-factor/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-component-size-by-common-factor/</a></p><p>20节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>明显就是并查集，只有大于1的公共因子才进行连接，求最大集合的数目</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 95 生成后缀数组</title>
      <link href="/2020/12/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-28-Problem-95-%E7%94%9F%E6%88%90%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
      <url>/2020/12/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-28-Problem-95-%E7%94%9F%E6%88%90%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如果只给定一个二叉树前序遍历数组pre和中序遍历数组in，<br>能否不重建树，而直接生成这个二叉树的后序数组并返回<br>已知二叉树中没有重复值</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目比较简单，利用递归生成即可。注意 为了加快寻找根元素在中序数组中的位置以区分左右子树，可以 事先把元素打入map，存下元素对应的位置。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>略 </p>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 94 达标扑克方法数</title>
      <link href="/2020/12/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-24-Problem-94-%E8%BE%BE%E6%A0%87%E6%89%91%E5%85%8B%E6%96%B9%E6%B3%95%E6%95%B0/"/>
      <url>/2020/12/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-24-Problem-94-%E8%BE%BE%E6%A0%87%E6%89%91%E5%85%8B%E6%96%B9%E6%B3%95%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一张扑克有3个属性，每种属性有3种值（A、B、C）<br>比如”AAA”，第一个属性值A，第二个属性值A，第三个属性值A<br>比如”BCA”，第一个属性值B，第二个属性值C，第三个属性值A<br>给定一个字符串类型的数组cards[]，每一个字符串代表一张扑克<br>从中挑选三张扑克，一个属性达标的条件是：这个属性在三张扑克中全一样，或全不一样<br>挑选的三张扑克达标的要求是：每种属性都满足上面的条件<br>比如：”ABC”、”CBC”、”BBC”<br>第一张第一个属性为”A”、第二张第一个属性为”C”、第三张第一个属性为”B”，全不一样<br>第一张第二个属性为”B”、第二张第二个属性为”B”、第三张第二个属性为”B”，全一样<br>第一张第三个属性为”C”、第二张第三个属性为”C”、第三张第三个属性为”C”，全一样<br>每种属性都满足在三张扑克中全一样，或全不一样，所以这三张扑克达标<br>返回在cards[]中任意挑选三张扑克，达标的方法数</p><p>19节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 93 最小覆盖区间问题</title>
      <link href="/2020/12/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-23-Problem-93-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-23-Problem-93-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Problem 92 1~N中1的出现次数问题</title>
      <link href="/2020/12/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-22-Problem-92-1-N%E4%B8%AD1%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-22-Problem-92-1-N%E4%B8%AD1%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个正数N，比如N = 13，在纸上把所有数都列出来如下：<br>1 2 3 4 5 6 7 8 9 10 11 12 13<br>可以数出1这个字符出现了6次<br>给定一个正数N，如果把1~N都列出来，<br>返回1这个字符出现的多少次</p><p>19节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>也是一种数位思想，统计1出现的次数，那就按位置进行统计，统计每一位贡献出来的1</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Trie </tag>
            
            <tag> Dynacmic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 91 实现LFU</title>
      <link href="/2020/12/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-20-Problem-91-%E5%AE%9E%E7%8E%B0LFU/"/>
      <url>/2020/12/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-20-Problem-91-%E5%AE%9E%E7%8E%B0LFU/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>leetcode原题：</p><p> <a href="https://leetcode.com/problems/lfu-cache/" target="_blank" rel="noopener">https://leetcode.com/problems/lfu-cache/</a></p><p>19</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 90 实现LRU</title>
      <link href="/2020/12/17/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-17-Problem-90-%E5%AE%9E%E7%8E%B0LRU/"/>
      <url>/2020/12/17/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-17-Problem-90-%E5%AE%9E%E7%8E%B0LRU/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>leetcode原题：</p><p><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">https://leetcode.com/problems/lru-cache/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>利用链表增删改的操作是 O(1)，哈希表可用来进行判断是否存在也是O(1)，结合起来。</li><li>可以利用双向链表 实现起来比较简单。重要的是维护好head、last变量。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span></span>&#123; </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> key;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">            <span class="keyword">public</span> LinkedNode next;</span><br><span class="line">            <span class="keyword">public</span> LinkedNode pre;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">LinkedNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.key = key;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer,LinkedNode&gt; data;</span><br><span class="line">        LinkedNode head;</span><br><span class="line">        LinkedNode last;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">            data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> res = data.get(key) == <span class="keyword">null</span> ? -<span class="number">1</span> : data.get(key).value;</span><br><span class="line">            <span class="keyword">if</span>(data.get(key) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> LinkedNode node = data.get(key);</span><br><span class="line">                <span class="keyword">if</span>(head != node)&#123;</span><br><span class="line">                   evict(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//新增</span></span><br><span class="line">            <span class="keyword">if</span>(data.get(key) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count == capacity)&#123;</span><br><span class="line">                    data.remove(last.key);</span><br><span class="line">                    last = last.pre;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> LinkedNode node = <span class="keyword">new</span> LinkedNode(key, value);</span><br><span class="line">                node.key = key;</span><br><span class="line">                node.value = value;</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                    head = node;</span><br><span class="line">                    last = node;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.next = head;</span><br><span class="line">                    head.pre = node;</span><br><span class="line">                    head = node;</span><br><span class="line">                &#125;</span><br><span class="line">                data.put(key,node);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> LinkedNode node = data.get(key);</span><br><span class="line">                node.value = value;</span><br><span class="line">                <span class="keyword">if</span>(node == head)&#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                evict(node); <span class="comment">//把原节点摘下，前置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(LinkedNode node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(last == node)&#123; <span class="comment">//最后一个节点</span></span><br><span class="line">                last = last.pre;</span><br><span class="line">                last.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//普通节点</span></span><br><span class="line">                node.next.pre = node.pre;</span><br><span class="line">                node.pre.next = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head.pre = node;</span><br><span class="line">            head = node;</span><br><span class="line">            head.pre = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LRUCache lruCache = <span class="keyword">new</span> LRUCache(<span class="number">3</span>);</span><br><span class="line">        lruCache.put(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        lruCache.put(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        lruCache.put(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        lruCache.put(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">4</span>));</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">3</span>));</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">2</span>));</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">1</span>));</span><br><span class="line">        lruCache.put(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">2</span>));</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">3</span>)); </span><br><span class="line">        System.out.println(lruCache.get(<span class="number">4</span>));</span><br><span class="line">        System.out.println(lruCache.get(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 89 两个有序数组间相加和的Topk问题 </title>
      <link href="/2020/12/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-13-Problem-89-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%97%B4%E7%9B%B8%E5%8A%A0%E5%92%8C%E7%9A%84Topk%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-13-Problem-89-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%97%B4%E7%9B%B8%E5%8A%A0%E5%92%8C%E7%9A%84Topk%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>牛客网原题：</p><p><a href="https://www.nowcoder.com/practice/7201cacf73e7495aa5f88b223bbbf6d1" target="_blank" rel="noopener">https://www.nowcoder.com/practice/7201cacf73e7495aa5f88b223bbbf6d1</a></p><p>18节 堆玩不转还是</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 88 最大路径和问题</title>
      <link href="/2020/12/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-13-Problem-88-%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-13-Problem-88-%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>牛客网原题：<br><a href="https://www.nowcoder.com/questionTerminal/8ecfe02124674e908b2aae65aad4efdf" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/8ecfe02124674e908b2aae65aad4efdf</a></p><p>18节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目的意思两条路径不能走相同的，这个题可以变通一下，变成同时走两条路，只不过走相同的位置只能获取一次，而且任意时刻，走的总格子数肯定是一样的</li><li>用递归是没问题的，但是必须优化，直接写递归可能是4个参数，开辟的缓存太大。我们发现，不管怎么走，任意时刻两个人走的总步数是一致的。可以根据这，降低一个维度。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//仔细分析之后吗，先去一次，再回来一次，等价于去了一次，在这状态上再去一次，只不是拿了之后就不能再拿了，那么，相当于两个人一块去，同时一个地方的时候，</span></span><br><span class="line">        <span class="comment">//只让一个人拿</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> M = scanner.nextInt();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = scanner.nextInt();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] ints = <span class="keyword">new</span> <span class="keyword">int</span>[M][N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                  ints[i][j] = scanner.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        final HashMap&lt;String, Integer&gt; dp = new HashMap&lt;&gt;(); hashmap依然超时</span></span><br><span class="line"><span class="comment">//        int[][][][] dp = new int[M][N][M][N]; //挂混存这个太大了，最后一个case 堆溢出了 50多M</span></span><br><span class="line">        <span class="comment">//可是直接做dp 四个变量，四个纬度，边界都搞不出来来，比较麻烦</span></span><br><span class="line">        <span class="comment">//所以还是想办法降低缓存大小,这个人的位置是二维，降成一维</span></span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[M][N][M];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N ;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; M;k++) dp[i][j][k] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(process(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ints, M, N,dp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义函数为 这两人到达右下角获取的的最大价值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> i1,<span class="keyword">int</span> j1,<span class="keyword">int</span> i2,<span class="keyword">int</span>[][] map,<span class="keyword">int</span> M,<span class="keyword">int</span> N, <span class="keyword">int</span>[][][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i1 &gt;= M || j1 &gt;= N || i2 &gt;= M || (i1+j1-i2) &gt;= N) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//越界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[i1][j1][i2] != -<span class="number">1</span>) <span class="keyword">return</span> dp[i1][j1][i2];</span><br><span class="line">        <span class="keyword">if</span>(i1 == M-<span class="number">1</span> &amp;&amp; j1 == N-<span class="number">1</span>)&#123; <span class="comment">//到达</span></span><br><span class="line">            dp[i1][j1][i2] = map[i1][j1];</span><br><span class="line">            <span class="keyword">return</span> map[i1][j1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p1 = process(i1,j1+<span class="number">1</span>,i2,map,M,N,dp);</span><br><span class="line">        <span class="keyword">int</span> p2 = process(i1,j1+<span class="number">1</span>,i2+<span class="number">1</span>,map,M,N,dp);</span><br><span class="line">        <span class="keyword">int</span> p3 = process(i1+<span class="number">1</span>,j1,i2,map,M,N,dp);</span><br><span class="line">        <span class="keyword">int</span> p4 = process(i1+<span class="number">1</span>,j1,i2+<span class="number">1</span>,map,M,N,dp);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> max = Math.max(Math.max(Math.max(p1, p2), p3), p4);</span><br><span class="line">        <span class="keyword">int</span> res = max + (i1 == i2 &amp;&amp; j1 == (i1+j1-i2) ? map[i1][j1] : map[i1][j1] + map[i2][i1+j1-i2]);</span><br><span class="line">        dp[i1][j1][i2] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 87 连接岛屿的最短桥问题</title>
      <link href="/2020/12/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-10-Problem-87-%E8%BF%9E%E6%8E%A5%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E7%9F%AD%E6%A1%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-10-Problem-87-%E8%BF%9E%E6%8E%A5%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E7%9F%AD%E6%A1%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode 原题：</p><p><a href="https://leetcode.com/problems/shortest-bridge/" target="_blank" rel="noopener">https://leetcode.com/problems/shortest-bridge/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目含义比较明确，就是有两座孤立的岛屿，然后看看连接起来 需要翻转几个0，显然bfs会很简单。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dirction_x = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dirction_y = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">shortestBridge</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = grid.length;</span><br><span class="line">        <span class="comment">//从一个1开始，记录下第一个岛屿的所有点,然后从这个岛屿进行bfs遍历，第一个遇到非同组的1，表明遇到另一个岛屿了</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] group = <span class="keyword">new</span> <span class="keyword">int</span>[N*N];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j != N)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找其中一个连续的岛屿</span></span><br><span class="line">        dfs(N,i,j,group,grid);</span><br><span class="line">        <span class="comment">//对这个连续对岛屿进行bfs 广播，一直到另一个岛屿</span></span><br><span class="line">        <span class="keyword">return</span> bfs(N, group, grid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span>[] group,<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = row * N + col;</span><br><span class="line">        <span class="keyword">if</span>(!peek(N,row,col)||group[index] == <span class="number">1</span> || grid[row][col] == <span class="number">0</span>)&#123;<span class="comment">//已经访问过了,或者越界</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        group[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">            dfs(N,row+dirction_x[i],col+dirction_y[i],group,grid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span>[] group,<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] queue = <span class="keyword">new</span> <span class="keyword">int</span>[N*N+<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> map[] = <span class="keyword">new</span> <span class="keyword">int</span>[N*N]; <span class="comment">//记录岛屿到达此点的距离</span></span><br><span class="line">        <span class="keyword">int</span> visited[] = <span class="keyword">new</span> <span class="keyword">int</span>[N*N]; <span class="comment">//代表是否入过队了</span></span><br><span class="line">        <span class="keyword">int</span> front  = <span class="number">0</span>,rear = <span class="number">0</span>;<span class="comment">//rear虚指，front实指</span></span><br><span class="line">        <span class="comment">//初始化，岛屿全部元素入队,并且初始化距离为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(group[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                queue[rear++] = i;</span><br><span class="line">                map[i] = <span class="number">0</span>;</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rear != front)&#123; <span class="comment">//队列不空</span></span><br><span class="line">             <span class="keyword">int</span> index = queue[front++];</span><br><span class="line">             <span class="keyword">int</span> col = index % N;</span><br><span class="line">             <span class="keyword">int</span> row = index / N;</span><br><span class="line">             <span class="comment">//探测</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">                 <span class="keyword">int</span> row_t =  row + dirction_x[i];</span><br><span class="line">                 <span class="keyword">int</span> col_t =  col + dirction_y[i];</span><br><span class="line">                 <span class="keyword">int</span> index_t = row_t * N + col_t;</span><br><span class="line">                 <span class="keyword">if</span> (peek(N,row_t,col_t)) &#123;</span><br><span class="line">                     <span class="keyword">if</span>(visited[index_t] == <span class="number">0</span>)&#123;</span><br><span class="line">                         <span class="keyword">if</span> (grid[row_t][col_t] == <span class="number">1</span>) &#123;</span><br><span class="line">                             <span class="keyword">return</span> map[index];</span><br><span class="line">                         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                             map[index_t] = map[index] + <span class="number">1</span>;</span><br><span class="line">                             queue[rear++] = index_t;</span><br><span class="line">                             visited[index_t] = <span class="number">1</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//true代表不越界</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">peek</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; N &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 86 汉诺塔的状态判断问题</title>
      <link href="/2020/12/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-08-Problem-86-%E6%B1%89%E8%AF%BA%E5%A1%94%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-08-Problem-86-%E6%B1%89%E8%AF%BA%E5%A1%94%E7%9A%84%E7%8A%B6%E6%80%81%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组arr，长度为N，arr中的值只有1，2，3三种<br>arr[i] == 1，代表汉诺塔问题中，从上往下第i个圆盘目前在左<br>arr[i] == 2，代表汉诺塔问题中，从上往下第i个圆盘目前在中<br>arr[i] == 3，代表汉诺塔问题中，从上往下第i个圆盘目前在右<br>那么arr整体就代表汉诺塔游戏过程中的一个状况<br>如果这个状况不是汉诺塔最优解运动过程中的状况，返回-1<br>如果这个状况是汉诺塔最优解运动过程中的状况，返回它是第几个状况</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>汉诺塔问题再熟悉不过了，这种问法感觉很不错。</li><li>首先数组中只会出现1,2,3这三种值。在汉诺塔中，如果想把第七个由左挪到右，需要先将前六个诺过去，然后直接将第7个挪到右，也就是说此时正在挪第7个的话，那么第7个之可能是在左盘子（还没挪）或者是右盘子 （刚挪完），把握住这一点，就好办了。</li><li>按照正常的汉诺塔递归过程去编写代码，在任意时刻一定时在挪某一层。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStepth</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> process = process(N - <span class="number">1</span>, arr, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> process;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[0～index] 第index+1层搬走,返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span>[] arr,<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[index] == mid) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index] == from ? <span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[index] == from)&#123;</span><br><span class="line">        <span class="keyword">return</span>  process(index-<span class="number">1</span>,arr,from,mid,to);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = process(index-<span class="number">1</span>,arr,mid,to,from);</span><br><span class="line">        <span class="keyword">if</span>(t == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;(index))+t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 85 子序列字面值问题</title>
      <link href="/2020/12/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-08-Problem-85-%E5%AD%90%E5%BA%8F%E5%88%97%E5%AD%97%E9%9D%A2%E5%80%BC%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-08-Problem-85-%E5%AD%90%E5%BA%8F%E5%88%97%E5%AD%97%E9%9D%A2%E5%80%BC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol><li>给定两个字符串S和T ，返回S的所有子序列中 有多少个子序列的字面值等于T</li><li>给定一个字符串Str 返回Str的所有子序列中有多少不同的字面值</li></ol><p>​        Leetcode原题：<a href="https://leetcode.com/problems/distinct-subsequences-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/distinct-subsequences-ii/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><p>第一问比较简单,定义dp[i][j]表示，[0~i]上子序列字面值等于t[0~j]的个数 则转移方程为<code>dp[i][j] = dp[i - 1][j] + (s[i - 1] == t[j - 1] ? dp[i - 1][j - 1] : 0);</code></p></li><li><p>第二问 可能比较难想，暴力自然不可以通过了，想的就是怎么在遍历字符过程中去除重复，认真观察，重复的子序列必然是由重复字符引起的。</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题目一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] t = T.toCharArray();</span><br><span class="line"><span class="comment">// dp[i][j] : s[0..i] T[0...j]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[i][j] : s只拿前i个字符做子序列，有多少个子序列，字面值等于T的前j个字符的前缀串</span></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length + <span class="number">1</span>][t.length + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// dp[0][0]</span></span><br><span class="line"><span class="comment">// dp[0][j] = s只拿前0个字符做子序列, T前j个字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t.length; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.length; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>] ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[s.length][t.length];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//题目二</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">distinctSubseqII</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> MOD = <span class="number">1000000000</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">if</span>( N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//字符上次出现后新增的</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(map.get(chars[i])==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    map.put(chars[i],cur);</span><br><span class="line">                    cur = (cur * <span class="number">2</span>)%MOD;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = cur;</span><br><span class="line">                    cur = ((cur *<span class="number">2</span>)%MOD-map.get(chars[i]) + MOD)%MOD;</span><br><span class="line">                    map.put(chars[i],tmp);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(cur-<span class="number">1</span>+MOD)%MOD;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 84 回文对问题</title>
      <link href="/2020/12/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-05-Problem-84-%E5%9B%9E%E6%96%87%E5%AF%B9%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-05-Problem-84-%E5%9B%9E%E6%96%87%E5%AF%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/palindrome-pairs/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-pairs/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 83 有序矩阵查第k小的数</title>
      <link href="/2020/12/03/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-03-Problem-83-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
      <url>/2020/12/03/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-03-Problem-83-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%9F%A5%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个每一行有序、每一列也有序，整体可能无序的二维数组<br>在给定一个正数k，<br>返回二维数组中，最小的第k个数</p><p>Leetcode原题：<br><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>需要利用82题的搜索过程，我们取出矩阵中的最小值和最大值，对这区间的数进行二分，每次搜索一个数，得出这个数的最小排名，从而去逼近K，最终得到答案。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> l = matrix[<span class="number">0</span>][<span class="number">0</span>],r = matrix[N-<span class="number">1</span>][N-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> real_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] res = find(matrix, mid);</span><br><span class="line">            <span class="keyword">if</span>(res[<span class="number">0</span>] == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> res[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (res[<span class="number">0</span>] &lt; k)&#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                real_num = res[<span class="number">1</span>];</span><br><span class="line">                r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> real_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] find(<span class="keyword">int</span>[][] m,<span class="keyword">double</span> num)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = m[<span class="number">0</span>].length-<span class="number">1</span>,res = <span class="number">0</span>,real_num = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; m.length &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] &lt;= num)&#123;</span><br><span class="line">                real_num =Math.max(m[i][j],real_num);</span><br><span class="line">                res += j+<span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;res,real_num&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 81 给数组打补丁问题</title>
      <link href="/2020/12/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-01-Problem-81-%E7%BB%99%E6%95%B0%E7%BB%84%E6%89%93%E8%A1%A5%E4%B8%81%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-01-Problem-81-%E7%BB%99%E6%95%B0%E7%BB%84%E6%89%93%E8%A1%A5%E4%B8%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/patching-array/" target="_blank" rel="noopener">https://leetcode.com/problems/patching-array/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>要求添加数字 使得数组内能累加到[1,n]这类题目也挺常见的，假设有[1,2，3],此时可以拿到的最小值是1，最大值是1+2+3 = 6，因为1，2，3是连续的，所以 [1,6]内的任意一个数字都可以拿到。但此时来了一个5，所以现在能拿到的最大值是6+5= 11,由于5+1 = 6，正好和之前[1,2,3]构成的数组[1~6]可以交接上，所以此时可以拿大的连续数字成了[1~11],此时再来一个7，7+1 = 8，7+11 = 18，所以又可以扩展[1~18],此时再来一个19，19+1 = 20，19+18 = 37，现在由19可以单独填充，正好扩展出[1~37]，但此时若来了39，39+1 =40，此时38就得不到了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> range = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[cur] &lt;= range+<span class="number">1</span>)&#123;</span><br><span class="line">                range += nums[cur++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res++; <span class="comment">//补range+1</span></span><br><span class="line">                range += range+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(range &gt;= n) <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (range &lt; n)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            range += range+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 82 有序矩阵值是否存在问题</title>
      <link href="/2020/12/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-01-Problem-82-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E5%80%BC%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-12-01-Problem-82-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E5%80%BC%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个每一行有序、每一列也有序，整体可能无序的二维数组<br>再给定一个数num，<br>返回二维数组中有没有num这个数</p><p> <a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/search-a-2d-matrix-ii/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>看到有序，先想二分。每次都能去除掉一部分元素，最终就能判定出</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length,N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = N-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (inEdge(l,r,M,N))&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[l][r] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[l][r] &gt; target)&#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">inEdge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &gt;= <span class="number">0</span> &amp;&amp; l &lt; m &amp;&amp; r &gt;= <span class="number">0</span> &amp;&amp; r &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 79 不能累加的最小正数</title>
      <link href="/2020/11/30/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-30-Problem-79-%E4%B8%8D%E8%83%BD%E7%B4%AF%E5%8A%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B0/"/>
      <url>/2020/11/30/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-30-Problem-79-%E4%B8%8D%E8%83%BD%E7%B4%AF%E5%8A%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个正数数组arr，<br>返回arr的子集不能累加出的最小正数<br>1）正常怎么做？<br>2）如果arr中肯定有1这个值，怎么做？</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这道题和前面的题目比较像， 都是要求数字连续这个特性。第二问中，如果有1，那么可以做到O(n)的复杂度。假设已经可以达到range了，下一个数字如果是range+1那是没问题的，提升range到range+1,下一个数字如果是大于range+1那么range+1就拼不出来了，为什么能确定拼不出来，要先排序！确保后面的数不会再减小，那么一定是拼不出来了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unformedSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(arr); <span class="comment">// O (N * logN)</span></span><br><span class="line"><span class="keyword">int</span> range = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// arr[0] == 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; range + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> range + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">range += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> range + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 80 挑选子集问题</title>
      <link href="/2020/11/30/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-30-Problem-80-%E6%8C%91%E9%80%89%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/30/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-30-Problem-80-%E6%8C%91%E9%80%89%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个有正、有负、有0的数组arr，<br>给定一个整数k，<br>返回arr的子集是否能累加出k<br>1）正常怎么做？<br>2）如果arr中的数值很大，但是arr的长度不大，怎么做？</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>1) 正常做法 还是递归，背包思想去凑 k就可以，但是因为有负数，所有dp数组index会出现负数，这时候就得涉及到进行偏移，保证数组index不会出现负数</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 78 约瑟夫环问题</title>
      <link href="/2020/11/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-26-Problem-78-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-26-Problem-78-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>约瑟夫环问题</p><p>给定一个链表头节点head，和一个正数m<br>从头开始，每次数到m就杀死当前节点<br>然后被杀节点的下一个节点从1开始重新数，<br>周而复始直到只剩一个节点，返回最后的节点<br>Leetcode :<br><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</a></p><p>16节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Problem 77 股票系列问题</title>
      <link href="/2020/11/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-23-Problem-77-%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-23-Problem-77-%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>15节</p><p>股票问题1：</p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p><p>股票问题2：</p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>股票问题3:</p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p><p>股票问题4：</p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/</a></p><p>股票问题5：</p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><p>股票问题6：</p><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>今天来吧股票问题整一个大总结</p><ul><li>问题一：买一次，卖一次，转化问题，找左边的最小值，与当前值做差，求最大值.</li><li>问题二：相当于无限次，转化也就是找所有的增长区间段。</li><li>问题三: 可以操作两次了，最大的收益。</li><li>问题四：最大可以操作K次，最大收益。</li></ul><p>和明显，问题三和问题四实际是一问，解决四就ok，最简单的办法就是dp，dp[i][k]的含义是从0～i上完成交易不超过k次的最大利润。那么对i位置，只有两种可能性 要么参与交易，要么不参与。参与了也好说，只可能是卖出，因为是完整的交易，进行斜率优化之后，便可以得出如下代码。</p><ul><li>问题五:其实本质没变，还是那个dp模型，所以下面的代码几乎一样，只不过稍微调整下，加了一个限制。</li><li>问题五:暂放。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题一:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            min = Math.min(prices[i],min);</span><br><span class="line">            res = Math.max(res,prices[i]-min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题二:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; prices.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            res  += Math.max(<span class="number">0</span>,prices[i+<span class="number">1</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题四:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = prices.length;</span><br><span class="line">        <span class="comment">//先进行边界处理</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt;= N/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//相当于不加限制,找所有的连续增长段</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">                res += Math.max(<span class="number">0</span>,prices[i+<span class="number">1</span>]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][k+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//第i个利用第i-1个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; k+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N;i++)&#123;</span><br><span class="line">                t = Math.max(t,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">                dp[i][j] = Math.max(t+prices[i],dp[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N-<span class="number">1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题三:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//第i个利用第i-1个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; <span class="number">2</span>+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N ;i++)&#123;</span><br><span class="line">                t = Math.max(t,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">                dp[i][j] = Math.max(t+prices[i],dp[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N-<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题五:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//表示0~i上无限次交易的最大利润</span></span><br><span class="line">        <span class="keyword">if</span>(N &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(<span class="number">0</span>,prices[<span class="number">1</span>]-prices[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> t = Math.max(-prices[<span class="number">1</span>],-prices[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; N;i++)&#123;</span><br><span class="line">            t = Math.max(t,dp[i-<span class="number">2</span>]-prices[i]);</span><br><span class="line">            dp[i] = Math.max(t+prices[i],dp[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(maxProfit(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 76 第一个缺失的正数</title>
      <link href="/2020/11/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-23-Problem-76-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B0/"/>
      <url>/2020/11/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-23-Problem-76-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode原题：</p><p>​    <a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">https://leetcode.com/problems/first-missing-positive/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这类题目使用的一种我管它称作 “占位”的思想<ul><li>对于直接判定垃圾值，会占用有效空间，所以减小连续的最大值</li><li>暂时无法判定是否为垃圾值，进行归位。</li></ul></li><li>需要用L保证扫描过的是连续空间，否则无法判断当前已经连续到哪个值了</li><li>是从1开始的，用双指针可能会很简单</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">法一:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>; <span class="comment">//L,R为虚指,所谓的有效区得保证有效，关键是连续，也就是扫描过去的元素得是连续的才行,L位置必须是放L+1的值</span></span><br><span class="line">        <span class="keyword">int</span> R = nums.length-<span class="number">1</span>; <span class="comment">//R+1代表可连续增长的最大值</span></span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[L]==L+<span class="number">1</span>)&#123;</span><br><span class="line">               L++;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[L] &lt;= L||nums[L] &gt; R+<span class="number">1</span> ||nums[L] == nums[nums[L]-<span class="number">1</span>])&#123;</span><br><span class="line">               swap(nums,L,R);</span><br><span class="line">               R--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               swap(nums,L,nums[L]-<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> loc1,<span class="keyword">int</span> loc2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num[loc1];</span><br><span class="line">        num[loc1] = num[loc2];</span><br><span class="line">        num[loc2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">法二:双指针</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 75 修复BST</title>
      <link href="/2020/11/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-21-Problem-75-%E4%BF%AE%E5%A4%8DBST/"/>
      <url>/2020/11/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-21-Problem-75-%E4%BF%AE%E5%A4%8DBST/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/recover-binary-search-tree/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目中只有两个节点会出错，那么实际中序遍历 要么出现降序一次，要么两次，要是一次只需要交换降序的两个节点，要是两次 需要把第一个降序的节点和最后一个节点交换</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode[] twoErrors(TreeNode head) &#123;</span><br><span class="line">TreeNode[] ans = <span class="keyword">new</span> TreeNode[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode cur = head;</span><br><span class="line">TreeNode mostRight = <span class="keyword">null</span>;</span><br><span class="line">TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">TreeNode e1 = <span class="keyword">null</span>;</span><br><span class="line">TreeNode e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">mostRight = cur.left;</span><br><span class="line"><span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">mostRight = mostRight.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">mostRight.right = cur;</span><br><span class="line">cur = cur.left;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= cur.val) &#123;</span><br><span class="line">e1 = e1 == <span class="keyword">null</span> ? pre : e1;</span><br><span class="line">e2 = cur;</span><br><span class="line">&#125;</span><br><span class="line">pre = cur;</span><br><span class="line">cur = cur.right;</span><br><span class="line">&#125;</span><br><span class="line">ans[<span class="number">0</span>] = e1;</span><br><span class="line">ans[<span class="number">1</span>] = e2;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 73</title>
      <link href="/2020/11/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-21-Problem-73/"/>
      <url>/2020/11/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-21-Problem-73/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>从二叉树的某个节点x开始，往下子节点都要的，叫子树；<br>在二叉树上只要能连起来的任何结构，叫子拓扑结构；<br>返回二叉树上满足搜索二叉树性质的、最大子拓扑结构的节点数</p><p>14节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 72 小于K的最大子数组和</title>
      <link href="/2020/11/18/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-18-Problem-72-%E5%B0%8F%E4%BA%8EK%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
      <url>/2020/11/18/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-18-Problem-72-%E5%B0%8F%E4%BA%8EK%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    请返回arr中，求子数组的累加和，是&lt;=K的并且是最大的<br>返回这个最大的累加和</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>考察的是前缀和的应用！前缀和已经多次提到了，就看你能不能灵活应用了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请返回arr中，求个子数组的累加和，是&lt;=K的，并且是最大的。</span></span><br><span class="line"><span class="comment">// 返回这个最大的累加和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxLessOrEqualK</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 记录i之前的，前缀和，按照有序表组织</span></span><br><span class="line">TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 一个数也没有的时候，就已经有一个前缀和是0了</span></span><br><span class="line">set.add(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 每一步的i，都求子数组必须以i结尾的情况下，求个子数组的累加和，是&lt;=K的，并且是最大的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">sum += arr[i]; <span class="comment">// sum -&gt; arr[0..i];</span></span><br><span class="line"><span class="keyword">if</span> (set.ceiling(sum - K) != <span class="keyword">null</span>) &#123;</span><br><span class="line">max = Math.max(max, sum - set.ceiling(sum - K));</span><br><span class="line">&#125;</span><br><span class="line">set.add(sum); <span class="comment">// 当前的前缀和加入到set中去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 71 最长的有效括号的子串</title>
      <link href="/2020/11/18/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-18-Problem-71-%E6%9C%80%E9%95%BF%E7%9A%84%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/11/18/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-18-Problem-71-%E6%9C%80%E9%95%BF%E7%9A%84%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个只由左括号和右括号的字符串<br>返回最长的有效括号子串的长度</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>分析题目，dp[i]代表以当前i位置结尾，最长的有效括号的子串长度。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s只由(和)组成</span></span><br><span class="line"><span class="comment">// 求最长有效括号子串长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="comment">// dp[i] : 子串必须以i位置结尾的情况下，往左最远能扩出多长的有效区域</span></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str.length];</span><br><span class="line"><span class="comment">// dp[0] = 0; （  ）</span></span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">')'</span>) &#123;</span><br><span class="line"><span class="comment">// 当前谁和i位置的)，去配！</span></span><br><span class="line">pre = i - dp[i - <span class="number">1</span>] - <span class="number">1</span>; <span class="comment">// 与str[i]配对的左括号的位置 pre</span></span><br><span class="line"><span class="keyword">if</span> (pre &gt;= <span class="number">0</span> &amp;&amp; str[pre] == <span class="string">'('</span>) &#123;</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span> + (pre &gt; <span class="number">0</span> ? dp[pre - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = Math.max(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 70 数组调整的逆序对问题</title>
      <link href="/2020/11/15/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-15-Problem-70-%E6%95%B0%E7%BB%84%E8%B0%83%E6%95%B4%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/15/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-15-Problem-70-%E6%95%B0%E7%BB%84%E8%B0%83%E6%95%B4%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定整数power，给定一个数组arr，给定一个数组reverse，<br>含义如下：<br>arr的长度一定是2的power次方<br>reverse中的每个值一定都在0~power范围。<br>例如power = 2, arr = {3, 1, 4, 2}，reverse = {0, 1, 0, 2}</p><p>任何一个在前的数字可以和任何一个在后的数组，构成一对数<br>可能是升序关系、相等关系或者降序关系<br>比如arr开始时有如下的降序对：(3,1)、(3,2)、(4,2)，一共3个<br>接下来根据reverse对arr进行调整：<br>reverse[0] = 0, 表示在arr中，划分每1(2的0次方)个数一组然后每个小组内部逆序，那么arr变成[3,1,4,2]，此时有3个逆序对</p><p>reverse[1] = 1, 表示在arr中，划分每2(2的1次方)个数一组，然后每个小组内部逆序，那么arr变成[1,3,2,4]，此时有1个逆序对<br>reverse[2] = 0, 表示在arr中，划分每1(2的0次方)个数一组，然后每个小组内部逆序，那么arr变成[1,3,2,4]，此时有1个逆序对<br>reverse[3] = 2, 表示在arr中，划分每4(2的2次方)个数一组，然后每个小组内部逆序，那么arr变成[4,2,3,1]，此时有4个逆序对<br>所以返回[3,1,1,4]，表示每次调整之后的逆序对数量</p><p>输入数据状况：<br>power的范围[0,20]<br>arr长度范围[1,10的7次方]<br>reverse长度范围[1,10的6次方]</p><p>16节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 69 回文对</title>
      <link href="/2020/11/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-12-Problem-69-%E5%9B%9E%E6%96%87%E5%AF%B9/"/>
      <url>/2020/11/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-12-Problem-69-%E5%9B%9E%E6%96%87%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode原题：</p><p>​    <a href="https://leetcode.com/problems/palindrome-pairs/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-pairs/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题简单思路是暴力 能做的。</li><li>提供第二种思路。我们针对每个字符串，要是能直接找出来与之配对能成为回文的，就不需要无脑的匹配再判断是不是回文了。那如果找是关键，是突破口！判断是回文的前缀，将后面逆序放前面则是回文！同理，判断是回文的后缀逆序，将前缀逆序放后面则是回文串！</li><li>同时，判断哪些前缀是回文，可以用mancher算法提前预处理得出，算是一个优化。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; palindromePairs(String[] words) &#123;</span><br><span class="line">HashMap&lt;String, Integer&gt; wordset = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">wordset.put(words[i], i);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//&#123; [6,23] 、 [7,13] &#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line"><span class="comment">// i words[i]</span></span><br><span class="line"><span class="comment">// findAll(字符串，在i位置，wordset) 返回所有生成的结果返回</span></span><br><span class="line">res.addAll(findAll(words[i], i, wordset));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; findAll(String word, <span class="keyword">int</span> index, HashMap&lt;String, Integer&gt; words) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">String reverse = reverse(word);</span><br><span class="line">Integer rest = words.get(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (rest != <span class="keyword">null</span> &amp;&amp; rest != index &amp;&amp; word.equals(reverse)) &#123;</span><br><span class="line">addRecord(res, rest, index);</span><br><span class="line">addRecord(res, index, rest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] rs = manacherss(word);</span><br><span class="line"><span class="keyword">int</span> mid = rs.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mid; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i - rs[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">rest = words.get(reverse.substring(<span class="number">0</span>, mid - i));</span><br><span class="line"><span class="keyword">if</span> (rest != <span class="keyword">null</span> &amp;&amp; rest != index) &#123;</span><br><span class="line">addRecord(res, rest, index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt; rs.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i + rs[i] == rs.length) &#123;</span><br><span class="line">rest = words.get(reverse.substring((mid &lt;&lt; <span class="number">1</span>) - i));</span><br><span class="line"><span class="keyword">if</span> (rest != <span class="keyword">null</span> &amp;&amp; rest != index) &#123;</span><br><span class="line">addRecord(res, index, rest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addRecord</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; newr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">newr.add(left);</span><br><span class="line">newr.add(right);</span><br><span class="line">res.add(newr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] manacherss(String word) &#123;</span><br><span class="line"><span class="keyword">char</span>[] mchs = manachercs(word);</span><br><span class="line"><span class="keyword">int</span>[] rs = <span class="keyword">new</span> <span class="keyword">int</span>[mchs.length];</span><br><span class="line"><span class="keyword">int</span> center = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pr = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != mchs.length; i++) &#123;</span><br><span class="line">rs[i] = pr &gt; i ? Math.min(rs[(center &lt;&lt; <span class="number">1</span>) - i], pr - i) : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i + rs[i] &lt; mchs.length &amp;&amp; i - rs[i] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mchs[i + rs[i]] != mchs[i - rs[i]]) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">rs[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + rs[i] &gt; pr) &#123;</span><br><span class="line">pr = i + rs[i];</span><br><span class="line">center = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] manachercs(String word) &#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] mchs = <span class="keyword">new</span> <span class="keyword">char</span>[chs.length * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != mchs.length; i++) &#123;</span><br><span class="line">mchs[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? <span class="string">'#'</span> : chs[index++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mchs;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r = chs.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">char</span> tmp = chs[l];</span><br><span class="line">chs[l++] = chs[r];</span><br><span class="line">chs[r--] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(chs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 68 修复BST</title>
      <link href="/2020/11/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-12-Problem-68-%E4%BF%AE%E5%A4%8DBST/"/>
      <url>/2020/11/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-12-Problem-68-%E4%BF%AE%E5%A4%8DBST/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode原题：</p><p>​    <a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/recover-binary-search-tree/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目比较简答，因为BST中序遍历是升序，任意调换两个节点，正常的影响就是把中序中这两个元素进行调换会出现两段降序。case1 还提示了 也会有情况出现一段降序。所以说最多两段降序。我们给交换回来即可。</li><li>用chi[]数组，0位置代表pre。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123; </span><br><span class="line">          TreeNode[] chs = <span class="keyword">new</span> TreeNode[<span class="number">3</span>];</span><br><span class="line">          InOrder(root,chs);</span><br><span class="line">          <span class="keyword">int</span> temp = chs[<span class="number">1</span>].val;</span><br><span class="line">          chs[<span class="number">1</span>].val = chs[<span class="number">2</span>].val;</span><br><span class="line">          chs[<span class="number">2</span>].val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(TreeNode root,TreeNode[] chs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        InOrder(root.left,chs);</span><br><span class="line">        <span class="keyword">if</span> (chs[<span class="number">0</span>] != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chs[<span class="number">0</span>].val &gt; root.val) &#123;</span><br><span class="line">                chs[<span class="number">1</span>] = chs[<span class="number">1</span>] == <span class="keyword">null</span> ? chs[<span class="number">0</span>] : chs[<span class="number">1</span>];</span><br><span class="line">                chs[<span class="number">2</span>] = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chs[<span class="number">0</span>] = root;</span><br><span class="line">        InOrder(root.right,chs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 67 打砖块</title>
      <link href="/2020/11/11/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-11-Problem-67-%E6%89%93%E7%A0%96%E5%9D%97/"/>
      <url>/2020/11/11/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-11-Problem-67-%E6%89%93%E7%A0%96%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/bricks-falling-when-hit/" target="_blank" rel="noopener">https://leetcode.com/problems/bricks-falling-when-hit/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>首先一定要熟悉并查集。此题是并查集的逆运用，思考并查集核心思想在于集合的合并。而击落砖块问的是掉落之后的个数，相当于初始情况是一个大集合，不断的击落砖块时，集合分散之后，那些无连接的集合大小。所以可以，倒过来想，从击落最后一块砖块开始，此时是分散集合，不断的把击落的往回放，则相当于集合合并了。</li><li>涉及到连接天花板，我们可以设计天花板集合、天花板元素 这种变量。通过此题我们可以学会灵活设计变量这技巧。</li><li>小技巧:<code>cellSet[parent1]^cellSet[parent2]</code>判断是否相同</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> parent[];</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> cellSize;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> cellSet[];</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> size[];</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[][] grid;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> M,N;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            M = grid.length;</span><br><span class="line">            N = grid[<span class="number">0</span>].length;</span><br><span class="line">            <span class="keyword">this</span>.grid = grid;</span><br><span class="line">            size = <span class="keyword">new</span> <span class="keyword">int</span>[M*N];</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[M*N];</span><br><span class="line">            cellSet = <span class="keyword">new</span> <span class="keyword">boolean</span>[M*N];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> index = i*N+j;</span><br><span class="line">                    <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                        parent[index] = index;</span><br><span class="line">                        size[index] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                            cellSet[index] = <span class="keyword">true</span>;</span><br><span class="line">                            cellSize++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            initConnnet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initConnnet</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123; <span class="comment">//直接上下左右的去连，边界处理，交给下游</span></span><br><span class="line">                    union(i,j,i-<span class="number">1</span>,j);</span><br><span class="line">                    union(i,j,i+<span class="number">1</span>,j);</span><br><span class="line">                    union(i,j,i,j-<span class="number">1</span>);</span><br><span class="line">                    union(i,j,i,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> par = parent[index];</span><br><span class="line">            <span class="keyword">while</span> (par != parent[par])&#123;</span><br><span class="line">                par = parent[par];</span><br><span class="line">            &#125;</span><br><span class="line">            parent[index] = par;</span><br><span class="line">            <span class="keyword">return</span> par;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> r1,<span class="keyword">int</span> c1,<span class="keyword">int</span> r2,<span class="keyword">int</span> c2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(validLoc(r1,c1) &amp;&amp; validLoc(r2,c2))&#123;</span><br><span class="line">                <span class="keyword">int</span> loc1 = r1*N+c1;</span><br><span class="line">                <span class="keyword">int</span> loc2 = r2*N+c2;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> parent1 = find(loc1);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> parent2 = find(loc2);</span><br><span class="line">                <span class="keyword">if</span>(parent1 != parent2)&#123;</span><br><span class="line">                    parent[parent1] = parent2;</span><br><span class="line">                    <span class="keyword">if</span>(cellSet[parent1]^cellSet[parent2])&#123;</span><br><span class="line">                        cellSize += cellSet[parent1] ? size[parent2]:size[parent1];</span><br><span class="line">                        cellSet[parent2] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    size[parent2] += size[parent1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validLoc</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> r &gt;= <span class="number">0</span> &amp;&amp; r &lt; M &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; N &amp;&amp; grid[r][c] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">            grid[r][c] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = r*N+c;</span><br><span class="line">            parent[cur] = cur;</span><br><span class="line">            size[cur] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> pre = cellSize;</span><br><span class="line">            <span class="keyword">if</span>(r == <span class="number">0</span>)&#123; <span class="comment">// 该恢复恢复，0行的肯定是天花板的元素,所以要是打的这里，本身就要先加入到天花板集合里</span></span><br><span class="line">                cellSize++;</span><br><span class="line">                cellSet[cur] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            union(r,c,r-<span class="number">1</span>,c);</span><br><span class="line">            union(r,c,r+<span class="number">1</span>,c);</span><br><span class="line">            union(r,c,r,c-<span class="number">1</span>);</span><br><span class="line">            union(r,c,r,c+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> now = cellSize;</span><br><span class="line">            <span class="keyword">return</span> now == pre ? <span class="number">0</span> : now-pre-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] hitBricks(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span>[][] hits) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[hits.length];</span><br><span class="line">        <span class="keyword">int</span> n = hits.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; hits.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[hits[i][<span class="number">0</span>]][hits[i][<span class="number">1</span>]] == <span class="number">1</span>)&#123;</span><br><span class="line">                grid[hits[i][<span class="number">0</span>]][hits[i][<span class="number">1</span>]] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> UnionFind uf = <span class="keyword">new</span> UnionFind(grid);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hits.length-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[hits[i][<span class="number">0</span>]][hits[i][<span class="number">1</span>]] == <span class="number">2</span>)&#123;</span><br><span class="line">                ans[i] =  uf.connect(hits[i][<span class="number">0</span>],hits[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] ints = hitBricks(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">1</span>&#125;&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">4</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;&#125;);</span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 66. 扰乱字符串</title>
      <link href="/2020/11/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-08-Problem-66-%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/11/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-08-Problem-66-%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode原题：</p><p><a href="https://leetcode.com/problems/scramble-string/" target="_blank" rel="noopener">https://leetcode.com/problems/scramble-string/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>思路比较直接，更加考察编程能力，包括这些位置的推断。以及递归的设计</li><li>普通递归，不去优化会卡在最后连个case上，加上缓存就可以顺利通过。主要是能快速写出来程序，所以没有进一步优化，也可以进一步写成数组严格递归的形式，甚至用斜率优化</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars2 = s2.toCharArray();</span><br><span class="line">        <span class="keyword">if</span> (s1.length() != s2.length()) <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//        return process(chars1,0,chars2,0,s1.length());</span></span><br><span class="line">        <span class="keyword">int</span>[][][]dp = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length()][s1.length()][s1.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process1(chars1,<span class="number">0</span>,chars2,<span class="number">0</span>,s1.length(),dp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] s1, <span class="keyword">int</span> l1, <span class="keyword">char</span>[] s2, <span class="keyword">int</span> l2, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">1</span>) <span class="keyword">return</span> s1[l1] == s2[l2];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> leftOffset = <span class="number">0</span>;leftOffset &lt; size-<span class="number">1</span>;leftOffset++)&#123; <span class="comment">//枚举交换点</span></span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            <span class="keyword">if</span> (isSameType(s1,l1,l1+leftOffset,s2,l2,l2+leftOffset) &amp;&amp; isSameType(s1,l1+leftOffset+<span class="number">1</span>,l1+size-<span class="number">1</span>,s2,l2+leftOffset+<span class="number">1</span>,l2+size-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(process(s1,l1,s2,l2,leftOffset+<span class="number">1</span>) &amp;&amp; process(s1,l1+leftOffset+<span class="number">1</span>,s2,l2+leftOffset+<span class="number">1</span>,size-leftOffset-<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSameType(s1,l1,l1+leftOffset,s2,l2+size-<span class="number">1</span>-leftOffset,l2+size-<span class="number">1</span>) &amp;&amp; isSameType(s1,l1+leftOffset+<span class="number">1</span>,l1+size-<span class="number">1</span>,s2,l2,l2+size-<span class="number">1</span>-leftOffset-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span> (process(s1,l1,s2,l2+size-<span class="number">1</span>-leftOffset,leftOffset+<span class="number">1</span>) &amp;&amp; process(s1,l1+leftOffset+<span class="number">1</span>,s2,l2,size-leftOffset-<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process1</span><span class="params">(<span class="keyword">char</span>[] s1, <span class="keyword">int</span> l1, <span class="keyword">char</span>[] s2, <span class="keyword">int</span> l2, <span class="keyword">int</span> size,<span class="keyword">int</span>[][][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[l1][l2][size]!=<span class="number">0</span>) <span class="keyword">return</span> dp[l1][l2][size]==<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">1</span>) <span class="keyword">return</span> s1[l1] == s2[l2];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> leftOffset = <span class="number">0</span>;leftOffset &lt; size-<span class="number">1</span>;leftOffset++)&#123; <span class="comment">//枚举交换点</span></span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            <span class="keyword">if</span> (isSameType(s1,l1,l1+leftOffset,s2,l2,l2+leftOffset) &amp;&amp; isSameType(s1,l1+leftOffset+<span class="number">1</span>,l1+size-<span class="number">1</span>,s2,l2+leftOffset+<span class="number">1</span>,l2+size-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(process1(s1,l1,s2,l2,leftOffset+<span class="number">1</span>,dp) &amp;&amp; process1(s1,l1+leftOffset+<span class="number">1</span>,s2,l2+leftOffset+<span class="number">1</span>,size-leftOffset-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                    dp[l1][l2][size] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSameType(s1,l1,l1+leftOffset,s2,l2+size-<span class="number">1</span>-leftOffset,l2+size-<span class="number">1</span>) &amp;&amp; isSameType(s1,l1+leftOffset+<span class="number">1</span>,l1+size-<span class="number">1</span>,s2,l2,l2+size-<span class="number">1</span>-leftOffset-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span> (process1(s1,l1,s2,l2+size-<span class="number">1</span>-leftOffset,leftOffset+<span class="number">1</span>,dp) &amp;&amp; process1(s1,l1+leftOffset+<span class="number">1</span>,s2,l2,size-leftOffset-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                    dp[l1][l2][size] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l1][l2][size] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">isSameType</span><span class="params">(<span class="keyword">char</span>[] s1,<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,<span class="keyword">char</span>[] s2,<span class="keyword">int</span> l2,<span class="keyword">int</span> r2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]  map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l1; i &lt;= r1 ; i++) &#123;</span><br><span class="line">            map[s1[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l2;i &lt;= r2;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(--map[s2[i]] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 65 超级洗衣机</title>
      <link href="/2020/11/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-08-Problem-65-%E8%B6%85%E7%BA%A7%E6%B4%97%E8%A1%A3%E6%9C%BA/"/>
      <url>/2020/11/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-08-Problem-65-%E8%B6%85%E7%BA%A7%E6%B4%97%E8%A1%A3%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>  Leetcode原题：<br>  <a href="https://leetcode.com/problems/super-washing-machines/" target="_blank" rel="noopener">https://leetcode.com/problems/super-washing-machines/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>考察单点瓶颈问题。诸如此类的还有接雨水问题等 都是考察 ”最短处“，整个问题的解决在于“痛点”。洗衣机每个都可以一次扔一件衣服，因为可以并发进行。那么只要找到需要扔到最多的，问题就解决了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinMoves</span><span class="params">(<span class="keyword">int</span>[] machines)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; machines.length;i++)&#123;</span><br><span class="line">           sum += machines[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % machines.length !=<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> avg = sum / machines.length;</span><br><span class="line">        <span class="keyword">int</span> leftSum = <span class="number">0</span>,ans = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; machines.length;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> leftRest = leftSum - i*avg;</span><br><span class="line">           <span class="keyword">int</span> rightRest = (sum - leftSum - machines[i]) - (machines.length-<span class="number">1</span>-i) * avg;</span><br><span class="line">           <span class="keyword">if</span>(leftRest &lt; <span class="number">0</span> &amp;&amp; rightRest &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               ans = Math.max(ans,Math.abs(leftRest) + Math.abs(rightRest));</span><br><span class="line">           &#125;<span class="keyword">else</span></span><br><span class="line">               ans = Math.max(ans,Math.max(Math.abs(leftRest),Math.abs(rightRest)));</span><br><span class="line">           leftSum += machines[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 64 谷歌抽牌问题</title>
      <link href="/2020/11/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-05-Problem-64-%E8%B0%B7%E6%AD%8C%E6%8A%BD%E7%89%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-05-Problem-64-%E8%B0%B7%E6%AD%8C%E6%8A%BD%E7%89%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    谷歌面试题扩展版<br>面值为1~N的牌组成一组，<br>每次你从组里等概率的抽出1~N中的一张<br>下次抽会换一个新的组，有无限组<br>当累加和<a时，你将一直抽牌当累加和>=a且<b时，你将获胜当累加和>=b时，你将失败<br>返回获胜的概率，给定的参数为N，a，b</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>可能一上来不知道如何下手，这种就想先定义递归含义。依据定义的含义在去写递归体，最后想递归边界，以及优化点。</li><li>这个题想到大概思路之后，还要注意优化，关键在于(a,b)之间的距离</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">1</span> || a &gt;= b || a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b - a &gt;= N) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所有参数都合法，并且b-a &lt; N</span></span><br><span class="line"><span class="keyword">return</span> p(<span class="number">0</span>, N, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏规则，如上，int N, int a, int b，固定参数！</span></span><br><span class="line"><span class="comment">// cur，目前到达了cur的累加和</span></span><br><span class="line"><span class="comment">// 返回赢的概率</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> N, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cur &gt;= a &amp;&amp; cur &lt; b) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur &gt;= b) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> w = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">w += p(cur + i, N, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> w / N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 63</title>
      <link href="/2020/11/04/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-04-Problem-63/"/>
      <url>/2020/11/04/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-04-Problem-63/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>好题。考察递归，重点思考后面元素是*或者.，需要对这种特殊清楚进行分析可能性。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][p.length()];</span><br><span class="line">        <span class="keyword">return</span> process2(s.toCharArray(),<span class="number">0</span>,p.toCharArray(),<span class="number">0</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> i,<span class="keyword">char</span>[] exp,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j==exp.length) <span class="keyword">return</span> i ==str.length;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span> != exp.length &amp;&amp; exp[j+<span class="number">1</span>] != <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i != str.length &amp;&amp; (str[i]==exp[j] || exp[j]==<span class="string">'.'</span>) &amp;&amp; process(str,i+<span class="number">1</span>,exp,j+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> == exp.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span> == str.length &amp;&amp; (str[i]==exp[j] || exp[j]==<span class="string">'.'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> c = i;</span><br><span class="line">                <span class="keyword">while</span> (c &lt; str.length &amp;&amp; (str[c]==exp[j]||exp[j]==<span class="string">'.'</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (process(str,c+<span class="number">1</span>,exp,j+<span class="number">2</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    c++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  process(str,i,exp,j+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process2</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> i,<span class="keyword">char</span>[] exp,<span class="keyword">int</span> j,<span class="keyword">boolean</span>[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j == exp.length) &#123;</span><br><span class="line">            dp[i][j] = i == str.length;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> != exp.length &amp;&amp; exp[j + <span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">            dp[i][j] = i != str.length &amp;&amp; (str[i] == exp[j] || exp[j] == <span class="string">'.'</span>) &amp;&amp; process(str, i + <span class="number">1</span>, exp, j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> == exp.length) &#123;</span><br><span class="line">                dp[i][j] = i + <span class="number">1</span> == str.length &amp;&amp; (str[i] == exp[j] || exp[j] == <span class="string">'.'</span>);</span><br><span class="line">                <span class="keyword">return</span> dp[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> c = i;</span><br><span class="line">                <span class="keyword">while</span> (c &lt; str.length &amp;&amp; (str[c] == exp[j] || exp[j] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (process(str, c + <span class="number">1</span>, exp, j + <span class="number">2</span>)) &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    c++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = process(str, i, exp, j + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--进行斜率优化，优化掉循环</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process2(s.toCharArray(),<span class="number">0</span>,p.toCharArray(),<span class="number">0</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> i,<span class="keyword">char</span>[] exp,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j==exp.length) <span class="keyword">return</span> i ==str.length;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span> != exp.length &amp;&amp; exp[j+<span class="number">1</span>] != <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i != str.length &amp;&amp; (str[i]==exp[j] || exp[j]==<span class="string">'.'</span>) &amp;&amp; process(str,i+<span class="number">1</span>,exp,j+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> == exp.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span> == str.length &amp;&amp; (str[i]==exp[j] || exp[j]==<span class="string">'.'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> c = i;</span><br><span class="line">                <span class="keyword">while</span> (c &lt; str.length &amp;&amp; (str[c]==exp[j]||exp[j]==<span class="string">'.'</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (process(str,c+<span class="number">1</span>,exp,j+<span class="number">2</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    c++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  process(str,i,exp,j+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process2</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> i,<span class="keyword">char</span>[] exp,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>) <span class="keyword">return</span> dp[i][j]==<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == exp.length) &#123;</span><br><span class="line">           res = i == str.length;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> != exp.length &amp;&amp; exp[j + <span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != str.length &amp;&amp; (str[i] == exp[j] || exp[j] == <span class="string">'.'</span>) &amp;&amp; process2(str, i + <span class="number">1</span>, exp, j + <span class="number">1</span>,dp))&#123;</span><br><span class="line">                    res = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> == exp.length) &#123;</span><br><span class="line">                    res =  i + <span class="number">1</span> == str.length &amp;&amp; (str[i] == exp[j] || exp[j] == <span class="string">'.'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">                        res = process2(str, i, exp, j + <span class="number">2</span>,dp);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(str[i] != exp[j] &amp;&amp; exp[j] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                            res =  process2(str, i, exp, j + <span class="number">2</span>,dp);</span><br><span class="line">                        &#125;<span class="keyword">else</span></span><br><span class="line">                            res = process2(str, i, exp, j + <span class="number">2</span>,dp) || process2(str, i+<span class="number">1</span>, exp, j,dp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = res?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 62 最长连续序列</title>
      <link href="/2020/11/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-01-Problem-62-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
      <url>/2020/11/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-11-01-Problem-62-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-consecutive-sequence/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>和之前的播放流题目类似，用头表，尾表的思想实现，只不过这个题是用map，不是基于链表的</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>)<span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, Integer&gt; head = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, Integer&gt; tail = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(head.containsKey(nums[i]) || tail.containsKey(nums[i]))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                head.put(nums[i],<span class="number">1</span>);</span><br><span class="line">                tail.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//和前面连一块</span></span><br><span class="line">            <span class="keyword">if</span> (tail.containsKey(nums[i] - <span class="number">1</span>)) &#123;</span><br><span class="line">                head.remove(nums[i]);</span><br><span class="line">                <span class="keyword">final</span> Integer preLen = tail.get(nums[i] - <span class="number">1</span>);</span><br><span class="line">                head.put(nums[i] - preLen, head.get(nums[i] - preLen) + <span class="number">1</span>);</span><br><span class="line">                tail.put(nums[i], preLen + <span class="number">1</span>);</span><br><span class="line">                res = Math.max(res,preLen+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//和后面连上，注意同时更新前面的连续序列</span></span><br><span class="line">            <span class="keyword">if</span> (head.containsKey(nums[i] + <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Integer posLen = head.get(nums[i] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">final</span> Integer preLen = tail.get(nums[i]);</span><br><span class="line">                head.put(nums[i]-preLen+<span class="number">1</span>,preLen+posLen);</span><br><span class="line">                tail.put(nums[i]+posLen,preLen+posLen);</span><br><span class="line">                res = Math.max(res,preLen+posLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 61 两个有序数整体K小</title>
      <link href="/2020/10/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-31-Problem-61-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E6%95%B4%E4%BD%93K%E5%B0%8F/"/>
      <url>/2020/10/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-31-Problem-61-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E6%95%B4%E4%BD%93K%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode.com/problems/median-of-two-sorted-arrays/</a><br>进阶问题：<br>在两个都有序的数组中找整体第K小的数<br>可以做到O(log(Min(M,N)))</p><p>12节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 60 查找种类及个数相同的子串</title>
      <link href="/2020/10/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-28-Problem-60-%E6%9F%A5%E6%89%BE%E7%A7%8D%E7%B1%BB%E5%8F%8A%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/10/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-28-Problem-60-%E6%9F%A5%E6%89%BE%E7%A7%8D%E7%B1%BB%E5%8F%8A%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定长度为m的字符串aim，以及一个长度为n的字符串str<br>问能否在str中找到一个长度为m的连续子串，<br>使得这个子串刚好由aim的m个字符组成，顺序无所谓，<br>返回任意满足条件的一个子串的起始位置，未找到返回-1</p><p>Leetcode:567</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目比较简单 使用滑动窗口+字符表映射就可以解决</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">containExactly</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span> || s1.length() &lt; s2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> M = str2.length;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            count[str2[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> all = M;</span><br><span class="line">        <span class="keyword">char</span>[] str1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0~M-1</span></span><br><span class="line">        <span class="keyword">for</span> (; R &lt; M; R++) &#123; <span class="comment">// 最早的M个字符，让其窗口初步形成</span></span><br><span class="line">            <span class="keyword">if</span> (count[str1[R]]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                all--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 窗口初步形成了，并没有判断有效无效，决定下一个位置一上来判断</span></span><br><span class="line">        <span class="comment">// 接下来的过程，窗口右进一个，左吐一个</span></span><br><span class="line">        <span class="keyword">for</span> (; R &lt; str1.length; R++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (all == <span class="number">0</span>) &#123; <span class="comment">// R-1</span></span><br><span class="line">                <span class="keyword">return</span> R - M;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count[str1[R]]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                all--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count[str1[R - M]]++ &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                all++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> all == <span class="number">0</span> ? R - M : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 59 切分回文串的最少刀数</title>
      <link href="/2020/10/27/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-27-Problem-59-%E5%88%87%E5%88%86%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%80%E6%95%B0/"/>
      <url>/2020/10/27/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-27-Problem-59-%E5%88%87%E5%88%86%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%80%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    问题一：一个字符串至少要切几刀能让切出来的子串都是回文串</p><p>问题二：返回问题一的其中一种划分结果</p><p>问题三：返回问题一的所有划分结果</p><p>11jie</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 58 整体回文串的所有添加结果</title>
      <link href="/2020/10/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-24-Problem-58-%E6%95%B4%E4%BD%93%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%89%80%E6%9C%89%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%9C/"/>
      <url>/2020/10/24/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-24-Problem-58-%E6%95%B4%E4%BD%93%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%89%80%E6%9C%89%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>问题一：一个字符串至少需要添加多少个字符能整体变成回文串</p><p><a href="https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/</a></p><p>问题二：返回问题一的其中一种添加结果</p><p>问题三：返回问题一的所有添加结果</p><p>11节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目原型比较简单，普通的dp 行列模型。主要是通过此题目 总结一下通过dp矩阵查找答案的方法。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>问题一:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> N = chars.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = chars[i]==chars[i+<span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">3</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">2</span>;j &lt; N;j++)&#123;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i+<span class="number">1</span>][j]+<span class="number">1</span>),dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + (chars[i]==chars[j] ?<span class="number">0</span>:<span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][N-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题二 :</p><p>其实可能性的划分，第三种可视为只有当chars[i] == chars[j]的时候 才会可能去取dp[i+1][j-1]的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题第二问，返回其中一种结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minInsertionsOneWay</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> N = str.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[i][i + <span class="number">1</span>] = str[i] == str[i + <span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; N; j++) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (str[i] == str[j]) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R = N - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span>[] ans = <span class="keyword">new</span> <span class="keyword">char</span>[N + dp[L][R]];</span><br><span class="line"><span class="keyword">int</span> ansl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ansr = ans.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[L][R - <span class="number">1</span>] == dp[L][R] - <span class="number">1</span>) &#123;</span><br><span class="line">ans[ansl++] = str[R];</span><br><span class="line">ans[ansr--] = str[R--];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[L + <span class="number">1</span>][R] == dp[L][R] - <span class="number">1</span>) &#123;</span><br><span class="line">ans[ansl++] = str[L];</span><br><span class="line">ans[ansr--] = str[L++];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans[ansl++] = str[L++];</span><br><span class="line">ans[ansr--] = str[R--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">ans[ansl] = str[L];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题三:</p><p>问题三，完全成了深度优先遍历。走dp去枚举所有可能性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本题第三问，返回所有可能的结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">minInsertionsAllWays</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">ans.add(s);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> N = str.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[i][i + <span class="number">1</span>] = str[i] == str[i + <span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; N; j++) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (str[i] == str[j]) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> M = N + dp[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span>[] path = <span class="keyword">new</span> <span class="keyword">char</span>[M];</span><br><span class="line">process(str, dp, <span class="number">0</span>, N - <span class="number">1</span>, path, <span class="number">0</span>, M - <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前来到的动态规划中的格子，(L,R)</span></span><br><span class="line"><span class="comment">// path ....  [pl....pr] ....</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span>[][] dp, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">char</span>[] path, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr, List&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt;= R) &#123; <span class="comment">// L &gt; R  L==R</span></span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">path[pl] = str[L];</span><br><span class="line">&#125;</span><br><span class="line">ans.add(String.valueOf(path));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[L][R - <span class="number">1</span>] == dp[L][R] - <span class="number">1</span>) &#123;</span><br><span class="line">path[pl] = str[R];</span><br><span class="line">path[pr] = str[R];</span><br><span class="line">process(str, dp, L, R - <span class="number">1</span>, path, pl + <span class="number">1</span>, pr - <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dp[L + <span class="number">1</span>][R] == dp[L][R] - <span class="number">1</span>) &#123;</span><br><span class="line">path[pl] = str[L];</span><br><span class="line">path[pr] = str[L];</span><br><span class="line">process(str, dp, L + <span class="number">1</span>, R, path, pl + <span class="number">1</span>, pr - <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str[L] == str[R] &amp;&amp; (L == R - <span class="number">1</span> || dp[L + <span class="number">1</span>][R - <span class="number">1</span>] == dp[L][R])) &#123;</span><br><span class="line">path[pl] = str[L];</span><br><span class="line">path[pr] = str[R];</span><br><span class="line">process(str, dp, L + <span class="number">1</span>, R - <span class="number">1</span>, path, pl + <span class="number">1</span>, pr - <span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 57 布尔运算</title>
      <link href="/2020/10/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-23-Problem-57-%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97/"/>
      <url>/2020/10/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-23-Problem-57-%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode-cn.com/problems/boolean-evaluation-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/boolean-evaluation-lcci/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题也是很类似的思想，比如讲，求最大子数组和？不管哪个子数组和最大，子数组一定是以某个元素结尾，所以我们找以当前元素为结尾的最大子数组，最终找到答案。此题求的是加括号的方法数，首先每个运算符号一定都会生效。通过加括号使得答案最终为1，那么一定是最后那个运算符起了决定作用得到1。所以我们遍历当前符号，看它左边有多少种为0位1的方案，右面有多少种，分别递归得到，得到之后，我们通过运算算出 当前符号最后生效时的方案数，全部累加即可得到。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> zeroCount;</span><br><span class="line">        <span class="keyword">int</span> OneCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(<span class="keyword">int</span> zeroCount, <span class="keyword">int</span> OneCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.zeroCount = zeroCount;</span><br><span class="line">            <span class="keyword">this</span>.OneCount = OneCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">countEval</span><span class="params">(String s, <span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Result[][] dp = <span class="keyword">new</span> Result[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">final</span> Result res = process(s.toCharArray(), <span class="number">0</span>, s.length() - <span class="number">1</span>,dp);</span><br><span class="line">        <span class="keyword">return</span> result == <span class="number">0</span>?res.zeroCount : res.OneCount;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【s，e】一定是两个字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] arr,<span class="keyword">int</span> s,<span class="keyword">int</span> e,Result[][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == e)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = arr[s]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(cnt^<span class="number">1</span>,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[s][e]!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[s][e];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> zeroCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oneCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s+<span class="number">1</span>;i &lt; e;i +=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//以i字符划分</span></span><br><span class="line">            <span class="keyword">final</span> Result left = process(arr, s, i - <span class="number">1</span>,dp);</span><br><span class="line">            <span class="keyword">final</span> Result right = process(arr, i + <span class="number">1</span>, e,dp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (arr[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&amp;'</span>:&#123;</span><br><span class="line">                    oneCount += left.OneCount * right.OneCount;</span><br><span class="line">                    zeroCount += left.zeroCount * right.OneCount + left.zeroCount * right.zeroCount + left.OneCount * right.zeroCount;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'|'</span>:&#123;</span><br><span class="line">                    oneCount += left.OneCount* right.OneCount + left.zeroCount * right.OneCount + left.OneCount * right.zeroCount;</span><br><span class="line">                    zeroCount += left.zeroCount * right.zeroCount;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'^'</span>:&#123;</span><br><span class="line">                    oneCount += left.OneCount * right.zeroCount + left.zeroCount * right.OneCount;</span><br><span class="line">                    zeroCount += left.zeroCount * right.zeroCount + left.OneCount * right.OneCount;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[s][e] = <span class="keyword">new</span> Result(zeroCount,oneCount);</span><br><span class="line">        <span class="keyword">return</span> dp[s][e];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 55 K个逆序对数组</title>
      <link href="/2020/10/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-22-Problem-55-K%E4%B8%AA%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E7%BB%84/"/>
      <url>/2020/10/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-22-Problem-55-K%E4%B8%AA%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：</p><p><a href="https://leetcode.com/problems/k-inverse-pairs-array/" target="_blank" rel="noopener">https://leetcode.com/problems/k-inverse-pairs-array/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这道题目是一道很不错的dp题目，这道题目如果去写几个例子，很容易发现特点，做好空间优化。</li><li>结果要取模运算的时候，任何一处加法减法都要加模再去取模，一个时防止溢出，一个是防止计算出现负数。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kInversePairs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= k;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; i)&#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j])%MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = ((dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j])%MOD - dp[i-<span class="number">1</span>][j-i]+MOD)%MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 56 BST转有序双向列表</title>
      <link href="/2020/10/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-22-Problem-56-BST%E8%BD%AC%E6%9C%89%E5%BA%8F%E5%8F%8C%E5%90%91%E5%88%97%E8%A1%A8/"/>
      <url>/2020/10/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-22-Problem-56-BST%E8%BD%AC%E6%9C%89%E5%BA%8F%E5%8F%8C%E5%90%91%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode原题：</p><p>​    给定一棵搜索二叉树头节点，转化成首尾相接的有序双向链表</p><p><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目不难，就是麻烦点，用树的递归遍历就可以搞定。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>​    略</p>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 54</title>
      <link href="/2020/10/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-20-Problem-54/"/>
      <url>/2020/10/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-20-Problem-54/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Lintcode原题：</p><p><a href="https://www.lintcode.com/problem/top-k-frequent-words-ii/" target="_blank" rel="noopener">https://www.lintcode.com/problem/top-k-frequent-words-ii/</a></p><p>第10节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 53 跳跃游戏</title>
      <link href="/2020/10/19/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-19-Problem-53-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/10/19/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-19-Problem-53-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game-ii/</a></p><p>补:</p><p><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><p>这两道题目都非常有特点，考察这种先遍历后更新的技巧，两道题目要一块看。</p></li><li><p>重点理解一下跳跃游戏II的三个变量</p><ul><li>Step : 当前走的步数</li><li>cur：当前步数以内能到达的位置</li><li>next: 如果多走一步 能到达的位置</li></ul><p>那么只有走到cur位置的下一个位置，相当于需要再跳，所以step++, cur = next即可。主要在更新next，保持next在多走一步情况下的最大位置。</p></li><li><p>题目二就是因为要考察最小步数,需要step记录，同时在遍历的同时要想办法记录何时去更新step。</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; cur)&#123;</span><br><span class="line">                step++;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            next = Math.max(nums[i]+i,next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; max_pos) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                max_pos = Math.max(i + nums[i],max_pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 52 step sum问题</title>
      <link href="/2020/10/17/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-17-Problem-52-step-sum%E9%97%AE%E9%A2%98/"/>
      <url>/2020/10/17/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-17-Problem-52-step-sum%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    定义何为step sum？<br>比如680，680 + 68 + 6 = 754，680的step sum叫754<br>给定一个正数num，判断它是不是某个数的step sum</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题目考查的二分。拿到题目务必好好观察特点。明显这个数组拆分累加之后是变大的。所以说 给一个数x，它是某个数字的step sum 取值一定在1到x之间。所以可以用二分来枚举。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isStepSum</span><span class="params">(<span class="keyword">int</span> stepSum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R = stepSum;</span><br><span class="line"><span class="keyword">int</span> M = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">M = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">cur = stepSum(M);</span><br><span class="line"><span class="keyword">if</span> (cur == stepSum) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &lt; stepSum) &#123;</span><br><span class="line">L = M + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">R = M - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stepSum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">num /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 51 俄罗斯套娃问题</title>
      <link href="/2020/10/14/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-14-Problem-51-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E9%97%AE%E9%A2%98/"/>
      <url>/2020/10/14/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-14-Problem-51-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    俄罗斯套娃问题</p><p>​    Leetcode 原题：</p><p>​    <a href="https://leetcode.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">https://leetcode.com/problems/russian-doll-envelopes/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典题目，是LIS问题的应用。有长和高两个维度，我们将信封按照长升序，并且长相等时按照宽降序。这样做的目的就是，当我们把宽单独拿出来，此时的最长递增子序列的长度就是嵌套层次。而如果宽也是升序排序，此时的LIS长度 就会因为长度相等而产生干扰，而宽度降序就会直接排除掉干扰。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Model</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> edge;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Model</span><span class="params">(<span class="keyword">int</span> edge, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.edge = edge;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Model[] model = <span class="keyword">new</span> Model[envelopes.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; envelopes.length; i++) &#123;</span><br><span class="line">            model[i] = <span class="keyword">new</span> Model(envelopes[i][<span class="number">0</span>],envelopes[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(model,(t1,t2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (t1.edge != t2.edge) <span class="keyword">return</span> t1.edge - t2.edge;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t2.height -t1.height;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] lis = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; model.length; i++) &#123;</span><br><span class="line">            lis[i] = model[i].height;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getLis(lis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLis</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        end[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> valid_loc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>,r = valid_loc;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(end[mid] &gt;= arr[i])&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    l = mid +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end[l] &lt; arr[i])&#123;</span><br><span class="line">                end[l+<span class="number">1</span>] = arr[i];</span><br><span class="line">                valid_loc++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end[l] = arr[i]; <span class="comment">//更新对应长度的子序列的最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid_loc+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 50 最长递增子序列</title>
      <link href="/2020/10/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-13-Problem-50-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2020/10/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-13-Problem-50-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    经典算法之最长递增子序列</p><p>​    Leetcode 原题：</p><p>​    <a href="https://leetcode.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">https://leetcode.com/problems/longest-increasing-subsequence</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>LIS 经典问题。普通的dp树N^2^的，不容易过，采用end数组的方式实现N*logN的</li><li>End[i]代表所有长度为i +1的递增子序列中的最小结尾。明确end数组含义，开始遍历数组arr，对每个值在end数组中查找第一个单于等于arr[i]的位置end[j]，说明arr[i]无法延伸到j+2长度，而是只能降低j+1递增子序列的末尾值。所以更新end[j]的值，同时记录dp[i]。end数组由含义决定是严格递增的对于end数组使用二分查找。整个过程就是N*logN。</li><li>实际上dp的记录可以省掉。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        end[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> valid_loc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>,r = valid_loc;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(end[mid] &gt;= arr[i])&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    l = mid +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end[l] &lt; arr[i])&#123;</span><br><span class="line">                end[l+<span class="number">1</span>] = arr[i];</span><br><span class="line">                valid_loc++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end[l] = arr[i]; <span class="comment">//更新对应长度的子序列的最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid_loc+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 49 移除无效括号</title>
      <link href="/2020/10/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-13-Problem-49-%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
      <url>/2020/10/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-13-Problem-49-%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode 原题：</p><p>​    <a href="https://leetcode.com/problems/remove-invalid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-invalid-parentheses/</a></p><p>第9节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 48 点灯问题</title>
      <link href="/2020/10/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-12-Problem-48-%E7%82%B9%E7%81%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2020/10/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-12-Problem-48-%E7%82%B9%E7%81%AF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组arr，长度为N，arr中的值不是0就是1。arr[i]表示第i栈灯的状态，0代表灭灯，1代表亮灯<br>每一栈灯都有开关，但是按下i号灯的开关，会同时改变i-1、i、i+1栈灯的状态<br>问题一：如果N栈灯排成一条直线,请问最少按下多少次开关？<br>i为中间位置时，i号灯的开关能影响i-1、i和i+1<br>0号灯的开关只能影响0和1位置的灯<br>N-1号灯的开关只能影响N-2和N-1位置的灯</p><p>问题二：如果N栈灯排成一个圈,请问最少按下多少次开关,能让灯都亮起来<br>i为中间位置时，i号灯的开关能影响i-1、i和i+1<br>0号灯的开关能影响N-1、0和1位置的灯<br>N-1号灯的开关能影响N-2、N-1和0位置的灯</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典的点灯问题。贪心的思路，尽可能少的点灯。然后 对于圈，无非是第一个位置比较特殊，单独对待一下。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无环的点灯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method01</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span>) <span class="keyword">return</span> arr[<span class="number">0</span>]^<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">2</span>) <span class="keyword">return</span> arr[<span class="number">0</span>]!=arr[<span class="number">1</span>]?Integer.MAX_VALUE : arr[<span class="number">0</span>]^<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] arr2 = Arrays.copyOf(arr,  arr.length);</span><br><span class="line">        <span class="comment">//可能性一</span></span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        p1 = loop2(arr,p1);</span><br><span class="line">        <span class="comment">//可能性二</span></span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">0</span>] ^= <span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">1</span>] ^=<span class="number">1</span>;</span><br><span class="line">        p2 = loop2(arr2,p2);</span><br><span class="line">        <span class="keyword">return</span> Math.min(p1,p2);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">loop2</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i - <span class="number">1</span>] == <span class="number">0</span>) &#123; <span class="comment">//灭灯</span></span><br><span class="line">                p++;</span><br><span class="line">                arr[i - <span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">                arr[i] ^= <span class="number">1</span>;</span><br><span class="line">                arr[(i+<span class="number">1</span>)%arr.length]^=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[arr.length-<span class="number">1</span>] == <span class="number">0</span> || arr[<span class="number">0</span>] == <span class="number">0</span>) p = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//循环点灯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span>) <span class="keyword">return</span> arr[<span class="number">0</span>]^<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">2</span>) <span class="keyword">return</span> arr[<span class="number">0</span>]!=arr[<span class="number">1</span>]?Integer.MAX_VALUE : arr[<span class="number">0</span>]^<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = Arrays.copyOf(arr,  arr.length);</span><br><span class="line">        <span class="comment">//前两位，你是不知道该取什么情况的，因为它不在我们说的普遍的位置，普遍的位置就希望左边过来的都是1</span></span><br><span class="line">        <span class="comment">//可能性一  0 不变，1不变</span></span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        p1 = loop2(arr2,p1);</span><br><span class="line">        <span class="comment">//可能性二 0不变 1变</span></span><br><span class="line">        arr2 = Arrays.copyOf(arr,  arr.length);</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">0</span>] ^=<span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">1</span>] ^=<span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">2</span>] ^=<span class="number">1</span>;</span><br><span class="line">        p2 = loop2(arr2,p2);</span><br><span class="line">        <span class="comment">//可能性三 0变 1不变</span></span><br><span class="line">        arr2 = Arrays.copyOf(arr,  arr.length);</span><br><span class="line">        <span class="keyword">int</span> p3 = <span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">0</span>] ^= <span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">1</span>] ^=<span class="number">1</span>;</span><br><span class="line">        arr2[N-<span class="number">1</span>] ^=<span class="number">1</span>;</span><br><span class="line">        p3 = loop2(arr2,p3);</span><br><span class="line">        <span class="comment">//可能性四 0变 1变</span></span><br><span class="line">        <span class="keyword">int</span> p4 = <span class="number">2</span>;</span><br><span class="line">        arr2 = Arrays.copyOf(arr,  arr.length);</span><br><span class="line">        arr2[N-<span class="number">1</span>] ^=<span class="number">1</span>;</span><br><span class="line">        arr2[<span class="number">2</span>] ^=<span class="number">1</span>;</span><br><span class="line">        p4 = loop2(arr2,p4);</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(Math.min(p1,p2),p3),p4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Greed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 47 蛇前进游戏</title>
      <link href="/2020/10/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-12-Problem-47-%E8%9B%87%E5%89%8D%E8%BF%9B%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/10/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-12-Problem-47-%E8%9B%87%E5%89%8D%E8%BF%9B%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个矩阵matrix，值有正、负、0<br>蛇可以空降到最左列的任何一个位置，初始增长值是0<br>蛇每一步可以选择右上、右、右下三个方向的任何一个前进<br>沿途的数字累加起来，作为增长值；但是蛇一旦增长值为负数，就会死去<br>蛇有一种能力，可以使用一次：把某个格子里的数变成相反数<br>蛇可以走到任何格子的时候停止<br>返回蛇能获得的最大增长值</p><p>第8节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>考察的是递归，无非是增加了一些条件。我们就按照最普通的递归来写，枚举所有的可能性，找出最大值。这样在数据量小的情况下肯定能过的，如果数据量大，就需要再思考如何优化。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snake</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = process(matrix,i,<span class="number">0</span>,<span class="keyword">false</span>,<span class="number">0</span>,M,N);</span><br><span class="line">            max = Math.max(t,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">boolean</span> used,<span class="keyword">int</span> sum,<span class="keyword">int</span> M,<span class="keyword">int</span> N)</span></span>&#123;  <span class="comment">//从i,j出发可以获得最大值</span></span><br><span class="line">        <span class="keyword">if</span>(!InEdge(i,j,M,N) || sum &lt; <span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">int</span> p1=Integer.MIN_VALUE,p2 = Integer.MIN_VALUE,p3 = Integer.MIN_VALUE,p4= Integer.MIN_VALUE,p5 = Integer.MIN_VALUE,p6= Integer.MIN_VALUE,p7 = Integer.MIN_VALUE,</span><br><span class="line">                p8 = Integer.MIN_VALUE,p9 = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p10 = sum + matrix[i][j], p11 = used ? Integer.MIN_VALUE:sum - matrix[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!used)&#123;</span><br><span class="line">            p1 = process(matrix,i-<span class="number">1</span>,j+<span class="number">1</span>,<span class="keyword">true</span>,sum-matrix[i][j],M,N);</span><br><span class="line">            p2 = process(matrix,i-<span class="number">1</span>,j+<span class="number">1</span>,<span class="keyword">false</span>,sum+matrix[i][j],M,N);</span><br><span class="line"></span><br><span class="line">            p3 = process(matrix,i,j+<span class="number">1</span>,<span class="keyword">true</span>,sum-matrix[i][j],M,N);</span><br><span class="line">            p4 = process(matrix,i,j+<span class="number">1</span>,<span class="keyword">false</span>,sum+matrix[i][j],M,N);</span><br><span class="line"></span><br><span class="line">            p5 = process(matrix,i+<span class="number">1</span>,j+<span class="number">1</span>,<span class="keyword">true</span>,sum-matrix[i][j],M,N);</span><br><span class="line">            p6= process(matrix,i+<span class="number">1</span>,j+<span class="number">1</span>,<span class="keyword">false</span>,sum+matrix[i][j],M,N);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p7 = process(matrix,i-<span class="number">1</span>,j+<span class="number">1</span>,<span class="keyword">true</span>,sum+matrix[i][j],M,N);</span><br><span class="line">            p8 = process(matrix,i,j+<span class="number">1</span>,<span class="keyword">true</span>,sum+matrix[i][j],M,N);</span><br><span class="line">            p9 = process(matrix,i+<span class="number">1</span>,j+<span class="number">1</span>,<span class="keyword">true</span>,sum+matrix[i][j],M,N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_no_stop = Math.max(Math.max(Math.max(Math.max(Math.max(Math.max(Math.max(p3,Math.max(p1,p2)),p4),p5),p6),p7),p8),p9);</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(max_no_stop,p10),p11);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 46 寻找word</title>
      <link href="/2020/10/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-10-Problem-46-%E5%AF%BB%E6%89%BEword/"/>
      <url>/2020/10/10/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-10-Problem-46-%E5%AF%BB%E6%89%BEword/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个char[][] matrix，也就是char类型的二维数组，再给定一个字符串word，<br>可以从任何一个某个位置出发，可以走上下左右，能不能找到word？<br> char[][] m = {  { ‘a’, ‘b’, ‘z’ },<br>                       { ‘c’, ‘d’, ‘o’ },<br>                       { ‘f’, ‘e’, ‘o’ }}<br>设定1：可以走重复路的情况下，返回能不能找到<br>比如，word = “zoooz”，是可以找到的，z -&gt; o -&gt; o -&gt; o -&gt; z，因为允许走一条路径中已经走过的字符<br>设定2：不可以走重复路的情况下，返回能不能找到<br>比如，word = “zoooz”，是不可以找到的，因为允许走一条路径中已经走过的字符不能重复走 </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>从每个字符 去感染一下，普通的递归题目</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以走重复路</span></span><br><span class="line"><span class="comment">// 从m[i][j]这个字符出发，能不能找到str[k...]这个后缀串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canLoop</span><span class="params">(<span class="keyword">char</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] str, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k == str.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == -<span class="number">1</span> || i == m.length || j == -<span class="number">1</span> || j == m[<span class="number">0</span>].length || m[i][j] != str[k]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不越界！m[i][j] == str[k] 对的上的！</span></span><br><span class="line"><span class="comment">// str[k+1....]</span></span><br><span class="line"><span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (canLoop(m, i + <span class="number">1</span>, j, str, k + <span class="number">1</span>) || canLoop(m, i - <span class="number">1</span>, j, str, k + <span class="number">1</span>) || canLoop(m, i, j + <span class="number">1</span>, str, k + <span class="number">1</span>)</span><br><span class="line">|| canLoop(m, i, j - <span class="number">1</span>, str, k + <span class="number">1</span>)) &#123;</span><br><span class="line">ans = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能走重复路</span></span><br><span class="line"><span class="comment">// 从m[i][j]这个字符出发，能不能找到str[k...]这个后缀串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">noLoop</span><span class="params">(<span class="keyword">char</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] str, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k == str.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == -<span class="number">1</span> || i == m.length || j == -<span class="number">1</span> || j == m[<span class="number">0</span>].length || m[i][j] != str[k]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不越界！也不是回头路！m[i][j] == str[k] 也对的上！</span></span><br><span class="line">m[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> ans = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (noLoop(m, i + <span class="number">1</span>, j, str, k + <span class="number">1</span>) || noLoop(m, i - <span class="number">1</span>, j, str, k + <span class="number">1</span>) || noLoop(m, i, j + <span class="number">1</span>, str, k + <span class="number">1</span>)</span><br><span class="line">|| noLoop(m, i, j - <span class="number">1</span>, str, k + <span class="number">1</span>)) &#123;</span><br><span class="line">ans = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">m[i][j] = str[k];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 45 最多盛水问题</title>
      <link href="/2020/10/07/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-07-Problem-45-%E6%9C%80%E5%A4%9A%E7%9B%9B%E6%B0%B4%E9%97%AE%E9%A2%98/"/>
      <url>/2020/10/07/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-07-Problem-45-%E6%9C%80%E5%A4%9A%E7%9B%9B%E6%B0%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Leetcode原题：<br><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode.com/problems/container-with-most-water/</a>    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>最多盛水问题，双指针，想不明白的话就是比较绕，关键点就是不断的把答案进行推高,最终逼近答案.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[p1] &lt; height[p2])&#123;</span><br><span class="line">               res = Math.max((p2-p1)*height[p1],res);</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max((p2-p1)*height[p2],res);</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 44 计算多括号表达式</title>
      <link href="/2020/10/03/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-03-Problem-44-%E8%AE%A1%E7%AE%97%E5%A4%9A%E6%8B%AC%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/10/03/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-10-03-Problem-44-%E8%AE%A1%E7%AE%97%E5%A4%9A%E6%8B%AC%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个字符串str，str表示一个公式，公式里可能有整数、加减乘除符号和左右括号 返回公式的计算结果，难点在于括号可能嵌套很多层,如：</p><p>str=”48<em>((70-65)-43)+8</em>1”，返回-1816。<br>str=”3+1<em>4”，返回7。<br>str=”3+(1</em>4)”，返回7。<br>【说明】<br>1.可以认为给定的字符串一定是正确的公式，即不需要对str做公式有效性检查<br>2.如果是负数，就需要用括号括起来，比如“4<em>(-3)”但如果负数作为公式的开头或括号部分的开头，则可以没有括号，比如”-3</em>4”和”(-3*4)”都是合法的。<br>3.不用考虑计算过程中会发生溢出的情况。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>常见的思路是利用栈结合操作符的优先级别进行计算，但递归本质上也是利用系统栈，我们利用递归来解决这种“优先级”的问题。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过递归计算括号优先级 1+10*3+4*5+7</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method1</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> (String)process(stack,<span class="number">0</span>,chars)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Object[] process(Stack&lt;String&gt; stack,<span class="keyword">int</span> i,<span class="keyword">char</span>[] chs)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = i;</span><br><span class="line">        <span class="keyword">if</span>(chs[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            stack.push(<span class="string">"0"</span>);</span><br><span class="line">            stack.push(<span class="string">"-"</span>);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; chs.length)&#123;</span><br><span class="line">            Double num = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//表示已经得出数字</span></span><br><span class="line">            <span class="keyword">if</span>(chs[start] == <span class="string">'('</span> )&#123;</span><br><span class="line">                <span class="keyword">final</span> Object[] ans = process(<span class="keyword">new</span> Stack&lt;String&gt;(), start + <span class="number">1</span>, chs);</span><br><span class="line">                start = (Integer) ans[<span class="number">1</span>];</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                num = Double.valueOf((String)ans[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                <span class="keyword">while</span> (start &lt; chs.length &amp;&amp; chs[start] &lt;= <span class="string">'9'</span> &amp;&amp; chs[start] &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">                    num = num *<span class="number">10</span> + (chs[start] - <span class="string">'0'</span>);</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Character op = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(start &lt; chs.length)&#123;</span><br><span class="line">                op = chs[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//push 之前如果是乘除法 先算</span></span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty()&amp;&amp;(stack.peek().equals(<span class="string">"*"</span>) || stack.peek().equals(<span class="string">"/"</span>)))&#123;</span><br><span class="line">                <span class="keyword">final</span> String tmp_op = stack.pop();</span><br><span class="line">                <span class="keyword">final</span> String num_a = stack.pop();</span><br><span class="line">                num = Double.valueOf(getCalculateRes(tmp_op,num_a,num.toString())) ;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(num.toString());</span><br><span class="line">            <span class="keyword">if</span>(op != <span class="keyword">null</span> &amp;&amp; op != <span class="string">')'</span>)</span><br><span class="line">                stack.push(op.toString());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算栈中加减运算表达式的值</span></span><br><span class="line">        String res = stack.pop();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(isOption(stack.peek()))&#123;</span><br><span class="line">                String option = stack.pop();</span><br><span class="line">                String temp = stack.pop();</span><br><span class="line">                res = getCalculateRes(option,temp,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Object[]&#123;res,start&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getCalculateRes</span><span class="params">(String op, String a, String b)</span> </span>&#123;</span><br><span class="line">        Double res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:&#123;</span><br><span class="line">                res = Double.valueOf(a) * Double.valueOf(b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:&#123;</span><br><span class="line">                res = Double.valueOf(a) / Double.valueOf(b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:&#123;</span><br><span class="line">                res = Double.valueOf(a) + Double.valueOf(b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:&#123;</span><br><span class="line">                res = Double.valueOf(a) - Double.valueOf(b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOption</span><span class="params">(String op)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(op.length() ==<span class="number">1</span> &amp;&amp; (op.equals(<span class="string">"+"</span>) || op.equals(<span class="string">"-"</span>))) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 43</title>
      <link href="/2020/09/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-29-Problem-43/"/>
      <url>/2020/09/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-29-Problem-43/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Dynamic programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 42 单词表拼接字符串种数</title>
      <link href="/2020/09/27/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-27-Problem-42-%E5%8D%95%E8%AF%8D%E8%A1%A8%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%8D%E6%95%B0/"/>
      <url>/2020/09/27/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-27-Problem-42-%E5%8D%95%E8%AF%8D%E8%A1%A8%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    假设所有字符都是小写字母  大字符串是str,arr是去重的单词表, 每个单词都不是空字符串且可以使用任意次.<br>使用arr中的单词有多少种拼接str的方式. 返回方法数.</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是说长的字符串用单词来拼起来，看看有几种方式。首先不难想的是，对字符串进行判断，在index位置，判断单词表中哪个单词可以作为开头，切割之后进行递归。此处，需要单词表，枚举每个单词之后，需要判断是不是可以作为当前字符串开头，这又是和平均字符串长度有关。</li><li>看到这种单词表的形式，我们常常想到用Trie来进行优化，把单词表用前缀树组织起来，这样在判断是不是有单词作为前缀时，可以在树上走一个平均长度就能判断出来，省去了每次递归都遍历单词表的时间。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：DP  dp[i..length-1] 表示这个字符串由单词拼接的方法数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">(String str,String words[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> N = str.length();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        dp[N] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; words.length;j++)&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> t = str.substring(i).indexOf(words[j]);</span><br><span class="line">                <span class="keyword">if</span>(t == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] += dp[i+words[j].length()];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：Dp 可以看到套了两个循环，indexOf方法查子串 底层kmp O(n),几乎是三阶的</span></span><br><span class="line">    <span class="comment">//优化点在于，我当前i开始的串 在查找d单词时候，能匹配上的单词 一定是前缀关系</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">(String str,String words[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> N = str.length();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        dp[N] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            prefixTree.addWord(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dp[i]表示 以i开始的字符串可以被words拼成的方法数</span></span><br><span class="line">            <span class="keyword">final</span> PrefixTree.Node root = prefixTree.root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = N-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">                dp[i] = <span class="number">0</span>;</span><br><span class="line">                PrefixTree.Node cur = root;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; chars.length)&#123;</span><br><span class="line">                    PrefixTree.Node temp = cur.chars[chars[j]-<span class="string">'a'</span>];</span><br><span class="line">                    <span class="keyword">if</span>(temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(temp.isWord)&#123;</span><br><span class="line">                            dp[i] += dp[j+<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        cur = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        Node root;</span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isWord;</span><br><span class="line">            Node[] chars;</span><br><span class="line">            String word;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.chars = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                cur.chars[chars[i]-<span class="string">'a'</span>] = cur.chars[chars[i]-<span class="string">'a'</span>] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node() : cur.chars[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">                cur = cur.chars[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">            cur.word = word;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
            <tag> Bit Manipuldate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 41 平方后数种类</title>
      <link href="/2020/09/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-25-Problem-41-%E5%B9%B3%E6%96%B9%E5%90%8E%E6%95%B0%E7%A7%8D%E7%B1%BB/"/>
      <url>/2020/09/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-25-Problem-41-%E5%B9%B3%E6%96%B9%E5%90%8E%E6%95%B0%E7%A7%8D%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    1.给定一个有序数组arr，其中值可能为正、负、0<br>​    返回arr中每个数都平方之后不同的结果有多少种？</p><p>​    2.给定一个数组arr，先递减然后递增，<br>​    返回arr中有多少个不同的数字？</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>两道题目实际是一道，想象成低谷，两个变量两边遍历一下即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>​    略</p>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 40 排序后的最大差值</title>
      <link href="/2020/09/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-25-Problem-40-%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/"/>
      <url>/2020/09/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-25-Problem-40-%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个数组arr，返回如果排序之后，相邻两数的最大差值 要求：时间复杂度O(N)</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题需要好好思考，其实没什么明显的知识点的提示，这时候就得想些 “特殊技巧”。这个题 N个数，可以分到N+1个桶中，把元素[min,max]，给把区间平均分配到桶中，间隔最大的两个元素 一定是夸桶！所以只需要在桶中维护最大，最小元素，最后挨个桶考察一下即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>]; <span class="comment">//0列放最小值,1列放最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">            bucket[i][<span class="number">0</span>] = Integer.MAX_VALUE;</span><br><span class="line">            bucket[i][<span class="number">1</span>] = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_num = Integer.MAX_VALUE,max_num = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            max_num = arr[i] &gt; max_num ? arr[i] : max_num;</span><br><span class="line">            min_num = arr[i] &lt; min_num ? arr[i] : min_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> step_len = (<span class="keyword">double</span>)(max_num - min_num)/n; <span class="comment">//是一个range，然后平均到 每个桶，这么大个范围</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> buloc = (<span class="keyword">int</span>)((arr[i]-min_num)/step_len);</span><br><span class="line">            buloc = buloc &lt; n ? buloc : buloc-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//更新buloc这个桶的最值</span></span><br><span class="line">            bucket[buloc][<span class="number">0</span>] =  arr[i] &lt; bucket[buloc][<span class="number">0</span>] ? arr[i] : bucket[buloc][<span class="number">0</span>];</span><br><span class="line">            bucket[buloc][<span class="number">1</span>] =  arr[i] &gt; bucket[buloc][<span class="number">1</span>] ? arr[i] : bucket[buloc][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastMax = bucket[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket[i][<span class="number">0</span>] == Integer.MAX_VALUE)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = bucket[i][<span class="number">0</span>] - lastMax &gt; res ? bucket[i][<span class="number">0</span>] - lastMax : res;</span><br><span class="line">            lastMax = bucket[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Problem 39 监控二叉树</title>
      <link href="/2020/09/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-25-Problem-39-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/09/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-25-Problem-39-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-cameras/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-cameras/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>贪心的思路，因为目标是很明确的，就是照完整棵树，相机树最少，那就是能不放则不放，主要考察两个小变量，放了没有?照到了没有？</li><li>结合二叉树的递归套路可解。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     TreeNode left;</span><br><span class="line">     TreeNode right;</span><br><span class="line">     TreeNode() &#123;&#125;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val;&#125;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">         <span class="keyword">this</span>.val = val;</span><br><span class="line">         <span class="keyword">this</span>.left = left;</span><br><span class="line">         <span class="keyword">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">boolean</span> isMonitor; <span class="comment">//节点放了没</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">boolean</span> isSet;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> isMonitor, <span class="keyword">int</span> num, <span class="keyword">boolean</span> isSet)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.isMonitor = isMonitor;</span><br><span class="line">           <span class="keyword">this</span>.num = num;</span><br><span class="line">           <span class="keyword">this</span>.isSet = isSet;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right ==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">final</span> Info info = process1(root);</span><br><span class="line">       <span class="keyword">return</span> info.isMonitor == <span class="keyword">false</span> ?info.num+<span class="number">1</span>:info.num ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//贪心解法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Info <span class="title">process1</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">boolean</span> isSet = <span class="keyword">false</span>,isMonitor = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">final</span> Info leftInfo = process1(node.left);</span><br><span class="line">       <span class="keyword">final</span> Info rightInfo = process1(node.right);</span><br><span class="line">       <span class="keyword">if</span>(leftInfo == <span class="keyword">null</span> &amp;&amp; rightInfo == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">false</span>,<span class="number">0</span>,<span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(leftInfo != <span class="keyword">null</span> &amp;&amp; rightInfo == <span class="keyword">null</span>)&#123;</span><br><span class="line">           num += leftInfo.num;</span><br><span class="line">           isSet = leftInfo.isMonitor == <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span>(isSet) &#123;</span><br><span class="line">               num++;</span><br><span class="line">               isMonitor = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(leftInfo.isSet)&#123;</span><br><span class="line">               isMonitor = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>  <span class="keyword">if</span>( rightInfo != <span class="keyword">null</span> &amp;&amp; leftInfo == <span class="keyword">null</span>)&#123;</span><br><span class="line">           num += rightInfo.num;</span><br><span class="line">           isSet = rightInfo.isMonitor == <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span>(isSet) &#123;</span><br><span class="line">               num++;</span><br><span class="line">               isMonitor = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(rightInfo.isSet)</span><br><span class="line">               isMonitor = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           num += leftInfo.num + rightInfo.num;</span><br><span class="line">           isSet = (!leftInfo.isMonitor || !rightInfo.isMonitor);</span><br><span class="line">           <span class="keyword">if</span>(isSet)&#123;</span><br><span class="line">               num++;</span><br><span class="line">               isMonitor = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(leftInfo.isSet || rightInfo.isSet)&#123;</span><br><span class="line">               isMonitor = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Info(isMonitor,num,isSet);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Greed </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 38 最大与运算</title>
      <link href="/2020/09/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-22-Problem-38-%E6%9C%80%E5%A4%A7%E4%B8%8E%E8%BF%90%E7%AE%97/"/>
      <url>/2020/09/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-22-Problem-38-%E6%9C%80%E5%A4%A7%E4%B8%8E%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个非负数组成的数组，长度一定大于1 想知道数组中哪两个数&amp;的结果最大<br>返回这个最大结果.时间复杂度O(N)，额外空间复杂度O(1)</p><p>第7节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
            <tag> Bit Manipuldate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 37 Nim博弈</title>
      <link href="/2020/09/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-21-Problem-37-Nim%E5%8D%9A/"/>
      <url>/2020/09/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-21-Problem-37-Nim%E5%8D%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Nim博弈. 给定一个正数数组arr 先手和后手每次可以选择在一个位置拿走若干值，值要大于0，但是要小于该处的剩余 谁最先拿空arr，谁赢。根据arr，返回谁赢</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目理解之后。需要转换思路。如果先手能保证每次拿一个数之后，异或值是0 ，不断的拿之后，最后后手面对异或和为0的情况 一定全是0，所以先手只能能保证当前异或值不是0，那就每次拿成0，这样 先手一定赢。</li><li>有一点在于，能不能保证每次把异或值不是0的这些数，通过拿某些数。异或和为0 ，答案是能。因为异或和的值 想象一下每一位 0或者1，一定是对应有一个数 在这一位上有0或者1。那这样一定是可以拆分出来保证异或值为0的。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printWinner</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">eor ^= num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (eor == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"后手赢"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"先手赢"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
            <tag> Bit Manipuldate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 36 异或和为0的最多子数组个数</title>
      <link href="/2020/09/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-21-Problem-36-%E5%BC%82%E6%88%96%E5%92%8C%E4%B8%BA0%E7%9A%84%E6%9C%80%E5%A4%9A%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/09/21/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-21-Problem-36-%E5%BC%82%E6%88%96%E5%92%8C%E4%B8%BA0%E7%9A%84%E6%9C%80%E5%A4%9A%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    数组中所有数都异或起来的结果，叫做异或和 给定一个数组arr，可以任意切分成若干个不相交的子数组<br>其中一定存在一种最优方案，使得切出异或和为0的子数组最多 返回这个最多数量</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>看到子数组先想DP ，打出前缀和，自己异或自己是0，利用这几点，题目就很简单了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划，利用异或的前缀和</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MosteorZeroParts2</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span>[] pre_xor = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length],dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">      <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      pre_xor[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">      map.put(<span class="number">0</span>,-<span class="number">1</span>); <span class="comment">//初始值，防止前面整个数组异或和为0的情况 ,注意踩坑</span></span><br><span class="line">      map.put(arr[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">      dp[<span class="number">0</span>] = arr[<span class="number">0</span>] == <span class="number">0</span>? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">          pre_xor[i] =  pre_xor[i-<span class="number">1</span>] ^ arr[i];</span><br><span class="line">          dp[i] =  map.get(pre_xor[i]) == <span class="keyword">null</span> ? dp[i-<span class="number">1</span>] : Math.max((map.get(pre_xor[i])&lt;<span class="number">0</span>?<span class="number">0</span>:dp[map.get(pre_xor[i])])+<span class="number">1</span>,dp[i-<span class="number">1</span>]);</span><br><span class="line">          map.put(pre_xor[i],i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[arr.length-<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Bit Manipuldate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 35 与数组中元素的最大异或值</title>
      <link href="/2020/09/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-20-Problem-35-%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/"/>
      <url>/2020/09/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-20-Problem-35-%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    <a href="https://leetcode.com/problems/maximum-xor-with-an-element-from-array/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-xor-with-an-element-from-array/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题还是比较经典的，有两种思路，一种是来个简单的，直接把查询的mi 和 数组都按照从小到大排序，加入前缀树中，代码几乎和34题一样</li><li>前缀树，节点可以存放一些附加信息，比如以当前路径为前缀的单词个数，当前节点是不是单词等等，这个地方存放以当前节点为前缀树的最小值，只有这棵树的最小值符合条件才可以往下走</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] maximizeXor(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[][] queries) &#123;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            prefixTree.addNum(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[queries.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.length; i++) &#123;</span><br><span class="line">           res[i] = prefixTree.getMaxXoR(queries[i][<span class="number">0</span>],queries[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            Node[] nodes;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                nodes = <span class="keyword">new</span> Node[<span class="number">2</span>];</span><br><span class="line">                min = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.min = min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Node root;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            Node cur = root;</span><br><span class="line">            root.min = root.min &gt; num ? num:root.min;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (num&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">                cur.nodes[temp] = cur.nodes[temp] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node():cur.nodes[temp];</span><br><span class="line">                cur.nodes[temp].min = cur.nodes[temp].min &gt; num ? num:cur.nodes[temp].min;</span><br><span class="line">                cur = cur.nodes[temp];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxXoR</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.min &gt; limit) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">int</span> res = num;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (num&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> expect = temp^<span class="number">1</span>;</span><br><span class="line">                expect ^= ( cur.nodes[expect]!= <span class="keyword">null</span> &amp;&amp; cur.nodes[expect].min &lt;= limit)? <span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">                res ^= (expect&lt;&lt;i);</span><br><span class="line">                cur = cur.nodes[expect];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (num&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur.nodes[temp] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.nodes[temp];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Bit Manipuldate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 34 最大异或和的两个数</title>
      <link href="/2020/09/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-16-Problem-34-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/09/16/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-16-Problem-34-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    数组中所有数都异或起来的结果，叫做异或和 给定一个数组arr，想知道arr中哪两个数的异或结果最大<br>返回最大的异或结果<br><a href="https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>是33题的简化版。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">       prefixTree.addNum(nums[<span class="number">0</span>]);</span><br><span class="line">       <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           res = Math.max(res,prefixTree.getMaxXor(nums[i]));</span><br><span class="line">           prefixTree.addNum(nums[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">           <span class="keyword">public</span> Node[] nodes;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               nodes = <span class="keyword">new</span> Node[<span class="number">2</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Node root;</span><br><span class="line">       <span class="keyword">int</span> size;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           root = <span class="keyword">new</span> Node();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">           Node cur = root;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">               <span class="keyword">int</span> temp = (num&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">               cur.nodes[temp] = cur.nodes[temp] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node():cur.nodes[temp];</span><br><span class="line">               cur = cur.nodes[temp];</span><br><span class="line">           &#125;</span><br><span class="line">           size++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxXor</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">           Node cur = root.nodes[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">int</span> res = num;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">               <span class="keyword">int</span> temp = (num&gt;&gt;i) &amp; <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">int</span> t = cur.nodes[temp^<span class="number">1</span>] == <span class="keyword">null</span> ? temp : temp^<span class="number">1</span>;</span><br><span class="line">               cur = cur.nodes[t];</span><br><span class="line">               res ^= (t&lt;&lt;i);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 33 最大异或和子数组</title>
      <link href="/2020/09/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-12-Problem-33-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2020/09/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-12-Problem-33-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    数组中所有数都异或起来的结果，叫做异或和,给定一个数组arr，返回arr的最大子数组异或和    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>首先看到这种和啊，数组啊，应该想到”前缀和“ ，要有这种意识，总要有些经验上的积累。</li><li>先做出前缀的异或和数组，这样对于数组preSum[i],和前置的哪个元素异或 得到最大值，最大值是多少？</li><li>preSum元素放到前缀树上，利用数位 的贪心思想即可求解。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaxSubXOR</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length == <span class="number">0</span> || arr == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        prefixTree.addNum(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>,res = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            xor ^= arr[i];</span><br><span class="line">            res = Math.max(prefixTree.getMaxXor(xor),res);</span><br><span class="line">            prefixTree.addNum(xor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            <span class="keyword">public</span> HashMap&lt;Integer,Node&gt; map;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (num&gt;&gt;i) &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur.map.get(temp) == <span class="keyword">null</span>) cur.map.put(temp,<span class="keyword">new</span> Node());</span><br><span class="line">                cur = cur.map.get(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxXor</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">int</span> res = num;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (num&gt;&gt;i) &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">31</span>)&#123;</span><br><span class="line">                    x = cur.map.get(temp)==<span class="keyword">null</span>?temp^<span class="number">1</span>:temp;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    x = cur.map.get(temp^<span class="number">1</span>)==<span class="keyword">null</span>?temp:temp^<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(x == <span class="number">1</span>)</span><br><span class="line">                    res ^=(x&lt;&lt;i);</span><br><span class="line">                cur = cur.map.get(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Bit Manipulate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 32 最少删除字符成为其子串</title>
      <link href="/2020/09/09/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-09-Problem-32-%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E6%88%90%E4%B8%BA%E5%85%B6%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/09/09/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-09-Problem-32-%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E6%88%90%E4%B8%BA%E5%85%B6%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？比如 s1 = “abcde”，s2 = “axbc”</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>一种暴力思路，将s2进行挑选，挑选删除字符少的子序列 看是不是s1子串。</li><li>编辑距离思路，挑选出s1的所有子串，挨个进行编辑距离的dp</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法一：暴力枚举，删除一个的时候，删除两个的时候，从小开始删，其实删完就是子序列，只要一个中，就中了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MyminCost1</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s2.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s2.length();i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(MyProcess1(i,s1,chars,<span class="number">0</span>,<span class="string">""</span>,<span class="keyword">new</span> HashMap&lt;String,Boolean&gt;())) <span class="keyword">return</span> s2.length()-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">MyProcess1</span><span class="params">(<span class="keyword">int</span> rest, String s1,<span class="keyword">char</span>[] s2,<span class="keyword">int</span> index, String subsquence, HashMap&lt;String,Boolean&gt; cache)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rest &gt; s2.length-index) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//必须挑完rest个，要固定从大到小枚举子序列，减枝</span></span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(subsquence) &amp;&amp; !cache.get(subsquence)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(rest == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cache.containsKey(subsquence)) <span class="keyword">return</span> cache.get(subsquence);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> res = s1.indexOf(subsquence);</span><br><span class="line">                    cache.put(subsquence, res != -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> res != -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">boolean</span> p1 = MyProcess1(rest-<span class="number">1</span>,s1,s2,index+<span class="number">1</span>,subsquence+s2[index],cache);</span><br><span class="line">        <span class="keyword">boolean</span> p2 = MyProcess1(rest,s1,s2,index+<span class="number">1</span>,subsquence,cache);</span><br><span class="line">        <span class="keyword">return</span> p1 || p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解法二：就是编辑问题的子问题，把s1的字串枚举出来，看看s2变成这个 花费多少删除代价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MyminCost2</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = s2.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; s1.length();j++)&#123;</span><br><span class="line">                String subStr = s1.substring(i,j+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> c = MyProcess2(subStr,s2);</span><br><span class="line">                <span class="keyword">if</span>(c == -<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res = Math.min(res,c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MyProcess2</span><span class="params">(String  s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] arr1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] arr2 = s2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length()+<span class="number">1</span>][s2.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt; s1.length()+<span class="number">1</span>;i++)  dp[i][<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;s2.length()+<span class="number">1</span>;j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s1.length()+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; s2.length()+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] !=-<span class="number">1</span> &amp;&amp;  arr1[i-<span class="number">1</span>] == arr2[j-<span class="number">1</span>]?dp[i-<span class="number">1</span>][j-<span class="number">1</span>]:Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">int</span> p2 = dp[i][j-<span class="number">1</span>]!=-<span class="number">1</span> ? dp[i][j-<span class="number">1</span>] + <span class="number">1</span> : Integer.MAX_VALUE;</span><br><span class="line">                dp[i][j] = p1==Integer.MAX_VALUE&amp;&amp;p2==Integer.MAX_VALUE? -<span class="number">1</span>:Math.min(p1,p2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 31 编辑距离问题</title>
      <link href="/2020/09/06/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-06-Problem-31-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2020/09/06/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-06-Problem-31-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    一个字符串 可以有插入（insert）、删除（delete）、替换（replace）操作，每种操作都有对应的代价。求一个字符串变成另一个最小的代价。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ol><li>经典的题目。动态规划中的行列模型。列举所有的可能性。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法：编辑距离问题，考察代价最小的最优解 ，典型的行列模型，关键在于，找准转换的所有可能性</span><br><span class="line">   public static int MyminCost(String s1, String s2, int ic, int dc, int rc) &#123;</span><br><span class="line">       final char[] arr1 &#x3D; s1.toCharArray();</span><br><span class="line">       final char[] arr2 &#x3D; s2.toCharArray();</span><br><span class="line">       int M &#x3D; arr1.length,N &#x3D; arr2.length;</span><br><span class="line">       final int[][] dp &#x3D; new int[M+1][N+1];</span><br><span class="line">       dp[0][0] &#x3D; 0;</span><br><span class="line">       for(int i &#x3D; 1;i &lt; M+1;i++)&#123;</span><br><span class="line">           dp[i][0] &#x3D; i*dc;</span><br><span class="line">       &#125;</span><br><span class="line">       for(int j &#x3D; 1;j &lt; N+1;j++)&#123;</span><br><span class="line">           dp[0][j] &#x3D; j*ic;</span><br><span class="line">       &#125;</span><br><span class="line">       for(int i &#x3D; 1;i &lt;&#x3D; M;i++)&#123;</span><br><span class="line">           for(int j &#x3D; 1; j &lt;&#x3D; N;j++)&#123;</span><br><span class="line">               dp[i][j] &#x3D; dp[i-1][j] + dc;</span><br><span class="line">               if(arr1[i-1]&#x3D;&#x3D;arr2[j-1]) dp[i][j] &#x3D; Math.min(dp[i][j],dp[i-1][j-1]);</span><br><span class="line">               dp[i][j] &#x3D; Math.min(dp[i][j],dp[i-1][j-1]+rc);</span><br><span class="line">               dp[i][j] &#x3D; Math.min(dp[i][j],dp[i-1][j-1]+ic+dc);</span><br><span class="line">               dp[i][j] &#x3D; Math.min(dp[i][j],dp[i][j-1]+ic);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return dp[M][N];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 30 相等子树</title>
      <link href="/2020/09/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-05-Problem-30-%E7%9B%B8%E7%AD%89%E5%AD%90%E6%A0%91/"/>
      <url>/2020/09/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-05-Problem-30-%E7%9B%B8%E7%AD%89%E5%AD%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如果一个节点X，它左树结构和右树结构完全一样,那么我们说以X为头的树是相等树。给定一棵二叉树的头节点head ，返回head整棵树上有多少棵相等子树</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>既然是比较树是不是一样的，那我们可以通过序列化的方式来描述一棵树。运用二叉树的递归套路，返回以head为头节点有多少个相等树，同时返回序列化结果。那么当拿到左右孩子的info信息时，便可以决定当前节点的相等子树个数。此外，比较序列化结果时，可以做一下hash。这样整体则是O(N)的运算。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> ans;</span><br><span class="line">        <span class="keyword">public</span> String str;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> a, String s)</span> </span>&#123;</span><br><span class="line">            ans = a;</span><br><span class="line">            str = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//方法一:朴素的做法，遍历每个节点来求相等节点个数,判断是不是相等,</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isSameTree</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> process1(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> leftNum = process1(node.left);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> rightNum = process1(node.right);</span><br><span class="line">        <span class="keyword">int</span> res = leftNum + rightNum;</span><br><span class="line">        <span class="keyword">final</span> String strLeft = preOrderSquence(node.left);</span><br><span class="line">        <span class="keyword">final</span> String strRight = preOrderSquence(node.right);</span><br><span class="line">        <span class="keyword">return</span> strLeft.equals(strRight) ? res+<span class="number">1</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">preOrderSquence</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"null,"</span>;</span><br><span class="line">        String str = node.value+<span class="string">","</span>;</span><br><span class="line">        <span class="keyword">final</span> String leftStr = preOrderSquence(node.left);</span><br><span class="line">        <span class="keyword">final</span> String rightStr = preOrderSquence(node.right);</span><br><span class="line">        <span class="keyword">return</span> str + leftStr + rightStr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//改进: 对序列化串做hash。时间复杂度O(N)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sameNumber2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        String algorithm = <span class="string">"SHA-256"</span>;</span><br><span class="line">        Hash hash = <span class="keyword">new</span> Hash(algorithm);</span><br><span class="line">        <span class="keyword">return</span> process(head, hash).ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node head, Hash hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="number">0</span>, hash.hashCode(<span class="string">"#,"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Info l = process(head.left, hash);</span><br><span class="line">        Info r = process(head.right, hash);</span><br><span class="line">        <span class="keyword">int</span> ans = (l.str.equals(r.str) ? <span class="number">1</span> : <span class="number">0</span>) + l.ans + r.ans;</span><br><span class="line">        String str = hash.hashCode(String.valueOf(head.value) + <span class="string">","</span> + l.str + r.str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(ans, str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 29 BST先序构造树</title>
      <link href="/2020/09/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-05-Problem-29-BST%E5%85%88%E5%BA%8F%E6%9E%84%E9%80%A0%E6%A0%91/"/>
      <url>/2020/09/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-05-Problem-29-BST%E5%85%88%E5%BA%8F%E6%9E%84%E9%80%A0%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​        已知一棵搜索二叉树上没有重复值的节点，现在有一个数组arr，是这棵搜索二叉树先序遍历的结果<br>请根据arr生成整棵树并返回头节点</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是递归在区间l-r中创建树,寻找左子树，右子树时候，因为是寻找第一个大于的,用二分正好，总体就是nlogn的</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        TreeNode() &#123;&#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法一：就是递归在区间l-r中创建树,寻找左子树，右子树时候，因为是寻找第一个大于的,用二分正好，总体就是nlogn的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  TreeNode <span class="title">bstFromPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( preorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>  process(preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[l]);</span><br><span class="line">        <span class="keyword">final</span> TreeNode root = <span class="keyword">new</span> TreeNode(preorder[l]);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bigger_index = binarySearch(preorder, l + <span class="number">1</span>, r, preorder[l]);</span><br><span class="line">        <span class="keyword">final</span> TreeNode leftChild = process(preorder, l + <span class="number">1</span>, bigger_index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> TreeNode rightChild = process(preorder, bigger_index, r);</span><br><span class="line">        root.left = leftChild;root.right = rightChild;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//查找第一个大于key的下标,-1为不存在</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = from,r = to;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(preorder[mid] &gt; key)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preorder[l] &gt; key ? l : l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 28 大楼轮廓线问题</title>
      <link href="/2020/09/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-01-Problem-28-%E5%A4%A7%E6%A5%BC%E8%BD%AE%E5%BB%93%E7%BA%BF%E9%97%AE%E9%A2%98/"/>
      <url>/2020/09/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-01-Problem-28-%E5%A4%A7%E6%A5%BC%E8%BD%AE%E5%BB%93%E7%BA%BF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    大楼轮廓线问题<br>​    <a href="https://leetcode.com/problems/the-skyline-problem/" target="_blank" rel="noopener">https://leetcode.com/problems/the-skyline-problem/</a></p><p>第4节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 27 字符串交错组成</title>
      <link href="/2020/09/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-01-Problem-27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E9%94%99%E7%BB%84%E6%88%90/"/>
      <url>/2020/09/01/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-09-01-Problem-27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E9%94%99%E7%BB%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    字符串交错组成<br>​    <a href="https://leetcode.com/problems/interleaving-string/" target="_blank" rel="noopener">https://leetcode.com/problems/interleaving-string/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>典型的dp行列模型，定义dp[i][j]表示s1的前i个和s2的前j个字符是否能组成s3的前i+j个字符</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] arr1 = s1.toCharArray(),arr2 = s2.toCharArray(),arr3 = s3.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> M = s1.length(),N = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(M+N != s3.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[M + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= M;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = arr1[i-<span class="number">1</span>] == arr3[i-<span class="number">1</span>] ? dp[i-<span class="number">1</span>][<span class="number">0</span>] : <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= N;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = arr2[j-<span class="number">1</span>] == arr3[j-<span class="number">1</span>] ? dp[<span class="number">0</span>][j-<span class="number">1</span>]:<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= M;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= N;j++)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> p1 = <span class="keyword">false</span>,p2 = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(arr1[i-<span class="number">1</span>] == arr3[i+j-<span class="number">1</span>])&#123;</span><br><span class="line">                    p1 = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(arr2[j-<span class="number">1</span>] == arr3[i+j-<span class="number">1</span>])&#123;</span><br><span class="line">                    p2 = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = p1|p2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[M][N];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 26 达标数组问题</title>
      <link href="/2020/08/30/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-30-Problem-26-%E8%BE%BE%E6%A0%87%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/08/30/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-30-Problem-26-%E8%BE%BE%E6%A0%87%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    生成长度为size的达标数组，什么叫达标？</p><p>达标：对于任意的 i&lt;k&lt;j，满足 [i] + [j] != [k] * 2</p><p>给定一个正数size，返回长度为size的达标数组</p><p>第4节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Problem 25 分糖果问题</title>
      <link href="/2020/08/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-26-Problem-25-%E5%88%86%E7%B3%96%E6%9E%9C%E9%97%AE%E9%A2%98/"/>
      <url>/2020/08/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-26-Problem-25-%E5%88%86%E7%B3%96%E6%9E%9C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    原问题：<a href="https://leetcode.com/problems/candy/" target="_blank" rel="noopener">https://leetcode.com/problems/candy/</a></p><p>​    进阶问题：在原问题的基础上，增加一个原则：<br>​        相邻的孩子间如果分数一样，分的糖果数必须一样<br>​    返回至少需要分多少糖</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>和原题基本一样通过两次遍历，先满足比左邻居的大，再遍历一次 满足比右边邻居的大。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(ratings.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> N = ratings.length;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       left[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i &lt; N;i++)&#123;</span><br><span class="line">           left[i] = ratings[i] &gt; ratings[i-<span class="number">1</span>]?left[i-<span class="number">1</span>]+<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       right[N-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = N-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">           right[j] = ratings[j] &gt; ratings[j+<span class="number">1</span>] ? right[j+<span class="number">1</span>]+<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">           res += Math.max(left[i],right[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 24 不相邻的最大子序列和</title>
      <link href="/2020/08/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-25-Problem-24-%E4%B8%8D%E7%9B%B8%E9%82%BB%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
      <url>/2020/08/25/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-25-Problem-24-%E4%B8%8D%E7%9B%B8%E9%82%BB%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    返回一个数组中，选择的数字不能相邻的情况下，最大子序列累加和</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这种子序列，首选DP，不相邻只是一个限制条件。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNotNearMaxSub</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || N ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = arr[arr.length-<span class="number">2</span>] &gt; arr[arr.length-<span class="number">1</span>] ? arr[arr.length-<span class="number">2</span>] :arr[arr.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> next_next = arr[arr.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = arr[N-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N-<span class="number">3</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp_next = next;</span><br><span class="line">            next = Math.max(Math.max(next,next_next + arr[i]),arr[i]); <span class="comment">//求当前dp对应的值，提前更新迭代，正好存下来</span></span><br><span class="line">            next_next = temp_next;</span><br><span class="line">            res = Math.max(res,next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 23 最大子矩阵和</title>
      <link href="/2020/08/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-22-Problem-23-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C/"/>
      <url>/2020/08/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-22-Problem-23-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    返回一个二维数组中，子矩阵最大累加和</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>子矩阵的最大累加和，子矩阵是任意的一个。做这种题目就是要想办法从某一个方向入手，能去枚举可能性。子矩阵可以分为以第一行为底的矩阵，第二行为底的子矩阵，第三行为底的子矩阵。同时我们想，在纵方向上进行累加起来，比如第一行和第二行的值累加成一个数组，此时这个数组的最大连续子数组实际就是以第二行为底，高为2的矩阵中，最大的子矩阵。通过枚举所有的子矩阵，利用寻找最大连续子数组的方式就可以找到最大的连续子矩阵。</li><li>整体思路就是 矩阵压缩+最大连续子数组</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getMaxMatrix(<span class="keyword">int</span>[][] matrix)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> r1 = <span class="number">0</span>,c1 = <span class="number">0</span>,r2 = <span class="number">0</span>,c2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = matrix.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> M = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>;start &lt; N;start++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">                sum[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> end = start;end &lt; N;end++)&#123;</span><br><span class="line">                sum[<span class="number">0</span>] += matrix[end][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> pre = sum[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> pre_srart = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; M;j++)&#123;</span><br><span class="line">                    sum[j] += matrix[end][j];</span><br><span class="line">                  <span class="keyword">if</span>(pre+sum[j] &gt; sum[j])&#123;</span><br><span class="line">                      pre = pre+sum[j];</span><br><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                      pre = sum[j];</span><br><span class="line">                      pre_srart = j;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span>(pre &gt; res)&#123;</span><br><span class="line">                      res = pre;</span><br><span class="line">                      r1 = start;</span><br><span class="line">                      c1 = pre_srart;</span><br><span class="line">                      r2 = end;</span><br><span class="line">                      c2 = j;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r1,c1,r2,c2&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 22 子数组最大累积和</title>
      <link href="/2020/08/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-22-Problem-22-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E7%A7%AF%E5%92%8C/"/>
      <url>/2020/08/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-22-Problem-22-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E7%A7%AF%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    返回一个数组中，子数组最大累加和</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题目就太常见了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max_subarr_sum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            pre = Math.max(arr[i],arr[i]+pre);</span><br><span class="line">            res = Math.max(res,pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 21 设计查询区间上目标数个数</title>
      <link href="/2020/08/19/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-19-Problem-21-%E8%AE%BE%E8%AE%A1%E6%9F%A5%E8%AF%A2%E5%8C%BA%E9%97%B4%E4%B8%8A%E7%9B%AE%E6%A0%87%E6%95%B0%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/08/19/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-19-Problem-21-%E8%AE%BE%E8%AE%A1%E6%9F%A5%E8%AF%A2%E5%8C%BA%E9%97%B4%E4%B8%8A%E7%9B%AE%E6%A0%87%E6%95%B0%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>数组为{3, 2, 2, 3, 1}，查询为(0, 3, 2)，意思是在数组里下标0~3这个范围上，有几个2？答案返回2。<br>假设给你一个数组arr，对这个数组的查询非常频繁，都给出来。</p><p>请返回 所有查询的结果</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>数据结构的题目 通常都是考察某种思想，而且这种思想 在工作中，碰到的各种组建都会有应用到的地方，是可以落地使用的。</li><li>此题可以用一种反向索引表，也就是key是待查的元素，v是一个list，存的是递增的index。查找时可以在list上用二分查找。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Finder</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] num;</span><br><span class="line">        HashMap&lt;Integer, List&lt;Integer&gt;&gt;  re_index;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">            num = Arrays.copyOfRange(arr,<span class="number">0</span>,arr.length);</span><br><span class="line">            re_index = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(re_index.containsKey(num[i]) ) &#123;</span><br><span class="line">                    re_index.get(num[i]).add(i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    list.add(i);</span><br><span class="line">                    re_index.put(num[i],list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> elem)</span></span>&#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;Integer&gt; list = re_index.get(elem);</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> a = binarySearch(list, l);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> b = binarySearch(list, r + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> b-a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Integer&gt; list,<span class="keyword">int</span> elem)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>,r = list.size()-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(list.get(mid) &gt;= elem)</span><br><span class="line">                    r = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list.get(l) &gt;= elem ? l:l+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Finder finder = <span class="keyword">new</span> Finder();</span><br><span class="line">            finder.build(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;);</span><br><span class="line">            System.out.println(finder.find(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 20 距离K的树节点</title>
      <link href="/2020/08/18/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-18-Problem-20-%E8%B7%9D%E7%A6%BBK%E7%9A%84%E6%A0%91%E8%8A%82%E7%82%B9/"/>
      <url>/2020/08/18/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-18-Problem-20-%E8%B7%9D%E7%A6%BBK%E7%9A%84%E6%A0%91%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定三个参数：<br>二叉树的头节点head，树上某个节点target，正数K<br>从target开始，可以向上走或者向下走，返回与target的距离是K的所有节点    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>可以往上走，那就是3个方向，找距离为K的，那不就是图的bfs吗。所以说思路要打开。树是不带父亲的路径的，需要自己用有序表存一下。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getKDistanceNodes</span><span class="params">(Node root, Node target, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Node, Node&gt; parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Node&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        dfs(root,<span class="keyword">null</span>,parent);</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">int</span> next_step = <span class="number">0</span>,next_batch = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        queue.add(target);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp_count = <span class="number">0</span>,temp_next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp_count &lt; next_batch)&#123;</span><br><span class="line">                <span class="keyword">final</span> Node node = queue.poll();</span><br><span class="line">                visited.add(node);</span><br><span class="line">                <span class="keyword">if</span>(next_step == K)&#123;</span><br><span class="line">                    list.add(node);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span> &amp;&amp; !visited.contains(node.left))&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                    temp_next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span> &amp;&amp; !visited.contains(node.right))&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                    temp_next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(parent.get(node) != <span class="keyword">null</span> &amp;&amp; !visited.contains(parent.get(node)))&#123;</span><br><span class="line">                    queue.add(parent.get(node));</span><br><span class="line">                    temp_next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp_count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(next_step == K) <span class="keyword">break</span>;</span><br><span class="line">            next_step++;</span><br><span class="line">            next_batch =temp_next_batch;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node cur,Node parent,Map&lt;Node,Node&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(cur,parent);</span><br><span class="line">            dfs(cur.left,cur,map);</span><br><span class="line">            dfs(cur.right,cur,map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 19</title>
      <link href="/2020/08/14/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-14-Problem-19-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/"/>
      <url>/2020/08/14/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-14-Problem-19-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode 自由之路</p><p>​    <a href="https://leetcode.com/problems/freedom-trail/" target="_blank" rel="noopener">https://leetcode.com/problems/freedom-trail/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Problem 18 最接近sum的子序列累加和问题</title>
      <link href="/2020/08/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-12-Problem-18-%E6%9C%80%E6%8E%A5%E8%BF%91sum%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E7%B4%AF%E5%8A%A0%E5%92%8C%E9%97%AE%E9%A2%98md/"/>
      <url>/2020/08/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-12-Problem-18-%E6%9C%80%E6%8E%A5%E8%BF%91sum%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E7%B4%AF%E5%8A%A0%E5%92%8C%E9%97%AE%E9%A2%98md/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    Leetcode 最接近sum的子序列累加和问题</p><p>​    <a href="https://leetcode.com/problems/closest-subsequence-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/closest-subsequence-sum/</a></p><p>​    3节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Problem 17 最少坐船数</title>
      <link href="/2020/08/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-12-Problem-17-%E6%9C%80%E5%B0%91%E5%9D%90%E8%88%B9%E6%95%B0md/"/>
      <url>/2020/08/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-12-Problem-17-%E6%9C%80%E5%B0%91%E5%9D%90%E8%88%B9%E6%95%B0md/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个正数数组arr，代表若干人的体重. 再给定一个正数limit，表示所有船共同拥有的载重量 每艘船最多坐两人，且不能超过载重 ,想让所有的人同时过河，并且用最好的分配方法让船尽量少。返回最少的船数</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>上道题目是同向的双指针，这就是对撞型的。尽可能少的，那就是让胖的尽可能捎带一个小的，稍不过来就单独成船。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getShipCout</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>,j = arr.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[j] &gt; limit)&#123;</span><br><span class="line">               <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (arr[i] + arr[j] &gt; limit ) &#123;</span><br><span class="line">               j--;</span><br><span class="line">               c++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               i++;</span><br><span class="line">               j--;</span><br><span class="line">               c++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(i == j) c++;</span><br><span class="line">       <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 16 最多比赛数</title>
      <link href="/2020/08/09/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-09-Problem-16-%E6%9C%80%E5%A4%9A%E6%AF%94%E8%B5%9B%E6%95%B0/"/>
      <url>/2020/08/09/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-09-Problem-16-%E6%9C%80%E5%A4%9A%E6%AF%94%E8%B5%9B%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个数组arr，代表每个人的能力值。再给定一个非负数k 如果两个人能力差值正好为k，那么可以凑在一起比赛 一局比赛只有两个人<br>返回最多可以同时有多少场比赛。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>双指针。注意双指针常用法有同向，也有对撞的。相差k，肯定是一个大，一个小呀，所以排序一下，用大的减小的为K，同时注意标记 。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">TotalGeme</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>,R = <span class="number">0</span>,N = arr.length,res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length];</span><br><span class="line">        <span class="keyword">while</span> (L &lt; N &amp;&amp; R &lt; N)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[L]) &#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">                    R++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[R] - arr[L] == k)&#123;</span><br><span class="line">                        used[L] = <span class="keyword">true</span>;</span><br><span class="line">                        used[R] = <span class="keyword">true</span>;</span><br><span class="line">                        L++;</span><br><span class="line">                        R++;</span><br><span class="line">                        res++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[R] - arr[L] &gt; k)&#123;</span><br><span class="line">                        L++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        R++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 15 最大正方形</title>
      <link href="/2020/08/07/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-07-Problem-15-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
      <url>/2020/08/07/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-07-Problem-15-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个只有0和1组成的二维数组,返回边框全是1的最大正方形面积</p><p>​    leetcode:<a href="https://leetcode.com/problems/largest-1-bordered-square/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-1-bordered-square/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>先来分析一下。求的是边框是1，是空心的。没有任何知识点的提示，那就从从数据规模上看，N的3次方是能满足的。所以我们不妨用暴力来做。</li><li>枚举长方形是 N的4次方，枚举正方形是N的3次方，此外，枚举完了正方形 我们还要判定是不是边框是1，不能再增加阶数了，我们希望是在常数操作下就可以判断出来，当然想到预处理.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largest1BorderedSquare</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = grid.length;</span><br><span class="line">        <span class="keyword">int</span> N = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (M == <span class="number">0</span> || N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//预处理数组，下1的个数,右1的个数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] downNum = <span class="keyword">new</span> <span class="keyword">int</span>[M][N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            downNum[M-<span class="number">1</span>][i]  = grid[M-<span class="number">1</span>][i] == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = M-<span class="number">2</span>;i &gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span> ;j &lt; N;j++)&#123;</span><br><span class="line">                downNum[i][j] = grid[i][j] == <span class="number">1</span> ? downNum[i+<span class="number">1</span>][j]+<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] rightNum = <span class="keyword">new</span> <span class="keyword">int</span>[M][N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            rightNum[i][N-<span class="number">1</span>]= grid[i][N-<span class="number">1</span>] == <span class="number">1</span>?<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = N-<span class="number">2</span>;j &gt;= <span class="number">0</span>;j --)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M;i++)&#123;</span><br><span class="line">                rightNum[i][j] =grid[i][j] == <span class="number">0</span>? <span class="number">0</span>:rightNum[i][j+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> border = <span class="number">1</span>; border &lt;= Math.min(N-j,M-i);border++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(downNum[i][j] &lt; border || rightNum[i][j] &lt; border)</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(rightNum[i+border-<span class="number">1</span>][j] &lt; border)</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(downNum[i][j+border-<span class="number">1</span>] &lt; border)</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            res = Math.max(res,border*border);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 13 字符串种类</title>
      <link href="/2020/08/04/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-04-Problem-13-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%8D%E7%B1%BB/"/>
      <url>/2020/08/04/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-08-04-Problem-13-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%8D%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    只由小写字母（a~z）组成的一批字符串 都放在字符类型的数组String[] arr中 如果其中某两个字符串所含有的字符种类完全一样 就将两个字符串算作一类 比如：baacbba和bac就算作一类 返回arr中有多少类？</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>很容易想到，一个字符串用一个map表来表示只与种类有关。但实际上26个字母，26位 利用一个整数就可以表示。所以有几个整数就是有几类。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countKind</span><span class="params">(String[] strings)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">            set.add(getInt(strings[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title">getInt</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; string.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = string.charAt(i)-<span class="string">'a'</span>;</span><br><span class="line">            res |= <span class="number">1</span>&lt;&lt;index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Bit Manipulate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 12</title>
      <link href="/2020/07/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-31-Problem-14/"/>
      <url>/2020/07/31/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-31-Problem-14/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Problem 12 整体有序的最小子数组</title>
      <link href="/2020/07/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-29-Problem-12-%E6%95%B4%E4%BD%93%E6%9C%89%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2020/07/29/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-29-Problem-12-%E6%95%B4%E4%BD%93%E6%9C%89%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个数组arr，只能对arr中的一个子数组排序，但是想让arr整体都有序 返回满足这一设定的子数组中，最短的是多长。</p><p>leetcode 链接:<a href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/shortest-unsorted-continuous-subarray/</a></p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典题目，简单分析一下，假设第一个元素比最后一个元素大，降序，那只能整体排序。如果第一个元素不是最小的，最后一个元素也不是最大的，他们都得参与排序，那么整体也得排序。</li><li>推广一下，也就是，对于当前元素 只有右面存在一个元素比我小就完蛋，当前元素就得参与排序，同理，左边有一个比我大的，就完蛋 我一样得参与排序，这就有了，我们分别从左边遍历，找到最后一个需要参与排序的元素， 从右面遍历找到参与排序的第一个元素，搞定！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinSubLen</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> max_l = nums[<span class="number">0</span>],index_l = <span class="number">0</span>,min_r = nums[nums.length-<span class="number">1</span>],index_r = nums.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i] &gt;= max_l )&#123;</span><br><span class="line">               max_l = nums[i];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               index_l = i;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>-i] &lt;= min_r)&#123;</span><br><span class="line">               min_r = nums[nums.length-<span class="number">1</span>-i];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               index_r = nums.length-<span class="number">1</span>-i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> index_l - index_r + <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span>: index_l - index_r + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 11 设计setAll</title>
      <link href="/2020/07/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-28-Problem-11-%E8%AE%BE%E8%AE%A1setAll/"/>
      <url>/2020/07/28/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-28-Problem-11-%E8%AE%BE%E8%AE%A1setAll/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    设计有setAll功能的哈希表</p><p>​    put、get、setAll方法，时间复杂度O(1)</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>考察思想 “版本”，利用时间戳做版本的思想。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValue</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> V value;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyValue</span><span class="params">(V v, <span class="keyword">long</span> t)</span> </span>&#123;</span><br><span class="line">value = v;</span><br><span class="line">time = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HashMap&lt;K, MyValue&lt;V&gt;&gt; map;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"><span class="keyword">private</span> MyValue&lt;V&gt; setAll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">time = <span class="number">0</span>;</span><br><span class="line">setAll = <span class="keyword">new</span> MyValue&lt;V&gt;(<span class="keyword">null</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">map.put(key, <span class="keyword">new</span> MyValue&lt;V&gt;(value, time++));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAll</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">setAll = <span class="keyword">new</span> MyValue&lt;V&gt;(value, time++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (map.get(key).time &gt; setAll.time) &#123;</span><br><span class="line"><span class="keyword">return</span> map.get(key).value;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> setAll.value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 10 司机调度</title>
      <link href="/2020/07/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-26-Problem-10-%E5%8F%B8%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
      <url>/2020/07/26/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-26-Problem-10-%E5%8F%B8%E6%9C%BA%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    现有司机N*2人，调度中心会将所有司机平分给A、B两个区域<br>​            第 i 个司机去A可得收入为income[i][0]，<br>​            第 i 个司机去B可得收入为income[i][1]，<br>返回所有调度方案中能使所有司机总收入最高的方案，是多少钱</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>最优解，一般考虑贪心 、dp。这个题实际贪心就可以。主要找出贪心策略，同一个人去A可能钱很多，去B可能钱也很多，那去A去B对这个人来说关系不大，而另一个人 去A钱很多，而去B钱很少，为了整体最优，去A的人当然优选第二个人，所以策略就来了。数组排序，排序策略是 income[i][0] - income[i][1] 降序。说明越大的 越适合去A，这样前N个去A，后N个去B即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxMoney</span><span class="params">(<span class="keyword">int</span>[][] income)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = income.length;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">arr[i] = income[i][<span class="number">1</span>] - income[i][<span class="number">0</span>];</span><br><span class="line">sum += income[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">int</span> M = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= M; i--) &#123;</span><br><span class="line">sum += arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 9 数据流问题</title>
      <link href="/2020/07/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-23-Problem-9-%E6%95%B0%E6%8D%AE%E6%B5%81%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/23/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-23-Problem-9-%E6%95%B0%E6%8D%AE%E6%B5%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    已知一个消息流会不断地吐出整数 1~N，但不一定按照顺序依次吐出 如果上次打印的序号为i， 那么当i+1出现时 请打印 i+1 及其之后接收过的并且连续的所有数 直到1~N全部接收并打印完<br>请设计这种接收并打印的结构。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典题目。大思路就是构建头链表，构建尾链表，来一个元素就要去头链中 拽出来前面的元素，同时检查这个元素是否在尾链中，同理也要尝试拽尾链中的元素。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> key;</span><br><span class="line">       String info;</span><br><span class="line">       Node next;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, String info)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.info = info;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Browse</span></span>&#123;</span><br><span class="line">       <span class="keyword">static</span> HashMap&lt;Integer,Node&gt; head;</span><br><span class="line">       <span class="keyword">static</span> HashMap&lt;Integer,Node&gt; tail;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> waitNo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           head = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           tail = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">           <span class="comment">//检查前面有没有尾巴和它连</span></span><br><span class="line">           <span class="keyword">if</span>(tail.containsKey(node.key-<span class="number">1</span>))&#123;</span><br><span class="line">               tail.get(node.key-<span class="number">1</span>).next = node;</span><br><span class="line">               tail.remove(node.key-<span class="number">1</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123; <span class="comment">//</span></span><br><span class="line">               head.put(node.key,node);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//检查有没有下面的头和它相连</span></span><br><span class="line">           <span class="keyword">if</span>(head.containsKey(node.key+<span class="number">1</span>))&#123;</span><br><span class="line">               node.next = head.get(node.key+<span class="number">1</span>);</span><br><span class="line">               head.remove(node.key+<span class="number">1</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               tail.put(node.key,node);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(waitNo == node.key)&#123;</span><br><span class="line">               print(node);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">           head.remove(node.key);</span><br><span class="line">           String str = <span class="string">""</span> + node.info;</span><br><span class="line">           waitNo++;</span><br><span class="line">           <span class="keyword">while</span> (node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">               str += node.next.info + <span class="string">" "</span>;</span><br><span class="line">               waitNo++;</span><br><span class="line">               node = node.next;</span><br><span class="line">           &#125;</span><br><span class="line">           tail.remove(node.key);</span><br><span class="line">           System.out.println(str);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Browse box = <span class="keyword">new</span> Browse();</span><br><span class="line"></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">2</span>,<span class="string">"B"</span>)); <span class="comment">// - 2"</span></span><br><span class="line">       System.out.println(<span class="string">"这是2来到的时候"</span>);</span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">1</span>,<span class="string">"A"</span>)); <span class="comment">// 1 2 -&gt; print, trigger is 1</span></span><br><span class="line">       System.out.println(<span class="string">"这是1来到的时候"</span>);</span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">4</span>,<span class="string">"D"</span>)); <span class="comment">// - 4</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">5</span>,<span class="string">"E"</span>)); <span class="comment">// - 4 5</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">7</span>,<span class="string">"G"</span>)); <span class="comment">// - 4 5 - 7</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">8</span>,<span class="string">"H"</span>)); <span class="comment">// - 4 5 - 7 8</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">6</span>,<span class="string">"F"</span>)); <span class="comment">// - 4 5 6 7 8</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">3</span>,<span class="string">"C"</span>)); <span class="comment">// 3 4 5 6 7 8 -&gt; print, trigger is 3</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">9</span>,<span class="string">"I"</span>)); <span class="comment">// 9 -&gt; print, trigger is 9</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">10</span>,<span class="string">"J"</span>)); <span class="comment">// 10 -&gt; print, trigger is 10</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">12</span>,<span class="string">"L"</span>)); <span class="comment">// - 12</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">13</span>,<span class="string">"M"</span>)); <span class="comment">// - 12 13</span></span><br><span class="line">       box.receive(<span class="keyword">new</span> Node(<span class="number">11</span>,<span class="string">"K"</span>)); <span class="comment">// 11 12 13 -&gt; print, trigger is 11</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 8  可乐找零问题</title>
      <link href="/2020/07/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-22-Problem-8-%E5%8F%AF%E4%B9%90%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/22/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-22-Problem-8-%E5%8F%AF%E4%B9%90%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    贩卖机只支持硬币支付，且收退都只支持10 ，50，100三种面额<br>一次购买只能出一瓶可乐，且投钱和找零都遵循优先使用大钱的原则<br>需要购买的可乐数量是m，<br>其中手头拥有的10、50、100的数量分别为a、b、c<br>可乐的价格是x(x是10的倍数)<br>请计算出需要投入硬币次数？</p><p>2节</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 7 最好收入问题</title>
      <link href="/2020/07/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-20-Problem-7-%E6%9C%80%E5%A5%BD%E6%94%B6%E5%85%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/20/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-20-Problem-7-%E6%9C%80%E5%A5%BD%E6%94%B6%E5%85%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定数组hard和money，长度都为N hard[i]表示i号的难度， money[i]表示i号工作的收入 ，给定数组ability，长度都为M，ability[j]表示j号人的能力 ，每一号工作，都可以提供无数的岗位，难度和收入都一样<br>但是人的能力必须&gt;=这份工作的难度，才能上班。<br>返回一个长度为M的数组ans，ans[j]表示j号人能获得的最好收入</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>先想一下 最简单的暴力，对每个人 我们去找到最好的工作，就得遍历所有的工作，为了减少遍历，我们可以事先把工作先按照收益升序，难度降序的方式排列起来，这样再对每个员工查找合适的工作时候，找到第一个难度可以胜任的工作就是满足要求的。那对每个员工，依然得从头去遍历数组，最差还是O(N^2^),再想办法优化一下 </li><li>想办法 避免回退！比如第一个人已经走到工作数组index = 5才胜任，对于第二个人，要是保证前5个工作一定是不合适的，那么就可以从index=5继续遍历了。其实把人提前按能力降序，再去遍历就是这个特点，因为涉及到排序 整个复杂度就是 O(N*logN),当然这个也可以用两个堆来代替。</li><li>其实还有更简洁的办法，我们想 同样难度下当然是工资越高越好，同样难度，工资小的那个工作直接丢掉。这样就可以直接在treemap里面，找到自己能适应的难度的工作就可以。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Position</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> hard;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> money;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Position</span><span class="params">(<span class="keyword">int</span> hard, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.hard = hard;</span><br><span class="line">            <span class="keyword">this</span>.money = money;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双堆 nlogn</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxProfit</span><span class="params">(<span class="keyword">int</span>[] hard,<span class="keyword">int</span>[] money,<span class="keyword">int</span>[] ability)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hard.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_profits = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> PriorityQueue&lt;Position&gt; min_heap= <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a.hard-b.hard);</span><br><span class="line">        <span class="keyword">final</span> PriorityQueue&lt;Position&gt; max_heap= <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b.money - a.money);</span><br><span class="line">        Arrays.sort(ability);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hard.length; i++) &#123;</span><br><span class="line">            min_heap.add(<span class="keyword">new</span> Position(hard[i],money[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ability.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!min_heap.isEmpty() &amp;&amp; min_heap.peek().hard &lt;= ability[i])&#123;</span><br><span class="line">                max_heap.add(min_heap.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!max_heap.isEmpty())</span><br><span class="line">                max_profits += max_heap.peek().money;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_profits;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//法二：提前预处理，精简职位</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> money;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> hard;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">money = m;</span><br><span class="line">hard = h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JobComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Job o1, Job o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1.hard != o2.hard ? (o1.hard - o2.hard) : (o2.money - o1.money);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getMoneys(Job[] job, <span class="keyword">int</span>[] ability) &#123;</span><br><span class="line">Arrays.sort(job, <span class="keyword">new</span> JobComparator());</span><br><span class="line"><span class="comment">// key : 难度   value：报酬</span></span><br><span class="line">TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">map.put(job[<span class="number">0</span>].hard, job[<span class="number">0</span>].money);</span><br><span class="line"><span class="comment">// pre : 上一份进入map的工作</span></span><br><span class="line">Job pre = job[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; job.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (job[i].hard != pre.hard &amp;&amp; job[i].money &gt; pre.money) &#123;</span><br><span class="line">pre = job[i];</span><br><span class="line">map.put(pre.hard, pre.money);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//最终的map 就是难度升序，并且对应的薪水也是升序的</span></span><br><span class="line"><span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[ability.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ability.length; i++) &#123;</span><br><span class="line"><span class="comment">// ability[i] 当前人的能力 &lt;= ability[i]  且离它最近的</span></span><br><span class="line">Integer key = map.floorKey(ability[i]);</span><br><span class="line">ans[i] = key != <span class="keyword">null</span> ? map.get(key) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 6 正负符号累加数字的方法数</title>
      <link href="/2020/07/17/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-17-Problem-6-%E6%AD%A3%E8%B4%9F%E7%AC%A6%E5%8F%B7%E7%B4%AF%E5%8A%A0%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0/"/>
      <url>/2020/07/17/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-17-Problem-6-%E6%AD%A3%E8%B4%9F%E7%AC%A6%E5%8F%B7%E7%B4%AF%E5%8A%A0%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个数组arr，你可以在每个数字之前决定+或者-  但是必须所有数字都参与 ,再给定一个数target，请问最后算出target的方法数是多少？</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>乍一看 ，典型的从左到右背包模型,可以给出dp的最优解。但实际上 想想看，这个target 可能是负的 ，dp[index][target]代表index到len-1的位置能组成target的方法数，这个target的变化值是很大的。所以直接做不合适。</li><li>既然直接做不合适，我们就想到去想办法转化题目<ul><li>首先想到 可以认为arr中都是非负数，因为即便是arr中有负数，比如[3,-4,2] 因为你能在每个数前面用+或者-号 所以[3,-4,2]其实和[3,4,2]达成一样的效果 那么我们就全把arr变成非负数，不会影响结果的</li><li>比如说给定一个数组, arr = [1, 2, 3, 4, 5] 并且 target = 3<br>其中一个方案是 : +1 -2 +3 -4 +5 = 3<br>该方案中取了正的集合为P = {1，3，5}<br>该方案中取了负的集合为N = {2，4}<br>所以任何一种方案，都一定有 sum(P) - sum(N) = target<br>现在我们来处理一下这个等式，把左右两边都加上sum(P) + sum(N)，那么就会变成如下：<br>sum(P) - sum(N) + sum(P) + sum(N) = target + sum(P) + sum(N)<br>2 * sum(P) = target + 数组所有数的累加和<br>sum(P) = (target + 数组所有数的累加和) / 2<br>也就是说，任何一个集合，只要累加和是(target + 数组所有数的累加和) / 2<br>那么就一定对应一种target的方式<br>也就是说，比如非负数组arr，target = 7, 而所有数累加和是11<br>求有多少方法组成7，其实就是求有多少种达到累加和(7+11)/2=9的方法</li><li>此外还可以添加一些 判定条件，如果arr都是非负数，并且所有数的累加和是sum，那么如果target&lt;sum，很明显没有任何方法可以达到target，可以直接返回0</li><li>arr内部的数组，不管怎么+和-，最终的结果都一定不会改变奇偶性  所以，如果所有数的累加和是sum</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : arr) &#123;</span><br><span class="line">sum += n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum &lt; target || ((target &amp; <span class="number">1</span>) ^ (sum &amp; <span class="number">1</span>)) != <span class="number">0</span> ? <span class="number">0</span> : subset2(arr, (target + sum) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求非负数组nums有多少个子集，累加和是s</span></span><br><span class="line"><span class="comment">// 二维动态规划</span></span><br><span class="line"><span class="comment">// 不用空间压缩</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">subset1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n = nums.length;</span><br><span class="line"><span class="comment">// dp[i][j] : nums前缀长度为i的所有子集，有多少累加和是j？</span></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][s + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// nums前缀长度为0的所有子集，有多少累加和是0？一个：空集</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] += dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n][s];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间压缩</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">subset2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &gt;= n; i--) &#123;</span><br><span class="line">dp[i] += dp[i - n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[s];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 5 释放AOE</title>
      <link href="/2020/07/14/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-14-Problem-5-%E9%87%8A%E6%94%BEAOE/"/>
      <url>/2020/07/14/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-14-Problem-5-%E9%87%8A%E6%94%BEAOE/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个非负数组x和hp，长度都是N，再给定一个正数range  ,x有序，x[i]表示i号怪兽在x轴上的位置；hp[i]表示i号怪兽的血量  再给定一个正数range，表示如果法师释放技能的范围长度 被打到的每只怪兽损失1点血量。<br>返回要把所有怪兽血量清空，至少需要释放多少次AOE技能？</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>首先这个题目注意是双向释放技能，那不管怎么说，也得遍历一头一头的来杀死怪兽，那怎么杀死？要释放的技能尽可能少，只要让每个技能都发挥最大的效益就可以，既然双向释放技能，对于当前的怪兽，最好的杀死策略就是让怪兽正好位于技能释放的最左端！</li><li>优化点在于，我们释放技能在一个区间上减1，在区间上做操作，可以用线段树</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一:贪心 O(N^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinAoe1</span><span class="params">(<span class="keyword">int</span>[] x,<span class="keyword">int</span>[] hp,<span class="keyword">int</span> range)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = x.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightEdge = <span class="number">0</span>,rightCenter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hp[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//对当前怪兽，找到最右面能打到的地方</span></span><br><span class="line">                <span class="keyword">while</span> (rightCenter &lt;N &amp;&amp; x[rightCenter] - x[i] &lt;= range)&#123;</span><br><span class="line">                    rightCenter++;</span><br><span class="line">                &#125;</span><br><span class="line">                rightCenter = rightCenter-<span class="number">1</span>; <span class="comment">//右面释放AOE的位置</span></span><br><span class="line">                <span class="keyword">while</span> (rightEdge &lt; N &amp;&amp; x[rightEdge] - x[rightCenter] &lt;= range)&#123;</span><br><span class="line">                    rightEdge++;</span><br><span class="line">                &#125;</span><br><span class="line">                rightEdge = rightEdge-<span class="number">1</span>;</span><br><span class="line">                res += hp[i];</span><br><span class="line">                AoeBlood(hp,i,rightEdge,hp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AoeBlood</span><span class="params">(<span class="keyword">int</span>[] hp,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hp[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                hp[i] = hp[i] - num &gt; <span class="number">0</span> ? hp[i] - num  : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//方法二：因为涉及到区间删除，所以可以用线段树优化成O(N*logN)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] sum;</span><br><span class="line">        <span class="keyword">int</span>[] data;</span><br><span class="line">        <span class="keyword">int</span>[] lazy;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(<span class="keyword">int</span>[] x)</span> </span>&#123;</span><br><span class="line">            data = Arrays.copyOfRange(x, <span class="number">0</span>, x.length);</span><br><span class="line">            sum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span> * x.length];</span><br><span class="line">            lazy =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span> * x.length];</span><br><span class="line">            build(<span class="number">1</span>,<span class="number">0</span>,x.length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            lazy[index&lt;&lt;<span class="number">1</span>] += lazy[index];</span><br><span class="line">            lazy[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] += lazy[index];</span><br><span class="line">            sum[index&lt;&lt;<span class="number">1</span>] +=  (mid-l+<span class="number">1</span>)*lazy[index];</span><br><span class="line">            sum[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] +=  (r-mid)*lazy[index];</span><br><span class="line">            lazy[index] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">                sum[index] = data[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            build(index&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">            build((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">            sum[index] = sum[index&lt;&lt;<span class="number">1</span>] + sum[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l == L &amp;&amp; r ==R)&#123;</span><br><span class="line">                <span class="keyword">return</span> sum[index];</span><br><span class="line">            &#125;</span><br><span class="line">            pushDown(index,l,r);</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(R &lt;= mid)</span><br><span class="line">                <span class="keyword">return</span> query(index&lt;&lt;<span class="number">1</span>,l,mid,L,R);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(L &gt;= mid+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> query((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> query(index&lt;&lt;<span class="number">1</span>,l,mid,L,mid) + query((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> elem)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l == L &amp;&amp; r == R)&#123;</span><br><span class="line">                lazy[index] += elem;</span><br><span class="line">                sum[index] += elem * (r-l+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(R &lt;= mid)</span><br><span class="line">                add(index&lt;&lt;<span class="number">1</span>,l,mid,L,R,elem);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(L &gt;= mid+<span class="number">1</span>)</span><br><span class="line">                add((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R,elem);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                add(index&lt;&lt;<span class="number">1</span>,l,mid,L,mid,elem);</span><br><span class="line">                add((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,R,elem);</span><br><span class="line">            &#125;</span><br><span class="line">            sum[index] = sum[index&lt;&lt;<span class="number">1</span>] + sum[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinAoe2</span><span class="params">(<span class="keyword">int</span>[] x,<span class="keyword">int</span>[] hp,<span class="keyword">int</span> range)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> SegmentTree seg = <span class="keyword">new</span> SegmentTree(hp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> cur_hp = seg.query(<span class="number">1</span>, <span class="number">0</span>, x.length - <span class="number">1</span>, i, i);</span><br><span class="line">            <span class="keyword">if</span>(cur_hp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> center = i;</span><br><span class="line">                <span class="keyword">int</span> right = i;</span><br><span class="line">                <span class="keyword">while</span> (center &lt; x.length &amp;&amp; x[center]-x[i] &lt;= range) center++;</span><br><span class="line">                center--;</span><br><span class="line">                <span class="keyword">while</span> (right &lt; x.length &amp;&amp; x[right] - x[center] &lt;= range) right++;</span><br><span class="line">                right--;</span><br><span class="line">                seg.add(<span class="number">1</span>,<span class="number">0</span>,x.length-<span class="number">1</span>,i,right,-cur_hp);</span><br><span class="line">                res+= cur_hp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Greed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 4 最少交换次数</title>
      <link href="/2020/07/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-13-Problem-4-%E6%9C%80%E5%B0%91%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0/"/>
      <url>/2020/07/13/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-13-Problem-4-%E6%9C%80%E5%B0%91%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    一个数组中只有两种字符’G’和’B’，可以让所有的G都放在左侧，所有的B都放在右侧 或者可以让所有的G都放在右侧，所有的B都放在左侧但是只能在相邻字符之间进行交换操作，返回至少需要交换几次</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题其实很简单，就是怕被说辞给吓住了，G在左侧，因为是最少的交换，所以一定从左侧开始让G移动。这样求的G在左侧的最少移动次数。同理，求的B在左侧的最少移动次数，也就是G在右侧，比较这两种情况</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以让G在左，或者在右</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minSteps2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.equals(<span class="string">""</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> step1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> step2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> gi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">'G'</span>) &#123; <span class="comment">// 当前的G，去左边   方案1</span></span><br><span class="line">step1 += i - (gi++);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 当前的B，去左边   方案2</span></span><br><span class="line">step2 += i - (bi++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.min(step1, step2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Greed </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 3 2的某次幂</title>
      <link href="/2020/07/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-12-Problem-3-2%E7%9A%84%E6%9F%90%E6%AC%A1%E5%B9%82/"/>
      <url>/2020/07/12/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-12-Problem-3-2%E7%9A%84%E6%9F%90%E6%AC%A1%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个非负整数num，如何不用循环语句，返回&gt;=num，并且离num最近的，2的某次方。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><p>考察位运算，不太好想。比如求<code>00001010</code>，求比它大的2的某次方,应该是<code>0010000</code>,实际上就是<code>00001111</code>加1，也就是说我们把原数最左侧的1的位置，右面全部变成1得到的就是答案。利用位运算，比如<code>00100000</code>,</p><ul><li>右移1次与原数或可得<code>00110000</code></li><li>再右移2次与原数或可得<code>00111100</code></li><li>再右移4次与原数或可得<code>00111111</code></li></ul><p>如果是<code>10000000</code>，经过上述的3步，也一定能变成<code>11111111</code>,所以对于int类型32位，我们按照上述步骤操作5次，不管原数是多大，一定能变成第一个1右侧全部是1的数字</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">n--;         <span class="comment">//特殊处理防止原数是2的某次幂，方便后续的统一处理</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"><span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 2 统计文件数量</title>
      <link href="/2020/07/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-08-Problem-2-%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%95%B0%E9%87%8F/"/>
      <url>/2020/07/08/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-08-Problem-2-%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>​    给定一个文件目录的路径，写一个函数统计这个目录下所有的文件数量并返回，隐藏文件也算，但是文件夹不算。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目说的很清楚了，考的就是一个简单的递归，使用一下文件相关的api即可。 </li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这个函数也会统计隐藏文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFileNumber</span><span class="params">(String folderPath)</span> </span>&#123;</span><br><span class="line">File root = <span class="keyword">new</span> File(folderPath);</span><br><span class="line"><span class="keyword">if</span> (!root.isDirectory() &amp;&amp; !root.isFile()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root.isFile()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Stack&lt;File&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">stack.add(root);</span><br><span class="line"><span class="keyword">int</span> files = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">File folder = stack.pop();</span><br><span class="line"><span class="keyword">for</span> (File next : folder.listFiles()) &#123;</span><br><span class="line"><span class="keyword">if</span> (next.isFile()) &#123;</span><br><span class="line">files++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (next.isDirectory()) &#123;</span><br><span class="line">stack.push(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Problem 1 绳子压点问题</title>
      <link href="/2020/07/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-05-Problem-1-%E7%BB%B3%E5%AD%90%E5%8E%8B%E7%82%B9%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/05/%E4%BC%81%E4%B8%9A%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98-2020-07-05-Problem-1-%E7%BB%B3%E5%AD%90%E5%8E%8B%E7%82%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个有序数组arr，代表坐落在X轴上的点，给定一个正数K，代表绳子的长度<br>返回绳子最多压中几个点？<br>注意：即使绳子边缘处盖住点也算盖住。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>有一个比较容易想到的思路就是把绳子看成长度固定的滑动窗口就可以了，依次遍历每个点作为绳子左端点的情况下 能压住几个点即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoint</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> N = arr.length;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; N) &#123;</span><br><span class="line"><span class="keyword">while</span> (right &lt; N &amp;&amp; arr[right] - arr[left] &lt;= L) &#123;  <span class="comment">//扩展窗口，扫描绳子长度内的点</span></span><br><span class="line">right++;</span><br><span class="line">&#125;</span><br><span class="line">max = Math.max(max, right - (left++));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 企业面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>412. Fizz Buzz </title>
      <link href="/2018/11/11/leetcode-leetcodetest-2018-11-11-412-Fizz-Buzz/"/>
      <url>/2018/11/11/leetcode-leetcodetest-2018-11-11-412-Fizz-Buzz/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/fizz-buzz/" target="_blank" rel="noopener">https://leetcode.com/problems/fizz-buzz/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em>a string array</em> <code>answer</code> <em>(<strong>1-indexed</strong>) where</em>:</p><ul><li><code>answer[i] == &quot;FizzBuzz&quot;</code> if <code>i</code> is divisible by <code>3</code> and <code>5</code>.</li><li><code>answer[i] == &quot;Fizz&quot;</code> if <code>i</code> is divisible by <code>3</code>.</li><li><code>answer[i] == &quot;Buzz&quot;</code> if <code>i</code> is divisible by <code>5</code>.</li><li><code>answer[i] == i</code> (as a string) if none of the above conditions are true.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 5</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 15</span><br><span class="line">Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;7&quot;,&quot;8&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;11&quot;,&quot;Fizz&quot;,&quot;13&quot;,&quot;14&quot;,&quot;FizzBuzz&quot;]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>考察会不会编程</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">3</span>==<span class="number">0</span> &amp;&amp; (i+<span class="number">1</span>) %<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(<span class="string">"Fizz"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(<span class="string">"Buzz"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                list.add((i+<span class="number">1</span>)+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>395. Longest Substring with At Least K Repeating Characters</title>
      <link href="/2018/11/11/leetcode-leetcodetest-2018-11-11-395-Longest-Substring-with-At-Least-K-Repeating-Characters/"/>
      <url>/2018/11/11/leetcode-leetcodetest-2018-11-11-395-Longest-Substring-with-At-Least-K-Repeating-Characters/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> and an integer <code>k</code>, return <em>the length of the longest substring of</em> <code>s</code> <em>such that the frequency of each character in this substring is greater than or equal to</em> <code>k</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aaabb&quot;, k &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest substring is &quot;aaa&quot;, as &#39;a&#39; is repeated 3 times.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ababbc&quot;, k &#x3D; 2</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest substring is &quot;ababb&quot;, as &#39;a&#39; is repeated 2 times and &#39;b&#39; is repeated 3 times.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> consists of only lowercase English letters.</li><li><code>1 &lt;= k &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>乍一看 特像滑动窗口对吧，直接用，一会发现，窗口结束不了，比如说，L =  0，R取扫描，对于abbbcccdefg    k =2的情况，明明只要L=1，R = 6位置就能得到答案的，结果R = 6，不满足条件啊，因为a还不够2啊，所以R 继续扫，又引入了新的字符，永远满足不了条件！</li><li>这个窗口不能直接用，就是因为你会不断的引入新字符，你得给认为的中断！比如讲，每次用窗口，认为的规定字符种类就必须是2种，那么遇到c的时候 L必须前移！</li><li>好好体会这道 窗口不能直接用的题目！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">//<span class="doctag">TODO:</span>做的还是慢</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">26</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">           <span class="keyword">int</span> kind = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (p1 &lt; chars.length)&#123;</span><br><span class="line">               <span class="keyword">while</span> (p2 &lt; chars.length)&#123;</span><br><span class="line">                   <span class="keyword">int</span> expect = chars[p2]-<span class="string">'a'</span>;</span><br><span class="line">                   <span class="keyword">if</span>(visited[expect] == <span class="number">0</span>)&#123;</span><br><span class="line">                       <span class="keyword">if</span>(kind+<span class="number">1</span> &gt; i)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                       kind++;</span><br><span class="line">                       set.add(expect);</span><br><span class="line">                   &#125;</span><br><span class="line">                   visited[expect]++;</span><br><span class="line">                   p2++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(kind == i)&#123;</span><br><span class="line">                   <span class="keyword">final</span> Iterator&lt;Integer&gt; iterator = set.iterator();</span><br><span class="line">                   <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                       <span class="keyword">final</span> Integer next = iterator.next();</span><br><span class="line">                       <span class="keyword">if</span>(visited[next] &lt; k)&#123;</span><br><span class="line">                           flag = <span class="keyword">false</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                       res = Math.max(res,p2-p1);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(--visited[chars[p1]-<span class="string">'a'</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                   kind--;</span><br><span class="line">                   set.remove(chars[p1]-<span class="string">'a'</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               p1++;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>387. First Unique Character in a String</title>
      <link href="/2018/11/11/leetcode-leetcodetest-2018-11-11-387-First-Unique-Character-in-a-String/"/>
      <url>/2018/11/11/leetcode-leetcodetest-2018-11-11-387-First-Unique-Character-in-a-String/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">https://leetcode.com/problems/first-unique-character-in-a-string/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code>, <em>find the first non-repeating character in it and return its index</em>. If it does not exist, return <code>-1</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcode&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;loveleetcode&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aabb&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s</code> consists of only lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>无</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            map[chars[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[chars[i]] == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>384. Shuffle an Array</title>
      <link href="/2018/11/11/leetcode-leetcodetest-2018-11-11-384-Shuffle-an-Array/"/>
      <url>/2018/11/11/leetcode-leetcodetest-2018-11-11-384-Shuffle-an-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/shuffle-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/shuffle-an-array/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, design an algorithm to randomly shuffle the array. All permutations of the array should be <strong>equally likely</strong> as a result of the shuffling.</p><p>Implement the <code>Solution</code> class:</p><ul><li><code>Solution(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li><li><code>int[] reset()</code> Resets the array to its original configuration and returns it.</li><li><code>int[] shuffle()</code> Returns a random shuffling of the array.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;, &quot;shuffle&quot;, &quot;reset&quot;, &quot;shuffle&quot;]</span><br><span class="line">[[[1, 2, 3]], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Solution solution &#x3D; new Solution([1, 2, 3]);</span><br><span class="line">solution.shuffle();    &#x2F;&#x2F; Shuffle the array [1,2,3] and return its result.</span><br><span class="line">                       &#x2F;&#x2F; Any permutation of [1,2,3] must be equally likely to be returned.</span><br><span class="line">                       &#x2F;&#x2F; Example: return [3, 1, 2]</span><br><span class="line">solution.reset();      &#x2F;&#x2F; Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]</span><br><span class="line">solution.shuffle();    &#x2F;&#x2F; Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 50</code></li><li><code>-106 &lt;= nums[i] &lt;= 106</code></li><li>All the elements of <code>nums</code> are <strong>unique</strong>.</li><li>At most <code>104</code> calls <strong>in total</strong> will be made to <code>reset</code> and <code>shuffle</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>利用随机交换就可以，注意踩坑.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cap;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        cap = Arrays.copyOf(nums, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(cap,cap.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] t = Arrays.copyOf(cap, cap.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t.length-<span class="number">1</span>; i&gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> loc = random.nextInt(i+<span class="number">1</span>);<span class="comment">//  踩坑</span></span><br><span class="line">            swap(t,i,loc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * int[] param_1 = obj.reset();</span></span><br><span class="line"><span class="comment"> * int[] param_2 = obj.shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>380. Insert Delete GetRandom O(1)</title>
      <link href="/2018/11/11/leetcode-leetcodetest-2018-11-11-380-Insert-Delete-GetRandom-O-1/"/>
      <url>/2018/11/11/leetcode-leetcodetest-2018-11-11-380-Insert-Delete-GetRandom-O-1/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="noopener">https://leetcode.com/problems/insert-delete-getrandom-o1/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement the <code>RandomizedSet</code> class:</p><ul><li><code>RandomizedSet()</code> Initializes the <code>RandomizedSet</code> object.</li><li><code>bool insert(int val)</code> Inserts an item <code>val</code> into the set if not present. Returns <code>true</code> if the item was not present, <code>false</code> otherwise.</li><li><code>bool remove(int val)</code> Removes an item <code>val</code> from the set if present. Returns <code>true</code> if the item was present, <code>false</code> otherwise.</li><li><code>int getRandom()</code> Returns a random element from the current set of elements (it’s guaranteed that at least one element exists when this method is called). Each element must have the <strong>same probability</strong> of being returned.</li></ul><p>You must implement the functions of the class such that each function works in <strong>average</strong> <code>O(1)</code> time complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">Output</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">RandomizedSet randomizedSet &#x3D; new RandomizedSet();</span><br><span class="line">randomizedSet.insert(1); &#x2F;&#x2F; Inserts 1 to the set. Returns true as 1 was inserted successfully.</span><br><span class="line">randomizedSet.remove(2); &#x2F;&#x2F; Returns false as 2 does not exist in the set.</span><br><span class="line">randomizedSet.insert(2); &#x2F;&#x2F; Inserts 2 to the set, returns true. Set now contains [1,2].</span><br><span class="line">randomizedSet.getRandom(); &#x2F;&#x2F; getRandom() should return either 1 or 2 randomly.</span><br><span class="line">randomizedSet.remove(1); &#x2F;&#x2F; Removes 1 from the set, returns true. Set now contains [2].</span><br><span class="line">randomizedSet.insert(2); &#x2F;&#x2F; 2 was already in the set, so return false.</span><br><span class="line">randomizedSet.getRandom(); &#x2F;&#x2F; Since 2 is the only number in the set, getRandom() will always return 2.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li>At most <code>2 * ``105</code> calls will be made to <code>insert</code>, <code>remove</code>, and <code>getRandom</code>.</li><li>There will be <strong>at least one</strong> element in the data structure when <code>getRandom</code> is called.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>数据结构题目，要求每个操作都是O(1)的，主要是删除操作，删掉之后就不连续了呀，那取随机值的时候，取到空就麻烦了，可以做一个映射表，记录索引，这时候就可以用交换操作代替直接删除，注意更新映射表，很有用的小技巧。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*<span class="number">100005</span>];</span><br><span class="line">     Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(val) != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        num[size++] = val;</span><br><span class="line">        map.put(val,size-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Integer loc = map.get(val);</span><br><span class="line">        <span class="keyword">if</span>(loc == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        map.remove(val);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (loc == size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(num,loc,size);</span><br><span class="line">        map.put(num[loc],loc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i = random.nextInt(size);</span><br><span class="line">        <span class="keyword">return</span> num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>454. 4Sum II</title>
      <link href="/2018/11/11/leetcode-leetcodetest-2018-11-11-454-4Sum-II/"/>
      <url>/2018/11/11/leetcode-leetcodetest-2018-11-11-454-4Sum-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/4sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/4sum-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The two tuples are:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [0], nums2 &#x3D; [0], nums3 &#x3D; [0], nums4 &#x3D; [0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>n == nums3.length</code></li><li><code>n == nums4.length</code></li><li><code>1 &lt;= n &lt;= 200</code></li><li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题告诉我们 还是要学会变通，4个数和为0的组合数几种，先前两个数组组合，后两个数组组合，注意sum的种数，最后再两两组合。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.length; j++) &#123;</span><br><span class="line">sum = A[i] + B[j];</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(sum)) &#123;</span><br><span class="line">map.put(sum, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(sum, map.get(sum) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D.length; j++) &#123;</span><br><span class="line">sum = C[i] + D[j];</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(-sum)) &#123;</span><br><span class="line">ans += map.get(-sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>378. Kth Smallest Element in a Sorted Matrix</title>
      <link href="/2018/11/10/leetcode-leetcodetest-2018-11-10-378-Kth-Smallest-Element-in-a-Sorted-Matrix/"/>
      <url>/2018/11/10/leetcode-leetcodetest-2018-11-10-378-Kth-Smallest-Element-in-a-Sorted-Matrix/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>n x n</code> <code>matrix</code> where each of the rows and columns is sorted in ascending order, return <em>the</em> <code>kth</code> <em>smallest element in the matrix</em>.</p><p>Note that it is the <code>kth</code> smallest element <strong>in the sorted order</strong>, not the <code>kth</code> <strong>distinct</strong> element.</p><p>You must find a solution with a memory complexity better than <code>O(n2)</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,5,9],[10,11,13],[12,13,15]], k &#x3D; 8</span><br><span class="line">Output: 13</span><br><span class="line">Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[-5]], k &#x3D; 1</span><br><span class="line">Output: -5</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li><li>All the rows and columns of <code>matrix</code> are <strong>guaranteed</strong> to be sorted in <strong>non-decreasing order</strong>.</li><li><code>1 &lt;= k &lt;= n2</code></li></ul><p><strong>Follow up:</strong></p><ul><li>Could you solve the problem with a constant memory (i.e., <code>O(1)</code> memory complexity)?</li><li>Could you solve the problem in <code>O(n)</code> time complexity? The solution may be too advanced for an interview but you may find reading <a href="http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf" target="_blank" rel="noopener">this paper</a> fun.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题应用到了 之前矩阵二分那道题目的搜索过程，此外我们可以用二分去搜索可能存在的值，每次搜索都可以判断这个数值所在的至少的排名，可能会更前，只要每次都可以去掉一部分数据，最终就可以逼近到想要的数据。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> l = matrix[<span class="number">0</span>][<span class="number">0</span>],r = matrix[N-<span class="number">1</span>][N-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> real_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] res = find(matrix, mid);</span><br><span class="line">            <span class="keyword">if</span>(res[<span class="number">0</span>] == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> res[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (res[<span class="number">0</span>] &lt; k)&#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                real_num = res[<span class="number">1</span>];</span><br><span class="line">                r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> real_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] find(<span class="keyword">int</span>[][] m,<span class="keyword">double</span> num)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = m[<span class="number">0</span>].length-<span class="number">1</span>,res = <span class="number">0</span>,real_num = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m.length &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] &lt;= num)&#123;</span><br><span class="line">                real_num =Math.max(m[i][j],real_num);</span><br><span class="line">                res += j+<span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;res,real_num&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>371. Sum of Two Integers</title>
      <link href="/2018/11/10/leetcode-leetcodetest-2018-11-10-371-Sum-of-Two-Integers/"/>
      <url>/2018/11/10/leetcode-leetcodetest-2018-11-10-371-Sum-of-Two-Integers/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-of-two-integers/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integers <code>a</code> and <code>b</code>, return <em>the sum of the two integers without using the operators</em> <code>+</code> <em>and</em> <code>-</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 1, b &#x3D; 2</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a &#x3D; 2, b &#x3D; 3</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-1000 &lt;= a, b &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>利用位运算做加法，其实很简单，你只要利用好真值表，表示出对应和的位运算操作，进位的位元算操作，就有了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>,elem1 = <span class="number">0</span>,elem2 = <span class="number">0</span>,jie = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">            elem1 = (a &gt;&gt; i)&amp;<span class="number">1</span>;</span><br><span class="line">            elem2 = (b &gt;&gt; i)&amp;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = elem1 ^ elem2 ^ jie; <span class="comment">//当前位</span></span><br><span class="line">            jie =jie&amp;(elem1^elem2)|elem1&amp;elem2;</span><br><span class="line">            res |= (t&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>350. Intersection of Two Arrays II</title>
      <link href="/2018/11/10/leetcode-leetcodetest-2018-11-10-350-Intersection-of-Two-Arrays-II/"/>
      <url>/2018/11/10/leetcode-leetcodetest-2018-11-10-350-Intersection-of-Two-Arrays-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-arrays-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must appear as many times as it shows in both arrays and you may return the result in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">Output: [2,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">Output: [4,9]</span><br><span class="line">Explanation: [9,4] is also accepted.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目简单，但是可以学到东西，看下数值范围，拿数组存下，再次遍历只要数组元素大于0，就统计，统计完记得减掉一个 。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1005</span>];</span><br><span class="line">            <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> elem : nums1) &#123;</span><br><span class="line">              map[elem]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> elem : nums2) &#123;</span><br><span class="line">               <span class="keyword">if</span>(map[elem]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                   res[cnt++] = elem;</span><br><span class="line">                   map[elem]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(res,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>347. Top K Frequent Elements</title>
      <link href="/2018/11/09/leetcode-leetcodetest-2018-11-09-347-Top-K-Frequent-Elements/"/>
      <url>/2018/11/09/leetcode-leetcodetest-2018-11-09-347-Top-K-Frequent-Elements/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">https://leetcode.com/problems/top-k-frequent-elements/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1], k &#x3D; 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li><li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>主要考察堆的典型Top K应用</li><li>先统计词频（小知识点），然后维护一个K的最小堆。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">num = k;</span><br><span class="line">count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1.count - o2.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">HashMap&lt;Integer, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(num)) &#123;</span><br><span class="line">map.put(num, <span class="keyword">new</span> Node(num));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.get(num).count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> CountComparator());</span><br><span class="line"><span class="keyword">for</span> (Node node : map.values()) &#123;</span><br><span class="line"><span class="keyword">if</span> (heap.size() &lt; k || (heap.size() == k &amp;&amp; node.count &gt; heap.peek().count)) &#123;</span><br><span class="line">heap.add(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">heap.poll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">ans[index++] = heap.poll().num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Heap </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>344. Reverse String</title>
      <link href="/2018/11/09/leetcode-leetcodetest-2018-11-09-344-Reverse-String/"/>
      <url>/2018/11/09/leetcode-leetcodetest-2018-11-09-344-Reverse-String/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/reverse-string/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-string/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p><p>You must do this by modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a> with <code>O(1)</code> extra memory.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>无</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = s[i];</span><br><span class="line">            s[i] = s[s.length-<span class="number">1</span>-i];</span><br><span class="line">            s[s.length-<span class="number">1</span>-i] = (<span class="keyword">char</span>)t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>341. Flatten Nested List Iterator</title>
      <link href="/2018/11/09/leetcode-leetcodetest-2018-11-09-341-Flatten-Nested-List-Iterator/"/>
      <url>/2018/11/09/leetcode-leetcodetest-2018-11-09-341-Flatten-Nested-List-Iterator/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>334. Increasing Triplet Subsequence</title>
      <link href="/2018/11/09/leetcode-leetcodetest-2018-11-09-334-Increasing-Triplet-Subsequence/"/>
      <url>/2018/11/09/leetcode-leetcodetest-2018-11-09-334-Increasing-Triplet-Subsequence/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/increasing-triplet-subsequence/" target="_blank" rel="noopener">https://leetcode.com/problems/increasing-triplet-subsequence/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, return <code>true</code> <em>if there exists a triple of indices</em> <code>(i, j, k)</code> <em>such that</em> <code>i &lt; j &lt; k</code> <em>and</em> <code>nums[i] &lt; nums[j] &lt; nums[k]</code>. If no such indices exists, return <code>false</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Any triplet where i &lt; j &lt; k is valid.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,4,3,2,1]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: No triplet exists.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,1,5,0,4,6]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The triplet (3, 4, 5) is valid because nums[3] &#x3D;&#x3D; 0 &lt; nums[4] &#x3D;&#x3D; 4 &lt; nums[5] &#x3D;&#x3D; 6.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题其实就是再问存不存在长度&gt;=3的递增子序列。首先普通dp方法是O(N^2)的肯定过不了。</li><li>使用end数组，这个在优化最长递增子序列问题时时O(N*logN),大概思路时 使用end数组,end[i]代表长度为i+1的最长递增子序列结尾的最小值，那么只要i推到2时候，就满足条件了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">//end[i] 代表 长度为i+1的子序列结尾的最小值</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = binarySearch(end, nums[i], c); <span class="comment">//c代表长度</span></span><br><span class="line">            <span class="keyword">if</span>(index == c) &#123; <span class="comment">//说明没找到，应该扩展</span></span><br><span class="line">                end[c++] = nums[i];</span><br><span class="line">                <span class="keyword">if</span>(c &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                end[index] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] end,<span class="keyword">int</span> x,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = t-<span class="number">1</span>,index = t;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(end[mid] &gt;= x)&#123;</span><br><span class="line">                index = mid;</span><br><span class="line">                r = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>329. Longest Increasing Path in a Matrix</title>
      <link href="/2018/11/07/leetcode-leetcodetest-2018-11-07-329-Longest-Increasing-Path-in-a-Matrix/"/>
      <url>/2018/11/07/leetcode-leetcodetest-2018-11-07-329-Longest-Increasing-Path-in-a-Matrix/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​     <a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-increasing-path-in-a-matrix/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> integers <code>matrix</code>, return <em>the length of the longest increasing path in</em> <code>matrix</code>.</p><p>From each cell, you can either move in four directions: left, right, up, or down. You <strong>may not</strong> move <strong>diagonally</strong> or move <strong>outside the boundary</strong> (i.e., wrap-around is not allowed).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[9,9,4],[6,6,8],[2,1,1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing path is [1, 2, 6, 9].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[3,4,5],[3,2,6],[2,2,1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= matrix[i][j] &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>遍历一下，配合上缓存，查找最长的路径即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dirx = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] diry = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> maxn = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; matrix[<span class="number">0</span>].length; i1++) &#123;</span><br><span class="line">                maxn = Math.max(maxn,process(matrix,i,i1,-<span class="number">1</span>, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> elem,<span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= matrix.length || j &lt; <span class="number">0</span> || j &gt;= matrix[<span class="number">0</span>].length||matrix[i][j] &lt;= elem) &#123; <span class="comment">//越界</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">4</span>;d++)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = process(matrix,i+dirx[d],j+diry[d],matrix[i][j],dp);</span><br><span class="line">                res = Math.max(t+<span class="number">1</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>328. Odd Even Linked List</title>
      <link href="/2018/11/06/leetcode-leetcodetest-2018-11-06-328-Odd-Even-Linked-List/"/>
      <url>/2018/11/06/leetcode-leetcodetest-2018-11-06-328-Odd-Even-Linked-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/odd-even-linked-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return <em>the reordered list</em>.</p><p>The <strong>first</strong> node is considered <strong>odd</strong>, and the <strong>second</strong> node is <strong>even</strong>, and so on.</p><p>Note that the relative order inside both the even and odd groups should remain as it was in the input.</p><p>You must solve the problem in <code>O(1)</code> extra space complexity and <code>O(n)</code> time complexity.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: [1,3,5,2,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [2,1,3,5,6,4,7]</span><br><span class="line">Output: [2,3,6,7,1,5,4]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the linked list is in the range <code>[0, 104]</code>.</li><li><code>-106 &lt;= Node.val &lt;= 106</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是遍历一趟把奇数的节点和偶数的节点分成两个链表</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next == <span class="keyword">null</span> || head.next.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode odd = head;</span><br><span class="line">        ListNode even_head = head.next;</span><br><span class="line">        ListNode even = head.next;</span><br><span class="line">        ListNode cur = even.next;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((step&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                odd.next = cur;</span><br><span class="line">                odd = odd.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                even.next = cur;</span><br><span class="line">                even = even.next;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">            cur= cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">       odd.next = even_head;</span><br><span class="line">        even.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>326. Power of Three</title>
      <link href="/2018/11/04/leetcode-leetcodetest-2018-11-04-326-Power-of-Three/"/>
      <url>/2018/11/04/leetcode-leetcodetest-2018-11-04-326-Power-of-Three/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/power-of-three/" target="_blank" rel="noopener">https://leetcode.com/problems/power-of-three/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em><code>true</code> if it is a power of three. Otherwise, return <code>false</code></em>.</p><p>An integer <code>n</code> is a power of three, if there exists an integer <code>x</code> such that <code>n == 3x</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 27</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 0</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 9</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= n &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>可以简单的模拟，也可以用打表法，打出在int范围内，3^x的最大值，那么只要被n整除，n就是3的某次方</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>324. Wiggle Sort II</title>
      <link href="/2018/11/04/leetcode-leetcodetest-2018-11-04-324-Wiggle-Sort-II/"/>
      <url>/2018/11/04/leetcode-leetcodetest-2018-11-04-324-Wiggle-Sort-II/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>322. Coin Change</title>
      <link href="/2018/11/01/leetcode-leetcodetest-2018-11-01-322-Coin-Change/"/>
      <url>/2018/11/01/leetcode-leetcodetest-2018-11-01-322-Coin-Change/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">https://leetcode.com/problems/coin-change/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p><p>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p><p>You may assume that you have an infinite number of each kind of coin.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [1,2,5], amount &#x3D; 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [1], amount &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>典型的DP。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = coins.length;</span><br><span class="line">        <span class="keyword">int</span> N = amount;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[M+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;i++) dp[M][i] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = M-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= N;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span>(j-coins[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i][j-coins[i]] != Integer.MAX_VALUE)&#123;</span><br><span class="line">                    p1 =  dp[i][j-coins[i]]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> p2 = dp[i+<span class="number">1</span>][j];</span><br><span class="line">                dp[i][j] = Math.min(p1,p2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][N]==Integer.MAX_VALUE ? -<span class="number">1</span>:dp[<span class="number">0</span>][N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>315. Count of Smaller Numbers After Self</title>
      <link href="/2018/10/29/leetcode-leetcodetest-2018-10-29-315-Count-of-Smaller-Numbers-After-Self/"/>
      <url>/2018/10/29/leetcode-leetcodetest-2018-10-29-315-Count-of-Smaller-Numbers-After-Self/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">https://leetcode.com/problems/count-of-smaller-numbers-after-self/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>nums</code> and you have to return a new <code>counts</code> array. The <code>counts</code> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,2,6,1]</span><br><span class="line">Output: [2,1,1,0]</span><br><span class="line">Explanation:</span><br><span class="line">To the right of 5 there are 2 smaller elements (2 and 1).</span><br><span class="line">To the right of 2 there is only 1 smaller element (1).</span><br><span class="line">To the right of 6 there is 1 smaller element (1).</span><br><span class="line">To the right of 1 there is 0 smaller element.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,-1]</span><br><span class="line">Output: [0,0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>愚蠢了，没反应过来，一开始看成了，在他后面是第几小元素，实际人家问的是后面有几个比它小的，典型的逆序对，用归并排序去解决 。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeInfo</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeInfo</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"NodeInfo&#123;"</span> +</span><br><span class="line">                    <span class="string">"value="</span> + value +</span><br><span class="line">                    <span class="string">", index="</span> + index +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        NodeInfo[] nodes = <span class="keyword">new</span> NodeInfo[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nodes[i] = <span class="keyword">new</span> NodeInfo(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) list.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt; <span class="number">1</span>) <span class="keyword">return</span> list;</span><br><span class="line">        process(nodes,<span class="number">0</span>,nodes.length-<span class="number">1</span>,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(NodeInfo[] num,<span class="keyword">int</span> l,<span class="keyword">int</span> r,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        process(num,l,mid,list);</span><br><span class="line">        process(num,mid+<span class="number">1</span>,r,list);</span><br><span class="line">        merge(num,l,r,list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(NodeInfo[] num, <span class="keyword">int</span> l , <span class="keyword">int</span> r, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> NodeInfo[] t = <span class="keyword">new</span> NodeInfo[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = l,p2 = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[p2].value &gt;= num[p1].value)&#123;</span><br><span class="line">                list.set(num[p1].index,list.get(num[p1].index)+p2-mid-<span class="number">1</span>);</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid)&#123;</span><br><span class="line">            list.set(num[p1].index,list.get(num[p1].index)+r-mid);</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = l;</span><br><span class="line">        p2 = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[p1].value &lt; num[p2].value)&#123;</span><br><span class="line">                t[c++] = num[p1++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t[c++] = num[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= mid ) t[c++] = num[p1++];</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= r )   t[c++] = num[p2++];</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= r;i++)&#123;</span><br><span class="line">            num[i] = t[c++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Merge Sort </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>300. Longest Increasing Subsequence</title>
      <link href="/2018/10/28/leetcode-leetcodetest-2018-10-28-300-Longest-Increasing-Subsequence/"/>
      <url>/2018/10/28/leetcode-leetcodetest-2018-10-28-300-Longest-Increasing-Subsequence/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>297. Serialize and Deserialize Binary Tree</title>
      <link href="/2018/10/28/leetcode-leetcodetest-2018-10-28-297-Serialize-and-Deserialize-Binary-Tree/"/>
      <url>/2018/10/28/leetcode-leetcodetest-2018-10-28-297-Serialize-and-Deserialize-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/serialize-and-deserialize-binary-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p><strong>Clarification:</strong> The input/output format is the same as <a href="https://leetcode.com/faq/#binary-tree" target="_blank" rel="noopener">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,null,null,4,5]</span><br><span class="line">Output: [1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 104]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题目解"><a href="#题目解" class="headerlink" title="题目解"></a>题目解</h3><ul><li>树的序列化与反序列化，把null值用一个特殊符号代替即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        process(root,builder);</span><br><span class="line">        <span class="keyword">final</span> String str = builder.toString();</span><br><span class="line">        <span class="keyword">return</span> str.substring(<span class="number">0</span>,str.length()-<span class="number">1</span>); <span class="comment">//去掉最后一个#</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(TreeNode root,StringBuilder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            builder.append(<span class="string">"*#"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        builder.append(root.val+<span class="string">"#"</span>);</span><br><span class="line">        process(root.left,builder);</span><br><span class="line">        process(root.right,builder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">""</span>.equals(data)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> String[] split = data.split(<span class="string">"#"</span>);</span><br><span class="line">        step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> unprocess(split);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">unprocess</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs[step].equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> num = Integer.parseInt(strs[step++]);</span><br><span class="line">            <span class="keyword">final</span> TreeNode cur = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">            cur.left = unprocess(strs);</span><br><span class="line">            cur.right = unprocess(strs);</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>295. Find Median from Data Stream</title>
      <link href="/2018/10/28/leetcode-leetcodetest-2018-10-28-295-Find-Median-from-Data-Stream/"/>
      <url>/2018/10/28/leetcode-leetcodetest-2018-10-28-295-Find-Median-from-Data-Stream/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">https://leetcode.com/problems/find-median-from-data-stream/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.</p><ul><li>For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.</li><li>For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li></ul><p>Implement the MedianFinder class:</p><ul><li><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.</li><li><code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.</li><li><code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10-5</code> of the actual answer will be accepted.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 1.5, null, 2.0]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MedianFinder medianFinder &#x3D; new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    &#x2F;&#x2F; arr &#x3D; [1]</span><br><span class="line">medianFinder.addNum(2);    &#x2F;&#x2F; arr &#x3D; [1, 2]</span><br><span class="line">medianFinder.findMedian(); &#x2F;&#x2F; return 1.5 (i.e., (1 + 2) &#x2F; 2)</span><br><span class="line">medianFinder.addNum(3);    &#x2F;&#x2F; arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); &#x2F;&#x2F; return 2.0</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-105 &lt;= num &lt;= 105</code></li><li>There will be at least one element in the data structure before calling <code>findMedian</code>.</li><li>At most <code>5 * 104</code> calls will be made to <code>addNum</code> and <code>findMedian</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>要求没输入一个数输出此前所有元素中的中位数，如果是偶数个元素，输出中间两个元素的平均值。</li><li>可以用BST，存下元素以及元素的个数、左子树的个数、右子树的个数，这样我们每次log级别的插入元素时候，是可以顺表数出来中位数的，But，BST最差会成链，所以还得改成AVL这种动态平衡的，那这个题就比较麻烦了，实际上我们只要最中间的两个数。</li><li>可以用堆，一个最大堆，保留前一半的数，一个最小堆保留后面的数。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span>  Queue&lt;Integer&gt; pre = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((a,b)-&gt;b-a);</span><br><span class="line">    <span class="keyword">public</span> Queue&lt;Integer&gt; post = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.isEmpty())&#123;</span><br><span class="line">            pre.add(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; pre.peek())&#123;</span><br><span class="line">            post.add(num);</span><br><span class="line">            <span class="keyword">if</span> (post.size() - pre.size() &gt; <span class="number">1</span>)</span><br><span class="line">                pre.add(post.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.add(num);</span><br><span class="line">            <span class="keyword">if</span> (pre.size() - post.size() &gt; <span class="number">1</span>)</span><br><span class="line">                post.add(pre.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.size() == post.size()) <span class="keyword">return</span> (pre.peek() + post.peek())*<span class="number">1.0</span>/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pre.size() &gt; post.size() ? pre.peek() : post.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Heap </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>289. Game of Life</title>
      <link href="/2018/10/28/leetcode-leetcodetest-2018-10-28-289-Game-of-Life/"/>
      <url>/2018/10/28/leetcode-leetcodetest-2018-10-28-289-Game-of-Life/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener">https://leetcode.com/problems/game-of-life/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    According to <a href="https://en.wikipedia.org/wiki/Conway&#39;s_Game_of_Life" target="_blank" rel="noopener">Wikipedia’s article</a>: “The <strong>Game of Life</strong>, also known simply as <strong>Life</strong>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p><p>The board is made up of an <code>m x n</code> grid of cells, where each cell has an initial state: <strong>live</strong> (represented by a <code>1</code>) or <strong>dead</strong> (represented by a <code>0</code>). Each cell interacts with its <a href="https://en.wikipedia.org/wiki/Moore_neighborhood" target="_blank" rel="noopener">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p><ol><li>Any live cell with fewer than two live neighbors dies as if caused by under-population.</li><li>Any live cell with two or three live neighbors lives on to the next generation.</li><li>Any live cell with more than three live neighbors dies, as if by over-population.</li><li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li></ol><p>The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the <code>m x n</code> grid <code>board</code>, return <em>the next state</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]</span><br><span class="line">Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[1,1],[1,0]]</span><br><span class="line">Output: [[1,1],[1,1]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 25</code></li><li><code>board[i][j]</code> is <code>0</code> or <code>1</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题，把题目读懂就不难，通过周围元素1的个数判断此元素的生死。</li><li>判断出此元素的生死，你还不能立即修改，因为，你该来会影响周围元素的判断呀，因为其实就是0和1代表生死，所以我们利用位元算，在权重为2的位置通过0和1来表示新状态。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        M = board.length;</span><br><span class="line">        N = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>,expect = <span class="number">0</span>; <span class="comment">//0不变，1取反</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">8</span>;d++)&#123;</span><br><span class="line">                    res +=getState(board,i+dir_x[d],j+dir_y[d]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">1</span> &amp;&amp; (res &lt;<span class="number">2</span> || res &gt; <span class="number">3</span>)) expect = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">0</span> &amp;&amp;res ==<span class="number">3</span>) expect = <span class="number">1</span>;</span><br><span class="line">                expect= (expect ^ board[i][j]);</span><br><span class="line">                board[i][j] = (expect&lt;&lt;<span class="number">1</span>)|board[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                board[i][j] &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">(<span class="keyword">int</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= M || j &lt;<span class="number">0</span> || j &gt;= N ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> board[i][j]&amp;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>287. Find the Duplicate Number</title>
      <link href="/2018/10/28/leetcode-leetcodetest-2018-10-28-287-Find-the-Duplicate-Number/"/>
      <url>/2018/10/28/leetcode-leetcodetest-2018-10-28-287-Find-the-Duplicate-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">https://leetcode.com/problems/find-the-duplicate-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.</p><p>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this repeated number</em>.</p><p>You must solve the problem <strong>without</strong> modifying the array <code>nums</code> and uses only constant extra space.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 105</code></li><li><code>nums.length == n + 1</code></li><li><code>1 &lt;= nums[i] &lt;= n</code></li><li>All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>利用数组的特性，让每个元素归位，就会找到重复元素。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[nums[i]-<span class="number">1</span>] == nums[i])</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                swap(nums,i,nums[i]-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>283. Move Zeroes</title>
      <link href="/2018/10/28/leetcode-leetcodetest-2018-10-28-283-Move-Zeroes/"/>
      <url>/2018/10/28/leetcode-leetcodetest-2018-10-28-283-Move-Zeroes/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/move-zeroes/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p><p><strong>Note</strong> that you must do this in-place without making a copy of the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>双指针交换即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p2 = <span class="number">0</span>; p2 &lt; nums.length; p2++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p2] != <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,p1++,p2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Two Pointers </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>239. Sliding Window Maximum</title>
      <link href="/2018/10/27/leetcode-leetcodetest-2018-10-27-239-Sliding-Window-Maximum/"/>
      <url>/2018/10/27/leetcode-leetcodetest-2018-10-27-239-Sliding-Window-Maximum/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>238. Product of Array Except Self</title>
      <link href="/2018/10/27/leetcode-leetcodetest-2018-10-27-238-Product-of-Array-Except-Self/"/>
      <url>/2018/10/27/leetcode-leetcodetest-2018-10-27-238-Product-of-Array-Except-Self/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">https://leetcode.com/problems/product-of-array-except-self/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.</p><p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p><p>You must write an algorithm that runs in <code>O(n)</code> time and without using the division operation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4]</span><br><span class="line">Output: [24,12,8,6]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,1,0,-3,3]</span><br><span class="line">Output: [0,0,9,0,0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目不难，我觉得这种小题就是好题，培养分析问题的思维。</li><li>提前构造一个辅助数组表示从右面的累成，然后从左遍历，保留左边的累成，这样就可以求出每个元素两边的累乘。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        suffix[nums.length-<span class="number">2</span>] = nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        suffix[nums.length-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = suffix.length-<span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            suffix[i] = suffix[i+<span class="number">1</span>] * nums[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            suffix[i] = suffix[i] * pre;</span><br><span class="line">            pre *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>237. Delete Node in a Linked List</title>
      <link href="/2018/10/27/leetcode-leetcodetest-2018-10-27-237-Delete-Node-in-a-Linked-List/"/>
      <url>/2018/10/27/leetcode-leetcodetest-2018-10-27-237-Delete-Node-in-a-Linked-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/delete-node-in-a-linked-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write a function to <strong>delete a node</strong> in a singly-linked list. You will <strong>not</strong> be given access to the <code>head</code> of the list, instead you will be given access to <strong>the node to be deleted</strong> directly.</p><p>It is <strong>guaranteed</strong> that the node to be deleted is <strong>not a tail node</strong> in the list.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/01/node1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [4,5,1,9], node &#x3D; 5</span><br><span class="line">Output: [4,1,9]</span><br><span class="line">Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/01/node2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [4,5,1,9], node &#x3D; 1</span><br><span class="line">Output: [4,5,9]</span><br><span class="line">Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of the nodes in the given list is in the range <code>[2, 1000]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li>The value of each node in the list is <strong>unique</strong>.</li><li>The <code>node</code> to be deleted is <strong>in the list</strong> and is <strong>not a tail</strong> node</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题确实有点取巧，耍小聪明来。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">          ListNode next = node.next;</span><br><span class="line">          node.val = next.val;</span><br><span class="line">          node.next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>236. Lowest Common Ancestor of a Binary Tree</title>
      <link href="/2018/10/27/leetcode-leetcodetest-2018-10-27-236-Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
      <url>/2018/10/27/leetcode-leetcodetest-2018-10-27-236-Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[2, 105]</code>.</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>All <code>Node.val</code> are <strong>unique</strong>.</li><li><code>p != q</code></li><li><code>p</code> and <code>q</code> will exist in the tree.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>最近公共祖先问题 LCA问题，也是经典的问题，简单的做法就是 求出跟几点到这个节点的路径，两条路径拿出来，再找第一个相交节点即可</li><li>高级的做法是树链剖分，这个数据结构比较复杂，专门出一章来解释，现在先用简单的做法。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> ArrayList&lt;TreeNode&gt; path1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="keyword">final</span> ArrayList&lt;TreeNode&gt; path2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          findX(path1,root,p.val);</span><br><span class="line">          findX(path2,root,q.val);</span><br><span class="line">          <span class="keyword">int</span> i = path1.size()-<span class="number">1</span>,j = path2.size() -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; path1.size() - path2.size();k++) i--;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; path2.size() - path1.size();k++) j--;</span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (;i &gt;=<span class="number">0</span>;i--,j--) <span class="keyword">if</span> (path1.get(i) == path2.get(j)) <span class="keyword">return</span> path1.get(i);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Integer <span class="title">findX</span><span class="params">(List&lt;TreeNode&gt; path,TreeNode root,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          path.add(root);</span><br><span class="line">          <span class="keyword">if</span> (root.val == t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(findX(path,root.left,t)==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(findX(path,root.right,t) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>234. Palindrome Linked List</title>
      <link href="/2018/10/27/leetcode-leetcodetest-2018-10-27-234-Palindrome-Linked-List/"/>
      <url>/2018/10/27/leetcode-leetcodetest-2018-10-27-234-Palindrome-Linked-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-linked-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a singly linked list, return <code>true</code> if it is a palindrome.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is in the range <code>[1, 105]</code>.</li><li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目就是判断链表是不是回文，你当然可以用容器存下来去判断，那这样肯定是不好的。经典的做法就是 ，找到中点或者上中点，下半段反转，两端进行遍历对比，判断完之后，给人家翻回来。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.val == head.next.val;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next; <span class="comment">//目的是上中点</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode mid = slow; <span class="comment">//slow 为 mid or up mid</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        slow = mid.next;</span><br><span class="line">        mid.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = slow.next;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        slow = pre;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( slow!= <span class="keyword">null</span> &amp;&amp; fast.val == slow.val)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> res = slow == <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//修正</span></span><br><span class="line">        slow = pre; <span class="comment">//pre在最后一个节点</span></span><br><span class="line">        pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow.next = pre;</span><br><span class="line">            pre =slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        mid.next = pre;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>279. Perfect Squares</title>
      <link href="/2018/10/27/leetcode-leetcodetest-2018-10-27-279-Perfect-Squares/"/>
      <url>/2018/10/27/leetcode-leetcodetest-2018-10-27-279-Perfect-Squares/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">https://leetcode.com/problems/perfect-squares/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em>the least number of perfect square numbers that sum to</em> <code>n</code>.</p><p>A <strong>perfect square</strong> is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, <code>1</code>, <code>4</code>, <code>9</code>, and <code>16</code> are perfect squares while <code>3</code> and <code>11</code> are not.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 12</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>首先得知道 四数定理。一个数由平方数组合，不会超过4个。</li><li>结合打表，把，1和2的打出来，判断3的，3的没有就是4个，也挺快。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashSet&lt;Integer&gt; d_set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (set.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">                set.add(i*i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i;j++)&#123;</span><br><span class="line">                    d_set.add(i*i + j*j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单个平方数</span></span><br><span class="line">        <span class="keyword">if</span>(set.contains(n)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(d_set.contains(n)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">final</span> Iterator&lt;Integer&gt; iterator = set.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                <span class="keyword">int</span> t = n - iterator.next();</span><br><span class="line">                <span class="keyword">if</span>(d_set.contains(t)) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>268. Missing Number</title>
      <link href="/2018/10/27/leetcode-leetcodetest-2018-10-27-268-Missing-Number/"/>
      <url>/2018/10/27/leetcode-leetcodetest-2018-10-27-268-Missing-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/missing-number/" target="_blank" rel="noopener">https://leetcode.com/problems/missing-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: n &#x3D; 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: n &#x3D; 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: n &#x3D; 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= n</code></li><li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>因为数据大小是有范围的，这种就可以利用桶排的思想。遍历两次即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length; <span class="comment">//期望的是0-N-1满，这样返回就是N</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            ints[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ints[i] == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>242. Valid Anagram</title>
      <link href="/2018/10/27/leetcode-leetcodetest-2018-10-27-242-Valid-Anagram/"/>
      <url>/2018/10/27/leetcode-leetcodetest-2018-10-27-242-Valid-Anagram/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-anagram/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code> <em>otherwise</em>.</p><p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li><li><code>s</code> and <code>t</code> consist of lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>比较简单了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] chars = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars2 = t.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(chars1.length != chars2.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars1.length; i++) &#123;</span><br><span class="line">            chars[chars1[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(--chars[chars2[i]-<span class="string">'a'</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>240. Search a 2D Matrix II</title>
      <link href="/2018/10/27/leetcode-leetcodetest-2018-10-27-240-Search-a-2D-Matrix-II/"/>
      <url>/2018/10/27/leetcode-leetcodetest-2018-10-27-240-Search-a-2D-Matrix-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/search-a-2d-matrix-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= n, m &lt;= 300</code></li><li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li><li>All the integers in each row are <strong>sorted</strong> in ascending order.</li><li>All the integers in each column are <strong>sorted</strong> in ascending order.</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>两个方向都是递增的，明显提示二分了，我们可以一个方向遍历，再另一个方向用二分</li><li>法一不好，没有充分利用二分特性！其实想清楚，只要在右上角，则可以不断的二分！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[M-<span class="number">1</span>][N-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == matrix[<span class="number">0</span>][<span class="number">0</span>] || target == matrix[M-<span class="number">1</span>][N-<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = M-<span class="number">1</span> ;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(binarySearch(matrix[i],target))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = num.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r- l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(num[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num[mid] &lt; target) l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num[l] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length,N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = N-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (inEdge(l,r,M,N))&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[l][r] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[l][r] &gt; target)&#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">inEdge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &gt;= <span class="number">0</span> &amp;&amp; l &lt; m &amp;&amp; r &gt;= <span class="number">0</span> &amp;&amp; r &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>230. Kth Smallest Element in a BST</title>
      <link href="/2018/10/26/leetcode-leetcodetest-2018-10-26-230-Kth-Smallest-Element-in-a-BST/"/>
      <url>/2018/10/26/leetcode-leetcodetest-2018-10-26-230-Kth-Smallest-Element-in-a-BST/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-smallest-element-in-a-bst/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>kth</code> <em>smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is <code>n</code>.</li><li><code>1 &lt;= k &lt;= n &lt;= 104</code></li><li><code>0 &lt;= Node.val &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>BST中寻找第K小，其实就是中序遍历的第K个节点,直接递归时候找出来就行</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(root,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">process</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root== <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> l = process(root.left, k);</span><br><span class="line">        <span class="keyword">if</span> (l != -<span class="number">1</span>) <span class="keyword">return</span> l;</span><br><span class="line">        c++;</span><br><span class="line">        <span class="keyword">if</span>(c == k) <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> r = process(root.right, k);</span><br><span class="line">        <span class="keyword">if</span> (r != -<span class="number">1</span>) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>227. Basic Calculator II</title>
      <link href="/2018/10/25/leetcode-leetcodetest-2018-10-25-227-Basic-Calculator-II/"/>
      <url>/2018/10/25/leetcode-leetcodetest-2018-10-25-227-Basic-Calculator-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/basic-calculator-ii/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/basic-calculator-ii/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> which represents an expression, <em>evaluate this expression and return its value</em>. </p><p>The integer division should truncate toward zero.</p><p>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-231, 231 - 1]</code>.</p><p><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot; 3&#x2F;2 &quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot; 3+5 &#x2F; 2 &quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> consists of integers and operators <code>(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)</code> separated by some number of spaces.</li><li><code>s</code> represents <strong>a valid expression</strong>.</li><li>All the integers in the expression are non-negative integers in the range <code>[0, 231 - 1]</code>.</li><li>The answer is <strong>guaranteed</strong> to fit in a <strong>32-bit integer</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这道题目是一种常见的思路，乘除的时候先算，在队列里存放加减的序列,然后遍历计算一下可以。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Deque&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (chars[i] == <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] &lt;= <span class="string">'9'</span> &amp;&amp; chars[i] &gt;= <span class="string">'0'</span>) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (chars[i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addNum(queue,num);</span><br><span class="line">                queue.addLast(String.valueOf(chars[i]));</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addNum(queue,num);</span><br><span class="line">        <span class="keyword">return</span>  getRes(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(Deque&lt;String&gt; queue,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!queue.isEmpty() &amp;&amp; (queue.peekLast().equals(<span class="string">"*"</span>) || queue.peekLast().equals(<span class="string">"/"</span>))) &#123;</span><br><span class="line">            String exp = queue.removeLast();</span><br><span class="line">            Integer a = Integer.valueOf(queue.removeLast());</span><br><span class="line">            <span class="keyword">if</span> (exp.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">                num = a * num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num = a / num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.addLast(String.valueOf(num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRes</span><span class="params">(Deque&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.valueOf(queue.removeFirst());</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            String exp = queue.removeFirst();</span><br><span class="line">            String num = queue.removeFirst();</span><br><span class="line">            <span class="keyword">if</span>(exp.equals(<span class="string">"+"</span>))&#123;</span><br><span class="line">                res += Integer.valueOf(num);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                res -= Integer.valueOf(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>218. The Skyline Problem</title>
      <link href="/2018/10/25/leetcode-leetcodetest-2018-10-25-218-The-Skyline-Problem/"/>
      <url>/2018/10/25/leetcode-leetcodetest-2018-10-25-218-The-Skyline-Problem/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>217. Contains Duplicate</title>
      <link href="/2018/10/25/leetcode-leetcodetest-2018-10-25-217-Contains-Duplicate/"/>
      <url>/2018/10/25/leetcode-leetcodetest-2018-10-25-217-Contains-Duplicate/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/contains-duplicate/" target="_blank" rel="noopener">https://leetcode.com/problems/contains-duplicate/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, return <code>true</code> if any value appears <strong>at least twice</strong> in the array, and return <code>false</code> if every element is distinct.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>考察会不会编程。</li><li>发现 用for each 循环 比普通的循环要快！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; nums.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            if (set.contains(nums[i])) return true;</span></span><br><span class="line"><span class="comment">//            set.add(nums[i]);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(i)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>215. Kth Largest Element in an Array</title>
      <link href="/2018/10/22/leetcode-leetcodetest-2018-10-22-215-Kth-Largest-Element-in-an-Array/"/>
      <url>/2018/10/22/leetcode-leetcodetest-2018-10-22-215-Kth-Largest-Element-in-an-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-largest-element-in-an-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>kth</code> <em>largest element in the array</em>.</p><p>Note that it is the <code>kth</code> largest element in the sorted order, not the <code>kth</code> distinct element.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,5,6,4], k &#x3D; 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,3,1,2,4,5,5,6], k &#x3D; 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>利用快排枢轴的方法，寻找第K大元素，经典题目.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span>  nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> process(nums,k,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> kth,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line"><span class="comment">//            System.out.println("i:"+i +" j:"+j +" kth:"+kth);</span></span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp =  nums[i];</span><br><span class="line">        <span class="keyword">int</span> p1 = i,p2 = j;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; p2)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p2 &gt; p1 &amp;&amp; nums[p2] &lt; tmp)&#123;</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p1 &lt; p2)&#123;</span><br><span class="line">                nums[p1] = nums[p2];</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; p2 &amp;&amp; nums[p1] &gt;= tmp)&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p1 &lt; p2)&#123;</span><br><span class="line">                nums[p2] = nums[p1];</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[p1] = tmp; <span class="comment">//p1位置确定</span></span><br><span class="line">        <span class="keyword">int</span> cur_k = p1 - i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur_k == kth) <span class="keyword">return</span> nums[p1];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur_k &gt; kth) <span class="keyword">return</span> process(nums,kth,i,p1-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> process(nums,kth-cur_k,p1+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Quick Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>212. Word Search II</title>
      <link href="/2018/10/22/leetcode-leetcodetest-2018-10-22-212-Word-Search-II/"/>
      <url>/2018/10/22/leetcode-leetcodetest-2018-10-22-212-Word-Search-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-search-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/word-search-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> <code>board</code> of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.</p><p>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words &#x3D; [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class="line">Output: [&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words &#x3D; [&quot;abcb&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 12</code></li><li><code>board[i][j]</code> is a lowercase English letter.</li><li><code>1 &lt;= words.length &lt;= 3 * 104</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>words[i]</code> consists of lowercase English letters.</li><li>All the strings of <code>words</code> are unique.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个和word Search 一的区别是，一只是给了一个单词，去判定存不存在，直接暴力搜就行，现在是判断一堆单词 看看拿个存在，也就是暴力搜的时候，你这个字符不仅仅是和一个单词的字符去比了，你要看，当前路径形成的单词有没有这个单词啊？是不是某个单词的前缀啊？要是直接比那就麻烦了，需要用有序表遍历挨个比，所以应该想到什么，Trie！它去组织单词，给组织起来，当前位置是单词就是，如果是路径也可以继续走，如果不是则直接返回。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        Node root;</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            Node[] nodes;</span><br><span class="line">            <span class="keyword">boolean</span> isWord;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = chars[i]-<span class="string">'a'</span>;</span><br><span class="line">                cur.nodes[index] = cur.nodes[index] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node():cur.nodes[index];</span><br><span class="line">                cur = cur.nodes[index];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] path = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            prefixTree.insert(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                process(res,path,<span class="number">0</span>,i,j,prefixTree.root,board);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;String&gt; res,<span class="keyword">char</span>[] path,<span class="keyword">int</span> k,<span class="keyword">int</span> i,<span class="keyword">int</span> j,PrefixTree.Node cur,<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index = board[i][j] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur.nodes[index] == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">         path[k] = board[i][j];</span><br><span class="line">         board[i][j] = <span class="string">'-'</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur.nodes[index].isWord) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(path,<span class="number">0</span>,k+<span class="number">1</span>));</span><br><span class="line">            cur.nodes[index].isWord = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续以感染的方式 继续检测单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">4</span>;d++)&#123;</span><br><span class="line">            process(res,path,k+<span class="number">1</span>,i+dir_x[d],j+dir_y[d],cur.nodes[index],board);</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = path[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Trie </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>210. Course Schedule II</title>
      <link href="/2018/10/21/leetcode-leetcodetest-2018-10-21-210-Course-Schedule-II/"/>
      <url>/2018/10/21/leetcode-leetcodetest-2018-10-21-210-Course-Schedule-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/course-schedule-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/course-schedule-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you <strong>must</strong> take course <code>bi</code> first if you want to take course <code>ai</code>.</p><ul><li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li></ul><p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 4, prerequisites &#x3D; [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">Output: [0,2,1,3]</span><br><span class="line">Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.</span><br><span class="line">So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 1, prerequisites &#x3D; []</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>ai != bi</code></li><li>All the pairs <code>[ai, bi]</code> are <strong>distinct</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>和课程安排一 没啥区别。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numCourses == <span class="number">1</span> ) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] v_edge = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, List&gt; adjacent = getAdjacent(prerequisites,v_edge);</span><br><span class="line">        <span class="keyword">return</span> judge(v_edge,adjacent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, List&gt; <span class="title">getAdjacent</span><span class="params">(<span class="keyword">int</span>[][] prerequisites, <span class="keyword">int</span>[] v_edge)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, List&gt; adject = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> from = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            v_edge[to]++;</span><br><span class="line">            <span class="keyword">if</span>(adject.containsKey(from))&#123;</span><br><span class="line">                adject.get(from).add(to);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(to);</span><br><span class="line">                adject.put(from,list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] judge(<span class="keyword">int</span>[] v_edge,Map&lt;Integer, List&gt; map)&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] collect = <span class="keyword">new</span> <span class="keyword">int</span>[v_edge.length];</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v_edge.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v_edge[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">final</span> Integer v = queue.poll();</span><br><span class="line">            collect[res++] = v;</span><br><span class="line">            <span class="keyword">final</span> List&lt;Integer&gt; list = map.get(v);</span><br><span class="line">            <span class="keyword">if</span>(list != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                    Integer t = list.get(i);</span><br><span class="line">                    <span class="keyword">if</span>(--v_edge[t] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res == v_edge.length) <span class="keyword">return</span> collect;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Topological Sorting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>208. Implement Trie (Prefix Tree)</title>
      <link href="/2018/10/21/leetcode-leetcodetest-2018-10-21-208-Implement-Trie-Prefix-Tree/"/>
      <url>/2018/10/21/leetcode-leetcodetest-2018-10-21-208-Implement-Trie-Prefix-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-trie-prefix-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A <a href="https://en.wikipedia.org/wiki/Trie" target="_blank" rel="noopener"><strong>trie</strong></a> (pronounced as “try”) or <strong>prefix tree</strong> is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p><p>Implement the Trie class:</p><ul><li><code>Trie()</code> Initializes the trie object.</li><li><code>void insert(String word)</code> Inserts the string <code>word</code> into the trie.</li><li><code>boolean search(String word)</code> Returns <code>true</code> if the string <code>word</code> is in the trie (i.e., was inserted before), and <code>false</code> otherwise.</li><li><code>boolean startsWith(String prefix)</code> Returns <code>true</code> if there is a previously inserted string <code>word</code> that has the prefix <code>prefix</code>, and <code>false</code> otherwise.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">Output</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; return True</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; return False</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; return True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; return True</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code> and <code>prefix</code> consist only of lowercase English letters.</li><li>At most <code>3 * 104</code> calls <strong>in total</strong> will be made to <code>insert</code>, <code>search</code>, and <code>startsWith</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个没什么难度，让实现一个Trie，只要学过这个东西，不难的。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Node[] nodes;</span><br><span class="line">        <span class="keyword">boolean</span> isWord;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = chars[i]-<span class="string">'a'</span>;</span><br><span class="line">            cur.nodes[index] = cur.nodes[index] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node():cur.nodes[index];</span><br><span class="line">            cur = cur.nodes[index];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = chars[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.nodes[index] != <span class="keyword">null</span>)</span><br><span class="line">                cur = cur.nodes[index];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = prefix.toCharArray();</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = chars[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.nodes[index] != <span class="keyword">null</span>)</span><br><span class="line">                cur = cur.nodes[index];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trie </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>207. Course Schedule</title>
      <link href="/2018/10/21/leetcode-leetcodetest-2018-10-21-207-Course-Schedule/"/>
      <url>/2018/10/21/leetcode-leetcodetest-2018-10-21-207-Course-Schedule/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">https://leetcode.com/problems/course-schedule/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you <strong>must</strong> take course <code>bi</code> first if you want to take course <code>ai</code>.</p><ul><li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li></ul><p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li>All the pairs prerequisites[i] are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>课程安排。典型的拓扑排序。图论的算法，有机会单独总结一次。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numCourses == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span>[] v_edge = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, List&gt; adjacent = getAdjacent(prerequisites,v_edge);</span><br><span class="line">        <span class="keyword">return</span> judge(v_edge,adjacent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, List&gt; <span class="title">getAdjacent</span><span class="params">(<span class="keyword">int</span>[][] prerequisites,<span class="keyword">int</span>[] v_edge)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, List&gt; adject = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> from = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> to = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            v_edge[to]++;</span><br><span class="line">            <span class="keyword">if</span>(adject.containsKey(from))&#123;</span><br><span class="line">                adject.get(from).add(to);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(to);</span><br><span class="line">                adject.put(from,list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span>[] v_edge,Map&lt;Integer, List&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v_edge.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v_edge[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">final</span> Integer v = queue.poll();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">final</span> List&lt;Integer&gt; list = map.get(v);</span><br><span class="line">            <span class="keyword">if</span>(list != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                    Integer t = list.get(i);</span><br><span class="line">                    <span class="keyword">if</span>(--v_edge[t] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == v_edge.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Algorithm -Topological Sorting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206. Reverse Linked List</title>
      <link href="/2018/10/18/leetcode-leetcodetest-2018-10-18-206-Reverse-Linked-List/"/>
      <url>/2018/10/18/leetcode-leetcodetest-2018-10-18-206-Reverse-Linked-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: [5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2]</span><br><span class="line">Output: [2,1]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个就是遍历一趟，把扫过的指针反向即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode cur = head,pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>204. Count Primes</title>
      <link href="/2018/10/15/leetcode-leetcodetest-2018-10-15-204-Count-Primes/"/>
      <url>/2018/10/15/leetcode-leetcodetest-2018-10-15-204-Count-Primes/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/count-primes/" target="_blank" rel="noopener">https://leetcode.com/problems/count-primes/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em>the number of prime numbers that are strictly less than</em> <code>n</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 10</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= n &lt;= 5 * 106</code></li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>数数素数，利用打表法，开数组，把素数打出来，再数就可以了。我们这里说的数素数指的是 埃及素数筛选法，时间复杂度是loglog(N)。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">boolean</span>[] primer = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9000000</span>]; <span class="comment">//false代表是</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; <span class="number">9000000</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!primer[i])&#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                    set.add(i);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>;j &lt; <span class="number">9000000</span>;j += i)&#123;</span><br><span class="line">                        primer[j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Integer primer_floor = set.floor(n);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> loc = list.indexOf(primer_floor);</span><br><span class="line">        <span class="keyword">if</span> (set.contains(n))&#123;</span><br><span class="line">            <span class="keyword">return</span> loc;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> loc +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>202. Happy Number</title>
      <link href="/2018/10/15/leetcode-leetcodetest-2018-10-15-202-Happy-Number/"/>
      <url>/2018/10/15/leetcode-leetcodetest-2018-10-15-202-Happy-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="noopener">https://leetcode.com/problems/happy-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write an algorithm to determine if a number <code>n</code> is happy.</p><p>A <strong>happy number</strong> is a number defined by the following process:</p><ul><li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li><li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li><li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li></ul><p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 19</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>看着是数学题，可是也不需要找规律，就是模拟实现一下就过了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!(set.contains(n) || n == <span class="number">1</span>))&#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            <span class="keyword">int</span> c = n;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (c != <span class="number">0</span>)&#123;</span><br><span class="line">                res += (c%<span class="number">10</span>)*(c%<span class="number">10</span>);</span><br><span class="line">                c /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !set.contains(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>200. Number of Islands</title>
      <link href="/2018/10/15/leetcode-leetcodetest-2018-10-15-200-Number-of-Islands/"/>
      <url>/2018/10/15/leetcode-leetcodetest-2018-10-15-200-Number-of-Islands/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-islands/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p><p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典的岛屿问题，数有多少个岛屿，一般两种做法，一个是感染的思路，遍历矩阵，对每个没遍历过的，从它开始进行BFS感染，把整个联通块串起来，并且标记好访问过，那么 循环矩阵时，进行过几次BFS，就是几个块。</li><li>典型的并查集，并查集的作用就是来判断两个元素是不是在同一个集合，进行集合的合并，同时可以记录有多少个集合，每个集合有多少个元素等。我们对矩阵中的元素，对每一个都看它的右面和下面，进行集合的合并。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span>[] parents;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">boolean</span>[] root; <span class="comment">//是不是根</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parent = c;</span><br><span class="line">        <span class="keyword">while</span> (parents[parent] != parent)&#123;</span><br><span class="line">            parent = parents[parent];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//路经压缩</span></span><br><span class="line">        parents[c] = parent;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root_a = find(a);</span><br><span class="line">        <span class="keyword">int</span> root_b = find(b);</span><br><span class="line">        <span class="keyword">if</span>(root_a != root_b)&#123;</span><br><span class="line">            parents[root_a] = root_b;</span><br><span class="line">            root[root_a] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        parents = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length*grid[<span class="number">0</span>].length];</span><br><span class="line">        root = <span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length*grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parents.length; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  =<span class="number">0</span> ;i &lt; grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    root[i*grid[<span class="number">0</span>].length+j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; grid[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[<span class="number">0</span>][i] == <span class="string">'1'</span> &amp;&amp; grid[<span class="number">0</span>][i-<span class="number">1</span>] ==<span class="string">'1'</span>)&#123;</span><br><span class="line">                union(i-<span class="number">1</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="comment">//看左面</span></span><br><span class="line">                    <span class="keyword">if</span>(j != <span class="number">0</span> &amp;&amp; grid[i][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                        union(i*grid[<span class="number">0</span>].length+j-<span class="number">1</span>,i*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(grid[i-<span class="number">1</span>][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                        union((i-<span class="number">1</span>)*grid[<span class="number">0</span>].length+j,i*grid[<span class="number">0</span>].length+j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root[i]) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>198. House Robber</title>
      <link href="/2018/10/13/leetcode-leetcodetest-2018-10-13-198-House-Robber/"/>
      <url>/2018/10/13/leetcode-leetcodetest-2018-10-13-198-House-Robber/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">https://leetcode.com/problems/house-robber/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).</span><br><span class="line">Total amount you can rob &#x3D; 1 + 3 &#x3D; 4.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 2), rob house 3 (money &#x3D; 9) and rob house 5 (money &#x3D; 1).</span><br><span class="line">Total amount you can rob &#x3D; 2 + 9 + 1 &#x3D; 12.</span><br></pre></td></tr></table></figure><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>打家劫舍 经典题目啊，像打家劫舍、循环的打家劫舍、点灯问题、循环的点灯问题 其实都差不多。</li><li>我们定义dp[i],代表 [i,len-1] 能拿到的最大值，那么此时有<script type="math/tex">dp[i] = max(dp[i+1],num[i]+dp[i+2])</script>,其实只跟后面两个元素有关，改成变量迭代的方式，省掉空间。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = nums[N-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = pre;</span><br><span class="line">            pre = Math.max(nums[i] + pre2,pre);</span><br><span class="line">            pre2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>191. Number of 1 Bits</title>
      <link href="/2018/10/10/leetcode-leetcodetest-2018-10-10-191-Number-of-1-Bits/"/>
      <url>/2018/10/10/leetcode-leetcodetest-2018-10-10-191-Number-of-1-Bits/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-1-bits/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">Hamming weight</a>).</p><p><strong>Note:</strong></p><ul><li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</li><li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two&#39;s_complement" target="_blank" rel="noopener">2’s complement notation</a>. Therefore, in <strong>Example 3</strong>, the input represents the signed integer. <code>-3</code>.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 00000000000000000000000000001011</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The input binary string 00000000000000000000000000001011 has a total of three &#39;1&#39; bits.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 00000000000000000000000010000000</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The input binary string 00000000000000000000000010000000 has a total of one &#39;1&#39; bit.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 11111111111111111111111111111101</span><br><span class="line">Output: 31</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &#39;1&#39; bits.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The input must be a <strong>binary string</strong> of length <code>32</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>遍历数一下就行，只不过这里，咱们通过取最右侧第一个1的方式，而不是一位一位无脑的遍历，这样就更快点。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( n!= <span class="number">0</span>)&#123;</span><br><span class="line">            n -= (n &amp; (-n));</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>190. Reverse Bits</title>
      <link href="/2018/10/10/leetcode-leetcodetest-2018-10-10-190-Reverse-Bits/"/>
      <url>/2018/10/10/leetcode-leetcodetest-2018-10-10-190-Reverse-Bits/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/reverse-bits/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-bits/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Reverse bits of a given 32 bits unsigned integer.</p><p><strong>Note:</strong></p><ul><li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned.</li><li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two&#39;s_complement" target="_blank" rel="noopener">2’s complement notation</a>. Therefore, in <strong>Example 2</strong> above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 00000010100101000001111010011100</span><br><span class="line">Output:    964176192 (00111001011110000010100101000000)</span><br><span class="line">Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 11111111111111111111111111111101</span><br><span class="line">Output:   3221225471 (10111111111111111111111111111111)</span><br><span class="line">Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The input must be a <strong>binary string</strong> of length <code>32</code></li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>我们就用一个比较简单的操作交换即可，就不借鉴各路大神的操作了。</li><li>对bit位交换，如果一样那就不用交换，如果不一样，各自位取反即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">16</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> M = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">            <span class="keyword">int</span> left = (M &amp; n);</span><br><span class="line">            <span class="keyword">int</span> right = (N &amp; n);</span><br><span class="line">            <span class="keyword">if</span>(left != <span class="number">0</span>&amp;&amp; right==<span class="number">0</span> || left==<span class="number">0</span> &amp;&amp; right!= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left == <span class="number">0</span>)&#123;</span><br><span class="line">                    n |= M;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    n &amp;= ~(M);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(right == <span class="number">0</span>)&#123;</span><br><span class="line">                    n |= N;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    n &amp;= ~(N);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>189. Rotate Array</title>
      <link href="/2018/10/09/leetcode-leetcodetest-2018-10-09-189-Rotate-Array/"/>
      <url>/2018/10/09/leetcode-leetcodetest-2018-10-09-189-Rotate-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-array/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,-100,3,99], k &#x3D; 2</span><br><span class="line">Output: [3,99,-1,-100]</span><br><span class="line">Explanation: </span><br><span class="line">rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class="line">rotate 2 steps to the right: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= k &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典的交换题目，三次交换即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; nums.length) k = k % nums.length;</span><br><span class="line">        swap(nums,nums.length-k,nums.length-<span class="number">1</span>);</span><br><span class="line">        swap(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>-k);</span><br><span class="line">        swap(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = l,p2 = r;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; p2)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[p1];</span><br><span class="line">            nums[p1] = nums[p2];</span><br><span class="line">            nums[p2] = temp;</span><br><span class="line">            p1++;</span><br><span class="line">            p2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>179. Largest Number</title>
      <link href="/2018/10/09/leetcode-leetcodetest-2018-10-09-179-Largest-Number/"/>
      <url>/2018/10/09/leetcode-leetcodetest-2018-10-09-179-Largest-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/largest-number/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a list of non-negative integers <code>nums</code>, arrange them such that they form the largest number and return it.</p><p>Since the result may be very large, so you need to return a string instead of an integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [10,2]</span><br><span class="line">Output: &quot;210&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,30,34,5,9]</span><br><span class="line">Output: &quot;9534330&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题是贪心，我们排序一下，排序时候，要不要交换，要看当前两个元素的是不交换拼接的值大，还是交换之后拼接的值大！</li><li>这就是贪心策略，应该多积累，见过就会，没见过就难想.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            list.add(String.valueOf(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        list.sort((a,b)-&gt;-(a+b).compareTo(b+a));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.length() != <span class="number">0</span> || !list.get(i).equals(<span class="string">"0"</span>) || i == list.size()-<span class="number">1</span>)</span><br><span class="line">                res.append(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Greed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>172. Factorial Trailing Zeroes</title>
      <link href="/2018/10/09/leetcode-leetcodetest-2018-10-09-172-Factorial-Trailing-Zeroes/"/>
      <url>/2018/10/09/leetcode-leetcodetest-2018-10-09-172-Factorial-Trailing-Zeroes/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/factorial-trailing-zeroes/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>n</code>, return <em>the number of trailing zeroes in</em> <code>n!</code>.</p><p>Note that <code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: 3! &#x3D; 6, no trailing zero.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 5</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 5! &#x3D; 120, one trailing zero.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= n &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这道题是与质数有关的题目，一个数的介乘分解质因数后有多少个质数a？这个是典型的题目</li><li>此题就是问，分解后有多少个5，因为2 * 5 = 10，而2的质数远比5多啊，所以取决于5</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">            res += n/<span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>171. Excel Sheet Column Number</title>
      <link href="/2018/10/08/leetcode-leetcodetest-2018-10-08-171-Excel-Sheet-Column-Number/"/>
      <url>/2018/10/08/leetcode-leetcodetest-2018-10-08-171-Excel-Sheet-Column-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">https://leetcode.com/problems/excel-sheet-column-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>columnTitle</code> that represents the column title as appears in an Excel sheet, return <em>its corresponding column number</em>.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: columnTitle &#x3D; &quot;A&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: columnTitle &#x3D; &quot;AB&quot;</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: columnTitle &#x3D; &quot;ZY&quot;</span><br><span class="line">Output: 701</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= columnTitle.length &lt;= 7</code></li><li><code>columnTitle</code> consists only of uppercase English letters.</li><li><code>columnTitle</code> is in the range <code>[&quot;A&quot;, &quot;FXSHRXW&quot;]</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是简单的映射</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String columnTitle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = columnTitle.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            res = res * <span class="number">26</span> + (chars[i] - <span class="string">'A'</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码解析</title>
      <link href="/2018/10/05/%E6%BA%90%E7%A0%81-jdk-2022-07-05-HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/10/05/%E6%BA%90%E7%A0%81-jdk-2022-07-05-HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>HashMap是特别常用的数据结构，源码很长,但底层原理并不复杂，本篇主要介绍hashmap的存储原理以及底层用到的数据结构，并对核心代码进行分析。</p></blockquote><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><ol><li><p>结构图</p><p>HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。其中当链表的长度大于等于 8 时， 链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表，整体的数据结构 如下：</p><p><img src="1.jpg" alt="结构图"></p></li><li><p>类注释信息</p><ul><li>允许 null 值，不同于 HashTable ，是线程不安全的;</li><li>load factor（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值，较高的 值会减少空间开销（扩容减少，数组大小增长速度变慢），但增加了查找成本（hash 冲突增加，链表长度变长），不扩容的条件：数组容量 &gt; 需要的数组大小 /load factor;</li><li>如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的 大小，这样可以防止在其过程中不断的扩容，影响性能；</li><li>HashMap 是非线程安全的，我们可以自己在外部加锁，或者通过Collections#synchronizedMap 来实现线程安全，Collections#synchronizedMap 的实 现是在每个方法上加上了 synchronized 锁；</li><li>在迭代过程中，如果 HashMap 的结构被修改，会快速失败。</li></ul></li><li><p>常见属性</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">   <span class="comment">//最大容量</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">  <span class="comment">//负载因子默认值</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">   <span class="comment">//bin(桶)容量大于等于8时，链表转化成红黑树</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//bin(桶)容量小于等于6时，红黑树转化成链表</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//容量最小64时才会转会成红黑树</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于fail-fast的，记录HashMap结构发生变化(数量变化或rehash)的数目</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//HashMap 的实际大小，可能不准(因为当你拿到这个值的时候，可能又发生了变化)</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 扩容的门槛，如果初始化时，给定数组大小的话，通过tableSizeFor 方法计算，永远接近于 2 的幂次方</span></span><br><span class="line">   <span class="comment">// 如果是通过 resize 方法进行扩容后，大小 = 数组容量 * 0.75</span></span><br><span class="line">   <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//存放数据的数组</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ol><li><p>整体流程</p><p>新增 key，value 大概的步骤如下：</p><ol><li>空数组有无初始化，没有的话初始化；</li><li>如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；</li><li>如果 hash 冲突，两种解决方案：链表 or 红黑树；</li><li>如果是链表，递归循环，把新元素追加到队尾；</li><li>如果是红黑树，调用红黑树新增的方法；</li><li>通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；</li><li>判断是否需要扩容，需要扩容进行扩容，结束。</li></ol></li></ol><p>​    我们来画一张示意图来描述下：</p><p>​    <img src="2.jpg" alt="添加元素流程图"></p><ol><li><p>源码实现</p><ol><li>添加元素 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//如果数组为空，初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// hashCode的算法先右移16 在并上数组大小-1</span></span><br><span class="line">        <span class="comment">// 如果当前索引位置是空的，直接生成新的节点在当前索引位置上</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 如果hash冲突，当前索引上有值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 如果key equals都相等，那么当前节点就是我们要新增的</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 如果是红黑树，使用红黑树的方式新增</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 是个链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//如果是最后一个，还找不到和新增的元素相等的，直接新增</span></span><br><span class="line">                    <span class="comment">//节点是新增到链表最后的</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//p.next是新增的节点，但是e仍然是null</span></span><br><span class="line">                        <span class="comment">//e和p.next都是持有对null的引用,即使p.next后来赋予了值</span></span><br><span class="line">                        <span class="comment">// 只是改变了p.next指向的引用，和e没有关系</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//新增时，链表的长度大于等于8时，链表转红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//链表中有元素和新增的元素相等，结束循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//更改循环的当前元素</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//说明新增的元素table中原来就有</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">// 当前节点移动到队尾</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">//如果kv的实际大小大于扩容的门槛，开始扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 删除不经常使用的元素</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>链表添加细节</p><p> 链表的添加比较简单，和LinkedList的追加实现是一样的，上面代码中描述的很清楚了，注意一点，当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，此方法 有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，当数组 大小小于 64 时，只会触发扩容，不会转化成红黑树 ，转化成红黑树的过程也比较简单，此处不再赘述 。</p><p>至于为什么是8 才会转红黑树，源码中有注释，可以参照,大概意思如下文:</p><blockquote><p>链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候， 使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要 的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，所以我们需要定义出转化的边界值。</p><p>在考虑设计 8 这个值的时候，我们参考了泊松分布概率函数，由泊松分布中得出结论，链表各 个长度的命中概率为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 0:    0.60653066</span><br><span class="line">* 1:    0.30326533</span><br><span class="line">* 2:    0.07581633</span><br><span class="line">* 3:    0.01263606</span><br><span class="line">* 4:    0.00157952</span><br><span class="line">* 5:    0.00015795</span><br><span class="line">* 6:    0.00001316</span><br><span class="line">* 7:    0.00000094</span><br><span class="line">* 8:    0.00000006</span><br><span class="line">* more: less than 1 in ten million</span><br></pre></td></tr></table></figure></blockquote><p>意思是，当链表的长度是 8 的时候，出现的概率是 0.00000006，不到千万分之一，所以说正常 情况下，链表的长度不可能到达 8 ，而一旦到达 8 时，肯定是 hash 算法出了问题，所以在这 种情况下，为了让 HashMap 仍然有较高的查询性能，所以让链表转化成红黑树，我们正常写 代码， 使用 HashMap 时， 几乎不会碰到链表转化成红黑树的情况， 毕竟概念只有千万分之 一。</p></li><li><p>红黑树添加细节</p><p>红黑树是一种动态平衡的数据结构 和AVL树、跳表类似，都具有动态平衡的特点，其实本身没多难，只是插入元素和删除元素后，需要平衡调整-“打补丁”操作,具体的调整规则就不再叙述了，红黑树不了解的可先跳过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树中加入节点</span></span><br><span class="line">        <span class="comment">//在计算新增的节点挂在那个节点上，是线程不安全的，</span></span><br><span class="line">        <span class="comment">//关键在于没有锁住tab,table可能是在动态的变化的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1:首先判断新增的节点在红黑树上是不是已经存在。</span></span><br><span class="line">        <span class="comment">//2:不在的话，根据hashcode，或者自定义的comparTo,递归找到要挂载的节点</span></span><br><span class="line">        <span class="comment">//3:和要挂载的节点建立父子，前后关系</span></span><br><span class="line">        <span class="comment">//4:判断是否需要着色，旋转。</span></span><br><span class="line">        <span class="comment">//5:对红黑树的根节点进行校验</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//h：key 的hash值</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//找到根节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">//自旋</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="comment">// p hash 值大于 h，说明 p 在 h 的右边</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// p hash 值小于 h，说明 p 在 h 的左边</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//要放进去key在当前树中已经存在了(equals来判断)</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="comment">//自己实现的Comparable的话，不能用hashcode比较了，需要用compareTo</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          <span class="comment">//得到key的Class类型，如果key没有实现Comparable就是null</span></span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                          <span class="comment">//当前节点pk和入参k不等</span></span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//找到和当前hashcode值相近的节点(当前节点的左右子节点其中一个为空即可)</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    <span class="comment">//生成新的节点</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="comment">//把新节点放在当前子节点为空的位置上</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">//当前节点和新节点建立父子，前后关系</span></span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    <span class="comment">//balanceInsertion 对红黑树进行着色或旋转，以达到更多的查找效率，着色或旋转的几种场景如下</span></span><br><span class="line">                    <span class="comment">//着色：新节点总是为红色；如果新节点的父亲是黑色，则不需要重新着色；如果父亲是红色，那么必须通过重新</span></span><br><span class="line">                    <span class="comment">//着色或者旋转的方法，再次达到红黑树的5个约束条件</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//旋转： 父亲是红色，叔叔是黑色时(前提是当前)</span></span><br><span class="line">                    <span class="comment">//如果当前节点是父亲的右节点，则进行左旋</span></span><br><span class="line">                    <span class="comment">//如果当前节点是父亲的左节点，则进行右旋</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//moveRootToFront 方法是把算出来的root放到根节点上</span></span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>HashMap 的查找主要分为以下三步：</p><ol><li><p>根据hashcode,算出数组的索引，找到槽点,槽点的key和查询的key相等，直接返回</p></li><li><p>判断当前节点有无 next 节点，有的话判断是链表类型，还是红黑树类型。</p></li><li><p>分别走链表和红黑树不同类型的查找方法。</p><ol><li><p>链表查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用自旋方式从链表中查找 key，e 初始为为链表的头节点 </span></span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">// 如果当前节点 hash 等于 key 的 hash，并且 equals 相等，当前节点就是我们要找的节点 </span></span><br><span class="line">  <span class="comment">// 当 hash 冲突时，同一个 hash 值上是一个链表的时候，我们是通过 equals 方法来比较 key 是否相同</span></span><br><span class="line">  <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">    <span class="keyword">return</span> e; </span><br><span class="line">  <span class="comment">// 否则，把当前节点的下一个节点拿出来继续寻找 &#125; </span></span><br><span class="line">&#125;<span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li><li><p>红黑树查找</p><p>说下思路:</p><ol><li><p>从根节点递归查找；</p></li><li><p>根据 hashcode，比较查找节点，左边节点，右边节点之间的大小，根本红黑树左小右大</p><p>的特性进行判断；</p></li><li><p>判断查找节点在第 2 步有无定位节点位置，有的话返回，没有的话重复 2，3 两步；</p></li><li><p>一直自旋到定位到节点位置为止。</p><p>如果红黑树比较平衡的话，每次查找的次数就是树的深度。</p></li></ol></li></ol></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​        HashMap 的内容虽然较多，但大多数 api 都只是对数组 + 链表 + 红黑树这种数据结构进行封 装而已，本文我们从新增和查找两个角度进行了源码的深入分析，分析了是如何对数组、链表 和红黑树进行操作的,更详细的内容可以自行阅读源码。</p>]]></content>
      
      
      <categories>
          
          <category> 源码 - jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>169. Majority Element</title>
      <link href="/2018/10/05/leetcode-leetcodetest-2018-10-05-169-Majority-Element/"/>
      <url>/2018/10/05/leetcode-leetcodetest-2018-10-05-169-Majority-Element/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">https://leetcode.com/problems/majority-element/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array <code>nums</code> of size <code>n</code>, return <em>the majority element</em>.</p><p>The majority element is the element that appears more than <code>⌊n / 2⌋</code> times. You may assume that the majority element always exists in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>水王问题、摩尔投票问题都是一类，这个考察的是，如果存在大于一半的元素，至多是一个，同理推导，对于N个元素中，要求个数大于 N/k的元素，这样元素至多是k-1个，不可能是k个。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>,elem = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == elem)&#123;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(--c &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    c = <span class="number">1</span>;</span><br><span class="line">                    elem = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>166. Fraction to Recurring Decimal</title>
      <link href="/2018/10/05/leetcode-leetcodetest-2018-10-05-166-Fraction-to-Recurring-Decimal/"/>
      <url>/2018/10/05/leetcode-leetcodetest-2018-10-05-166-Fraction-to-Recurring-Decimal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/fraction-to-recurring-decimal/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/fraction-to-recurring-decimal/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.</p><p>If the fractional part is repeating, enclose the repeating part in parentheses.</p><p>If multiple answers are possible, return <strong>any of them</strong>.</p><p>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>104</code> for all the given inputs.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numerator &#x3D; 1, denominator &#x3D; 2</span><br><span class="line">Output: &quot;0.5&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numerator &#x3D; 2, denominator &#x3D; 1</span><br><span class="line">Output: &quot;2&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numerator &#x3D; 4, denominator &#x3D; 333</span><br><span class="line">Output: &quot;0.(012)&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= numerator, denominator &lt;= 231 - 1</code></li><li><code>denominator != 0</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>做这道题 关键是寻找循环节，可以通过余数去判断。</li><li>用map去记录位置，找到循环节然后插入括号。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numerator == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">&#125;</span><br><span class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// "+" or "-"</span></span><br><span class="line">res.append(((numerator &gt; <span class="number">0</span>) ^ (denominator &gt; <span class="number">0</span>)) ? <span class="string">"-"</span> : <span class="string">""</span>);</span><br><span class="line"><span class="keyword">long</span> num = Math.abs((<span class="keyword">long</span>) numerator);</span><br><span class="line"><span class="keyword">long</span> den = Math.abs((<span class="keyword">long</span>) denominator);</span><br><span class="line"><span class="comment">// integral part</span></span><br><span class="line">res.append(num / den);</span><br><span class="line">num %= den;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fractional part</span></span><br><span class="line">res.append(<span class="string">"."</span>);</span><br><span class="line">HashMap&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Long, Integer&gt;();</span><br><span class="line">map.put(num, res.length());</span><br><span class="line"><span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">num *= <span class="number">10</span>;</span><br><span class="line">res.append(num / den);</span><br><span class="line">num %= den;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(num)) &#123;</span><br><span class="line"><span class="keyword">int</span> index = map.get(num);</span><br><span class="line">res.insert(index, <span class="string">"("</span>);</span><br><span class="line">res.append(<span class="string">")"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map.put(num, res.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>162. Find Peak Element</title>
      <link href="/2018/10/05/leetcode-leetcodetest-2018-10-05-162-Find-Peak-Element/"/>
      <url>/2018/10/05/leetcode-leetcodetest-2018-10-05-162-Find-Peak-Element/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="noopener">https://leetcode.com/problems/find-peak-element/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A peak element is an element that is strictly greater than its neighbors.</p><p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <strong>any of the peaks</strong>.</p><p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</p><p>You must write an algorithm that runs in <code>O(log n)</code> time.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>nums[i] != nums[i + 1]</code> for all valid <code>i</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>要求log(N)，提示很明确了二分。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> res = isPeek(nums, mid);</span><br><span class="line">            <span class="keyword">if</span>(res == <span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(res &lt; <span class="number">0</span>) r = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isPeek</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mid == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[mid+<span class="number">1</span>] &lt; nums[mid] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (mid == nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[mid] &gt; nums[mid-<span class="number">1</span>] ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid-<span class="number">1</span>] &lt; nums[mid] &amp;&amp; nums[mid] &lt; nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//往右走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid-<span class="number">1</span>] &gt; nums[mid] &amp;&amp; nums[mid] &gt; nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//往左走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid-<span class="number">1</span>] &gt; nums[mid] &amp;&amp; nums[mid] &lt; nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160. Intersection of Two Linked Lists</title>
      <link href="/2018/10/05/leetcode-leetcodetest-2018-10-05-160-Intersection-of-Two-Linked-Lists/"/>
      <url>/2018/10/05/leetcode-leetcodetest-2018-10-05-160-Intersection-of-Two-Linked-Lists/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-linked-lists/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p><p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_statement.png" alt="img"></p><p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p><p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p><p><strong>Custom Judge:</strong></p><p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p><ul><li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li><li><code>listA</code> - The first linked list.</li><li><code>listB</code> - The second linked list.</li><li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li><li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li></ul><p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">Output: Intersected at &#39;8&#39;</span><br><span class="line">Explanation: The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect).</span><br><span class="line">From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">Output: Intersected at &#39;2&#39;</span><br><span class="line">Explanation: The intersected node&#39;s value is 2 (note that this must not be 0 if the two lists intersect).</span><br><span class="line">From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">Output: No intersection</span><br><span class="line">Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.</span><br><span class="line">Explanation: The two lists do not intersect, so return null.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes of <code>listA</code> is in the <code>m</code>.</li><li>The number of nodes of <code>listB</code> is in the <code>n</code>.</li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt; m</code></li><li><code>0 &lt;= skipB &lt; n</code></li><li><code>intersectVal</code> is <code>0</code> if <code>listA</code> and <code>listB</code> do not intersect.</li><li><code>intersectVal == listA[skipA] == listB[skipB]</code> if <code>listA</code> and <code>listB</code> intersect.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个就是找第一个公共结点，只需要让长度长的链表提前跑，使两个链表指针，在从后面开始数长度相同的位置开始，一块遍历即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> &amp;&amp; headB != <span class="keyword">null</span> || headB == <span class="keyword">null</span> &amp;&amp; headA != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cntA = <span class="number">0</span>,cntB = <span class="number">0</span>;</span><br><span class="line">        ListNode p1 = headA,p2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cntA++;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cntB++;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = headA;</span><br><span class="line">        p2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (cntA - cntB &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            cntA--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cntB - cntA &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            cntB--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span> &amp;&amp; p1 != p2)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>155. Min Stack</title>
      <link href="/2018/10/05/leetcode-leetcodetest-2018-10-05-155-Min-Stack/"/>
      <url>/2018/10/05/leetcode-leetcodetest-2018-10-05-155-Min-Stack/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">https://leetcode.com/problems/min-stack/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><p>Implement the <code>MinStack</code> class:</p><ul><li><code>MinStack()</code> initializes the stack object.</li><li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li><li><code>void pop()</code> removes the element on the top of the stack.</li><li><code>int top()</code> gets the top element of the stack.</li><li><code>int getMin()</code> retrieves the minimum element in the stack.</li></ul><p>You must implement a solution with <code>O(1)</code> time complexity for each function.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin(); &#x2F;&#x2F; return -3</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();    &#x2F;&#x2F; return 0</span><br><span class="line">minStack.getMin(); &#x2F;&#x2F; return -2</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.</li><li>At most <code>3 * 104</code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此类题目就是要求你重做数据结构，实现某种功能    </li><li>此题考查的是栈</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     Stack&lt;Integer&gt; stack;</span><br><span class="line">    Stack&lt;Integer&gt; min_stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        min_stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">       stack.push(val);</span><br><span class="line">        <span class="keyword">if</span> (min_stack.isEmpty())&#123;</span><br><span class="line">            min_stack.push(val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            min_stack.push(val &lt; min_stack.peek()?val:min_stack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        min_stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>152. Maximum Product Subarray</title>
      <link href="/2018/10/05/leetcode-leetcodetest-2018-10-05-152-Maximum-Product-Subarray/"/>
      <url>/2018/10/05/leetcode-leetcodetest-2018-10-05-152-Maximum-Product-Subarray/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-product-subarray/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, find a contiguous non-empty subarray within the array that has the largest product, and return <em>the product</em>.</p><p>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p><p>A <strong>subarray</strong> is a contiguous subsequence of the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,-2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [2,3] has the largest product 6.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,0,-1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>最大乘积子数组，dp_max[i]表示 以i结尾的最大乘积子数组，dp_min[i]表示以i结尾的最小乘积子数组,主要是数值可能是负的，可能会出现负负得正的情况，那我们可以避开这种详细的讨论，因为答案一定在与dp_min数组或者dp_max数组乘积中可以得出。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min_pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max_pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = max_pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = Math.min(Math.min(nums[i],min_pre*nums[i]),nums[i]*max_pre);</span><br><span class="line">            max_pre = Math.max(Math.max(nums[i],max_pre*nums[i]),nums[i]*min_pre);</span><br><span class="line">            min_pre = tmp;</span><br><span class="line">            res = Math.max(res,max_pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>150. Evaluate Reverse Polish Notation</title>
      <link href="/2018/10/03/leetcode-leetcodetest-2018-10-03-150-Evaluate-Reverse-Polish-Notation/"/>
      <url>/2018/10/03/leetcode-leetcodetest-2018-10-03-150-Evaluate-Reverse-Polish-Notation/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">https://leetcode.com/problems/evaluate-reverse-polish-notation/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank" rel="noopener">Reverse Polish Notation</a>.</p><p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. Each operand may be an integer or another expression.</p><p><strong>Note</strong> that division between two integers should truncate toward zero.</p><p>It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: ((2 + 1) * 3) &#x3D; 9</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;&#x2F;&quot;,&quot;+&quot;]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: (4 + (13 &#x2F; 5)) &#x3D; 6</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens &#x3D; [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;&#x2F;&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">Output: 22</span><br><span class="line">Explanation: ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> is either an operator: <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, <code>&quot;*&quot;</code>, or <code>&quot;/&quot;</code>, or an integer in the range <code>[-200, 200]</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是计算后缀表达式</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> [] stack = <span class="keyword">new</span> <span class="keyword">int</span>[tokens.length];</span><br><span class="line">        <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">            String c = tokens[i];</span><br><span class="line">            <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"+"</span>:&#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> a = stack[top--];</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> b = stack[top--];</span><br><span class="line">                    stack[++top] = a + b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"-"</span>:&#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> a = stack[top--];</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> b = stack[top--];</span><br><span class="line">                    stack[++top] = b-a;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"*"</span>:&#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> a = stack[top--];</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> b = stack[top--];</span><br><span class="line">                    stack[++top] = a * b;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"/"</span> : &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> a = stack[top--];</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> b = stack[top--];</span><br><span class="line">                    stack[++top] = b /a ;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:&#123;</span><br><span class="line">                    <span class="comment">//操作数</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> v = Integer.parseInt(c);</span><br><span class="line">                    stack[++top] = v;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)stack[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>149. Max Points on a Line</title>
      <link href="/2018/10/03/leetcode-leetcodetest-2018-10-03-149-Max-Points-on-a-Line/"/>
      <url>/2018/10/03/leetcode-leetcodetest-2018-10-03-149-Max-Points-on-a-Line/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/max-points-on-a-line/" target="_blank" rel="noopener">https://leetcode.com/problems/max-points-on-a-line/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of <code>points</code> where <code>points[i] = [xi, yi]</code> represents a point on the <strong>X-Y</strong> plane, return <em>the maximum number of points that lie on the same straight line</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[1,1],[2,2],[3,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points &#x3D; [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= points.length &lt;= 300</code></li><li><code>points[i].length == 2</code></li><li><code>-104 &lt;= xi, yi &lt;= 104</code></li><li>All the <code>points</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个看规模 长度最大 300，300个点，就for循环遍历一点问题没有</li><li>分析题目，其实就查 和你在一条直线上的点，用两个点计算出表达式，计算后面点是不是在表达式上，统计个数，拿出最大值即可。</li><li>注意！做差和0比的时候，double 这种浮点数容易出现精度问题，导致结果不是0，拿精度比。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line">        <span class="keyword">int</span> N = points.length;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p1 = <span class="number">0</span>; p1 &lt; N - <span class="number">1</span>; p1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = p1 + <span class="number">1</span>; t &lt; N; t++) &#123;</span><br><span class="line">                <span class="comment">//计算斜率及直线表达式</span></span><br><span class="line">                <span class="keyword">double</span> k = points[t][<span class="number">0</span>] - points[p1][<span class="number">0</span>] == <span class="number">0</span> ? Integer.MAX_VALUE : (<span class="keyword">double</span>)(points[t][<span class="number">1</span>] - points[p1][<span class="number">1</span>]) / (points[t][<span class="number">0</span>] - points[p1][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">double</span> b = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (k != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    b = points[p1][<span class="number">1</span>] - k * points[p1][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> tmp_max = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> p2 = t + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 扫描共线点</span></span><br><span class="line">                <span class="keyword">if</span> (k == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (p2 &lt; N) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (points[p2][<span class="number">0</span>] == points[p1][<span class="number">0</span>]) &#123;</span><br><span class="line">                            tmp_max++;</span><br><span class="line">                            res = Math.max(tmp_max, res);</span><br><span class="line">                        &#125;</span><br><span class="line">                        p2++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (p2 &lt; N) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (Math.abs(points[p2][<span class="number">1</span>]-(k * points[p2][<span class="number">0</span>] + b)) &lt; eps) &#123;</span><br><span class="line">                            tmp_max++;</span><br><span class="line">                            res = Math.max(tmp_max, res);</span><br><span class="line">                        &#125;</span><br><span class="line">                        p2++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>148. Sort List</title>
      <link href="/2018/10/02/leetcode-leetcodetest-2018-10-02-148-Sort-List/"/>
      <url>/2018/10/02/leetcode-leetcodetest-2018-10-02-148-Sort-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/sort-list/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [4,2,1,3]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [-1,5,3,4,0]</span><br><span class="line">Output: [-1,0,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is in the range <code>[0, 5 * 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目难度中等。首先题目是对链表排序，首先想到什么？大声喊出来，没错，我听到了你的回答，归并排序，一个简单而又神奇的算法！</li><li>归并排序，二路归并需要中间分开，可以用快慢指针的方法找到上中点，这些小技巧啊 平时都要用起来才行。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//链表的归并,时间复杂度是N*logN</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> process(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">process</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next ==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">       ListNode fast = head.next,slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode right = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode left = process(head);</span><br><span class="line">        right = process(right);</span><br><span class="line">        <span class="keyword">return</span>  merge(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">merge</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right!= <span class="keyword">null</span>)&#123;</span><br><span class="line">              ListNode cur =<span class="keyword">null</span>,head = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                  ListNode tmp;</span><br><span class="line">                  <span class="keyword">if</span>(left.val &lt; right.val)&#123;</span><br><span class="line">                      tmp = left;</span><br><span class="line">                      left = left.next;</span><br><span class="line">                  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                      tmp = right;</span><br><span class="line">                      right = right.next;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span>(cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      cur = tmp;</span><br><span class="line">                      head = cur;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      cur.next = tmp;</span><br><span class="line">                      cur = cur.next;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">while</span> (left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                  cur.next = left;</span><br><span class="line">                  left = left.next;</span><br><span class="line">                  cur = cur.next;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">while</span> (right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                  cur.next = right;</span><br><span class="line">                  right = right.next;</span><br><span class="line">                  cur = cur.next;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> head;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>146. LRU Cache</title>
      <link href="/2018/10/01/leetcode-leetcodetest-2018-10-01-146-LRU-Cache/"/>
      <url>/2018/10/01/leetcode-leetcodetest-2018-10-01-146-LRU-Cache/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>141. Linked List Cycle</title>
      <link href="/2018/10/01/leetcode-leetcodetest-2018-10-01-141-Linked-List-Cycle/"/>
      <url>/2018/10/01/leetcode-leetcodetest-2018-10-01-141-Linked-List-Cycle/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p><p>Return <code>true</code> <em>if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no cycle in the linked list.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of the nodes in the list is in the range <code>[0, 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>掌握一个技巧，使用快慢指针，如果成环，他们相遇的第一个节点就是入环节点，很有用的这个技巧，原理证明不用管。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode slow = head,fast = head.next.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>&amp;&amp;fast.next != <span class="keyword">null</span> &amp;&amp; slow != fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow == fast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>140. Word Break II</title>
      <link href="/2018/10/01/leetcode-leetcodetest-2018-10-01-140-Word-Break-II/"/>
      <url>/2018/10/01/leetcode-leetcodetest-2018-10-01-140-Word-Break-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/word-break-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p><p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsanddog&quot;, wordDict &#x3D; [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]</span><br><span class="line">Output: [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;pineapplepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]</span><br><span class="line">Output: [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]</span><br><span class="line">Explanation: Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li><li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li><li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题难度为Hard，但其实和单词分解一差不多，这个要求的不仅仅判断能不能分解，而且把所有的情况都找出来，那这肯定得递归来收集答案了。</li><li>问题是，我们收集时候，即使当前单词能被拆分，那怎么判断这种情况要不要递归下去，因为递归下去目的就是收集答案，我们可以在单词分解一的基础上，利用DP数组，来进行判断是否选择递归。</li><li>一个一个单元点组合起来，就成了一道难题了，要是没有单词分解一的铺垫，你能不能想到，提前打一个dp出来来收集答案呢？其实之前有遇到过类似，比如：回文串分解。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            <span class="keyword">public</span> Node[] nodes; <span class="comment">//26个字母</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">            <span class="keyword">public</span>  String word;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">                isWord = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Node root;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="keyword">null</span> || <span class="string">""</span>.equals(word)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                cur.nodes[chars[i]-<span class="string">'a'</span>] = cur.nodes[chars[i]-<span class="string">'a'</span>] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node(): cur.nodes[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">                cur = cur.nodes[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">            cur.word = word;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordDict.size(); i++) &#123;</span><br><span class="line">            prefixTree.addWord(wordDict.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[N+<span class="number">1</span>];</span><br><span class="line">        dp[N] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] word = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            PrefixTree.Node cur = prefixTree.root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.nodes[word[j]-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur.nodes[word[j]-<span class="string">'a'</span>].isWord&amp;&amp;dp[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur = cur.nodes[word[j]-<span class="string">'a'</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        process(word,<span class="number">0</span>,prefixTree,<span class="keyword">new</span> StringBuilder(),res,dp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] word, <span class="keyword">int</span> index, PrefixTree ptree, StringBuilder builder, List&lt;String&gt; res,<span class="keyword">boolean</span>[] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index  == word.length) &#123;</span><br><span class="line">            builder.deleteCharAt(builder.length() - <span class="number">1</span>);</span><br><span class="line">            res.add(builder.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PrefixTree.Node cur = ptree.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index;i &lt; word.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.nodes[word[i]-<span class="string">'a'</span>] != <span class="keyword">null</span> &amp;&amp; cur.nodes[word[i]-<span class="string">'a'</span>].isWord &amp;&amp; dp[i+<span class="number">1</span>])&#123;</span><br><span class="line">                builder.append(cur.nodes[word[i]-<span class="string">'a'</span>].word+<span class="string">" "</span>);</span><br><span class="line">                process(word,i+<span class="number">1</span>,ptree,builder,res,dp);</span><br><span class="line">                builder.delete(builder.lastIndexOf(cur.nodes[word[i]-<span class="string">'a'</span>].word),builder.length());</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.nodes[word[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>139. Word Break</title>
      <link href="/2018/10/01/leetcode-leetcodetest-2018-10-01-139-Word-Break/"/>
      <url>/2018/10/01/leetcode-leetcodetest-2018-10-01-139-Word-Break/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-break/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/word-break/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;,&quot;code&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;,&quot;pen&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.</span><br><span class="line">Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 300</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li><li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li><li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>不难想，无非就是递归来切这个字符串，每切的时候还得判断，当前切的这一下是在单词表中的吗？把单词表用有序表存起来，查找时间仍和这个查找的字符串长度有关。我们可以用Trie，把单词表组织起来，有路代表能组成单词，可以加快查找过程。</li><li>此外，我们定义dp[i]，代表[i,len-1]的字符串能否被单词表分解？dp[0]则是答案。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixTree</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            <span class="keyword">public</span> Node[] nodes; <span class="comment">//26个字母</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line">            <span class="keyword">public</span>  String word;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                nodes = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">                isWord = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Node root;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrefixTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="keyword">null</span> || <span class="string">""</span>.equals(word)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">            Node cur = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                cur.nodes[chars[i]-<span class="string">'a'</span>] = cur.nodes[chars[i]-<span class="string">'a'</span>] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node(): cur.nodes[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">                cur = cur.nodes[chars[i]-<span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.isWord = <span class="keyword">true</span>;</span><br><span class="line">            cur.word = word;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PrefixTree prefixTree = <span class="keyword">new</span> PrefixTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordDict.size(); i++) &#123;</span><br><span class="line">            prefixTree.addWord(wordDict.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[N+<span class="number">1</span>];</span><br><span class="line">        dp[N] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] word = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            PrefixTree.Node cur = prefixTree.root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.nodes[word[j]-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur.nodes[word[j]-<span class="string">'a'</span>].isWord&amp;&amp;dp[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur = cur.nodes[word[j]-<span class="string">'a'</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>138. Copy List with Random Pointer</title>
      <link href="/2018/09/29/leetcode-leetcodetest-2018-09-29-138-Copy-List-with-Random-Pointer/"/>
      <url>/2018/09/29/leetcode-leetcodetest-2018-09-29-138-Copy-List-with-Random-Pointer/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">https://leetcode.com/problems/copy-list-with-random-pointer/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p><p>Construct a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="noopener"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p><p>For example, if there are two nodes <code>X</code> and <code>Y</code> in the original list, where <code>X.random --&gt; Y</code>, then for the corresponding two nodes <code>x</code> and <code>y</code> in the copied list, <code>x.random --&gt; y</code>.</p><p>Return <em>the head of the copied linked list</em>.</p><p>The linked list is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p><ul><li><code>val</code>: an integer representing <code>Node.val</code></li><li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</li></ul><p>Your code will <strong>only</strong> be given the <code>head</code> of the original linked list.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/12/18/e1.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/12/18/e2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [[1,1],[2,1]]</span><br><span class="line">Output: [[1,1],[2,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2019/12/18/e3.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [[3,null],[3,0],[3,null]]</span><br><span class="line">Output: [[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>-104 &lt;= Node.val &lt;= 104</code></li><li><code>Node.random</code> is <code>null</code> or is pointing to some node in the linked list.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目难度中等，看你会不会灵活处理。对已有的链表，模仿着创造出一条新的来，random也要指向对应新的节点才可以。</li><li>遍历3次，第一次再节点后面插入一个新的节点，第二次将对应的random指向好，第三次，将对应的新节点串联起来。 </li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node new_node = <span class="keyword">new</span> Node(cur.val);</span><br><span class="line">            new_node.next = cur.next;</span><br><span class="line">            cur.next = new_node;</span><br><span class="line">            cur = new_node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        Node new_head  = <span class="keyword">null</span>;</span><br><span class="line">        Node new_last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node random = cur.random;</span><br><span class="line">            <span class="keyword">if</span> (random != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> Node new_random = random.next;</span><br><span class="line">                cur.next.random = new_random;</span><br><span class="line">            &#125;</span><br><span class="line">             cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (new_head == <span class="keyword">null</span>)&#123;</span><br><span class="line">                new_head = cur.next;</span><br><span class="line">                new_last = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                new_last.next = cur.next;</span><br><span class="line">                new_last = new_last.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linkedlist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136. Single Number</title>
      <link href="/2018/09/28/leetcode-leetcodetest-2018-09-28-136-Single-Number/"/>
      <url>/2018/09/28/leetcode-leetcodetest-2018-09-28-136-Single-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a <strong>non-empty</strong> array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p><p>You must implement a solution with a linear runtime complexity and use only constant extra space.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-3 * 104 &lt;= nums[i] &lt;= 3 * 104</code></li><li>Each element in the array appears twice except for one element which appears only once.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，考察位运算，我们知道异或运算是不同为1，相同为0，而0与任何数异或都是数字本身，所以 异或一遍就能得到答案</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            n ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>134. Gas Station</title>
      <link href="/2018/09/28/leetcode-leetcodetest-2018-09-28-134-Gas-Station/"/>
      <url>/2018/09/28/leetcode-leetcodetest-2018-09-28-134-Gas-Station/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">https://leetcode.com/problems/gas-station/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>ith</code> station is <code>gas[i]</code>.</p><p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>ith</code> station to its next <code>(i + 1)th</code> station. You begin the journey with an empty tank at one of the gas stations.</p><p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4</span><br><span class="line">Travel to station 4. Your tank &#x3D; 4 - 1 + 5 &#x3D; 8</span><br><span class="line">Travel to station 0. Your tank &#x3D; 8 - 2 + 1 &#x3D; 7</span><br><span class="line">Travel to station 1. Your tank &#x3D; 7 - 3 + 2 &#x3D; 6</span><br><span class="line">Travel to station 2. Your tank &#x3D; 6 - 4 + 3 &#x3D; 5</span><br><span class="line">Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.</span><br><span class="line">Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: gas &#x3D; [2,3,4], cost &#x3D; [3,4,3]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">You can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class="line">Let&#39;s start at station 2 and fill up with 4 unit of gas. Your tank &#x3D; 0 + 4 &#x3D; 4</span><br><span class="line">Travel to station 0. Your tank &#x3D; 4 - 3 + 2 &#x3D; 3</span><br><span class="line">Travel to station 1. Your tank &#x3D; 3 - 3 + 3 &#x3D; 3</span><br><span class="line">You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.</span><br><span class="line">Therefore, you can&#39;t travel around the circuit once no matter where you start.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == gas.length == cost.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= gas[i], cost[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>加油站问题，经典题目！我们这个地方用滑动窗口解</li><li>我们首先用cost数组减掉gas数组，存回cost数组，这样&gt;=0表示从这出发能到达下个点，我们从L位置遍历过程中，进行累加cost数组前缀和preSum，如果出现负数肯定是到达不了下个位置了。</li><li>滑动窗口要找单调性，不能回退，比如说 [L,R]，此时不满足情况即preSum &lt; 0，那么[L+1,R] 的位置一定也不满足，因为当初你有可能携带汽油到达L位置，结果从L都到不了R，现在从L+1的位置 怎么可能到达了R! </li><li>为了节省空间，在cost数组本身进行环形增长，达到长度N，其实完全可以再开辟个数组，复制一遍不用这么麻烦</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = cost.length;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>) <span class="keyword">return</span> gas[<span class="number">0</span>]-cost[<span class="number">0</span>] &gt;= <span class="number">0</span>?<span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            cost[i] = gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; N)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; N &amp;&amp;cost[p1] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p1 &lt; N)&#123;</span><br><span class="line">                <span class="keyword">int</span> p2 = p1,preSum = cost[p1];</span><br><span class="line">                <span class="comment">//窗口增长</span></span><br><span class="line">                <span class="keyword">while</span> ((p2-p1+N)%N+<span class="number">1</span>&lt;N &amp;&amp; preSum &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    p2 = (p2+<span class="number">1</span>)%N;</span><br><span class="line">                    preSum += cost[p2];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(preSum &gt;= <span class="number">0</span> ) <span class="keyword">return</span> p1;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p2 &gt; p1) p1 = p2;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>131. Palindrome Partitioning</title>
      <link href="/2018/09/27/leetcode-leetcodetest-2018-09-27-131-Palindrome-Partitioning/"/>
      <url>/2018/09/27/leetcode-leetcodetest-2018-09-27-131-Palindrome-Partitioning/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-partitioning/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a <strong>palindrome</strong>. Return all possible palindrome partitioning of <code>s</code>.</p><p>A <strong>palindrome</strong> string is a string that reads the same backward as forward.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aab&quot;</span><br><span class="line">Output: [[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;</span><br><span class="line">Output: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s</code> contains only lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>中等难度。要求我们输出所有的切分之后每一块都是回文串的可能性，要枚举第一刀切在哪，要保证切出来的是回文串，切完第一刀之后，我们可以递归去收集答案，第一刀切出来的这个部分是不是回文串还要判断</li><li>为了加速判断，可以事先用DP把回文串的下标求出来，加速判断过程，但怪异的事，这种做法竟然不如现判断的效果好，八成leetcode的测试用例不行。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事先dp 求解回文串下标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            dp[i][i]  = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; N)</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = chars[i] == chars[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">3</span>;i &gt;=<span class="number">0</span> ;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">2</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(chars[i] != chars[j]) dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        process(res,list,<span class="number">0</span>,s,dp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;List&lt;String&gt;&gt; res,List&lt;String&gt; path,<span class="keyword">int</span> index,String str,<span class="keyword">boolean</span>[][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = str.length();</span><br><span class="line">        <span class="keyword">if</span>(index == N)&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">            res.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index;i &lt; N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[index][i])&#123;</span><br><span class="line">                path.add(str.substring(index,i+<span class="number">1</span>));</span><br><span class="line">                process(res,path,i+<span class="number">1</span>,str,dp);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现判断</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        partitioning(<span class="number">0</span>, s, result, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">partitioning</span><span class="params">(<span class="keyword">int</span> index, String s, List&lt;List&lt;String&gt;&gt; result, List&lt;String&gt; ds)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (index == s.length())&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(ds));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s, index, i))&#123;</span><br><span class="line">                ds.add(s.substring(index, i+<span class="number">1</span>));</span><br><span class="line">                partitioning(i+<span class="number">1</span>, s, result, ds);</span><br><span class="line">                ds.remove(ds.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(start) != s.charAt(end))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>130. Surrounded Regions</title>
      <link href="/2018/09/27/leetcode-leetcodetest-2018-09-27-130-Surrounded-Regions/"/>
      <url>/2018/09/27/leetcode-leetcodetest-2018-09-27-130-Surrounded-Regions/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">https://leetcode.com/problems/surrounded-regions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> matrix <code>board</code> containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>, <em>capture all regions that are 4-directionally surrounded by</em> <code>&#39;X&#39;</code>.</p><p>A region is <strong>captured</strong> by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">Output: [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">Explanation: Notice that an &#39;O&#39; should not be flipped if:</span><br><span class="line">- It is on the border, or</span><br><span class="line">- It is adjacent to an &#39;O&#39; that should not be flipped.</span><br><span class="line">The bottom &#39;O&#39; is on the border, so it is not flipped.</span><br><span class="line">The other three &#39;O&#39; form a surrounded region, so they are flipped.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;X&quot;]]</span><br><span class="line">Output: [[&quot;X&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>board[i][j]</code> is <code>&#39;X&#39;</code> or <code>&#39;O&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题说的是，把完全包起来的区域里的O-&gt;X,边界上能联通的O不要变，这个还是挺好的，要求你转换思路，我们先把O存成另一个字符C，然后从边界出发去进行BFS 也就是 感染操作，上下左右的去联通，联通了就置成另一个字符K，那么我们再进行遍历，所有的C变成X，所有的K变回O即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> M,N;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        M = board.length;</span><br><span class="line">        N = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            <span class="comment">//统一表示成'C'</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> ( board[i][j] == <span class="string">'O'</span>)</span><br><span class="line">                         board[i][j] = <span class="string">'C'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始从边界进行扫描</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++) &#123;</span><br><span class="line">            infect(board,<span class="number">0</span>,i);</span><br><span class="line">            infect(board,M-<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            infect(board,i,<span class="number">0</span>);</span><br><span class="line">            infect(board,i,N-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)&#123;</span><br><span class="line">            <span class="comment">//统一表示成'C'</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> ( board[i][j] == <span class="string">'C'</span>)</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">if</span> ( board[i][j] == <span class="string">'K'</span>)</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isJudge(i,j) &amp;&amp; board[i][j] == <span class="string">'C'</span>)&#123;</span><br><span class="line">            board[i][j] = <span class="string">'K'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">4</span>;d++)&#123;</span><br><span class="line">                infect(board,i+dir_x[d],j + dir_y[d]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">isJudge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; M &amp;&amp; j &gt;= <span class="number">0</span>&amp;&amp; j&lt;N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>128. Longest Consecutive Sequence</title>
      <link href="/2018/09/27/leetcode-leetcodetest-2018-09-27-128-Longest-Consecutive-Sequence/"/>
      <url>/2018/09/27/leetcode-leetcodetest-2018-09-27-128-Longest-Consecutive-Sequence/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-consecutive-sequence/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence.</em></p><p>You must write an algorithm that runs in <code>O(n)</code> time.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [100,4,200,1,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求最长连续序列，需要两个容器，一个装头，一个装尾，每个元素来了，要看看它前面的元素在尾里面？在的话把自己添加进去，同时存储对应前面的值，接下来再看它后面的 是头吗？如果是，需要重新更正之前的头对应后面的个数，与信息流的题目类似。head容器、tail容器。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums.length == <span class="number">1</span>)<span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, Integer&gt; head = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">final</span> Map&lt;Integer, Integer&gt; tail = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(head.containsKey(nums[i]) || tail.containsKey(nums[i]))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                head.put(nums[i],<span class="number">1</span>);</span><br><span class="line">                tail.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//和前面连一块</span></span><br><span class="line">            <span class="keyword">if</span> (tail.containsKey(nums[i] - <span class="number">1</span>)) &#123;</span><br><span class="line">                head.remove(nums[i]);</span><br><span class="line">                <span class="keyword">final</span> Integer preLen = tail.get(nums[i] - <span class="number">1</span>);</span><br><span class="line">                head.put(nums[i] - preLen, head.get(nums[i] - preLen) + <span class="number">1</span>);</span><br><span class="line">                tail.put(nums[i], preLen + <span class="number">1</span>);</span><br><span class="line">                res = Math.max(res,preLen+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//和后面连上，注意同时更新前面的连续序列</span></span><br><span class="line">            <span class="keyword">if</span> (head.containsKey(nums[i] + <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Integer posLen = head.get(nums[i] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">final</span> Integer preLen = tail.get(nums[i]);</span><br><span class="line">                head.put(nums[i]-preLen+<span class="number">1</span>,preLen+posLen);</span><br><span class="line">                tail.put(nums[i]+posLen,preLen+posLen);</span><br><span class="line">                res = Math.max(res,preLen+posLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>127. Word Ladder</title>
      <link href="/2018/09/27/leetcode-leetcodetest-2018-09-27-127-Word-Ladder/"/>
      <url>/2018/09/27/leetcode-leetcodetest-2018-09-27-127-Word-Ladder/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">https://leetcode.com/problems/word-ladder/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code> such that:</p><ul><li>Every adjacent pair of words differs by a single letter.</li><li>Every <code>si</code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li><li><code>sk == endWord</code></li></ul><p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or</em> <code>0</code> <em>if no such sequence exists.</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= beginWord.length &lt;= 10</code></li><li><code>endWord.length == beginWord.length</code></li><li><code>1 &lt;= wordList.length &lt;= 5000</code></li><li><code>wordList[i].length == beginWord.length</code></li><li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li><li><code>beginWord != endWord</code></li><li>All the words in <code>wordList</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题其实就是图，以每个单词为顶点，相邻的顶点是差一个字母的单词，构造出邻接表之后，把起点也加到图中，那么就是求起点到终点的最短路径问题，单源最短路径有迪杰斯特拉算法 或者更简单的BFS即可。</li><li>再构造邻接表的时候注意，对这个单词寻找邻居时候，不要直接遍历单词表，而是对这个单词的每个字母去调整出新单词，判断单词表中是否存在，这样会更快.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] vToStr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String,Integer&gt; strToMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = wordList.size()+<span class="number">1</span>;</span><br><span class="line">        vToStr = <span class="keyword">new</span> String[N];</span><br><span class="line">        strToMap =  <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        wordList.add(beginWord);</span><br><span class="line">        <span class="comment">// 处理映射</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            vToStr[i] = wordList.get(i);</span><br><span class="line">            strToMap.put(vToStr[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Integer end = strToMap.get(endWord);</span><br><span class="line">        <span class="keyword">if</span>(end == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; adjectTb = getAdjectTb();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bfs = bfs(adjectTb,N,strToMap.get(beginWord),end);</span><br><span class="line">        <span class="keyword">return</span> bfs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; getAdjectTb()&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vToStr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> String str = vToStr[i];</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; chars.length; i1++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">'a'</span>;k &lt;= <span class="string">'z'</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(chars[i1] == k)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">char</span> tmp = chars[i1];</span><br><span class="line">                    chars[i1] = k;</span><br><span class="line">                    <span class="keyword">final</span> String s = <span class="keyword">new</span> String(chars);</span><br><span class="line">                    <span class="keyword">final</span> Integer con = strToMap.get(s);</span><br><span class="line">                    <span class="keyword">if</span>(con != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        list.add(con);</span><br><span class="line">                    &#125;</span><br><span class="line">                    chars[i1] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; adjectTb ,<span class="keyword">int</span> N,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] queue = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>,rear = <span class="number">0</span>;</span><br><span class="line">        queue[rear++] = begin;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        visited[begin] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (front != rear)&#123;</span><br><span class="line">            <span class="keyword">int</span> next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; batchSize;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = queue[front++];</span><br><span class="line">                <span class="keyword">if</span>(tmp == end)</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">final</span> List&lt;Integer&gt; adjents = adjectTb.get(tmp);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adjents.size(); j++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Integer t = adjents.get(j);</span><br><span class="line">                    <span class="keyword">if</span>(!visited[t])&#123;</span><br><span class="line">                        queue[rear++] = t;</span><br><span class="line">                        visited[t] = <span class="keyword">true</span>;</span><br><span class="line">                        next_batch++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">            batchSize = next_batch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125. Valid Palindrome</title>
      <link href="/2018/09/26/leetcode-leetcodetest-2018-09-26-125-Valid-Palindrome/"/>
      <url>/2018/09/26/leetcode-leetcodetest-2018-09-26-125-Valid-Palindrome/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-palindrome/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p><p>Given a string <code>s</code>, return <code>true</code> <em>if it is a <strong>palindrome</strong>, or</em> <code>false</code> <em>otherwise</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;amanaplanacanalpanama&quot; is a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;race a car&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;raceacar&quot; is not a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot; &quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: s is an empty string &quot;&quot; after removing non-alphanumeric characters.</span><br><span class="line">Since an empty string reads the same forward and backward, it is a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 2 * 105</code></li><li><code>s</code> consists only of printable ASCII characters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目不难，就是注意字符类型，判断好就行</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R = str.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line"><span class="comment">// 英文（大小写） + 数字</span></span><br><span class="line"><span class="keyword">if</span> (validChar(str[L]) &amp;&amp; validChar(str[R])) &#123;</span><br><span class="line"><span class="keyword">if</span> (!equal(str[L], str[R])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">L++;</span><br><span class="line">R--;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">L += validChar(str[L]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">R -= validChar(str[R]) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validChar</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isLetter(c) || isNumber(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equal</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isNumber(c1) || isNumber(c2)) &#123;</span><br><span class="line"><span class="keyword">return</span> c1 == c2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a  A   32</span></span><br><span class="line"><span class="comment">// b  B   32</span></span><br><span class="line"><span class="comment">// c  C   32</span></span><br><span class="line"><span class="keyword">return</span> (c1 == c2) || (Math.max(c1, c2) - Math.min(c1, c2) == <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLetter</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>124. Binary Tree Maximum Path Sum</title>
      <link href="/2018/09/24/leetcode-leetcodetest-2018-09-24-124-Binary-Tree-Maximum-Path-Sum/"/>
      <url>/2018/09/24/leetcode-leetcodetest-2018-09-24-124-Binary-Tree-Maximum-Path-Sum/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-maximum-path-sum/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p><p>The <strong>path sum</strong> of a path is the sum of the node’s values in the path.</p><p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 &#x3D; 6.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">Output: 42</span><br><span class="line">Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 &#x3D; 42.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 3 * 104]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>二叉树的递归套路，主要靠一点区分就是，这个最大路径要么经过我root，要么不经过，如果经过的话，一定要和子树经过头的最大路径连起来才可以。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeInfo</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSum;</span><br><span class="line">        <span class="keyword">int</span> fromHeadMaxSum;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeInfo</span><span class="params">(<span class="keyword">int</span> maxSum, <span class="keyword">int</span> fromHeadMaxSum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.maxSum = maxSum;</span><br><span class="line">            <span class="keyword">this</span>.fromHeadMaxSum = fromHeadMaxSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxPathSumProcess(root).maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NodeInfo <span class="title">maxPathSumProcess</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSum = root.val;</span><br><span class="line">        <span class="keyword">int</span> fromHeadMaxSum = root.val;</span><br><span class="line">        <span class="keyword">final</span> NodeInfo leftInfo = maxPathSumProcess(root.left);</span><br><span class="line">        <span class="keyword">final</span> NodeInfo rightInfo = maxPathSumProcess(root.right);</span><br><span class="line">        <span class="comment">//第一种情况，不经过root</span></span><br><span class="line">        <span class="keyword">if</span>(leftInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">            maxSum = Math.max(leftInfo.maxSum,maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">            maxSum = Math.max(rightInfo.maxSum,maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二种，经过root了</span></span><br><span class="line">        <span class="keyword">if</span> (leftInfo!=<span class="keyword">null</span> &amp;&amp; leftInfo.fromHeadMaxSum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            maxSum = Math.max(maxSum, leftInfo.fromHeadMaxSum + root.val);</span><br><span class="line">            fromHeadMaxSum = Math.max(leftInfo.fromHeadMaxSum + root.val,fromHeadMaxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightInfo!=<span class="keyword">null</span> &amp;&amp; rightInfo.fromHeadMaxSum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            maxSum = Math.max(maxSum, rightInfo.fromHeadMaxSum + root.val);</span><br><span class="line">            fromHeadMaxSum = Math.max(rightInfo.fromHeadMaxSum + root.val,fromHeadMaxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span> &amp;&amp; rightInfo != <span class="keyword">null</span> &amp;&amp; leftInfo.fromHeadMaxSum &gt; <span class="number">0</span> &amp;&amp; rightInfo.fromHeadMaxSum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            maxSum = Math.max(maxSum, leftInfo.fromHeadMaxSum + root.val + rightInfo.fromHeadMaxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NodeInfo(maxSum,fromHeadMaxSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>122. Best Time to Buy and Sell Stock II</title>
      <link href="/2018/09/23/leetcode-leetcodetest-2018-09-23-122-Best-Time-to-Buy-and-Sell-Stock-II/"/>
      <url>/2018/09/23/leetcode-leetcodetest-2018-09-23-122-Best-Time-to-Buy-and-Sell-Stock-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p><p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3.</span><br><span class="line">Total profit is 4 + 3 &#x3D; 7.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.</span><br><span class="line">Total profit is 4.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>股票系列问题 第二问，是说 同时可以持有一份股票，可以当天买，当天卖，交易次数不限，求最大利润，问题其实可以转换成，再上坡，下坡中，求所有上坡的和</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; prices.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            res  += Math.max(<span class="number">0</span>,prices[i+<span class="number">1</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>121. Best Time to Buy and Sell Stock</title>
      <link href="/2018/09/23/leetcode-leetcodetest-2018-09-23-121-Best-Time-to-Buy-and-Sell-Stock/"/>
      <url>/2018/09/23/leetcode-leetcodetest-2018-09-23-121-Best-Time-to-Buy-and-Sell-Stock/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p><p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-1 &#x3D; 5.</span><br><span class="line">Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transactions are done and the max profit &#x3D; 0.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>股票系列问题可是经典题目，这是股票一，买一次，卖一次求最大利润，题目转化成，对当前i位置，减去我左边的最小值，即为当前位置卖出的最大利润，遍历一趟得结果</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            min = Math.min(prices[i],min);</span><br><span class="line">            res = Math.max(res,prices[i]-min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>118. Pascal&#39;s Triangle</title>
      <link href="/2018/09/23/leetcode-leetcodetest-2018-09-23-118-Pascal-s-Triangle/"/>
      <url>/2018/09/23/leetcode-leetcodetest-2018-09-23-118-Pascal-s-Triangle/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/pascals-triangle/" target="_blank" rel="noopener">https://leetcode.com/problems/pascals-triangle/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer <code>numRows</code>, return the first numRows of <strong>Pascal’s triangle</strong>.</p><p>In <strong>Pascal’s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numRows &#x3D; 5</span><br><span class="line">Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numRows &#x3D; 1</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>杨辉三角，普通循环就搞定了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tmp.add(<span class="number">1</span>);</span><br><span class="line">        res.add(tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; numRows;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;Integer&gt; last = res.get(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            cur.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i;j++)&#123;</span><br><span class="line">                cur.add(last.get(j-<span class="number">1</span>) + (j &gt;= last.size()? <span class="number">0</span>:last.get(j)));</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>116. Populating Next Right Pointers in Each Node</title>
      <link href="/2018/09/22/leetcode-leetcodetest-2018-09-22-116-Populating-Next-Right-Pointers-in-Each-Node/"/>
      <url>/2018/09/22/leetcode-leetcodetest-2018-09-22-116-Populating-Next-Right-Pointers-in-Each-Node/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">https://leetcode.com/problems/populating-next-right-pointers-in-each-node/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 212 - 1]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><p><strong>Follow-up:</strong></p><ul><li>You may only use constant extra space.</li><li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>T103 提到了层次遍历一次取一批的技巧，这个题就用的上了，一次取出来一批，设置好右节点即可 。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> bathSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            Node pre = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bathSize; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre = cur;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre.next = cur;</span><br><span class="line">                     pre = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(cur.left);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(cur.right);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bathSize = next_batch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>108. Convert Sorted Array to Binary Search Tree</title>
      <link href="/2018/09/22/leetcode-leetcodetest-2018-09-22-108-Convert-Sorted-Array-to-Binary-Search-Tree/"/>
      <url>/2018/09/22/leetcode-leetcodetest-2018-09-22-108-Convert-Sorted-Array-to-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a <strong>height-balanced</strong> binary search tree</em>.</p><p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line">Explanation: [0,-10,5,null,-3,null,9] is also accepted:</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,3]</span><br><span class="line">Output: [3,1]</span><br><span class="line">Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> is sorted in a <strong>strictly increasing</strong> order.</li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这是个简单题，主要要求的很明确了，要是高度是平衡的，那么就用二分，中点当根，然后递归下去即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r -l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> TreeNode left = process(num, l, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> TreeNode right = process(num, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">final</span> TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        root.left = left;</span><br><span class="line">        root.right = right;</span><br><span class="line">        root.val = num[mid];</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/2018/09/21/leetcode-leetcodetest-2018-09-21-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/"/>
      <url>/2018/09/21/leetcode-leetcodetest-2018-09-21-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder &#x3D; [-1], inorder &#x3D; [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> and <code>inorder</code> consist of <strong>unique</strong> values.</li><li>Each value of <code>inorder</code> also appears in <code>preorder</code>.</li><li><code>preorder</code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.</li><li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>前序遍历与中序遍历，前序与层序，加上保证值不同，便可以唯一确定一棵树，先序确定出跟，然后另一个数组确定出对应的左右子树。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constuctTree(preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constuctTree</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,<span class="keyword">int</span> l2,<span class="keyword">int</span> r2,HashMap&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 &gt; r1) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            TreeNode root = <span class="keyword">new</span> TreeNode(preorder[l1]);</span><br><span class="line">            <span class="keyword">final</span> Integer loc = map.get(root.val);</span><br><span class="line">            <span class="keyword">final</span> TreeNode left = constuctTree(preorder, l1 + <span class="number">1</span>, l1 + loc -l2, l2, loc - <span class="number">1</span>, map);</span><br><span class="line">            <span class="keyword">final</span> TreeNode right = constuctTree(preorder, l1 + loc - l2 + <span class="number">1</span>, l1 - l2 + r2, loc + <span class="number">1</span>, r2, map);</span><br><span class="line">            root.left = left;</span><br><span class="line">            root.right = right;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104. Maximum Depth of Binary Tree</title>
      <link href="/2018/09/21/leetcode-leetcodetest-2018-09-21-104-Maximum-Depth-of-Binary-Tree/"/>
      <url>/2018/09/21/leetcode-leetcodetest-2018-09-21-104-Maximum-Depth-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p><p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 104]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>很简单的递归套路</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> l = getHeight(root.left);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> r = getHeight(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(l,r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>103. Binary Tree Zigzag Level Order Traversal</title>
      <link href="/2018/09/21/leetcode-leetcodetest-2018-09-21-103-Binary-Tree-Zigzag-Level-Order-Traversal/"/>
      <url>/2018/09/21/leetcode-leetcodetest-2018-09-21-103-Binary-Tree-Zigzag-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes’ values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[20,9],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是让你一层是从左到右，下一层又是从右到左</li><li>这里介绍一个特别重要的技巧，好多题目可以这么解，就是用队列层序遍历时候，每次从队列里拿元素，一次性拿一批，把这一层的都是拿出来，拿出来你想正着就正着，想倒着就倒着 再折腾一次就可以！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> next_batch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; batchSize;i++)&#123;</span><br><span class="line">                <span class="keyword">final</span> TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(node.left);</span><br><span class="line">                        next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(node.right);</span><br><span class="line">                        next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">                c.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">                    reverse(c);</span><br><span class="line">                &#125;</span><br><span class="line">            batchSize = next_batch;</span><br><span class="line">            flag ^= <span class="number">1</span>;</span><br><span class="line">            list.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ArrayList&lt;Integer&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = c.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size()/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = c.get(i);</span><br><span class="line">            c.set(i,c.get(len-<span class="number">1</span>-i));</span><br><span class="line">            c.set(len-<span class="number">1</span>-i,tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>102. Binary Tree Level Order Traversal</title>
      <link href="/2018/09/18/leetcode-leetcodetest-2018-09-18-102-Binary-Tree-Level-Order-Traversal/"/>
      <url>/2018/09/18/leetcode-leetcodetest-2018-09-18-102-Binary-Tree-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>二叉树的层序遍历，常规操作.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">final</span> Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> batch = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> next_batch=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; batch;i++)&#123;</span><br><span class="line">                <span class="keyword">final</span> TreeNode tmp = queue.poll();</span><br><span class="line">                list.add(tmp.val);</span><br><span class="line">                <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(tmp.left);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(tmp.right);</span><br><span class="line">                    next_batch++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">            batch = next_batch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>101. Symmetric Tree</title>
      <link href="/2018/09/18/leetcode-leetcodetest-2018-09-18-101-Symmetric-Tree/"/>
      <url>/2018/09/18/leetcode-leetcodetest-2018-09-18-101-Symmetric-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/symmetric-tree/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>好题啊好题，虽说是简单题，还蛮考验小聪明的，其实就是说你得始终验证每个节点的左树是不是和右树一样，对每个节点都得验证这是递归，进行验证的时候，你得拿到对应的兄弟节点，所以可以 直接传两次！把树直接传两次！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode leftRoot,TreeNode rightRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftRoot != <span class="keyword">null</span> &amp;&amp; rightRoot != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftRoot.val != rightRoot.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> isMirror(leftRoot.left,rightRoot.right) &amp;&amp; isMirror(leftRoot.right,rightRoot.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(leftRoot == <span class="keyword">null</span> &amp;&amp; rightRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>98. Validate Binary Search Tree</title>
      <link href="/2018/09/16/leetcode-leetcodetest-2018-09-16-98-Validate-Binary-Search-Tree/"/>
      <url>/2018/09/16/leetcode-leetcodetest-2018-09-16-98-Validate-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/validate-binary-search-tree/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p><p>A <strong>valid BST</strong> is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&#39;s value is 5 but its right child&#39;s value is 4.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[1, 104]</code>.</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>BST的中序遍历一定是递增的，验证这个条件即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root,list);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i) &lt;= list.get(i-<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left,list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inOrder(root.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>94. Binary Tree Inorder Traversal</title>
      <link href="/2018/09/13/leetcode-leetcodetest-2018-09-13-94-Binary-Tree-Inorder-Traversal/"/>
      <url>/2018/09/13/leetcode-leetcodetest-2018-09-13-94-Binary-Tree-Inorder-Traversal/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-inorder-traversal/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes’ values</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1,null,2,3]</span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root &#x3D; [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>普通的中序遍历</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        process(res,root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;Integer&gt; res,TreeNode root)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">          process(res,root.left);</span><br><span class="line">          res.add(root.val);</span><br><span class="line">          process(res,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>91. Decode Ways</title>
      <link href="/2018/09/13/leetcode-leetcodetest-2018-09-13-91-Decode-Ways/"/>
      <url>/2018/09/13/leetcode-leetcodetest-2018-09-13-91-Decode-Ways/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">https://leetcode.com/problems/decode-ways/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    A message containing letters from <code>A-Z</code> can be <strong>encoded</strong> into numbers using the following mapping:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; &quot;1&quot;</span><br><span class="line">&#39;B&#39; -&gt; &quot;2&quot;</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; &quot;26&quot;</span><br></pre></td></tr></table></figure><p>To <strong>decode</strong> an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, <code>&quot;11106&quot;</code> can be mapped into:</p><ul><li><code>&quot;AAJF&quot;</code> with the grouping <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> with the grouping <code>(11 10 6)</code></li></ul><p>Note that the grouping <code>(1 11 06)</code> is invalid because <code>&quot;06&quot;</code> cannot be mapped into <code>&#39;F&#39;</code> since <code>&quot;6&quot;</code> is different from <code>&quot;06&quot;</code>.</p><p>Given a string <code>s</code> containing only digits, return <em>the <strong>number</strong> of ways to <strong>decode</strong> it</em>.</p><p>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: &quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: &quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;06&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: &quot;06&quot; cannot be mapped to &quot;F&quot; because of the leading zero (&quot;6&quot; is different from &quot;06&quot;).</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> contains only digits and may contain leading zero(s).</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求解码的字符串种数，这种求种数、求最优解的都可以考虑dp，主要是思路来的快</li><li>定义dp[i]  表示 [i~len-1]区间上 解码字符串的种数</li><li>考虑当前 chars[i],字符单独解码的情况，考虑它与后面字符共同解码的情况，进行枚举即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">//明显的dp,dp[i]，表示i~s.lengtn-1有多少种解码方式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = chars.length;</span><br><span class="line">        <span class="keyword">int</span> pre1 = chars[N-<span class="number">1</span>] == <span class="string">'0'</span> ?  <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(chars[i] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//一位数的时候</span></span><br><span class="line">                <span class="keyword">if</span>(chars[i+<span class="number">1</span>] != <span class="string">'0'</span>)&#123;</span><br><span class="line">                    p1 = pre1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//两位数计算</span></span><br><span class="line">                <span class="keyword">int</span> num = (chars[i]-<span class="string">'0'</span>)*<span class="number">10</span>+(chars[i+<span class="number">1</span>]-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                    p2 = pre2;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = p1 + p2;</span><br><span class="line">            &#125;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>88. Merge Sorted Array</title>
      <link href="/2018/09/13/leetcode-leetcodetest-2018-09-13-88-Merge-Sorted-Array/"/>
      <url>/2018/09/13/leetcode-leetcodetest-2018-09-13-88-Merge-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p><p><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.</p><p>The final sorted array should not be returned by the function, but instead be <em>stored inside the array</em> <code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3</span><br><span class="line">Output: [1,2,2,3,5,6]</span><br><span class="line">Explanation: The arrays we are merging are [1,2,3] and [2,5,6].</span><br><span class="line">The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The arrays we are merging are [1] and [].</span><br><span class="line">The result of the merge is [1].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The arrays we are merging are [] and [1].</span><br><span class="line">The result of the merge is [1].</span><br><span class="line">Note that because m &#x3D; 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-109 &lt;= nums1[i], nums2[j] &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>小小的考察，从后遍历，往后放置即可，还是从题目本身出发，好好分析！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m-<span class="number">1</span>,j = n-<span class="number">1</span>,k = nums1.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                    nums1[k--] = nums1[i--];</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k != -<span class="number">1</span> &amp;&amp; i == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (k &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> Merge Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>84. Largest Rectangle in Histogram</title>
      <link href="/2018/09/11/leetcode-leetcodetest-2018-09-11-84-Largest-Rectangle-in-Histogram/"/>
      <url>/2018/09/11/leetcode-leetcodetest-2018-09-11-84-Largest-Rectangle-in-Histogram/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-rectangle-in-histogram/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of integers <code>heights</code> representing the histogram’s bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: heights &#x3D; [2,1,5,6,2,3]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: The above is a histogram where width of each bar is 1.</span><br><span class="line">The largest rectangle is shown in the red area, which has an area &#x3D; 10 units.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: heights &#x3D; [2,4]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= heights.length &lt;= 105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个是单调栈的应用，单调栈求的是，以当前值为最小值的最大区间。</li><li>还是从题目本身出发，先分析，分析出哪个知识点，用哪个知识点，最大的矩形面积，这个矩形一定是以某个高度为高，然后以这个高度尽可能向两边扩形成一个最大矩形。此外，这个高度一定是在所有的高度里面的，所以我们就可以遍历这些高度，对这些高度，找每个高度形成的最大区间，所有里面的最大面积就是答案。所以说，我们一定要通过分析，找到一个突破点，可以通过枚举去找到所有可能性，进而找到答案。</li><li>有关单调栈的实现这一块，看其它文章的总结。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> N = heights.length,top = -<span class="number">1</span>,res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (top != -<span class="number">1</span> &amp;&amp; heights[stack[top]] &gt;= heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> elem = stack[top--];</span><br><span class="line">                <span class="keyword">int</span> leftMin = top == -<span class="number">1</span> ? -<span class="number">1</span> : stack[top];</span><br><span class="line">                <span class="keyword">int</span> rightMin = i;</span><br><span class="line">                <span class="keyword">int</span> num = (rightMin - <span class="number">1</span> - leftMin) * heights[elem];</span><br><span class="line">                res =  Math.max(res,num);</span><br><span class="line">            &#125;</span><br><span class="line">            stack[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (top!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> elem = stack[top--];</span><br><span class="line">            <span class="keyword">int</span> leftMin = top == -<span class="number">1</span> ? -<span class="number">1</span> : stack[top];</span><br><span class="line">            <span class="keyword">int</span> rightMin = N;</span><br><span class="line">            <span class="keyword">int</span> num = (rightMin - <span class="number">1</span> - leftMin) * heights[elem];</span><br><span class="line">            res = Math.max(res,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Monotonic Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>79. Word Search</title>
      <link href="/2018/09/11/leetcode-leetcodetest-2018-09-11-79-Word-Search/"/>
      <url>/2018/09/11/leetcode-leetcodetest-2018-09-11-79-Word-Search/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener">https://leetcode.com/problems/word-search/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</p><p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;SEE&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCB&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>就是简单的暴力搜索即可。</li><li>下面两个方法，其实思路时一模一样，但是 方法二，就是省掉了数组标记，而是在自身上做标记，用回溯的方法，判断也少点，就这它的时间比方法一快了一倍。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_x = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dir_y = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board[<span class="number">0</span>].length * board.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] arr = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(i,j,<span class="number">0</span>,arr,board,visited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法一，暴力搜索，dfs，对每个位置去搜索单词即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> index,<span class="keyword">char</span>[] arr,<span class="keyword">char</span>[][] board,<span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> loc = i*board[<span class="number">0</span>].length + j;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span>|| j &gt;= board[<span class="number">0</span>].length || visited[loc])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[index] == board[i][j];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == arr[index])&#123;</span><br><span class="line">                visited[loc] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>;d &lt; <span class="number">4</span>;d++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(i+dir_x[d],j+dir_y[d],index+<span class="number">1</span>,arr,board,visited))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[loc] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] w = word.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (f(board, i, j, w, <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前到达了b[i][j]，word[k....]</span></span><br><span class="line"><span class="comment">// 从b[i][j]出发，能不能搞定word[k....] true false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>[][] b, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] w, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k == w.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// word[k.....] 有字符</span></span><br><span class="line"><span class="comment">// 如果(i,j)越界，返回false</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == b.length || j &lt; <span class="number">0</span> || j == b[<span class="number">0</span>].length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b[i][j] != w[k]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> tmp = b[i][j];</span><br><span class="line">b[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> ans = f(b, i - <span class="number">1</span>, j, w, k + <span class="number">1</span>) </span><br><span class="line">|| f(b, i + <span class="number">1</span>, j, w, k + <span class="number">1</span>) </span><br><span class="line">|| f(b, i, j - <span class="number">1</span>, w, k + <span class="number">1</span>)</span><br><span class="line">|| f(b, i, j + <span class="number">1</span>, w, k + <span class="number">1</span>);</span><br><span class="line">b[i][j] = tmp;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>78. Subsets</title>
      <link href="/2018/09/11/leetcode-leetcodetest-2018-09-11-78-Subsets/"/>
      <url>/2018/09/11/leetcode-leetcodetest-2018-09-11-78-Subsets/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">https://leetcode.com/problems/subsets/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible subsets (the power set)</em>.</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0]</span><br><span class="line">Output: [[],[0]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求子集，从左到右递归枚举，加上回溯，收集起来即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; fin = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fin.add(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            fin.add(nums[i]);</span><br><span class="line">            process(res,path,nums,<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        res.add(fin);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; path,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index,<span class="keyword">int</span> lim)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lim == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">            res.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index==nums.length || nums.length-index &lt; lim)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(nums[index]);</span><br><span class="line">        process(res,path,nums,index+<span class="number">1</span>,lim-<span class="number">1</span>);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        process(res,path,nums,index+<span class="number">1</span>,lim);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>76. Minimum Window Substring</title>
      <link href="/2018/09/11/leetcode-leetcodetest-2018-09-11-76-Minimum-Window-Substring/"/>
      <url>/2018/09/11/leetcode-leetcodetest-2018-09-11-76-Minimum-Window-Substring/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-window-substring/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window substring</strong> of</em> <code>s</code> <em>such that every character in</em> <code>t</code> <em>(<strong>including duplicates</strong>) is included in the window. If there is no such substring**, return the empty string</em> <code>&quot;&quot;</code><em>.</em></p><p>The testcases will be generated such that the answer is <strong>unique</strong>.</p><p>A <strong>substring</strong> is a contiguous sequence of characters within the string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot;</span><br><span class="line">Output: &quot;BANC&quot;</span><br><span class="line">Explanation: The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;, t &#x3D; &quot;a&quot;</span><br><span class="line">Output: &quot;a&quot;</span><br><span class="line">Explanation: The entire string s is the minimum window.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a&quot;, t &#x3D; &quot;aa&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: Both &#39;a&#39;s from t must be included in the window.</span><br><span class="line">Since the largest window of s only has one &#39;a&#39;, return empty string.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == s.length</code></li><li><code>n == t.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><p>尝试考虑滑动窗口，滑动窗口能使用，一定要具有单调性，能保证求解的时候，R可以不回退！比如说</p><p>L=2，R=6，此时满足条件了，记录下来，继续考量L = 3，R= 6是否是更优的，来逼近答案，那为什么不考虑 L = 3，R = 4，5 这两个窗口呢？这两个窗口不是被跳过去了吗？因为L = 2,R = 5的时候 都不满足条件，那L=3，R= 5这个更小的窗口 怎么可能满足条件呢！所以这叫R 不回退！</p></li><li><p>第二点，如何判断此时窗口是满足条件的窗口，窗口内的元素是包含制定字符串元素，种类以及对应的个数。我们引入一种“欠债表”的思想，这个表内，初始化时，是我们要还的字符，也就是指定的字符串对应字符及个数，此外维护一个变量是代表 我们还欠着多少，当变量为0时，表明此窗口如何符合条件。具体看代码来理解。</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] tb = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>]; <span class="comment">//欠债表</span></span><br><span class="line">        <span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] p_str = t.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p_str.length; i++) &#123;</span><br><span class="line">            tb[p_str[i]]++;</span><br><span class="line">            in++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_n = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sloc = <span class="number">0</span>,eloc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = <span class="number">0</span>;p1 &lt; str.length;p1++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (p2 &lt; str.length &amp;&amp; in &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (--tb[str[p2++]] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    in--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(in == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p2 - p1 &lt; min_n)&#123;</span><br><span class="line">                    min_n = p2-p1;</span><br><span class="line">                    sloc = p1;</span><br><span class="line">                    eloc = p2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++tb[str[p1]] &gt; <span class="number">0</span>)&#123; in++; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(sloc,eloc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75. Sort Colors</title>
      <link href="/2018/09/11/leetcode-leetcodetest-2018-09-11-75-Sort-Colors/"/>
      <url>/2018/09/11/leetcode-leetcodetest-2018-09-11-75-Sort-Colors/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-colors/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p><p>We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.</p><p>You must solve this problem without using the library’s sort function.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,0,1]</span><br><span class="line">Output: [0,1,2]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>nums[i]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这就是经典的三色旗问题呢，高频题里还是主要以经典题目为主。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>,p3 = nums.length-<span class="number">1</span>,p2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= p3)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[p2] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums,p1,p2);</span><br><span class="line">                p2++;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[p2] == <span class="number">2</span>)&#123;</span><br><span class="line">                swap(nums,p2,p3);</span><br><span class="line">                p3--;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                p2++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>73. Set Matrix Zeroes</title>
      <link href="/2018/09/11/leetcode-leetcodetest-2018-09-11-73-Set-Matrix-Zeroes/"/>
      <url>/2018/09/11/leetcode-leetcodetest-2018-09-11-73-Set-Matrix-Zeroes/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/set-matrix-zeroes/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>‘s.</p><p>You must do it <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in place</a>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: [[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[0].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>-231 &lt;= matrix[i][j] &lt;= 231 - 1</code></li></ul><p><strong>Follow up:</strong></p><ul><li>A straightforward solution using <code>O(mn)</code> space is probably a bad idea.</li><li>A simple improvement uses <code>O(m + n)</code> space, but still not the best solution.</li><li>Could you devise a constant space solution?</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题有点像炸弹人游戏，我们遍历一趟就可以，简单的做法就是利用数组标记下哪一行，哪一列需要置0</li><li>Follow Up中，提示 能不能用常量空间做标记，这种优化，在面试中也常问。我们想的就是怎么节省空间？自然想办法就是在给的空间上想办法利用，</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>​    方法一:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length];</span><br><span class="line">        <span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    row[i] = <span class="number">1</span>;</span><br><span class="line">                    col[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] == <span class="number">1</span> || col[j]==<span class="number">1</span>)&#123;</span><br><span class="line">                   matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    优化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> col0 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">col0 = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = matrix.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (col0) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>70. Climbing Stairs</title>
      <link href="/2018/09/09/leetcode-leetcodetest-2018-09-09-70-Climbing-Stairs/"/>
      <url>/2018/09/09/leetcode-leetcodetest-2018-09-09-70-Climbing-Stairs/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">https://leetcode.com/problems/climbing-stairs/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p><p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>比较经典的递归问题了，现在回过头来看，用动归的递推，还是挺简单的。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">2</span>,pre2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = pre1 + pre2;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>69. Sqrt(x)</title>
      <link href="/2018/09/07/leetcode-leetcodetest-2018-09-07-69-Sqrt-x/"/>
      <url>/2018/09/07/leetcode-leetcodetest-2018-09-07-69-Sqrt-x/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">https://leetcode.com/problems/sqrtx/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a non-negative integer <code>x</code>, compute and return <em>the square root of</em> <code>x</code>.</p><p>Since the return type is an integer, the decimal digits are <strong>truncated</strong>, and only <strong>the integer part</strong> of the result is returned.</p><p><strong>Note:</strong> You are not allowed to use any built-in exponent function or operator, such as <code>pow(x, 0.5)</code> or <code>x ** 0.5</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= x &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这就是经典的二分求根号，不过这个题更简单，求的就是第一个满足((long)mid * mid) &lt;= x的整数。用res保留下解，不断的去推进这个值，这种写法简单好用，推荐！</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = x;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(((<span class="keyword">long</span>)mid * mid) &lt;= x)&#123;</span><br><span class="line">               res = mid;</span><br><span class="line">               l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66. Plus One</title>
      <link href="/2018/09/07/leetcode-leetcodetest-2018-09-07-66-Plus-One/"/>
      <url>/2018/09/07/leetcode-leetcodetest-2018-09-07-66-Plus-One/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">https://leetcode.com/problems/plus-one/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given a <strong>large integer</strong> represented as an integer array <code>digits</code>, where each <code>digits[i]</code> is the <code>ith</code> digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading <code>0</code>‘s.</p><p>Increment the large integer by one and return <em>the resulting array of digits</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br><span class="line">Incrementing by one gives 123 + 1 &#x3D; 124.</span><br><span class="line">Thus, the result should be [1,2,4].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br><span class="line">Incrementing by one gives 4321 + 1 &#x3D; 4322.</span><br><span class="line">Thus, the result should be [4,3,2,2].</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; [9]</span><br><span class="line">Output: [1,0]</span><br><span class="line">Explanation: The array represents the integer 9.</span><br><span class="line">Incrementing by one gives 9 + 1 &#x3D; 10.</span><br><span class="line">Thus, the result should be [1,0].</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li><li><code>digits</code> does not contain any leading <code>0</code>‘s.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>其实就是用数组进行大数运算，这个比较简单，只是简单的加法，累加时候注意加入进位，最后要判断是不是仍有进位，如果还有，要注意扩容数组</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有点类似大数运算，需要考虑进位情况，这个是比较简答的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> jie = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(jie == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> mod = (digits[i] + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (digits[i] + jie)/<span class="number">10</span>;</span><br><span class="line">            digits[i] = mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jie == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[]  new_digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; digits.length;i++) new_digits[i] = digits[i];</span><br><span class="line">            new_digits[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> new_digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>62. Unique Paths</title>
      <link href="/2018/09/04/leetcode-leetcodetest-2018-09-04-62-Unique-Paths/"/>
      <url>/2018/09/04/leetcode-leetcodetest-2018-09-04-62-Unique-Paths/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">https://leetcode.com/problems/unique-paths/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p><p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p>The test cases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: m &#x3D; 3, n &#x3D; 7</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Down</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题实际就是求排列组合，能想到这就简单，不然就吃力了，因为是矩型，而且只能左到右，上到下的走，所以从开始点到结束点，从左到右，从上到下 一定都是固定的步数。</li><li>排列组合的计算，方法数有很多，主要是用到简化公式的方法，不然直接计算 很容易就溢出了，至于计算方法，待我其它文章详细总结。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)C2(m+n-<span class="number">2</span>,m-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">C2</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            res =res*(n-m+i)/i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55. Jump Game</title>
      <link href="/2018/09/03/leetcode-leetcodetest-2018-09-03-55-Jump-Game/"/>
      <url>/2018/09/03/leetcode-leetcodetest-2018-09-03-55-Jump-Game/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/jump-game/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game/submissions/</a>    </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>nums</code>. You are initially positioned at the array’s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p><p>Return <code>true</code> <em>if you can reach the last index, or</em> <code>false</code> <em>otherwise</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>经典题目。这个题就是考察“不回退”的技巧，用一个变量去扩展可以走到的路。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; max_pos) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                max_pos = Math.max(i + nums[i],max_pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>54. Spiral Matrix</title>
      <link href="/2018/09/03/leetcode-leetcodetest-2018-09-03-54-Spiral-Matrix/"/>
      <url>/2018/09/03/leetcode-leetcodetest-2018-09-03-54-Spiral-Matrix/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/spiral-matrix/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题不难，也没什么特殊的知识点，就是一个技巧，用几个变量控制好 从左到右，从右到左，从上到下，从下到上的范围，循环进行即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> N = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> d_left=<span class="number">0</span>,d_right=N-<span class="number">1</span>,d_up=<span class="number">0</span>,d_down = M-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>,cur_row = -<span class="number">1</span>,cur_col = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (c &lt; M*N)&#123;</span><br><span class="line">            <span class="comment">//往右</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d_left;i &lt;= d_right;i++)&#123;</span><br><span class="line">                list.add(matrix[d_up][i]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_up++;</span><br><span class="line">            <span class="comment">//往下</span></span><br><span class="line">            <span class="keyword">if</span>(c &gt;= M * N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = d_up;i &lt;= d_down;i++)&#123;</span><br><span class="line">                list.add(matrix[i][d_right]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_right--;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= M * N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//往左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = d_right;i &gt;= d_left;i--)&#123;</span><br><span class="line">                list.add(matrix[d_down][i]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_down--;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= M * N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//往上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d_down;i &gt;= d_up;i--)&#123;</span><br><span class="line">                list.add(matrix[i][d_left]);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            d_left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>53. Maximum Subarray</title>
      <link href="/2018/09/03/leetcode-leetcodetest-2018-09-03-53-Maximum-Subarray/"/>
      <url>/2018/09/03/leetcode-leetcodetest-2018-09-03-53-Maximum-Subarray/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.</p><p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum &#x3D; 6.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,4,-1,7,8]</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution using the <strong>divide and conquer</strong> approach, which is more subtle.</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>比较常见的dp模型，从左到右,dp[i] 表示以i结尾的最大字数组的和</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = arr.length;</span><br><span class="line">        <span class="keyword">int</span> pre = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            pre = Math.max(arr[i],arr[i]+pre);</span><br><span class="line">            res = Math.max(res,pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. Merge Intervals</title>
      <link href="/2018/09/03/leetcode-leetcodetest-2018-09-03-56-Merge-Intervals/"/>
      <url>/2018/09/03/leetcode-leetcodetest-2018-09-03-56-Merge-Intervals/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-intervals/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals &#x3D; [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目比较简单，就是输出有多少个覆盖的区间，遍历一趟，记录下来即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = intervals.length;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= end)&#123;</span><br><span class="line">                end = Math.max(intervals[i][<span class="number">1</span>],end);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                intervals[t][<span class="number">0</span>] = start;</span><br><span class="line">                intervals[t++][<span class="number">1</span>] = end;</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals[t][<span class="number">0</span>] = start;</span><br><span class="line">        intervals[t++][<span class="number">1</span>] = end;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[t][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t;i++)&#123;</span><br><span class="line">            res[i][<span class="number">0</span>] = intervals[i][<span class="number">0</span>];</span><br><span class="line">            res[i][<span class="number">1</span>] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50. Pow(x, n)</title>
      <link href="/2018/09/01/leetcode-leetcodetest-2018-09-01-50-Pow-x-n/"/>
      <url>/2018/09/01/leetcode-leetcodetest-2018-09-01-50-Pow-x-n/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">https://leetcode.com/problems/powx-n/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(x, n)</a>, which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>xn</code>).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-100.0 &lt; x &lt; 100.0</code></li><li><code>-231 &lt;= n &lt;= 231-1</code></li><li><code>-104 &lt;= xn &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>求m^n，可以对n用二分，加快累乘的速度</li><li>m^ (-n) = 1/m^n,这容易，所以，如果是负的，我们统一成正的处理，最后看是不是用1除即可。</li><li>注意边界，(-n)可能是Integer的最小值，所以如果直接转成绝对值就出错了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> raw = n;</span><br><span class="line">        n = n &gt; <span class="number">0</span> ? n : (n == Integer.MIN_VALUE ? Integer.MAX_VALUE : -n);</span><br><span class="line">        <span class="keyword">double</span> power = x;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                res *= power;</span><br><span class="line">            &#125;</span><br><span class="line">            power *= power;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> raw &gt; <span class="number">0</span> ? res : <span class="number">1</span>/res/(raw == Integer.MIN_VALUE ? x:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49. Group Anagrams</title>
      <link href="/2018/09/01/leetcode-leetcodetest-2018-09-01-49-Group-Anagrams/"/>
      <url>/2018/09/01/leetcode-leetcodetest-2018-09-01-49-Group-Anagrams/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener">https://leetcode.com/problems/group-anagrams/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p><p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]</span><br><span class="line">Output: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;&quot;]</span><br><span class="line">Output: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;a&quot;]</span><br><span class="line">Output: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> consists of lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>与字母种数有关，与字母顺序无关，这种题目出现的很高，也不难，做一个词频映射表表，能表示出来哪个字符出现的次数即可</li><li>是26个字符，所以char[26], 即可，注意这个地方就是要用char类型数组，因为不同的频次对应不同的字符。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        HashMap&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span>[] chars = strs[i].toCharArray();</span><br><span class="line">            <span class="keyword">char</span>[] dic = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; chars.length; i1++) &#123;</span><br><span class="line">                dic[chars[i1]-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> String dic_key = <span class="keyword">new</span> String(dic);</span><br><span class="line">            <span class="keyword">if</span>(map.get(dic_key) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(strs[i]);</span><br><span class="line">                map.put(dic_key,list);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.get(dic_key).add(strs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        map.forEach((k,v)-&gt;lists.add(v));</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48. Rotate Image</title>
      <link href="/2018/09/01/leetcode-leetcodetest-2018-09-01-48-Rotate-Image/"/>
      <url>/2018/09/01/leetcode-leetcodetest-2018-09-01-48-Rotate-Image/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/rotate-image/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-image/submissions/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <strong>90</strong> degrees (clockwise).</p><p>You have to rotate the image <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>第一次做还没反应过来怎么做。其实就注意一个点，是矩阵，90度旋转，它同一圈的不会转出去，所以就又一个对焦，一圈一圈转就行。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>,b = <span class="number">0</span>,c = matrix.length-<span class="number">1</span>,d = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &lt; c)&#123;</span><br><span class="line">            rotateSwap(matrix,a++,b++,c--,d--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotateSwap</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; d-b;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = matrix[a][b+i];</span><br><span class="line">            matrix[a][b+i] = matrix[c-i][b];</span><br><span class="line">            matrix[c-i][b] = matrix[c][d-i];</span><br><span class="line">            matrix[c][d-i] = matrix[a+i][d];</span><br><span class="line">            matrix[a+i][d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>46. Permutations</title>
      <link href="/2018/08/30/leetcode-leetcodetest-2018-08-30-46-Permutations/"/>
      <url>/2018/08/30/leetcode-leetcodetest-2018-08-30-46-Permutations/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1]</span><br><span class="line">Output: [[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li>All the integers of <code>nums</code> are <strong>unique</strong>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>全排列，基础的递归题目。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        process(list,nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回[index,len-1]位置的全排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length)&#123;</span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                tmp.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index;i &lt; nums.length;i++)&#123;</span><br><span class="line">            swap(nums,index,i);</span><br><span class="line">            process(list,nums,index+<span class="number">1</span>);</span><br><span class="line">            swap(nums,index,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = num[i];</span><br><span class="line">        num[i] = num[j];</span><br><span class="line">        num[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>44. Wildcard Matching</title>
      <link href="/2018/08/28/leetcode-leetcodetest-2018-08-28-44-Wildcard-Matching/"/>
      <url>/2018/08/28/leetcode-leetcodetest-2018-08-28-44-Wildcard-Matching/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/wildcard-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/wildcard-matching/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code> where:</p><ul><li><code>&#39;?&#39;</code> Matches any single character.</li><li><code>&#39;*&#39;</code> Matches any sequence of characters (including the empty sequence).</li></ul><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; matches any sequence.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cb&quot;, p &#x3D; &quot;?a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length, p.length &lt;= 2000</code></li><li><code>s</code> contains only lowercase English letters.</li><li><code>p</code> contains only lowercase English letters, <code>&#39;?&#39;</code> or <code>&#39;*&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目是通配符匹配，用动态规划会简单点, i,j的含义是s的前0~i字符能否与p的0~j字符匹配,然后根据p[j]是什么样的字符进行可能性的枚举即可。</li><li></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"**"</span>.equals(p) || <span class="string">"*"</span>.equals(p))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] p_str = p.toCharArray();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str.length + <span class="number">1</span>][p_str.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process(str,p_str,s.length()-<span class="number">1</span>,p.length()-<span class="number">1</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">char</span>[] p,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] dp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j+<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span>)&#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = i==-<span class="number">1</span>?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>]==<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j;k &gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[k] != <span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p[j] == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i;k &gt;= -<span class="number">1</span>;k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(process(str,p,k,j-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p[j] == <span class="string">'?'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (process(str,p,i-<span class="number">1</span>,j-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==p[j]&amp;&amp;process(str,p,i-<span class="number">1</span>,j-<span class="number">1</span>,dp))&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. Trapping Rain Water</title>
      <link href="/2018/08/26/leetcode-leetcodetest-2018-08-26-42-Trapping-Rain-Water/"/>
      <url>/2018/08/26/leetcode-leetcodetest-2018-08-26-42-Trapping-Rain-Water/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">https://leetcode.com/problems/trapping-rain-water/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [4,2,0,3,2,5]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>乍一看，以为是单调栈，单调栈最大的特点就是，能求以当前元素为最小值的最长区间，这个题实际上并不适合，所以说上来先不要急着套模型，先从题目本身出发，去思考如何解决。</li><li>每个柱子都有可能接住雨水，接的大小实际就是它能“涨”多高，不就是取决于它左边最高高度和右面最高高度的最小值么。想明白这个地方，这个题就有了。</li><li>构造出辅助数组left[i],表示从0~i中的最大值，right[i]，表示i~lenth-1中的最大值，其中left可以再第二次遍历求每个柱子接水的时候一并算出，这样两个循环就搞定了。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">        <span class="keyword">int</span> max_n = height[height.length-<span class="number">1</span>];</span><br><span class="line">        right[height.length-<span class="number">1</span>] = max_n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = height.length-<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            max_n = Math.max(height[i],max_n);</span><br><span class="line">            right[i] = max_n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        max_n = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; height.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> expect = Math.min(max_n,right[i+<span class="number">1</span>]);</span><br><span class="line">            res += expect &lt; height[i] ? <span class="number">0</span> : expect-height[i];</span><br><span class="line">            max_n = Math.max(max_n,height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>41. First Missing Positive</title>
      <link href="/2018/08/23/leetcode-leetcodetest-2018-08-23-41-First-Missing-Positive/"/>
      <url>/2018/08/23/leetcode-leetcodetest-2018-08-23-41-First-Missing-Positive/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">https://leetcode.com/problems/first-missing-positive/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an unsorted integer array <code>nums</code>, return the smallest missing positive integer.</p><p>You must implement an algorithm that runs in <code>O(n)</code> time and uses constant extra space.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,0]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,4,-1,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [7,8,9,11,12]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题为hard 难度,不过确实不错！理解好题目，要求O(N),那肯定不能排序。</li><li>假设数组长度为N，最理想的情况就是return N+1，说明1～N 全部出现了，那如果，在我们遍历过程中，出现了一个 不在[1,N]区间的元素或者重复出现[1,N]中的元素 意味着，我们期待的N+1不可能实现了，因为有其他元素 “占位”了，此时最理想的情况是 [1,N-1]仍然满足条件，return N,所以，当扫描到异常元素时，会导致我们期望的值缩小。</li><li>有一点，我们怎么保证我们扫描过的元素是连续的，并且是不重复的，因为重复的会占位，所以我们用双指针，L代表扫描过有效的元素。R代表我们期望的，利用下表与值的关系来重新排列，让元素在对应的下表位置(O(N)),</li><li>特别注意<code>nums[L] == nums[nums[L]-1]</code>,当要置位的元素已经存在时候，说明也是垃圾值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>; <span class="comment">//L,R为虚指,所谓的有效区得保证有效，关键是连续，也就是扫描过去的元素得是连续的才行,L位置必须是放L+1的值</span></span><br><span class="line">        <span class="keyword">int</span> R = nums.length-<span class="number">1</span>; <span class="comment">//R+1代表可连续增长的最大值</span></span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[L]==L+<span class="number">1</span>)&#123;</span><br><span class="line">               L++;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[L] &lt;= L||nums[L] &gt; R+<span class="number">1</span> ||nums[L] == nums[nums[L]-<span class="number">1</span>])&#123;</span><br><span class="line">               swap(nums,L,R);</span><br><span class="line">               R--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               swap(nums,L,nums[L]-<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> loc1,<span class="keyword">int</span> loc2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num[loc1];</span><br><span class="line">        num[loc1] = num[loc2];</span><br><span class="line">        num[loc2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Two Pointer </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>38. Count and Say</title>
      <link href="/2018/08/21/leetcode-leetcodetest-2018-08-21-38-Count-and-Say/"/>
      <url>/2018/08/21/leetcode-leetcodetest-2018-08-21-38-Count-and-Say/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">https://leetcode.com/problems/count-and-say/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    The <strong>count-and-say</strong> sequence is a sequence of digit strings defined by the recursive formula:</p><ul><li><code>countAndSay(1) = &quot;1&quot;</code></li><li><code>countAndSay(n)</code> is the way you would “say” the digit string from <code>countAndSay(n-1)</code>, which is then converted into a different digit string.</li></ul><p>To determine how you “say” a digit string, split it into the <strong>minimal</strong> number of substrings such that each substring contains exactly <strong>one</strong> unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.</p><p>For example, the saying and conversion for digit string <code>&quot;3322251&quot;</code>:</p><p><img src="https://assets.leetcode.com/uploads/2020/10/23/countandsay.jpg" alt="img"></p><p>Given a positive integer <code>n</code>, return <em>the</em> <code>nth</code> <em>term of the <strong>count-and-say</strong> sequence</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: &quot;1&quot;</span><br><span class="line">Explanation: This is the base case.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 4</span><br><span class="line">Output: &quot;1211&quot;</span><br><span class="line">Explanation:</span><br><span class="line">countAndSay(1) &#x3D; &quot;1&quot;</span><br><span class="line">countAndSay(2) &#x3D; say &quot;1&quot; &#x3D; one 1 &#x3D; &quot;11&quot;</span><br><span class="line">countAndSay(3) &#x3D; say &quot;11&quot; &#x3D; two 1&#39;s &#x3D; &quot;21&quot;</span><br><span class="line">countAndSay(4) &#x3D; say &quot;21&quot; &#x3D; one 2 + one 1 &#x3D; &quot;12&quot; + &quot;11&quot; &#x3D; &quot;1211&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 30</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>很多题目只是表面花里胡哨，读懂了，把题目简化一下，就发现时一个很普通的模型，此题就属于这类，写好递归即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] last = countAndSay(n - <span class="number">1</span>).toCharArray();</span><br><span class="line">StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; last.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (last[i - <span class="number">1</span>] == last[i]) &#123;</span><br><span class="line">times++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans.append(times);</span><br><span class="line">ans.append(last[i - <span class="number">1</span>]);</span><br><span class="line">times = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans.append(times);</span><br><span class="line">ans.append(last[last.length - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36. Valid Sudoku</title>
      <link href="/2018/08/21/leetcode-leetcodetest-2018-08-21-36-Valid-Sudoku/"/>
      <url>/2018/08/21/leetcode-leetcodetest-2018-08-21-36-Valid-Sudoku/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode.com/problems/valid-sudoku/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-sudoku/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Determine if a <code>9 x 9</code> Sudoku board is valid. Only the filled cells need to be validated <strong>according to the following rules</strong>:</p><ol><li>Each row must contain the digits <code>1-9</code> without repetition.</li><li>Each column must contain the digits <code>1-9</code> without repetition.</li><li>Each of the nine <code>3 x 3</code> sub-boxes of the grid must contain the digits <code>1-9</code> without repetition.</li></ol><p><strong>Note:</strong></p><ul><li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li><li>Only the filled cells need to be validated according to the mentioned rules.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: board &#x3D; </span><br><span class="line">[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> is a digit <code>1-9</code> or <code>&#39;.&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>其实就是遍历，判断一下此时在列方向、行方向是不是不满足条件，遍历过程中标记好条件即可。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//主要是存当前行、当前列、当前子块</span></span><br><span class="line">        <span class="keyword">int</span>[][] rowVisited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">10</span>]; <span class="comment">// 第二维是数字</span></span><br><span class="line">        <span class="keyword">int</span>[][] colVisited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">10</span>]; <span class="comment">//第二维是数字</span></span><br><span class="line">        <span class="keyword">int</span>[][] subMatrixVisited = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">9</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> subId =<span class="number">3</span> * (i/<span class="number">3</span>) + j/<span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">char</span> t = board[i][j]; </span><br><span class="line">                    <span class="keyword">if</span>(t == <span class="string">'.'</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> num = t - <span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(rowVisited[i][num] == <span class="number">1</span> || colVisited[j][num] == <span class="number">1</span> || subMatrixVisited[subId][num]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rowVisited[i][num] = <span class="number">1</span>;</span><br><span class="line">                    colVisited[j][num] = <span class="number">1</span>;</span><br><span class="line">                    subMatrixVisited[subId][num]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34. Find First and Last Position of Element in Sorted Array</title>
      <link href="/2018/08/20/leetcode-leetcodetest-2018-08-20-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/"/>
      <url>/2018/08/20/leetcode-leetcodetest-2018-08-20-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p><p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [], target &#x3D; 0</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>nums</code> is a non-decreasing array.</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>二分的典型应用，查找第一个满足条件的值，其实 二分在求某个函数的解时，威力无穷，有机会专门总结一下。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.length==<span class="number">0</span>?<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125; : (nums[<span class="number">0</span>]==target ? <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125; : <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = binarySearch(nums, target );</span><br><span class="line">        <span class="keyword">if</span>(left == Integer.MAX_VALUE||nums[left] &gt; target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> right = binarySearch(nums, target + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right == Integer.MAX_VALUE ? nums.length-<span class="number">1</span>:right-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找 查找第一个一个大于等于target的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r =nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                res = Math.min(res,mid);</span><br><span class="line">                r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                l = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>33. Search in Rotated Sorted Array</title>
      <link href="/2018/08/20/leetcode-leetcodetest-2018-08-20-33-Search-in-Rotated-Sorted-Array/"/>
      <url>/2018/08/20/leetcode-leetcodetest-2018-08-20-33-Search-in-Rotated-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/search-in-rotated-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p><p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p><p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of</em> <code>target</code> <em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li>All values of <code>nums</code> are <strong>unique</strong>.</li><li><code>nums</code> is an ascending array that is possibly rotated.</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>题目不错，已经要求你log(n)的时间复杂度，那只能往二分上去想了，这是很明确的吧。</li><li>既然二分，关键在于根据题目的特点，找到能每次二分的点，每次能砍掉近一半的数据，此题的特点是原先是上升的，如果出现了下降的元素，那么就是发生了旋转,我们可以先通过比较l和r位置元素判断出此时是否是旋转区间，如果不是，直接二分查找，如果是可以通过l、mid、r三个位置的元素来确定哪个区间出现了旋转区间，对于无旋转区间的 可以直接判断出target是否存在此区间。</li><li>利用好，无旋转区间，即上升区间的特点，可以减少很多复杂的判断，最终目的就是缩小解空间，最终逼近答案</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[r])&#123; <span class="comment">//l 到 r内 是递增区间，无旋转点，直接二分查找</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//l 到 r内 含有旋转点 ,进一步通过mid 来定位旋转点</span></span><br><span class="line">                <span class="keyword">if</span>(nums[l] &lt;= nums[mid])&#123; <span class="comment">//左边无旋转点,从[l,mid]是升区间</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[l] &lt;= target &amp;&amp; nums[mid] &gt;= target)&#123;</span><br><span class="line">                        <span class="comment">//来此区间找</span></span><br><span class="line">                        r = mid -<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        l = mid +<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  <span class="comment">//从mid+1到r才是正常区间</span></span><br><span class="line">                        <span class="comment">//左边有旋转区间,右边无旋转点，即问题变成了，此时如何判断target是在左变还是右边?通过右区间判断</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[mid] &lt;= target &amp;&amp; nums[r] &gt;=target)&#123; <span class="comment">//来右边</span></span><br><span class="line">                        l = mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                        r = mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>29. Divide Two Integers</title>
      <link href="/2018/08/20/leetcode-leetcodetest-2018-08-20-29-Divide-Two-Integers/"/>
      <url>/2018/08/20/leetcode-leetcodetest-2018-08-20-29-Divide-Two-Integers/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/divide-two-integers/" target="_blank" rel="noopener">https://leetcode.com/problems/divide-two-integers/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers <strong>without</strong> using multiplication, division, and mod operator.</p><p>The integer division should truncate toward zero, which means losing its fractional part. For example, <code>8.345</code> would be truncated to <code>8</code>, and <code>-2.7335</code> would be truncated to <code>-2</code>.</p><p>Return <em>the <strong>quotient</strong> after dividing</em> <code>dividend</code> <em>by</em> <code>divisor</code>.</p><p><strong>Note:</strong> Assume we are dealing with an environment that could only store integers within the <strong>32-bit</strong> signed integer range: <code>[−231, 231 − 1]</code>. For this problem, if the quotient is <strong>strictly greater than</strong> <code>231 - 1</code>, then return <code>231 - 1</code>, and if the quotient is <strong>strictly less than</strong> <code>-231</code>, then return <code>-231</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend &#x3D; 10, divisor &#x3D; 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 10&#x2F;3 &#x3D; 3.33333.. which is truncated to 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend &#x3D; 7, divisor &#x3D; -3</span><br><span class="line">Output: -2</span><br><span class="line">Explanation: 7&#x2F;-3 &#x3D; -2.33333.. which is truncated to -2.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= dividend, divisor &lt;= 231 - 1</code></li><li><code>divisor != 0</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这题leetcode标注为中等难度，点踩的人特别多， 我也比较晕 不知道考察什么，可能还没领会到精髓。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//溢出的情况判断</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span> dividend/divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28. Implement strStr()</title>
      <link href="/2018/08/20/leetcode-leetcodetest-2018-08-20-28-Implement-strStr/"/>
      <url>/2018/08/20/leetcode-leetcodetest-2018-08-20-28-Implement-strStr/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-strstr/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strStr()</a>.</p><p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p><p><strong>Clarification:</strong></p><p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p><p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C’s <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strstr()</a> and Java’s <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String" target="_blank" rel="noopener">indexOf()</a>).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li><li><code>haystack</code> and <code>needle</code> consist of only lowercase English characters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题leetcode是标注是easy,其实考察的是kmp字符串匹配算法，疑问java的indexOf方法底层实际就是kmp的实现，所以这个地方就偷个懒了，有关Kmp方法以及它的改进，有机会我会详细讲解。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26. Remove Duplicates from Sorted Array</title>
      <link href="/2018/08/20/leetcode-leetcodetest-2018-08-20-26-Remove-Duplicates-from-Sorted-Array/"/>
      <url>/2018/08/20/leetcode-leetcodetest-2018-08-20-26-Remove-Duplicates-from-Sorted-Array/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-array/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>.</p><p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code> should hold the final result. It does not matter what you leave beyond the first <code>k</code> elements.</p><p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p><p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> with O(1) extra memory.</p><p><strong>Custom Judge:</strong></p><p>The judge will test your solution with the following code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums &#x3D; [...]; &#x2F;&#x2F; Input array</span><br><span class="line">int[] expectedNums &#x3D; [...]; &#x2F;&#x2F; The expected answer with correct length</span><br><span class="line"></span><br><span class="line">int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; Calls your implementation</span><br><span class="line"></span><br><span class="line">assert k &#x3D;&#x3D; expectedNums.length;</span><br><span class="line">for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] &#x3D;&#x3D; expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,2]</span><br><span class="line">Output: 2, nums &#x3D; [1,2,_]</span><br><span class="line">Explanation: Your function should return k &#x3D; 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">Output: 5, nums &#x3D; [0,1,2,3,4,_,_,_,_,_]</span><br><span class="line">Explanation: Your function should return k &#x3D; 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li><li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，双指针，通过一次遍历把重复元素去除掉，简答题目第一次能做出来也挺不错的，不知道为什么那么多人点踩。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>; <span class="comment">//p1实指，p1以及之后都是留下来的了</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> p2 = <span class="number">0</span>;p2 &lt; nums.length;p2++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p1] != nums[p2])&#123;</span><br><span class="line">                nums[++p1] = nums[p2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23. Merge k Sorted Lists</title>
      <link href="/2018/08/17/leetcode-leetcodetest-2018-08-17-23-Merge-k-Sorted-Lists/"/>
      <url>/2018/08/17/leetcode-leetcodetest-2018-08-17-23-Merge-k-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-k-sorted-lists/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p><p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">Output: [1,1,2,3,4,4,5,6]</span><br><span class="line">Explanation: The linked-lists are:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">merging them into one sorted list:</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: lists &#x3D; [[]]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 104</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-104 &lt;= lists[i][j] &lt;= 104</code></li><li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li><li>The sum of <code>lists[i].length</code> will not exceed <code>10^4</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>难度不大，主要考察堆，属于堆的典型题目，再配合链表，算是常考题目了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        ListNode last = <span class="keyword">null</span>;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;((a,b)-&gt;a.val - b.val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                heap.add(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">final</span> ListNode t = heap.poll();</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">                head = t;</span><br><span class="line">                last = t;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                last.next = t;</span><br><span class="line">                last = last.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                heap.add(t.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22. Generate Parentheses</title>
      <link href="/2018/08/15/leetcode-leetcodetest-2018-08-15-22-Generate-Parentheses/"/>
      <url>/2018/08/15/leetcode-leetcodetest-2018-08-15-22-Generate-Parentheses/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/generate-parentheses/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 3</span><br><span class="line">Output: [&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: [&quot;()&quot;]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>普通题，考察写递归的能力。</li><li>要的是全部解，这种全部可能性的肯定是递归来收集答案了，注意递归的写法，确定递归函数中需要哪些信息来确定参数，要尽可能的减少参数</li><li>递归中，假设到[0,index-1]的已经正确的填完了，现在来填index的位置，每次填，用条件保证填对，这样到length的位置，递归结束，此时的填写的path是正确的一种，不用再进行判断。如何判断此时填什么符合？<ul><li>首先，leftSize表示还能填左括号的个数，开始默认是n个,那么leftSize &gt; 0，此时可以填 左括号,填完leftSize 需要减1</li><li>右括号填写的条件是，已经填的右括号的个数: $index-(N-leftSize)$  仍然小于左括号个数：$N-leftSize$,整理可得$index &lt; 2 *(N-leftSize)$</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        process(n,<span class="number">0</span>,res,path,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> leftRest,<span class="keyword">int</span> index,List&lt;String&gt; res,StringBuilder path,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">2</span>*N)&#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftRest &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            process(leftRest-<span class="number">1</span>,index+<span class="number">1</span>,res,path.append(<span class="string">"("</span>),N);</span><br><span class="line">            path.deleteCharAt(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">2</span> *(N-leftRest))&#123;</span><br><span class="line">            process(leftRest,index+<span class="number">1</span>,res,path.append(<span class="string">")"</span>),N);</span><br><span class="line">            path.deleteCharAt(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21. Merge Two Sorted Lists</title>
      <link href="/2018/08/15/leetcode-leetcodetest-2018-08-15-21-Merge-Two-Sorted-Lists/"/>
      <url>/2018/08/15/leetcode-leetcodetest-2018-08-15-21-Merge-Two-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p> <a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p><p>Merge the two lists in a one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p><p>Return <em>the head of the merged linked list</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: list1 &#x3D; [1,2,4], list2 &#x3D; [1,3,4]</span><br><span class="line">Output: [1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: list1 &#x3D; [], list2 &#x3D; []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: list1 &#x3D; [], list2 &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>Both <code>list1</code> and <code>list2</code> are sorted in <strong>non-decreasing</strong> order.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，细心点就可以了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">        ListNode head = list1;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">                pre = pre ==<span class="keyword">null</span>?list1:pre.next;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode tmp = list2.next;</span><br><span class="line">                list2.next = list1;</span><br><span class="line">                <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre = list2;</span><br><span class="line">                    head = list2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre.next = list2;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                list2 = tmp;</span><br><span class="line">                list1 = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list2 != <span class="keyword">null</span>)</span><br><span class="line">            pre.next = list2;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20. Valid Parentheses</title>
      <link href="/2018/08/15/leetcode-leetcodetest-2018-08-15-20-Valid-Parentheses/"/>
      <url>/2018/08/15/leetcode-leetcodetest-2018-08-15-20-Valid-Parentheses/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-parentheses/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;()&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;(]&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> consists of parentheses only <code>&#39;()[]{}&#39;</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>很简单，栈的最基本应用</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">int</span> N = str.length;</span><br><span class="line"><span class="keyword">char</span>[] stack = <span class="keyword">new</span> <span class="keyword">char</span>[N];</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> cha = str[i];</span><br><span class="line"><span class="keyword">if</span> (cha == <span class="string">'('</span> || cha == <span class="string">'['</span> || cha == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">stack[size++] = cha == <span class="string">'('</span> ? <span class="string">')'</span> : (cha == <span class="string">'['</span> ? <span class="string">']'</span> : <span class="string">'&#125;'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> last = stack[--size];</span><br><span class="line"><span class="keyword">if</span> (cha != last) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19. Remove Nth Node From End of List</title>
      <link href="/2018/08/15/leetcode-leetcodetest-2018-08-15-19-Remove-Nth-Node-From-End-of-List/"/>
      <url>/2018/08/15/leetcode-leetcodetest-2018-08-15-19-Remove-Nth-Node-From-End-of-List/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-nth-node-from-end-of-list/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">Output: [1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1], n &#x3D; 1</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head &#x3D; [1,2], n &#x3D; 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in the list is <code>sz</code>.</li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>简单题，考察数据结构基本功，写的时候耐心点，细节点即可。</li><li>小技巧，保留一个pre和cur遍历指针相隔K个，这样等cur==null时，pre指向的就是要的元素。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          ListNode cur = head,pre = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(step &gt;= n)&#123;</span><br><span class="line">                  pre = pre == <span class="keyword">null</span> ? head : pre.next;</span><br><span class="line">              &#125;</span><br><span class="line">              cur = cur.next;</span><br><span class="line">              step++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> head.next;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              pre.next = pre.next.next;</span><br><span class="line">              <span class="keyword">return</span> head;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17. Letter Combinations of a Phone Number</title>
      <link href="/2018/08/14/leetcode-leetcodetest-2018-08-14-17-Letter-Combinations-of-a-Phone-Number/"/>
      <url>/2018/08/14/leetcode-leetcodetest-2018-08-14-17-Letter-Combinations-of-a-Phone-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">https://leetcode.com/problems/letter-combinations-of-a-phone-number/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p><p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><img src="https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png" alt="img"></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; &quot;&quot;</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits &#x3D; &quot;2&quot;</span><br><span class="line">Output: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> is a digit in the range <code>[&#39;2&#39;, &#39;9&#39;]</code>.</li></ul><p>​    </p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>不难，主要是考察会不会写递归，在递归中收集组合</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[][] phone = &#123; </span><br><span class="line">&#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> &#125;, <span class="comment">// 2    0</span></span><br><span class="line">&#123; <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span> &#125;, <span class="comment">// 3    1</span></span><br><span class="line">&#123; <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span> &#125;, <span class="comment">// 4    2</span></span><br><span class="line">&#123; <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span> &#125;, <span class="comment">// 5    3</span></span><br><span class="line">&#123; <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span> &#125;, <span class="comment">// 6    </span></span><br><span class="line">&#123; <span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span> &#125;, <span class="comment">// 7 </span></span><br><span class="line">&#123; <span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span> &#125;,   <span class="comment">// 8</span></span><br><span class="line">&#123; <span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span> &#125;, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "23"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] str = digits.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] path = <span class="keyword">new</span> <span class="keyword">char</span>[str.length];</span><br><span class="line">process(str, <span class="number">0</span>, path, ans);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> index, <span class="keyword">char</span>[] path, List&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == str.length) &#123;</span><br><span class="line">ans.add(String.valueOf(path));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">char</span>[] cands = phone[str[index] - <span class="string">'2'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> cur : cands) &#123;</span><br><span class="line">path[index] = cur;</span><br><span class="line">process(str, index + <span class="number">1</span>, path, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 3Sum</title>
      <link href="/2018/08/13/leetcode-leetcodetest-2018-08-13-15-3Sum/"/>
      <url>/2018/08/13/leetcode-leetcodetest-2018-08-13-15-3Sum/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p><p>Notice that the solution set must not contain duplicate triplets.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [-1,0,1,2,-1,-4]</span><br><span class="line">Output: [[-1,-1,2],[-1,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">nums[0] + nums[1] + nums[1] &#x3D; (-1) + 0 + 1 &#x3D; 0.</span><br><span class="line">nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0.</span><br><span class="line">nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0.</span><br><span class="line">The distinct triplets are [-1,0,1] and [-1,-1,2].</span><br><span class="line">Notice that the order of the output and the order of the triplets does not matter.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,1]</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The only possible triplet does not sum up to 0.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [0,0,0]</span><br><span class="line">Output: [[0,0,0]]</span><br><span class="line">Explanation: The only possible triplet sums up to 0.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>中等难度，不错的题目。先理解题目，要求输出的三元组 是元素的值，并且list里面的3元组不能重复</li><li>可以这样想3元组和为0，3个元素一定是小中大的关系，可以枚举小的元素，再去找中和大的元素。可以将元素排序，这样依次枚举，枚举的一定是小的元素，巧妙的避免重复。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> p1 = i+<span class="number">1</span>,p2 = nums.length-<span class="number">1</span>,target = <span class="number">0</span>-nums[i];</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; p2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[p1]+nums[p2] == target)&#123;</span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    tmp.add(nums[i]);</span><br><span class="line">                    tmp.add(nums[p1++]);</span><br><span class="line">                    tmp.add(nums[p2--]);</span><br><span class="line">                    list.add(tmp);</span><br><span class="line">                    <span class="keyword">while</span> (p2 &gt; p1 &amp;&amp; nums[p2] == nums[p2+<span class="number">1</span>]) p2--;</span><br><span class="line">                    <span class="keyword">while</span> (p1 &lt; p2 &amp;&amp; nums[p1] == nums[p1-<span class="number">1</span>]) p1++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[p1]+nums[p2] &lt; target)&#123;</span><br><span class="line">                    p1++;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14. Longest Common Prefix</title>
      <link href="/2018/08/11/leetcode-leetcodetest-2018-08-11-14-Longest-Common-Prefix/"/>
      <url>/2018/08/11/leetcode-leetcodetest-2018-08-11-14-Longest-Common-Prefix/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-common-prefix/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 200</code></li><li><code>0 &lt;= strs[i].length &lt;= 200</code></li><li><code>strs[i]</code> consists of only lowercase English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>遍历，不断缩短前缀即可</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String commonPrefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[i].indexOf(commonPrefix) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> length = commonPrefix.length();</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> ( j = length-<span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(strs[i].indexOf(commonPrefix.substring(<span class="number">0</span>,j)) == <span class="number">0</span>)&#123;</span><br><span class="line">                        commonPrefix = commonPrefix.substring(<span class="number">0</span>,j);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    commonPrefix = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> commonPrefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13. Roman to Integer</title>
      <link href="/2018/08/11/leetcode-leetcodetest-2018-08-11-13-Roman-to-Integer/"/>
      <url>/2018/08/11/leetcode-leetcodetest-2018-08-11-13-Roman-to-Integer/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/roman-to-integer/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>For example, <code>2</code> is written as <code>II</code> in Roman numeral, just two ones added together. <code>12</code> is written as <code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;III&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: III &#x3D; 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 15</code></li><li><code>s</code> contains only the characters <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code>.</li><li>It is <strong>guaranteed</strong> that <code>s</code> is a valid roman numeral in the range <code>[1, 3999]</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>水题，比较简单，看懂题意就能做.</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">// C     M     X   C     I   X</span></span><br><span class="line"><span class="comment">// 100  1000  10   100   1   10</span></span><br><span class="line"><span class="keyword">int</span> nums[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">switch</span> (s.charAt(i)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">nums[i] = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">nums[i] = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">nums[i] = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">nums[i] = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">nums[i] = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">nums[i] = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">nums[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">sum -= nums[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum + nums[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Container With Most Water</title>
      <link href="/2018/08/08/leetcode-leetcodetest-2018-08-08-11-Container-With-Most-Water/"/>
      <url>/2018/08/08/leetcode-leetcodetest-2018-08-08-11-Container-With-Most-Water/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode.com/problems/container-with-most-water/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>ith</code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p><p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p><p>Return <em>the maximum amount of water a container can store</em>.</p><p><strong>Notice</strong> that you may not slant the container.</p><p><strong>Example 1:</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br><span class="line">Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: height &#x3D; [1,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>绝对的经典问题，通过双指针，不断的推高答案，不是一下找到答案，而是尽可能的寻找到最接近答案的值</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>,p2 = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[p1] &lt; height[p2])&#123;</span><br><span class="line">               res = Math.max((p2-p1)*height[p1],res);</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = Math.max((p2-p1)*height[p2],res);</span><br><span class="line">                p2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two pointer </tag>
            
            <tag> greed </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10. Regular Expression Matching</title>
      <link href="/2018/08/08/leetcode-leetcodetest-2018-08-08-10-Regular-Expression-Matching/"/>
      <url>/2018/08/08/leetcode-leetcodetest-2018-08-08-10-Regular-Expression-Matching/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given an input string <code>s</code> and a pattern <code>p</code>, implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code> where:</p><ul><li><code>&#39;.&#39;</code> Matches any single character.</li><li><code>&#39;*&#39;</code> Matches zero or more of the preceding element.</li></ul><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;aa&quot;, p &#x3D; &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;ab&quot;, p &#x3D; &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= p.length &lt;= 30</code></li><li><code>s</code> contains only lowercase English letters.</li><li><code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and <code>&#39;*&#39;</code>.</li><li>It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这个题，第一次做的的话 会比较麻烦。用i代表字符串的当前字符，j代表正则表达式的当前字符，主要分区，后面的字符是不是<em>这种情况，如果是\</em>，说明当前i未必非得让j来匹配，i和j不同要继续看i和j+2可不可能匹配，如果i后面是一串连续相同的字符，要考虑j是匹配几个着同样的字符呢？</li><li>进行斜率优化，其实，递归是从左到右进行的，循环是可以通过观察替换出来的。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(s.toCharArray(),<span class="number">0</span>,p.toCharArray(),<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> i,<span class="keyword">char</span>[] exp,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==exp.length) <span class="keyword">return</span> i ==str.length;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span> != exp.length &amp;&amp; exp[j+<span class="number">1</span>] != <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i != str.length &amp;&amp; (str[i]==exp[j] || exp[j]==<span class="string">'.'</span>) &amp;&amp; process(str,i+<span class="number">1</span>,exp,j+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> == exp.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span> == str.length &amp;&amp; (str[i]==exp[j] || exp[j]==<span class="string">'.'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> c = i;</span><br><span class="line">                <span class="keyword">while</span> (c &lt; str.length &amp;&amp; (str[c]==exp[j]||exp[j]==<span class="string">'.'</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (process(str,c+<span class="number">1</span>,exp,j+<span class="number">2</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    c++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  process(str,i,exp,j+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> process(s.toCharArray(),<span class="number">0</span>,p.toCharArray(),<span class="number">0</span>,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> i,<span class="keyword">char</span>[] exp,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>) <span class="keyword">return</span> dp[i][j]==<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == exp.length) &#123;</span><br><span class="line">           res = i == str.length;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> != exp.length &amp;&amp; exp[j + <span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != str.length &amp;&amp; (str[i] == exp[j] || exp[j] == <span class="string">'.'</span>) &amp;&amp; process2(str, i + <span class="number">1</span>, exp, j + <span class="number">1</span>,dp))&#123;</span><br><span class="line">                    res = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> == exp.length) &#123;</span><br><span class="line">                    res =  i + <span class="number">1</span> == str.length &amp;&amp; (str[i] == exp[j] || exp[j] == <span class="string">'.'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">                        res = process2(str, i, exp, j + <span class="number">2</span>,dp);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(str[i] != exp[j] &amp;&amp; exp[j] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                            res =  process2(str, i, exp, j + <span class="number">2</span>,dp);</span><br><span class="line">                        &#125;<span class="keyword">else</span></span><br><span class="line">                            res = process2(str, i, exp, j + <span class="number">2</span>,dp) || process2(str, i+<span class="number">1</span>, exp, j,dp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = res?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8. String to Integer (atoi)</title>
      <link href="/2018/08/05/leetcode-leetcodetest-2018-08-05-8-String-to-Integer-atoi/"/>
      <url>/2018/08/05/leetcode-leetcodetest-2018-08-05-8-String-to-Integer-atoi/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode.com/problems/string-to-integer-atoi/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer (similar to C/C++’s <code>atoi</code> function).</p><p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p><ol><li>Read in and ignore any leading whitespace.</li><li>Check if the next character (if not already at the end of the string) is <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code>. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.</li><li>Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.</li><li>Convert these digits into an integer (i.e. <code>&quot;123&quot; -&gt; 123</code>, <code>&quot;0032&quot; -&gt; 32</code>). If no digits were read, then the integer is <code>0</code>. Change the sign as necessary (from step 2).</li><li>If the integer is out of the 32-bit signed integer range <code>[-231, 231 - 1]</code>, then clamp the integer so that it remains in the range. Specifically, integers less than <code>-231</code> should be clamped to <code>-231</code>, and integers greater than <code>231 - 1</code> should be clamped to <code>231 - 1</code>.</li><li>Return the integer as the final result.</li></ol><p><strong>Note:</strong></p><ul><li>Only the space character <code>&#39; &#39;</code> is considered a whitespace character.</li><li><strong>Do not ignore</strong> any characters other than the leading whitespace or the rest of the string after the digits.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;42&quot;</span><br><span class="line">Output: 42</span><br><span class="line">Explanation: The underlined characters are what is read in, the caret is the current reader position.</span><br><span class="line">Step 1: &quot;42&quot; (no characters read because there is no leading whitespace)</span><br><span class="line">         ^</span><br><span class="line">Step 2: &quot;42&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)</span><br><span class="line">         ^</span><br><span class="line">Step 3: &quot;42&quot; (&quot;42&quot; is read in)</span><br><span class="line">           ^</span><br><span class="line">The parsed integer is 42.</span><br><span class="line">Since 42 is in the range [-231, 231 - 1], the final result is 42.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation:</span><br><span class="line">Step 1: &quot;   -42&quot; (leading whitespace is read and ignored)</span><br><span class="line">            ^</span><br><span class="line">Step 2: &quot;   -42&quot; (&#39;-&#39; is read, so the result should be negative)</span><br><span class="line">             ^</span><br><span class="line">Step 3: &quot;   -42&quot; (&quot;42&quot; is read in)</span><br><span class="line">               ^</span><br><span class="line">The parsed integer is -42.</span><br><span class="line">Since -42 is in the range [-231, 231 - 1], the final result is -42.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation:</span><br><span class="line">Step 1: &quot;4193 with words&quot; (no characters read because there is no leading whitespace)</span><br><span class="line">         ^</span><br><span class="line">Step 2: &quot;4193 with words&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)</span><br><span class="line">         ^</span><br><span class="line">Step 3: &quot;4193 with words&quot; (&quot;4193&quot; is read in; reading stops because the next character is a non-digit)</span><br><span class="line">             ^</span><br><span class="line">The parsed integer is 4193.</span><br><span class="line">Since 4193 is in the range [-231, 231 - 1], the final result is 4193.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length &lt;= 200</code></li><li><code>s</code> consists of English letters (lower-case and upper-case), digits (<code>0-9</code>), <code>&#39; &#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;.&#39;</code>.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>这题点踩的人有点多，个人也感觉这个题不是很漂亮，主要条件描述不清楚，各种异常的情况 报错了才知道，而且也考察不出什么东西。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="keyword">if</span>(s.length() ==<span class="number">0</span> || s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span> c = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(c&lt;=<span class="string">'z'</span> &amp;&amp; c &gt;= <span class="string">'a'</span> || c == <span class="string">'.'</span> || c &lt;= <span class="string">'Z'</span>&amp;&amp; c &gt;= <span class="string">'A'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//一定是以数字或者字符或者空白开头</span></span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>( i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">'+'</span> || s.charAt(i) == <span class="string">'-'</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">if</span>(!(s.charAt(<span class="number">0</span>) &lt;= <span class="string">'9'</span> &amp;&amp; s.charAt(<span class="number">0</span>) &gt;= <span class="string">'0'</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.length() &amp;&amp; !(s.charAt(i+<span class="number">1</span>) &gt;=<span class="string">'0'</span> &amp;&amp; s.charAt(i+<span class="number">1</span>) &lt;=<span class="string">'9'</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String regex = <span class="string">"[-+]?\\d+"</span>;</span><br><span class="line">        <span class="keyword">final</span> Pattern pattern = Pattern.compile(regex);</span><br><span class="line">        <span class="keyword">final</span> Matcher matcher = pattern.matcher(s);</span><br><span class="line">        <span class="keyword">if</span>(matcher.find())&#123;</span><br><span class="line">            <span class="keyword">final</span> String int_str = matcher.group();</span><br><span class="line">            <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                l = Integer.parseInt(int_str);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">if</span>(int_str.charAt(<span class="number">0</span>) == <span class="string">'-'</span>)</span><br><span class="line">                    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7. Reverse Integer</title>
      <link href="/2018/08/05/leetcode-leetcodetest-2018-08-05-7-Reverse-Integer/"/>
      <url>/2018/08/05/leetcode-leetcodetest-2018-08-05-7-Reverse-Integer/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-integer/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a signed 32-bit integer <code>x</code>, return <code>x</code> <em>with its digits reversed</em>. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range <code>[-2^31, 2^31 - 1]</code>, then return <code>0</code>.</p><p><strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</strong></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x &#x3D; 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>-231 &lt;= x &lt;= 23^1 - 1</code></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ol><li>此题偏简单，不能使用Long来存，反转之后，我们需要一位一位的进行计算存值，肯定会有溢出的情况，所以，我们要学会“提前处理”，<code>res==m &amp;&amp; x%10 &lt; o</code>  否则很有可能到最后是溢出的情况而我们又判断不出此时的情况。</li><li>可以将传入的整数以负数形式存储，这样存的值对于反转之后Integer.MIN来说正好存下，当然此题不会传入这种值，但若是以字符串形式传入，这个技巧就生效了。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> neg = x &lt; <span class="number">0</span>;</span><br><span class="line">        x = neg ? x : -x;   <span class="comment">//溢出是两个方向的，统一变负数处理，可以换成一个方向上 </span></span><br><span class="line">        <span class="keyword">int</span> m = Integer.MIN_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> o = Integer.MIN_VALUE % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res &lt; m || res==m &amp;&amp; x%<span class="number">10</span> &lt; o) <span class="comment">//提前进行整数溢出的判断</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neg ? res : Math.abs(res);  <span class="comment">//理论会有 负数没溢出，转绝对值溢出的情况，所以应该特殊处理，但这个题输入是一个整数，不会出现反转是-2147483647</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. Longest Palindromic Substring</title>
      <link href="/2018/08/05/leetcode-leetcodetest-2018-08-05-5-Longest-Palindromic-Substring/"/>
      <url>/2018/08/05/leetcode-leetcodetest-2018-08-05-5-Longest-Palindromic-Substring/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-palindromic-substring/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>​    Given a string <code>s</code>, return <em>the longest palindromic substring</em> in <code>s</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Explanation: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> consist of only digits and English letters.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题是比较经典的DP问题，可以先对边界进行单独处理，转移方程如下:<script type="math/tex; mode=display">dp[i][j] = \begin{cases} true & i = j\\equal(chars[i],chars[j]) & j=i+1,j < N  \end{cases}</script>然后，再对非边界内元素进行递推即可:<script type="math/tex; mode=display">dp[i][j] = \begin{cases}  if (chars[i]=chars[j])  & dp[i+1][j-1]\\ else & false \end{cases}</script></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sd=<span class="number">0</span>,ed=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> N = s.length();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; N)&#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = chars[i]==chars[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][i+<span class="number">1</span>])&#123;</span><br><span class="line">                        res = <span class="number">2</span>;</span><br><span class="line">                        sd = i;</span><br><span class="line">                        ed = i+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">3</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">2</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[i] == chars[j])&#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i+<span class="number">1</span> &gt; res)&#123;</span><br><span class="line">                        res = j-i+<span class="number">1</span>;</span><br><span class="line">                        sd = i;</span><br><span class="line">                        ed = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(sd,ed+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. Add Two Numbers</title>
      <link href="/2018/08/04/leetcode-leetcodetest-2018-08-04-2-Add-Two-Numbers/"/>
      <url>/2018/08/04/leetcode-leetcodetest-2018-08-04-2-Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode.com/problems/add-two-numbers/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">Output: [7,0,8]</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">Output: [8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>It is guaranteed that the list represents a number that does not have leading zeros.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>注意几个点</p><ul><li>注意进位的处理，每次累加 记得加上进位</li><li>最后若仍有进位，需要单独新建一个节点来保留进位</li><li>为减少额外空间，可以将结果累加到l1上或者l2上而不必新建节点。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jie = <span class="number">0</span>;</span><br><span class="line">        ListNode p1 = l1;</span><br><span class="line">        ListNode p2 = l2;</span><br><span class="line">        ListNode p1_last = <span class="keyword">null</span>;;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = (p1.val + p2.val + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (p1.val + p2.val + jie)/<span class="number">10</span>;</span><br><span class="line">            p1.val = left;</span><br><span class="line">            p1_last = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = (p1.val + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (p1.val + jie)/<span class="number">10</span>;</span><br><span class="line">            p1.val = left;</span><br><span class="line">            p1_last = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = (p2.val + jie)%<span class="number">10</span>;</span><br><span class="line">            jie = (p2.val + jie)/<span class="number">10</span>;</span><br><span class="line">            p1_last.next = <span class="keyword">new</span> ListNode(left);</span><br><span class="line">            p1_last = p1_last.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jie != <span class="number">0</span>)&#123;</span><br><span class="line">            p1_last.next = <span class="keyword">new</span> ListNode(jie);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link href="/2018/08/04/leetcode-leetcodetest-2018-08-04-3-Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2018/08/04/leetcode-leetcodetest-2018-08-04-3-Longest-Substring-Without-Repeating-Characters/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p>​    <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a> </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given a string <code>s</code>, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3.</span><br><span class="line">Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> consists of English letters, digits, symbols and spaces.</li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>此题相对简单，属于中等难度，可以使用滑动窗口或者动态规划来做，看到最优解，习惯性的使用DP来解</li><li>定义dp[i]含义为以i位置结尾的最长不重复子串长度，思考如何用dp[i]推导出dp[i+1],由于是不重复子串， 所以i+1位置结尾的子串，需要考虑i+1位置自符出现的位置,可以建立一个辅助map，来记录当前字符上次出现的位置,递推方程如下:</li></ul><script type="math/tex; mode=display">dp[i] = \left\{dp[i-1],i-map[chars[i]] \right\}\left ( i=1,2...n-1 \right )</script><ul><li>动态规划在分析过程中，经常是“需要什么就要创建什么”，通常要建立一些辅助数组来推导最优解</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">            map[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[chars[<span class="number">0</span>]] = <span class="number">0</span>;<span class="comment">//注意记录字符最近一次出现的位置，不要漏掉首个字符</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p1 = dp[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> p2 = i-map[chars[i]];</span><br><span class="line">            dp[i] = Math.min(p1,p2);</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">            map[chars[i]]  = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. Median of Two Sorted Arrays</title>
      <link href="/2018/08/04/leetcode-leetcodetest-2018-08-04-4-Median-of-Two-Sorted-Arrays/"/>
      <url>/2018/08/04/leetcode-leetcodetest-2018-08-04-4-Median-of-Two-Sorted-Arrays/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/2018/08/01/leetcode-leetcodetest-2018-08-01-1-Two-Sum/"/>
      <url>/2018/08/01/leetcode-leetcodetest-2018-08-01-1-Two-Sum/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p> <a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p><p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p><p>You can return the answer in any order.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: Because nums[0] + nums[1] &#x3D;&#x3D; 9, we return [0, 1].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">Output: [0,1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>Only one valid answer exists.</strong></li></ul><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>此题比较简单，可以学到一个基本技巧-“在遍历过程中寻找已经处理过的元素”，并且尽可能快的查找元素，优先考虑到有序表结构。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(target - nums[i]), i &#125;;</span><br><span class="line">&#125;</span><br><span class="line">map.put(nums[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - leetcode高频面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
